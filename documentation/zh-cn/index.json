[
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/page_object_models/",
	"title": "PO设计模式",
	"tags": [],
	"description": "",
	"content": "PO（page object）设计模式是在自动化中已经流行起来的一种易于维护和减少代码的设计模式. 在自动化测试中, PO对象作为一个与页面交互的接口. 测试中需要与页面的UI进行交互时, 便调用PO的方法. 这样做的好处是, 如果页面的UI发生了更改,那么测试用例本身不需要更改, 只需更改PO中的代码即可.\nPO设计模式具有以下优点:\n 测试代码与页面的定位代码（如定位器或者其他的映射）相分离. 该页面提供的方法或元素在一个独立的类中, 而不是将这些方法或元素分散在整个测试中.  这允许在一个地方修改由于UI变化所带来的所有修改. 随着这种\u0026quot;测试设计模式\u0026quot;的广泛使用, 可以在众多博客中找到有关此技术的有用信息. 我们鼓励希望了解更多信息的读者在互联网上搜索有关此主题的博客. 许多人已经写过这种设计模式, 并且可以提供超出本用户指南范围的有用提示. 不过, 为了让您入门, 我们将通过一个简单的示例来说明页面对象.\n首先, 思考一个不使用PO模式的自动化测试的典型案例:\n/*** * Tests login feature */ public class Login { public void testLogin() { // 在登录页面上填写登录数据  driver.findElement(By.name(\u0026#34;user_name\u0026#34;)).sendKeys(\u0026#34;testUser\u0026#34;); driver.findElement(By.name(\u0026#34;password\u0026#34;)).sendKeys(\u0026#34;my supersecret password\u0026#34;); driver.findElement(By.name(\u0026#34;sign-in\u0026#34;)).click(); // 登录后验证h1标签是否为Hello userName  driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).isDisplayed(); assertThat(driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).getText(), is(\u0026#34;Hello userName\u0026#34;)); } } 这种方法有两个问题.\n 测试方法与定位器 (在此实例中为By.name)耦合过于严重. 如果测试的用户界面更改了其定位器或登录名的输入和处理方式, 则测试本身必须进行更改. 在对登录页面的所有测试中, 同一个定位器会散布在其中.  可以在以下登录页面的示例中应用PO设计模式重写此示例.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Sign-in page. */ public class SignInPage { protected static WebDriver driver; // \u0026lt;input name=\u0026#34;user_name\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By usernameBy = By.name(\u0026#34;user_name\u0026#34;); // \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By passwordBy = By.name(\u0026#34;password\u0026#34;); // \u0026lt;input name=\u0026#34;sign_in\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;SignIn\u0026#34;\u0026gt;  private By signinBy = By.name(\u0026#34;sign_in\u0026#34;); public SignInPage(WebDriver driver){ this.driver = driver; } /** * Login as valid user * * @param userName * @param password * @return HomePage object */ public HomePage loginValidUser(String userName, String password) { driver.findElement(usernameBy).sendKeys(userName); driver.findElement(passwordBy).sendKeys(password); driver.findElement(signinBy).click(); return new HomePage(driver); } } Home page的PO如下所示.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Home Page */ public class HomePage { protected static WebDriver driver; // \u0026lt;h1\u0026gt;Hello userName\u0026lt;/h1\u0026gt;  private By messageBy = By.tagName(\u0026#34;h1\u0026#34;); public HomePage(WebDriver driver){ this.driver = driver; if (!driver.getTitle().equals(\u0026#34;Home Page of logged in user\u0026#34;)) { throw new IllegalStateException(\u0026#34;This is not Home Page of logged in user,\u0026#34; + \u0026#34; current page is: \u0026#34; + driver.getCurrentUrl()); } } /** * Get message (h1 tag) * * @return String message text */ public String getMessageText() { return driver.findElement(messageBy).getText(); } public HomePage manageProfile() { // Page encapsulation to manage profile functionality  return new HomePage(driver); } /* 提供登录用户主页所代表的服务的更多方法. 这些方法可能会返回更多页面对象. 例如, 单击\u0026#34;撰写邮件\u0026#34;按钮可以返回ComposeMail类对象 */ } 那么, 接下来的登录测试用例将使用这两个页面对象.\n/*** * Tests login feature */ public class TestLogin { @Test public void testLogin() { SignInPage signInPage = new SignInPage(driver); HomePage homePage = signInPage.loginValidUser(\u0026#34;userName\u0026#34;, \u0026#34;password\u0026#34;); assertThat(homePage.getMessageText(), is(\u0026#34;Hello userName\u0026#34;)); } } PO的设计方式具有很大的灵活性, 但是有一些基本规则可以使测试代码具有理想的可维护性.\nPO本身绝不应进行判断或断言. 判断和断言是测试的一部分, 应始终在测试的代码内, 而不是在PO中. PO用来包含页面的表示形式, 以及页面通过方法提供的服务, 但是与PO无关的测试代码不应包含在其中.\n实例化PO时, 应进行一次验证, 即验证页面以及页面上可能的关键元素是否已正确加载. 在上面的示例中, SignInPage和HomePage的构造函数均检查预期的页面是否可用并准备接受测试请求.\nPO不一定需要代表整个页面. PO设计模式可用于表示页面上的组件. 如果自动化测试中的页面包含多个组件, 则每个组件都有单独的页面对象, 则可以提高可维护性.\n还有其他设计模式也可以在测试中使用. 一些使用页面工厂实例化其页面对象. 讨论所有这些都不在本用户指南的范围之内. 在这里, 我们只想介绍一些概念, 以使读者了解可以完成的一些事情. 如前所述, 许多人都在此主题上写博客, 我们鼓励读者搜索有关这些主题的博客.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/legacy_docs/selenium_rc/",
	"title": "Selenium 1 (Selenium RC)",
	"tags": [],
	"description": "",
	"content": "介绍 在WebDriver / Selenium合并产生功能更强大的Selenium 2之前, Selenium RC一直是Selenium的主要项目. 再次特意强调的是, Selenium 1不再享有技术支持.\nSelenium RC 的工作原理 首先, 我们将描述Selenium RC的组件如何运行 以及每个组件在运行测试脚本中所扮演的角色.\nRC 组件 Selenium RC 组件包括:\n Selenium 服务器, 用于启动并关闭浏览器, 解释运行从测试程序传递来的Selenese命令, 并充当 HTTP代理 , 拦截和验证在浏览器和AUT之间传递的HTTP消息. 客户端库, 提供每种编程语言和 Selenium RC 服务器之间的接口.  以下是一个简化的架构图:\n该图显示了客户端库与服务器通信, 并传递了用来执行的每个Selenium命令. 然后, 服务器使用Selenium-Core的JavaScript命令 将Selenium命令传递到浏览器. 浏览器使用其JavaScript解释器执行Selenium命令. 这将运行您在测试脚本中指定的Selenese操作或验证行为.\nSelenium 服务器 Selenium 服务器从您的测试程序接收Selenium命令, 对其进行解释, 然后将运行这些测试的结果报告给您的程序.\nRC服务器捆绑了Selenium Core并将其自动注入浏览器. 当您的测试程序打开浏览器(使用客户端库API函数)时, 会发生这种情况. Selenium-Core是一个JavaScript程序, 实际上是一组JavaScript函数, 这些函数使用浏览器的内置JavaScript解释器来解释 和执行Selenese命令.\n服务器使用简单的HTTP GET / POST请求从您的测试程序接收Selenese命令. 这意味着您可以使用任何可以发送HTTP请求的编程语言 来自动执行浏览器中的Selenium测试.\n客户端库 客户端库提供了编程支持, 使您可以从自己设计的程序中运行Selenium命令. 每种受支持的语言都有一个不同的客户端库. Selenium客户端库提供了一个编程接口(API), 即一组函数, 可从您自己的程序中运行Selenium命令. 在每个界面中, 都有一个支持每个Selenese命令的编程功能.\n客户端库接受Selenese命令, 并将其传递给Selenium 服务器, 以针对被测应用程序(AUT)处理特定操作或测试. 客户端库还接收该命令的结果, 并将其传递回您的程序. 您的程序可以接收结果并将其存储到程序变量中, 并将其报告为成功或失败, 或者如果是意外错误, 则可以采取纠正措施.\n因此, 要创建测试程序, 只需编写一个使用客户端库API运行一组Selenium命令的程序. 并且, 可选地, 如果您已经在Selenium-IDE中创建了Selenese测试脚本, 则可以 生成Selenium RC代码 . Selenium-IDE可以(使用其\u0026quot;导出\u0026quot;菜单项) 将其Selenium命令转换为客户端驱动程序的API函数调用. 有关从Selenium-IDE导出RC代码的详细信息, 请参见Selenium-IDE章节.\n安装 安装对于Selenium来说是谬称. Selenium具有一组可用您选择的编程语言提供的库. 您可以从 下载页面下载它们.\n选择了要使用的语言后, 您只需要:\n 安装Selenium RC服务器. 使用特定语言的客户端驱动程序设置编程项目.  安装Selenium服务器 Selenium RC服务器只是一个Java jar 文件 ( selenium-server-standalone-.jar ), 不需要任何特殊的安装. 只需下载zip文件并将服务器提取到所需目录中就足够了.\n运行Selenium服务器 在开始任何测试之前, 您必须启动服务器. 转到Selenium RC服务器所在的目录, 然后从命令行控制台运行以下命令.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar 通过创建包含上述命令的批处理或Shell可执行文件 (Windows上为.bat, Linux上为.sh), 可以简化此操作. 然后在桌面上对该可执行文件创建快捷方式, 只需双击该图标即可启动服务器.\n为了使服务器运行, 您需要安装Java并正确配置PATH环境变量才能从控制台运行它. 您可以通过在控制台上运行以下命令来检查是否正确安装了Java.\njava -version 如果您查看到预期的版本号(必须为1.5或更高版本), 就可以开始使用Selenium RC了.\n使用Java客户端驱动程序  从SeleniumHQ 下载页面 下载Selenium Java客户端驱动程序zip 解压 selenium-java-.jar 文件 打开所需的Java IDE(Eclipse, NetBeans, IntelliJ, Netweaver等) 创建一个Java项目. 将selenium-java-.jar文件添加到您的项目中作为依赖. 将文件selenium-java-.jar添加到您的项目类路径中. 从Selenium-IDE中, 将脚本导出到Java文件并将其包含在Java项目中, 或者使用selenium-java-client API用Java编写Selenium测试. 该API将在本章稍后介绍. 您可以使用JUnit或TestNg来运行测试, 也可以编写自己的简单main()程序. 这些概念将在本节稍后说明. 从控制台运行Selenium服务器. 从Java IDE或命令行执行测试.  有关Java测试项目配置的详细信息, 请参阅附录部分. 使用Eclipse配置Selenium RC和使用Intellij配置Selenium RC.\n使用Python客户端驱动程序  通过PIP安装Selenium, 说明链接在SeleniumHQ 下载页面 用Python编写Selenium测试 或将脚本从Selenium-IDE导出到python文件. 从控制台运行Selenium服务器 从控制台或Python IDE执行测试  有关Python客户端驱动程序配置的详细信息, 请参见附录Python客户端驱动程序配置.\n使用.NET客户端驱动程序  从SeleniumHQ 下载页面 下载Selenium RC 解压缩文件夹 下载并安装NUnit (注意：您可以将NUnit用作测试引擎. 如果您还不熟悉NUnit, 还可以编写一个简单的main()函数来运行测试； 但是NUnit作为测试引擎非常有用) 打开所需的.Net IDE(Visual Studio, SharpDevelop, MonoDevelop) 创建一个类库(.dll) 添加对以下DLL的引用： nmock.dll, nunit.core.dll, nunit.framework.dll, ThoughtWorks.Selenium.Core.dll, ThoughtWorks.Selenium.IntegrationTests.dll 和ThoughtWorks.Selenium.UnitTests.dll 用.Net语言(C＃, VB.Net)编写Selenium测试, 或将脚本从Selenium-IDE导出到C＃文件, 然后将此代码复制到刚创建的类文件中. 编写自己的简单main()程序, 或者可以在项目中包含NUnit来运行测试. 这些概念将在本章稍后说明. 从控制台运行Selenium服务器 从IDE, NUnit GUI或命令行运行测试  有关使用Visual Studio配置.NET客户端驱动程序的详细信息, 请参阅附录.NET客户端驱动程序配置.\n使用Ruby客户端驱动程序  如果您还没有RubyGems, 请从RubyForge安装它. 运行 gem install selenium-client 在测试脚本的顶部, 添加 require \u0026quot;selenium/client\u0026quot; 使用任何Ruby测试工具 (例如Test::Unit, Mini::Test或RSpec)编写测试脚本. 从控制台运行Selenium RC服务器. 以与运行其他任何Ruby脚本相同的方式执行测试.  有关Ruby客户端驱动程序配置的详细信息, 请参见 Selenium-Client documentation_\n从 Selenese 到程序 使用Selenium RC的主要任务 是将您的Selenese转换为编程语言. 在本节中, 我们提供了几种不同的特定于语言的示例.\n示例测试脚本 让我们从一个Selenese测试脚本示例开始. 试想用Selenium-IDE录制以下测试.\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     注意：此示例适用于Google搜索页面 http://www.google.com\nSelenese作为编程代码 这是(通过Selenium-IDE)导出到每种支持的编程语言的测试脚本. 如果您具有基本的面向对象编程语言的基础知识, 则可以通过阅读以下示例之一 来了解Selenium如何运行Selenese命令. 要查看特定语言的示例, 请选择以下按钮之一.\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } } Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt; Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end 在下一节中, 我们将说明如何使用生成的代码来构建测试程序.\n编写测试程序 现在, 我们将使用每种受支持的编程语言的示例 来说明如何对自己的测试进行编程. 本质上有两个任务:\n 从Selenium-IDE将脚本生成为代码, 可以选择修改结果. 编写一个非常简单的执行生成代码的主程序.  (可选)您可以采用测试引擎平台, 例如JUnit或Java的TestNG, 或使用NUnit的.NET (如果使用的是其中一种语言).\n在这里, 我们显示特定于语言的示例. 特定语言的API彼此之间往往有所不同, 因此您会为每个API找到单独的解释\n Java C# Python Ruby Perl, PHP  Java 对于Java, 人们使用JUnit或TestNG作为测试引擎.\n某些开发环境(如Eclipse)通过插件直接支持这些环境. 这使它变得更加容易. 讲授JUnit或TestNG不在本文档的范围之内, 但是可以在网上找到资料, 并且可以找到出版物. 如果您恰巧熟悉Java全家桶, 那么您的开发人员将已经具有使用某种测试框架的经验.\n您可能需要将测试类从\u0026rdquo; NewTest\u0026quot;重命名为您自己选择的名称. 另外, 您将需要在语句中更改浏览器打开参数:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); Selenium-IDE生成的代码将如下所示. 此示例具有手动添加的注释, 以提高清晰度.\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# .NET客户端驱动程序可与Microsoft.NET一起使用. 它可以与任何.NET测试框架( 如NUnit或Visual Studio 2005 Team System)一起使用.\nSelenium-IDE假定您将使用NUnit作为测试框架. 您可以在下面的生成的代码中看到这一点. 它包含NUnit的using语句以及相应的NUnit属性, 这些属性标识测试类的每个成员函数的角色.\n您可能必须将测试类从\u0026rdquo; NewTest\u0026quot;重命名为您自己选择的名称. 另外, 您将需要在语句中更改浏览器打开参数:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); 生成的代码将类似于此.\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } } 您可以允许NUnit管理测试的执行. 或者, 您可以编写一个简单的 main() 程序, 该程序实例化测试对象并依次运行三个方法 SetupTest(), TheNewTest()和 TeardownTest() .\nPython Pyunit是用于Python的测试框架.\n基本测试结构是:\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Selenium-IDE的旧版本(2.0之前的版本)生成 需要旧Selenium gem的Ruby代码. 因此, 建议如下更新IDE生成的所有Ruby脚本:\n  在第一行, 修改 require \u0026quot;selenium\u0026quot; 为 require \u0026quot;selenium/client\u0026quot;\n  在第十一行, 修改 Selenium::SeleniumDriver.new 为 Selenium::Client::Driver.new\n  您可能还希望将类名更改为比\u0026quot;无标题\u0026quot;更具信息性的名称, 并将测试方法的名称更改为 \u0026ldquo;test_untitled\u0026quot;以外的名称.\n这是一个通过修改Selenium IDE 生成的Ruby代码创建的简单示例, 如上所述.\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP 文档团队的成员尚未将Selenium RC与Perl或PHP一起使用. 如果您将Selenium RC和这两种语言一起使用, 请联系文档团队(请参阅贡献一章). 我们很乐意提供一些您的经验和示例, 以支持Perl和PHP用户.\n学习 API Selenium RC API使用命名约定, 假设您了解Selenese, 则大部分接口将是不言自明的. 但是, 在这里, 我们解释了最关键且可能不太明显的方面.\n启动浏览器 CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start 这些示例中的每一个都打开浏览器 并通过为程序变量分配\u0026quot;浏览器实例\u0026quot;来表示该浏览器. 然后, 该程序变量用于从浏览器调用方法. 这些方法执行Selenium命令, 即 open 或 type 或 verify 命令.\n创建浏览器实例时所需的参数是:\n  host 指定服务器所在计算机的IP地址. 通常, 这是与客户端运行所在的计算机相同的主机, 因此在这种情况下, 将传递本地主机. 在某些客户端中, 这是可选参数\n  port 指定服务器正在侦听的TCP/IP套接字, 以等待客户端建立连接. 在某些客户端驱动程序中这也是可选的.\n  browser 您要在其中运行测试的浏览器. 这是一个必需的参数.\n  url 被测应用程序的基本URL. 这是所有客户端库所必需的, 并且是启动浏览器-代理-AUT通信所必需的信息\n  请注意, 某些客户端库要求通过调用浏览器的 start() 方法 来明确启动浏览器.\n运行命令 将浏览器初始化并分配给变量(通常称为\u0026quot;Selenium\u0026rdquo;)后, 可以通过从浏览器变量调用相应的方法来使其运行Selenese命令. 例如, 调用Selenium对象的 type 方法:\nselenium.type(\u0026#34;field-id\u0026#34;,\u0026#34;string to type\u0026#34;) 在后台, 浏览器实际上将执行 type 操作, 该操作基本上与用户通过以下方式在浏览器中键入输入相同： 使用定位符和您在方法调用期间指定的字符串.\n报告结果 Selenium RC没有自己的报告结果机制. 相反, 它允许您使用所选编程语言的功能来构建根据需要定制的报告. 太好了, 但是如果您只是想快速地为您完成某件事, 该怎么办？ 与开发自己的测试报告代码相比, 现有的库或测试框架通常可以更快地满足您的需求.\n测试框架报告工具 测试框架可用于许多编程语言. 这些功能以及提供用于执行测试的灵活测试引擎的主要功能, 包括用于报告结果的库代码. 例如, Java有两个常用的测试框架, 即JUnit和TestNG. .NET也有自己的NUnit\n我们不会在这里教框架本身； 这超出了本用户指南的范围. 我们将简单介绍与Selenium相关的框架功能以及您可以应用的一些技术. 这些测试框架上都有不错的书籍, 但是互联网上的信息也很多.\n测试报告库 还提供了专门创建的第三方库, 用于以您选择的编程语言报告测试结果. 这些通常支持多种格式, 例如HTML或PDF.\n最好的方法是什么? 大多数测试框架的新手都将从框架的内置报告功能开始. 从那里开始, 大多数人会检查任何可用的库, 因为与开发自己的库相比, 这样做所花的时间更少. 毫无疑问, 当您开始使用Selenium时, 您将开始输入自己的\u0026quot;打印报表\u0026quot;来报告进度. 这可能会逐渐导致您开发自己的报告, 这可能与使用库或测试框架同时进行. 无论如何, 经过最初但短暂的学习后, 您自然会开发出最适合自己情况的方法.\n测试报告示例 为了说明, 我们将指导您使用Selenium支持的其他一些语言的一些特定工具. 此处列出的是常用的, 并且由本指南的作者广泛使用(因此建议使用).\nJava测试报告   如果使用JUnit开发了Selenium测试用例, 则可以使用JUnit报告生成测试报告.\n  如果使用TestNG开发了Selenium测试用例, 则无需外部任务即可生成测试报告. TestNG框架生成一个HTML报告, 其中列出了测试的详细信息.\n  ReportNG是用于TestNG框架的HTML报告插件. 它旨在替代默认的TestNG HTML报告. ReportNG提供了简单的, 以颜色编码的测试结果视图.\n  记录Selenese命令  记录Selenium可以用于生成测试中所有Selenese命令 以及每个命令的成功或失败的报告. 记录Selenium扩展了Java客户端驱动程序 以添加此Selenese记录功能.  Python测试报告  使用Python客户端驱动程序时, 可以使用HTMLTestRunner生成测试报告.  Ruby测试报告  如果RSpec框架用于在Ruby中编写Selenium测试用例, 则其HTML报告可用于生成测试报告.  为测试加料 现在, 我们将介绍使用Selenium RC的全部原因, 并在测试中添加编程逻辑. 与任何程序相同. 程序流使用条件语句和迭代进行控制. 另外, 您可以使用I/O报告进度信息. 在本节中, 我们将展示一些示例, 说明如何将编程语言构造与Selenium结合以解决常见的测试问题.\n当您从对页面元素存在的简单测试 过渡到涉及多个网页和变化数据的动态功能测试时, 您将需要编程逻辑来验证预期结果. 基本上, Selenium-IDE不支持迭代和标准条件语句. 您可以通过将Javascript嵌入 Selenese参数中来执行某些条件, 但是迭代是不可能的, 并且大多数条件在编程语言. 此外, 您可能需要进行异常处理才能恢复错误. 出于这些原因及其他原因, 我们在本节中进行了说明, 以说明如何使用常见的编程技术为您的自动化测试提供更大的\u0026quot;验证能力\u0026rdquo;.\n本节中的示例使用C＃和Java编写, 尽管代码很简单并且可以轻松地适应其他受支持的语言. 如果您对面向对象的编程语言有一些基本的了解, 那么本部分将不难理解.\n迭代 迭代是人们在测试中需要做的最常见的事情之一. 例如, 您可能要多次执行搜索. 或者, 可能是为了验证测试结果, 您需要处理从数据库返回的\u0026quot;结果集\u0026rdquo;.\n使用我们之前使用的相同Google搜索示例, 让我们检查Selenium搜索结果. 该测试可以使用Selenese:\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     该代码已重复执行3次相同的步骤. 但是, 同一代码的多个副本不是良好的编程习惯, 因为维护起来需要做更多的工作. 通过使用编程语言, 我们可以遍历搜索结果以提供更灵活和可维护的解决方案.\n在 C# 中 // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); } 条件陈述 为了说明在测试中的使用条件, 我们将从一个示例开始. 当页面上没有预期的元素时, 会发生运行Selenium测试时遇到的常见问题. 例如, 当运行以下行时:\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); 如果页面上没有元素\u0026quot;q\u0026rdquo;, 则抛出异常:\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found 这可能会导致测试中止. 对于某些测试, 这就是您想要的. 但是通常这是不希望的, 因为您的测试脚本还有许多其他后续测试需要执行.\n更好的方法是先验证元素是否确实存在, 然后在元素不存在时采取替代方法. 让我们用Java看一下\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } 这种方法的优点是即使页面上某些UI元素不可用, 也可以继续执行测试.\n从测试中执行JavaScript 在执行Selenium不直接支持的应用程序时, JavaScript非常方便. Selenium API的 getEval 方法.\n考虑具有复选框的应用程序, 该复选框没有静态标识符. 在这种情况下, 可以评估Selenium RC中的JavaScript以获取所有复选框的ID, 然后执行它们.\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } 计算页面上的图像数量:\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); 记住要在DOM表达式的情况下使用window对象, 因为默认情况下是指Selenium窗口, 而不是测试窗口.\n服务器选项 启动服务器时, 命令行选项可用于更改默认服务器行为.\n回想一下, 通过运行以下命令来启动服务器.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar 要查看选项列表, 请使用 -h 选项运行服务器.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h 您会看到服务器可以使用的所有选项的列表 以及每个选项的简要说明. 提供的描述并不总是足够的, 因此我们提供了一些更重要选项的解释.\n代理配置 如果您的AUT在需要身份验证的HTTP代理后面, 则应使用以下命令配置http.proxyHost, http.proxyPort, http.proxyUser 和http.proxyPassword.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password 多窗口模式 如果您使用的是Selenium 1.0, 则可能会跳过本节, 因为多窗口模式是默认行为. 但是, 在版本1.0之前, Selenium默认在子frame中运行测试中的应用程序, 如下所示.\n某些应用程序无法在子框架中正常运行, 需要将其加载到窗口的顶部框架中. 多窗口模式选项允许AUT在单独的窗口中运行, 而不是在默认帧中运行, 然后在默认帧中可以拥有所需的顶部帧.\n对于旧版本的Selenium, 您必须使用以下选项明确指定多窗口模式:\n-multiwindow 从Selenium RC 1.0开始, 如果您想在一个框架内运行测试(即使用早期Selenium版本的标准), 则可以使用选项将此状态指定给Selenium服务器\n-singlewindow 指定Firefox配置文件 除非您为每个实例分别指定一个配置文件, 否则Firefox将不会同时运行两个实例. Selenium RC 1.0和更高版本会自动在单独的配置文件中运行, 因此, 如果您使用的是Selenium 1.0, 则可以跳过本节. 但是, 如果您使用的是旧版本的Selenium, 或者需要使用特定的配置文件进行测试 (例如添加https证书或安装了一些插件), 则需要明确指定配置文件.\n首先, 要创建一个单独的Firefox配置文件, 请遵循以下步骤. 打开Windows\u0026quot;开始\u0026quot;菜单, 选择\u0026quot;运行\u0026rdquo;, 然后键入并输入以下内容之一:\nfirefox.exe -profilemanager firefox.exe -P 使用对话框创建新的配置文件. 然后, 当您运行Selenium服务器时, 告诉它使用带有服务器命令行选项 -firefoxProfileTemplate 的 新Firefox配置文件, 并使用其文件名和目录路径指定配置文件的路径.\n-firefoxProfileTemplate \u0026#34;path to the profile\u0026#34; 注意: 确保将您的个人资料放在默认文件夹之外的新文件夹中！！！！ 如果删除配置文件, 则Firefox配置文件管理器工具将删除文件夹中的所有文件, 无论它们是否是配置文件.\n有关Firefox配置文件的更多信息, 请参见 Mozilla的知识库\n使用-htmlSuite在服务器内直接运行Selenese 通过将html文件传递到服务器的命令行, 可以直接在Selenium 服务器中运行Selenese html文件. 例如:\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; 这将自动启动您的HTML套件, 运行所有测试并保存带有结果的漂亮HTML报告.\n注意: 使用此选项时, 服务器将启动测试并等待指定的秒数以完成测试； 否则, 服务器将停止测试. 如果在这段时间内未完成测试, 则该命令将以非零的退出代码退出, 并且不会生成任何结果文件.\n此命令行很长, 因此在键入时要小心. 请注意, 这要求您传递HTML Selenese套件, 而不是单个测试. 另请注意-htmlSuite选项与 -interactive不兼容, 您不能同时运行两者e.\nSelenium 服务器日志 服务端日志 启动Selenium服务器时, -log 选项可用于 将Selenium服务器报告的有价值的调试信息 记录到文本文件中.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log 该日志文件比标准控制台日志更详细 (它包含DEBUG级别的日志消息). 日志文件还包括记录器名称和记录消息的线程的ID号. 例如:\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW 消息格式为\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE 此消息可能是多行.\n浏览器端日志 浏览器端的JavaScript(Selenium Core)也记录重要消息. 在许多情况下, 这些对于最终用户比常规的Selenium 服务器日志更有用. 要访问浏览器端日志, 请将 -browserSideLog参数传递给Selenium服务器.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog 必须与 -log 参数结合使用, 以将browserSideLogs(以及所有其他DEBUG级别的日志记录消息)记录到文件中.\n指定特定浏览器的路径 您可以为Selenium RC指定到特定浏览器的路径. 如果您使用同一浏览器的不同版本, 并且希望使用特定的浏览器, 这将很有用. 另外, 它用于允许您的测试在Selenium RC不直接支持的浏览器上运行. 在指定运行模式时, 请使用*custom说明符, 后跟浏览器可执行文件的完整路径:\n*custom \u0026lt;path to browser\u0026gt; Selenium RC 架构 注意: 本主题试图说明Selenium RC背后的技术实现. Selenium用户了解这一点并不是基本知识, 但对于理解您将来可能会发现的一些问题可能很有用.\n要详细了解Selenium RC Server的工作原理 以及为什么使用代理注入和增强特权模式, 您必须首先了解 同源政策.\n同源策略 Selenium面临的主要限制是同源策略. 此安全限制适用于市场上的每个浏览器, 其目的是确保一个站点的内容永远不会被另一个站点的脚本访问. 同源策略规定, 浏览器中加载的任何代码只能在该网站的域内运行. 它无法在其他网站上执行功能. 因此, 例如, 如果浏览器在加载www.mysite.com时加载了JavaScript代码, 则即使该网站是您的另一个网站, 也无法针对www.mysite2.com运行该加载的代码. 如果可能的话, 如果您在其他标签上打开了帐户页面, 则在您打开的任何网站上放置的脚本都将能够读取银行帐户上的信息. 这称为XSS(跨站点脚本).\n要在此政策下工作, 必须将Selenium-Core(及其实现所有魔术的JavaScript命令) 放置在与被测应用程序相同的来源(相同的URL)中.\n从历史上看, Selenium-Core受此问题限制, 因为它是用JavaScript实现的. 但是, Selenium RC不受\u0026quot;同一来源\u0026quot;政策的限制. 它使用Selenium服务器作为代理可以避免此问题. 从本质上讲, 它告诉浏览器该浏览器正在服务器提供的单个\u0026quot;欺骗\u0026quot;网站上工作.\n注意: 您可以在Wikipedia页面上找到有关此主题的其他信息, 这些信息与同源策略和XSS有关.\n代理注入 Selenium用来避免\u0026quot;同源策略\u0026quot;的第一种方法是代理注入. 在代理注入模式下, Selenium 服务器充当客户端配置的 HTTP proxy 1 位于浏览器和Test2中. 然后, 它在虚构的URL下掩盖AUT (嵌入Selenium-Core和测试集, 并像它们来自同一来源一样进行交付).\n以下是架构图.\n当测试套件以您喜欢的语言开始时, 会发生以下情况:\n 客户端/驱动程序与Selenium-RC服务器建立连接. Selenium RC服务器启动带有URL的浏览器(或重用旧的浏览器), 该URL将Selenium-Core的JavaScript注入浏览器加载的网页中. 客户端驱动程序将Selenese命令传递到服务器. 服务器解释命令, 然后触发相应的JavaScript执行以在浏览器中执行该命令. Selenium-Core指示浏览器按照第一条指令操作, 通常会打开AUT的页面. 浏览器收到打开的请求, 并从Selenium RC服务器 (设置为供浏览器使用的HTTP代理) 中请求网站的内容. Selenium RC服务器与Web服务器进行通信以请求页面, 并在收到页面后将页面发送给浏览器, 以掩盖其来源, 以使页面看起来与Selenium-Core来自同一服务器 (这使Selenium-Core可以遵从使用同源策略). 浏览器接收网页并将其呈现在为其保留的框架/窗口中.  特权浏览器 此方法中的此工作流程与代理注入非常相似, 但主要区别在于浏览器以一种称为 增强特权 的特殊模式启动, 该模式允许网站执行通常不允许的操作 (例如XSS_或填充文件上传输入)和对Selenium非常有用的东西). 通过使用这些浏览器模式, Selenium Core能够直接打开AUT并与其内容进行读取/交互, 而不必将整个AUT传递给Selenium RC服务器.\n以下是架构图.\n当测试套件以您喜欢的语言开始时, 会发生以下情况:\n 客户端/驱动程序与Selenium-RC服务器建立连接. Selenium RC服务器启动一个带有URL的浏览器(或重用旧的浏览器), 该URL将在网页中加载Selenium-Core. Selenium-Core从客户端/驱动程序获取第一条指令 (通过向Selenium RC服务器发出的另一个HTTP请求). Selenium-Core对该第一条指令起作用, 通常会打开AUT的页面. 浏览器收到打开请求, 并向Web服务器询问该页面. 浏览器收到网页后, 将其呈现在为其保留的框架/窗口中.  处理HTTPS和安全弹出窗口 当许多应用程序需要发送加密的信息(例如密码或信用卡信息)时, 它们从使用HTTP切换到HTTPS. 这在当今的许多网络应用程序中很常见. Selenium RC支持这一点.\n为了确保HTTPS站点是真实的, 浏览器将需要安全证书. 否则, 当浏览器使用HTTPS访问AUT时, 将假定该应用程序不被\u0026quot;信任\u0026rdquo;. 发生这种情况时, 浏览器将显示安全弹出窗口, 并且无法使用Selenium RC关闭这些弹出窗口\n在Selenium RC测试中处理HTTPS时, 必须使用支持该模式并为您处理安全证书的运行模式. 您在测试程序初始化Selenium时指定运行模式.\n在Selenium RC 1.0 beta 2和更高版本中, 将*firefox或*iexplore用于运行模式. 在早期版本中, 包括Selenium RC 1.0 beta 1, 在运行模式中使用*chrome或*iehta. 使用这些运行模式, 您将不需要安装任何特殊的安全证书. Selenium RC会为您处理.\n在1.0版中, 建议使用运行模式*firefox或*iexplore. 但是, 还有*iexploreproxy和*firefoxproxy的其他运行模式. 提供这些仅是为了向后兼容, 除非传统测试程序要求, 否则不应使用它们. 如果您的应用程序打开其他浏览器窗口, 则它们的使用将对安全证书处理和多个窗口的运行产生限制.\n在早期版本的Selenium RC中, *chrome或*iehta是支持HTTPS和安全弹出窗口处理的运行模式. 尽管它们变得相当稳定并且许多人使用了它们, 但这些被认为是\u0026quot;实验模式\u0026rdquo;. 如果使用的是Selenium 1.0, 则不需要, 也不应使用这些较早的运行模式.\n安全证书说明 通常, 浏览器将通过安装您已经拥有的安全证书来信任您正在测试的应用程序. 您可以在浏览器的选项或Internet属性中进行检查 (如果您不知道AUT的安全证书, 请咨询系统管理员). 当Selenium加载浏览器时, 它将注入代码以拦截浏览器和服务器之间的消息. 浏览器现在认为不受信任的软件正试图看起来像您的应用程序. 它通过弹出消息提醒您.\n为解决此问题, Selenium RC(再次使用支持此功能的运行模式时) 将在浏览器可以访问它的位置临时将其自己的安全证书安装到客户端计算机上. 这会欺骗浏览器以使其正在访问的网站与您的AUT不同, 从而有效地抑制了弹出窗口.\nSelenium早期版本使用的另一种方法是安装Selenium安装随附的Cybervillians安全证书. 但是, 大多数用户不再需要这样做. 如果您以代理注入模式运行Selenium RC, 则可能需要显式安装此安全证书.\n支持其他浏览器和浏览器配置 除了Internet Explorer和Mozilla Firefox外, Selenium API还支持在多种浏览器上运行. 请访问https://selenium.dev网站以获取受支持的浏览器. 另外, 当不直接支持浏览器时, 您仍然可以在测试应用程序启动时通过使用 \u0026ldquo;*custom\u0026quot;运行模式(即代替*firefox或*iexplore) 对所选浏览器运行Selenium测试. 这样, 您可以将路径传递到API调用内的浏览器可执行文件. 也可以从服务器以交互方式完成此操作.\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com 使用不同的浏览器配置运行测试 通常, Selenium RC自动配置浏览器, 但是如果您使用\u0026rdquo;*custom\u0026quot;运行模式启动浏览器, 则可以强制Selenium RC照原样启动浏览器, 而无需使用自动配置.\n例如, 您可以使用这样的自定义配置启动Firefox:\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com 请注意, 以这种方式启动浏览器时, 必须手动配置浏览器以将Selenium服务器用作代理. 通常, 这仅意味着打开浏览器首选项并将\u0026quot;localhost:4444\u0026quot;指定为HTTP代理, 但是不同浏览器的说明可能会有根本不同. 有关详细信息, 请查阅浏览器的文档.\n请注意, Mozilla浏览器的启动和停止方式可能会有所不同. 可能需要设置MOZ_NO_REMOTE环境变量, 以使Mozilla浏览器的行为更加可预测. Unix用户应避免使用Shell脚本启动浏览器. 通常最好直接使用二进制可执行文件(例如firefox-bin).\n解决常见问题 在开始使用Selenium RC时, 通常会遇到一些潜在的问题. 我们在这里介绍它们及其解决方案.\n无法连接到服务器 当您的测试程序无法连接到Selenium 服务器时, Selenium会在您的测试程序中引发异常. 它应该显示此消息或类似的消息:\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2) 如果看到这样的消息, 请确保已启动Selenium服务器. 如果是这样, 则Selenium客户端库和Selenium服务器之间的连接存在问题.\n从Selenium RC开始时, 大多数人开始是在同一台计算机上运行测试程序(带有Selenium客户端库) 和Selenium服务器. 为此, 请使用\u0026quot;localhost\u0026quot;作为连接参数. 我们建议您以这种方式开始, 因为它可以减少您入门时可能出现的网络问题的影响. 假设您的操作系统具有典型的网络和TCP/IP设置, 那么您应该没有什么困难. 实际上, 许多人选择以这种方式运行测试.\n但是, 如果您确实想在远程计算机上运行Selenium服务器, 则假设两台计算机之间具有有效的TCP/IP连接, 则连接应该很好.\n如果连接困难, 可以使用常用的网络工具, 例如ping, telnet, ifconfig(Unix)/ipconfig (Windows) 等, 以确保您具有有效的网络连接. 如果不熟悉这些, 则系统管理员可以为您提供帮助.\n无法加载浏览器 好的, 这并非友好的错误消息, 很抱歉, 但是如果Selenium服务器无法加载浏览器, 您可能会看到此错误.\n(500) Internal Server Error 这可能是由于\n Firefox(Selenium 1.0之前的版本)无法启动, 因为浏览器已经打开, 并且您未指定单独的配置文件. 请参阅\u0026quot;服务器选项\u0026quot;下有关Firefox配置文件的部分 您使用的运行模式与您计算机上的任何浏览器都不匹配. 程序打开浏览器时检查您传递给Selenium的参数. 您已明确指定浏览器的路径(使用\u0026rdquo;*custom\u0026rdquo; –参见上文), 但该路径不正确. 检查以确保路径正确. 还要检查用户组, 以确保浏览器和\u0026rdquo;*custom\u0026quot;参数没有已知问题.  Selenium 找不到AUT 如果您的测试程序成功启动了浏览器, 但是浏览器未显示您正在测试的网站, 则最可能的原因是您的测试程序未使用正确的URL.\n这很容易发生. 当您使用Selenium-IDE导出脚本时, 它会插入一个虚拟URL. 您必须手动将URL更改为正确的URL才能测试您的应用程序.\nFirefox在准备配置文件时拒绝关闭 最常见的情况是在Firefox上运行Selenium RC测试程序, 但是已经运行了Firefox浏览器会话, 并且在启动Selenium服务器时未指定单独的配置文件. 测试程序中的错误如下所示:\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile 以下是来自服务器的完整错误消息:\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock 要解决此问题, 请参阅\u0026quot;指定单独的Firefox配置文件\u0026quot;部分\n版本问题 确保您的Selenium版本支持您的浏览器版本. 例如, Selenium RC 0.92不支持Firefox3. 有时您可能很幸运(例如我). 但不要忘记检查您使用的Selenium版本支持哪些浏览器版本. 如有疑问, 请使用最新版本的Selenium和浏览器使用最广泛的版本.\n启动服务器时出现错误消息: \u0026ldquo;(不支持的major.minor版本49.0)\u0026rdquo; 此错误表明您使用的Java版本不正确. Selenium服务器需要Java 1.5或更高版本.\n要检查您的Java版本, 请从命令行运行.\njava -version 您应该看到一条消息, 显示Java版本.\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) 如果看到较低的版本号, 则可能需要更新JRE, 或者只需将其添加到PATH环境变量中即可.\n404 error when running the getNewBrowserSession command 如果尝试打开\u0026rdquo; http://www.google.com/selenium-server/\u0026quot;上的页面时遇到404错误, 则一定是因为Selenium服务器未正确配置为代理. Selenium-server\u0026quot;目录在google.com上不存在； 仅当正确配置了代理后, 该目录才存在. 代理配置在很大程度上取决于如何使用firefox, iexplore, opera或custom启动浏览器.\n  iexplore：如果使用*iexplore启动浏览器, 则可能是Internet Explorer的代理设置有问题. Selenium服务器尝试在Internet选项控制面板中配置全局代理设置. 您必须确保在Selenium服务器启动浏览器时正确配置了这些配置. 尝试查看\u0026rdquo; Internet选项\u0026quot;控制面板. 单击\u0026quot;连接\u0026quot;选项卡, 然后单击\u0026quot;局域网设置\u0026rdquo;.\n 如果您需要使用代理来访问要测试的应用程序, 则需要使用\u0026rdquo; -Dhttp.proxyHost\u0026quot;启动Selenium服务器. 有关更多详细信息, 请参见 代理配置 . 您也可以尝试手动配置代理, 然后使用*custom或*iehta浏览器启动器启动浏览器.    custom: 使用*custom时, 必须正确(手动)配置代理, 否则会出现404错误. 仔细检查您是否正确配置了代理设置. 要检查您是否正确配置了代理, 则是试图故意不正确地配置浏览器. 尝试将浏览器配置为使用错误的代理服务器主机名或错误的端口. 如果您错误地成功配置了浏览器的代理设置, 则浏览器将无法连接到Internet, 这是一种确保正在调整相关设置的方法.\n  对于其他浏览器(*firefox, *opera), 我们会自动为您硬编码代理, 因此此功能没有已知问题. 如果您遇到404错误, 并已按照本用户指南进行操作, 请仔细将结果发布到用户组, 以获取用户社区的帮助.\n  权限被拒绝错误 发生此错误的最常见原因是您的会话试图跨域 (例如, 从http://domain1访问页面, 然后从http://domain2访问页面)来违反同源策略. 协议(从http://domainX移至https://domainX).\n当JavaScript尝试查找尚不可用 (在页面完全加载之前)或不再可用 (在页面开始卸载之后)的UI对象时, 也会发生此错误. 最常见的情况是AJAX页面正在处理页面的某些部分 或独立于较大页面而加载和/或重新加载的子frame.\n该错误可能是间歇性的. 通常, 用调试器不可能重现该问题, 因为问题是由于竞争条件引起的, 当将调试器的开销添加到系统中时, 这些竞争条件是无法再现的. 许可问题在本教程中进行了详细介绍. 仔细阅读有关同源策略, 代理注入的部分.\n处理浏览器弹出窗口 在Selenium测试中可以得到几种\u0026quot;弹出窗口\u0026rdquo;. 如果Selenium命令是由浏览器而不是AUT发起的, 则可能无法通过运行Selenium命令来关闭这些弹出窗口. 您可能需要知道如何进行管理. 每种类型的弹出窗口都需要以不同的方式处理.\n  HTTP基本身份验证对话框： 这些对话框提示输入用户名/密码登录到站点. 要登录到需要HTTP基本身份验证的站点, 请使用 RFC 1738中所述的URL中的用户名和密码, 如下所示：open (\u0026rdquo; http//myusername:myuserpassword@myexample.com/blah/blah/blah\u0026rdquo;).\n  SSL证书警告： 当Selenium RC启用为代理时, 它会自动尝试欺骗SSL证书. 请参阅HTTPS部分中的更多内容. 如果您的浏览器配置正确, 您将永远不会看到SSL证书警告, 但是您可能需要将浏览器配置为信任我们危险的\u0026quot;CyberVillains\u0026rdquo; SSL证书颁发机构. 再次, 请参阅HTTPS部分以了解如何执行此操作.\n  模态JavaScript警报/确认/提示对话框： Selenium试图向您隐藏这些对话框 (通过替换window.alert, window.confirm和window.prompt), 以便它们不会停止您页面的执行. 如果您看到警告弹出窗口, 可能是因为它是在页面加载过程中触发的, 对于我们而言, 保护该页面通常为时过早. Selenese包含用于断言或验证警报和确认弹出窗口的命令. 请参阅第4章中有关这些主题的部分.\n  在Linux上, 为什么我的Firefox浏览器会话没有关闭? 在Unix/Linux上, 您必须直接调用\u0026quot;firefox-bin\u0026rdquo;, 因此请确保路径中包含可执行文件. 如果通过外壳程序脚本执行Firefox, 则该终止浏览器了. SeleniumRC将终止该外壳程序脚本, 使浏览器保持运行状态. 您可以像这样直接指定firefox-bin的路径.\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome不适用于自定义配置文件 检查Firefox配置文件文件夹 -\u0026gt; prefs.js-\u0026gt; \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; 像这样注释此行：\u0026quot;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; 然后再试一次.\n是否可以在加载父页面时加载自定义弹出窗口(即, 在父页面的javascript window.onload()函数运行之前) 否. Selenium依靠拦截器来确定正在加载的窗口名称. 如果在onload()函数之后加载窗口, 则这些拦截器最适合捕获新窗口. Selenium可能无法识别在onload功能之前加载的Windows.\nLinux上的Firefox 在Unix/Linux上, Selenium 1.0之前的版本需要直接调用\u0026quot;firefox-bin\u0026rdquo;, 因此, 如果您使用的是以前的版本, 请确保路径中包含真正的可执行文件.\n在大多数Linux发行版中, 真正的 firefox-bin 位于:\n/usr/lib/firefox-x.x.x/ 其中x.x.x是您当前拥有的版本号. 因此, 要将该路径添加到用户的路径. 您将必须将以下内容添加到您的.bashrc文件中:\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; 如有必要, 您可以在测试中直接指定firefox-bin的路径, 如下所示:\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IE和样式属性 如果您在Internet Explorer上运行测试, 则无法使用其 style 属性来查找元素. 例如:\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] 这将在Firefox, Opera或Safari中完美运行, 但不适用于IE. IE将 @style 中的键解释为大写. 因此, 即使源代码是小写的, 您也应该使用:\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] 如果您的测试打算在多个浏览器上运行, 那么这将是一个问题, 但是您可以轻松地对测试进行编码以检测情况 并尝试仅在IE中运行的替代定位器.\n遇到错误-随着*googlechrome浏览器的关闭, \u0026ldquo;无法将对象转换为原始值\u0026rdquo; 为避免此错误, 您必须使用禁用 同源策略检查的选项启动浏览器:\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); IE中遇到的错误-\u0026ldquo;无法打开应用程序窗口；弹出窗口阻止程序已启用？\u0026rdquo; 为避免此错误, 您必须配置浏览器： 禁用弹出窗口阻止程序, 并取消选中工具\u0026raquo;选项\u0026raquo;安全中的\u0026quot;启用保护模式\u0026quot;选项.\n  代理人是中间的第三人, 两人之间传球. 它充当将AUT传送到浏览器的\u0026quot;网络服务器\u0026rdquo;. 作为代理, Selenium服务器可以\u0026quot;说谎\u0026quot;AUT的真实URL. \u0026#x21a9;\u0026#xfe0e;\n 启动浏览器时使用的配置文件将localhost:4444设置为HTTP代理, 这就是为什么浏览器执行的任何HTTP请求都将通过Selenium服务器并且响应将通过它而不是真实服务器通过的原因. \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/introduction/the_selenium_project_and_tools/",
	"title": "Selenium 项目和工具",
	"tags": [],
	"description": "",
	"content": "Selenium 控制网页浏览器 Selenium 有很多功能， 但其核心是 web 浏览器自动化的一个工具集， 它使用最好的技术来远程控制浏览器实例， 并模拟用户与浏览器的交互。\n它允许用户模拟终端用户执行的常见活动；将文本输入到字段中，选择下拉值和复选框，并单击文档中的链接。 它还提供许多其他控件，比如鼠标移动、任意 JavaScript 执行等等。\n虽然 Selenium 主要用于网站的前端测试，但其核心是浏览器用户代理库。 这些接口在应用程序中无处不在，它们鼓励与其他库进行组合，以满足您的目的。\n一个接口来统治它们 该项目的指导原则之一是支持所有（主要）浏览器技术的通用接口。 Web 浏览器是非常复杂的，高度工程化的应用程序， 以完全不同的方式执行它们的操作，但是在执行这些操作时，它们通常看起来是一样的 即使文本以相同的字体呈现，图像也会显示在相同的位置，并且链接会将您带到相同的目的地。 下面发生的事情就像白天和黑夜一样不同。 Selenium “抽象”了这些差异，向编写代码的人隐藏了它们的细节和复杂性。 这允许您编写几行代码来执行一个复杂的工作流程， 但是这几行代码将在 Firefox、 Internet Explorer、 Chrome 和所有其他支持的浏览器上执行。\n工具和支持 Selenium 的极简设计方法使其具有通用性，可以作为更大应用程序中的组件。 Selenium 保护伞下提供的周边基础设施为您提供了组合自己的 浏览器 grid 的工具， 因此测试就可以跨一系列机器在不同的浏览器和多个操作系统上运行。\n想象一下， 服务器机房或数据中心的一组计算机同时启动浏览器，访问站点的链接、表单和表格 — 全天 24 小时测试应用程序。 通过为最常见的语言提供的简单编程接口， 这些测试将不知疲倦地并行运行， 当错误发生时向您报告。\n通过为用户提供工具和文档， 不仅可以控制浏览器， 还可以方便地扩展和部署这些 grid， 从而帮助您实现这一目标。\n通过为用户提供工具和文档，不仅可以控制浏览器， 还可以简化网格的伸缩和部署。 来帮助您实现这一目标， 这些工具和文档\n谁在使用 Selenium 世界上许多最重要的公司都在基于浏览器的测试中采用了 Selenium， 这常常取代了多年来涉及其他专有工具的工作。 随着它越来越受欢迎， 它的需求和挑战也成倍增加。\n随着网络变得越来越复杂，新的技术被添加到网站上， 这个项目的任务就是尽可能地跟上它们。 作为一个开源项目，这种支持是通过许多志愿者的慷慨捐赠来提供的， 每个志愿者都有一份“日常工作”。\n该项目的另一个任务是鼓励更多的志愿者参与到这项工作中来， 并建立一个强大的社区，以便项目能够继续跟上新兴的技术， 并继续成为功能测试自动化的主导平台。\n历史 当 Selenium 1 于 2004 年发布时， 出于减少在 web 应用程序前端手工验证一致行为所花费的时间的需要。 它利用了当时可用的工具， 并严重依赖于向测试中的 web 页面注入 JavaScript 来模拟用户的交互。\n虽然 JavaScript 是一个很好的工具， 可以让您自省 DOM 的属性， 并进行某些客户端观察， 否则您将无法进行这些观察， 但是它不具备像使用鼠标和键盘那样自然复制用户交互的能力。\n从那时起，Selenium 已经成长并成熟了很多， 成为世界上许多（不是大多数）大型机构广泛使用的工具。 Selenium 已经从 Thoughtworks 为特定受众和特定用例开发的自制测试自动化工具包， 转移到世界上的浏览器自动化库。\n正如 Selenium RC 利用了当时可用的工具一样， Selenium WebDriver 将浏览器交互部分带到浏览器供应商的地盘， 并要求他们负责后端、面向浏览器的实现，从而推动了这一传统。 最近，这项工作已经发展成为 W3C 标准化过程， 其目标是将 Selenium 中的 WebDriver 组件转换为用户代理的 du jeur 远程控制库。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/understanding_the_components/",
	"title": "了解组件",
	"tags": [],
	"description": "",
	"content": "使用 WebDriver 构建测试套件需要您理解并有效地使用许多不同的组件。就像软件中的一切一样， 不同的人对同一个想法使用不同的术语。下面是在这个描述中如何使用术语的细分。\n专业术语  API: 应用程序编程接口。这是一组用来操作 WebDriver 的 “命令”。 库: 一个代码模块，它包含 api 和实现这些 api 所需的代码。库是对应于具体的语言的，例如 Java 的 .jar 文件，.NET 的 .dll 文件，等等。 驱动程序: 负责控制实际的浏览器。大多数驱动程序是由浏览器厂商自己创建的。 驱动程序通常是与浏览器一起在系统上运行的可执行模块，而不是在执行测试套件的系统上。 (尽管它们可能是同一个系统。) 注意: 有些人把驱动称为代理。 框架: 用于支持 WebDriver 套件的附加库。这些框架可能是测试框架，如 JUnit 或 NUnit。 它们也可能是支持自然语言特性的框架，如 Cucumber 或 Robotium。还可以编写和使用框架来操作或配置被测试的系统、 数据创建、测试预言等等。  组成部分 至少，WebDriver 通过一个驱动程序与浏览器对话。通信有两种方式: WebDriver 通过驱动程序向浏览器传递命令， 然后通过相同的路径接收信息。\n驱动程序是特定于浏览器的，例如 ChromeDriver 对应于谷歌的 Chrome/Chromium， GeckoDriver 对应于 Mozilla 的 Firefox 的，等等。驱动程序在与浏览器相同的系统上运行。 这可能与执行测试本身的系统相同，也可能不同。\n上面这个简单的例子就是 _直接_通信。与浏览器的通信也可以是通过 Selenium 服务器或 RemoteWebDriver 进行的 _远程_通信。RemoteWebDriver 与驱动程序和浏览器运行在同一个系统上。\n远程通信也可以使用 Selenium Server 或 Selenium Grid 进行，这两者依次与主机系统上的驱动程序进行通信\n应用框架 WebDriver 有且只有一个任务: 通过上面的任何方法与浏览器通信。WebDriver 对测试一窍不通：它不知道如何比较事物、 断言通过或失败，当然它也不知道报告或 Given/When/Then 语法。\n这就是各种框架发挥作用的地方。至少你需要一个与绑定语言相匹配的测试框架，比如. NET 的 NUnit, Java 的 JUnit, Ruby 的 RSpec 等等。\n测试框架负责运行和执行 WebDriver 以及测试中相关步骤。因此，您可以认为它看起来类似于下图。\n像 Cucumber 这样的自然语言框架/工具可能作为上图中测试框架框的一部分存在， 或者它们可能将测试框架完全封装在它们自己的实现中。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/getting_started/",
	"title": "入门指南",
	"tags": [],
	"description": "",
	"content": "入门指南 如果您刚刚接触 Selenium，我们有一些资源可以帮助您快速上手。\n 快速浏览  WebDriver IDE Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/driver_idiosyncrasies/shared_capabilities/",
	"title": "共享的功能",
	"tags": [],
	"description": "",
	"content": "为了通过Selenium WebDriver创建新会话, 本地端应向远程端提供基本功能. 远端使用相同的功能集来创建会话并描述当前会话功能.\nWebDriver提供了每个远程端将 (或应该) 支持实现的功能. 以下是WebDriver支持的功能:\nbrowserName: 此功能用于设置既定会话的 browserName . 如果未在远端安装指定的浏览器, 则会话创建将失败 This capability is used to set the browserName for a given session. If the specified browser is not installed at the remote end, the session creation will fail\nbrowserVersion: 此功能是可选的, 用于在远程端设置可用的浏览器版本. 例如, 如果在仅安装80版本的系统上询问75版本的Chrome, 则会话创建将失败\n页面加载策略 通过URL导航到新页面时, 默认情况下, Selenium将等待页面完全加载后再进行响应. 这对于初学者来说效果很好, 但是在加载大量第三方资源的页面上可能会导致较长的等待时间. 在这种情况下, 使用非默认策略可以使测试的执行速度更快, 但是也可能导致不稳定, 即页面上的元素随元素加载和大小变化而改变位置.\n页面加载策略可以参考链接 document.readyState 如下述表格的描述:\n   策略 准备完成的状态 备注     normal complete 默认情况下使用, 等待所有资源下载完成   eager interactive DOM访问已准备就绪, 但其他资源 (如图像) 可能仍在加载中   none Any 完全不阻塞WebDriver    platformName 这标识了远端的操作系统, 获取 platformName 将返回操作系统的名称.\n在基于云的供应者中, 设置 platformName 将在远程端设置操作系统.\nacceptInsecureCerts 此功能检查在会话期间导航时 是否使用了过期的 (或) 无效的 TLS Certificate .\n如果将功能设置为 false, 则页面浏览遇到任何域证书问题时, 将返回insecure certificate error . 如果设置为 true, 则浏览器将信任无效证书.\n默认情况下, 此功能将信任所有自签名证书. 设置后, acceptInsecureCerts 功能将在整个会话中生效.\nSession timeouts WebDriver session 具有一定的 session timeout 间隔, 在此间隔内, 用户可以控制执行脚本或从浏览器检索信息的行为.\n每个会话超时都配置有不同 timeouts 的组合, 如下所述:\nScript Timeout: 指定在当前浏览上下文中, 中断正在执行脚本的时机. WebDriver创建新会话时, 将设置默认的超时时间为 30,000 .\nPage Load Timeout: 指定在当前浏览上下文中, 加载网页的时间间隔. WebDriver创建新会话时, 默认设置超时时间为 300,000 . 如果页面加载限制了给定 (或默认) 的时间范围, 则该脚本将被 TimeoutException 停止.\nImplicit Wait Timeout 指定在定位元素时, 等待隐式元素定位策略的时间. WebDriver创建新会话时, 将设置默认超时时间为 0 .\nunhandledPromptBehavior 指定当前会话 user prompt handler 的状态. 默认为 dismiss and notify state .\nUser Prompt Handler 这定义了在远端出现用户提示时必须采取的措施. 该行为由unhandledPromptBehavior 功能定义, 具有以下状态:\n dismiss accept dismiss and notify accept and notify ignore  setWindowRect 此命令更改当前浏览上下文中窗口的大小和位置. 此命令作为 getWindowRect 对应的设置方法, 该命令接受 width, height, x, y 作为 可选 参数.\n在自动化期间, 当前浏览上下文将与描述浏览器窗口可见性状态的窗口状态相关联. 窗口状态为\n maximized minimized normal fullscreen  设置 Width 或 Height 不能保证结果窗口的大小一定完全匹配所请求的窗口大小. 这是因为某些驱动程序可能无法以单像素为单位调整大小. 因此, 通过 getWindowRect 获取窗口状态 (或详细信息) 可能与浏览器设置的值不匹配.\nstrictFileInteractability The new capabilitiy indicates if strict interactability checks should be applied to input type=file elements. As strict interactability checks are off by default, there is a change in behaviour when using Element Send Keys with hidden file upload controls.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/selenium_installation/installing_selenium_libraries/",
	"title": "安装 Selenium 库",
	"tags": [],
	"description": "",
	"content": "首先，您需要为自动化项目安装 Selenium 绑定库。 库的安装过程取决于您选择使用的语言。\nJava 可以使用 Maven 安装 Java 的 Selenium 库。 在项目 pom.xml 中添加 selenium-java 依赖项：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; selenium-java 依赖项支持在所有 Selenium 支持的浏览器中运行自动化项目。 如果只想在特定的浏览器中运行测试，可以在 pom.xml 文件中添加该浏览器的依赖项。 例如，您应该在 pom.xml 文件中添加以下依赖项，以便于只在 Firefox 中运行测试：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 同样，如果您只想在 Chrome 上运行测试，您应该添加以下依赖项：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python 可以使用 pip 安装 Python 的 Selenium 库：\npip install selenium 或者，您也可以下载 PyPI source archive (selenium-x.x.x.tar.gz) 并使用 setup.py 进行安装：\npython setup.py install C# 可以使用 NuGet 安装 C# 的 Selenium 库：\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby 可以使用 gem 安装 Ruby 的 Selenium 库：\ngem install selenium-webdriver JavaScript 可以使用 npm 安装 JavaScript 的 Selenium 库\nnpm install selenium-webdriver "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/getting_started/quick/",
	"title": "快速浏览",
	"tags": [],
	"description": "",
	"content": "Selenium 不仅仅是一个工具或 API, 它还包含许多工具.\nWebDriver 如果您开始使用桌面网站测试自动化, 那么您将使用 WebDriver APIs. WebDriver 使用浏览器供应商提供的浏览器自动化 API 来控制浏览器和运行测试. 这就像真正的用户正在操作浏览器一样. 由于 WebDriver 不要求使用应用程序代码编译其 API, 因此它本质上不具有侵入性. 因此, 您测试的应用程序与实时推送的应用程序相同.\nSelenium IDE Selenium IDE (Integrated Development Environment 集成开发环境) 是用来开发 Selenium 测试用例的工具. 这是一个易于使用的 Chrome 和 Firefox 浏览器扩展, 通常是开发测试用例最有效率的方式. 它使用现有的 Selenium 命令记录用户在浏览器中的操作, 参数由元素的上下文确定. 这不仅节省了开发时间, 而且是学习 Selenium 脚本语法的一种很好的方法.\nGrid Selenium Grid允许您在不同平台的不同机器上运行测试用例. 可以本地控制测试用例的操作, 当测试用例被触发时, 它们由远端自动执行.\n当开发完WebDriver测试之后, 您可能需要在多个浏览器和操作系统的组合上运行测试. 这就是 Grid 的用途所在.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/getting_started_with_webdriver/browsers/",
	"title": "浏览器",
	"tags": [],
	"description": "",
	"content": "消费级浏览器 当前Selenium框架支持以下浏览器:\n   浏览器 维护者 支持的版本     Chrome Chromium 所有版本   Firefox Mozilla 54及以上版本   Internet Explorer Selenium 6及以上版本   Opera Opera Chromium / Presto 10.5及以上版本   Safari Apple 10及以上版本    专业级浏览器 还有一些通常在开发环境中使用的专业级浏览器。 我们也可以使用其中一些浏览器实现自动化的目的， Selenium支持以下专业驱动:\n   驱动名称 用途 维护者     HtmlUnitDriver Rhino支持的无头浏览器模拟器 Selenium项目组    "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/front_matter/copyright_and_attributions/",
	"title": "版权和归属",
	"tags": [],
	"description": "",
	"content": "Selenium文档 Copyright \u0026copy; 2013-2020 , Software Freedom Conservancy.\n我们已尽一切努力使本文档尽可能完整和准确, 但难以保证一定适用. 信息提供是基于“as-is”的. 若本文档所含信息引起的任何损失或损害, 作者和出版者对所有个人或实体均不承担任何责任. 不承担任何与使用本文信息相关的专利责任.\n归属 感谢: Selenium Main Repository Selenium IDE Docker Selenium Selenium Website \u0026amp; Docs Previous Selenium Website Previous Documentation Rewrite Project Selenium文档项目使用的第三方软件:    软件 版本 许可     Hugo v0.59.0 Apache 2.0   Hugo Learn Theme v2.4.0 MIT   Code Tabs Style \u0026mdash; MIT    许可 源自Selenium项目的所有代码和文档均基于Apache2.0的许可, 由 Software Freedom Conservancy 作为版权所有者.\n为方便起见, 此处包含许可证, 您也可以在此查看 Apache 基金会站点:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/grid/purposes_and_main_functionalities/",
	"title": "目的和主要功能",
	"tags": [],
	"description": "",
	"content": " 为所有的测试提供统一的入口 管理和控制运行着浏览器的节点/环境 扩展 并行测试 跨平台(操作系统)测试 负载测试  "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/remote_webdriver/remote_webdriver_server/",
	"title": "远程WebDriver服务器",
	"tags": [],
	"description": "",
	"content": "服务器将始终在安装了待测浏览器的机器上运行. 可以从命令行或通过代码配置来使用服务器.\n从命令行启动服务器 下载 selenium-server-standalone-{VERSION}.jar 后, 将其传到具有待测浏览器的电脑上. 然后, 切换到包含此jar文件的目录中, 运行以下命令:\njava -jar selenium-server-standalone-{VERSION}.jar 运行服务器的注意事项 调用者应调用 Selenium#stop() 或 WebDriver#quit 以结束每次会话.\nSelenium服务器在内存中保留每个运行会话的日志, 这些日志将在调用 Selenium#stop() 或 WebDriver#quit 时清除. 如果您忘记终止这些会话, 则可能会造成服务器内存泄漏. 如果您保持运行时间非常长的会话, 则可能需要不时执行停止或退出的操作 (或使用-Xmx jvm选项增加内存) .\n超时 (自2.21版本) 服务器有两种不同的超时, 可以按如下设置:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  控制允许浏览器挂起的时间 (以秒为单位的值) .   timeout  控制在回收会话之前允许客户端离开的时间 (以秒为单位的值) .    从2.21版本开始不再支持系统属性 selenium.server.session.timeout.\n请注意, 当常规超时机制发生故障时, browserTimeout旨在用作备份超时机制, 该机制应主要在网格和服务器的环境中使用, 以确保崩溃或丢失的进程不会驻留太长时间, 从而干扰了运行时环境.\n以编程方式配置服务器 从理论上讲, 此过程就像将 DriverServlet映射到URL一样简单, 但是也可以将页面托管在轻量级容器中, 例如完全用代码配置的Jetty. 步骤如下.\n 下载并解压 selenium-server.zip. 将这些Jar设置在CLASSPATH中. 创建一个名为 AppServer的新类. 在这里, 我使用Jetty, 因此您也需要download:  import org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } } "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/worst_practices/captchas/",
	"title": "验证码",
	"tags": [],
	"description": "",
	"content": "验证码 (CAPTCHA), 是 全自动区分计算机和人类的图灵测试 (Completely Automated Public Turing test to tell Computers and Humans Apart) 的简称, 是被明确地设计用于阻止自动化的, 所以不要尝试!\n规避验证码的检查, 主要有两个策略:\n 在测试环境中禁用验证码 添加钩子以允许测试绕过验证码  "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/introduction/",
	"title": "介绍",
	"tags": [],
	"description": "",
	"content": "介绍 Selenium 是一系列工具和库的综合项目，这些工具和库支持 web 浏览器的自动化。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/legacy_docs/migrating_from_rc_to_webdriver/",
	"title": "从RC迁移到WebDriver",
	"tags": [],
	"description": "",
	"content": "如何迁移到Selenium WebDriver 在采用Selenium 2时, 一个常见的问题是, 在将新测试添加到现有测试集中时, 正确的做法是什么? 刚接触框架的用户可以通过使用新的WebDriver API编写测试开始. 但是, 已经拥有一套现有测试的用户又该如何呢? 本指南旨在演示如何将现有测试迁移到新的API, 从而允许使用WebDriver提供的新功能编写所有新测试.\n此处介绍的方法描述了向WebDriver API的零星迁移, 而无需一次大刀阔斧地重新进行所有工作. 这意味着您可以留出更多时间来迁移现有测试, 这可以使您更轻松地决定将精力花在哪里.\n本指南使用Java编写, 因为它为迁移提供了最佳支持. 由于我们为其他语言提供了更好的工具, 因此本指南将扩展为包括这些语言.\n为什么要迁移到WebDriver 将一组测试从一个API移到另一个API需要大量的工作. 为什么您和您的团队考虑采取此举? 这是您应考虑迁移Selenium测试以使用WebDriver的一些原因.\n 较小, 紧凑的API. WebDriver的API比原始的Selenium RC API更面向对象. 这样可以更轻松地使用. 更好地模拟用户交互. WebDriver在可能的情况下利用本机事件与网页进行交互. 这更紧密地模仿了您的用户使用您的网站和应用程序的方式. 此外, WebDriver提供了高级的用户交互API, 使您可以为与网站的复杂交互建模. 浏览器供应商的支持. Opera, Mozilla和Google都是WebDriver开发的积极参与者, 并且各自都有工程师致力于改善框架. 通常, 这意味着对WebDriver的支持已包含在浏览器本身中： 您的测试运行得尽可能快且稳定.  在开始之前 为了使迁移过程尽可能轻松, 请确保所有测试都在最新的Selenium版本中正常运行. 这听起来似乎显而易见, 但是最好说一下!\n开始上手 开始迁移的第一步是更改获取Selenium实例的方式. 使用Selenium RC时, 就像这样:\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); 应该这样替换:\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); 下一步 一旦测试成功执行, 下一步就是迁移实际的测试代码以使用WebDriver API. 根据代码的抽象程度, 这可能是一个短暂的过程, 也可能是一个漫长的过程. 在这两种情况下, 方法都是相同的, 可以简单地总结一下：修改代码以在使用新API时进行编辑.\n如果您需要从Selenium实例中提取基础WebDriver实现, 则只需将其强制转换为WrapsDriver:\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); 这使您可以继续正常传递Selenium实例, 但可以根据需要解包WebDriver实例.\n有时, 您的代码库将主要使用较新的API. 此时, 您可以翻转关系, 使用WebDriver并按需实例化Selenium实例:\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); 常见问题 幸运的是, 您不是第一个进行此迁移的人, 因此这里有其他人已经看到的一些常见问题以及如何解决它们.\n单击和键入更加完整 Selenium RC测试中的常见模式如下所示:\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); 这依赖于以下事实： \u0026ldquo;类型\u0026quot;仅替换所标识元素的内容, 而不触发用户与页面进行交互时通常会触发的所有事件. 最后的\u0026quot;key*\u0026ldquo;直接调用导致JS处理程序按预期方式触发.\n使用WebDriverBackedSelenium时, 填写表单字段的结果将是\u0026quot;exciting texttt\u0026rdquo;： 并非您所期望的! 这样做的原因是WebDriver更准确地模拟了用户行为, 因此一直会触发事件.\n相同的事实有时可能会导致页面加载比Selenium 1测试中更早触发. 如果WebDriver抛出\u0026quot;StaleElementException\u0026rdquo;, 您可以说这已经发生.\nWaitForPageToLoad很快返回 发现何时完成页面加载是一项艰巨的任务. 我们的意思是\u0026quot;何时触发加载事件\u0026rdquo;, \u0026ldquo;何时完成所有AJAX请求\u0026rdquo;, \u0026ldquo;何时没有网络流量\u0026rdquo;, \u0026ldquo;何时document.readyState发生更改\u0026rdquo; 或其他所有内容?\nWebDriver试图模拟原始的Selenium行为, 但是由于种种原因, 这种方法并不总是能完美发挥作用. 最常见的原因是, 很难区分在尚未开始的页面加载与在方法调用之间完成的页面加载之间的区别. 有时这意味着在页面完成（甚至开始!）加载之前, 控件已返回测试.\n解决方案是等待特定的东西. 通常, 这可能是您想与之交互的元素, 或者是将某些Javascript变量设置为特定值. 一个例子是:\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, Duration.ofSeconds(30)); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); 其中\u0026quot;visibilityOfElementLocated\u0026quot;实现为:\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } 这看起来很复杂, 但这几乎是所有样板代码. 唯一有趣的一点是, 将反复评估\u0026quot;ExpectedCondition\u0026rdquo;, 直到\u0026quot;apply\u0026quot;方法返回的结果既不是\u0026quot;null\u0026rdquo; 也不是Boolean.FALSE.\n当然, 添加所有这些\u0026quot;等待\u0026quot;调用可能会使您的代码混乱. 如果是这样, 并且您的需求很简单, 请考虑使用隐式等待:\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); 这样, 每次定位某个元素时（如果不存在该元素）, 都会重试该位置, 直到该元素存在或经过30秒为止.\n通过XPath或CSS选择器查找并不总是可行, 但在Selenium 1中却可以 在Selenium 1中, xpath通常使用捆绑的库而不是浏览器本身的功能. 除非没有其他选择, 否则WebDriver将始终使用本机浏览器方法. 这意味着复杂的xpath表达式可能会在某些浏览器上中断.\nSelenium 1中的CSS选择器是使用Sizzle库实现的. 这实现了CSS Selector规范的超集, 而且并不总是清楚您越界的位置. 如果您使用的是WebDriverBackedSelenium, 并且使用Sizzle定位器而不是CSS选择器来查找元素, 则会在控制台上记录一条警告. 值得花时间去寻找这些东西, 尤其是如果由于找不到元素而导致测试失败时.\n没有Browserbot Selenium RC是基于Selenium Core的, 因此, 当您执行Javascript时, 可以访问Selenium Core的某些部分以使事情变得容易. 由于WebDriver不基于Selenium Core, 因此不再可能. 如何判断您是否正在使用Selenium Core?简单! 只要看看您的\u0026quot;getEval\u0026quot;或类似调用是否在评估的Javascript中使用\u0026quot;Selenium\u0026quot;或\u0026quot;browserbot\u0026rdquo;.\n您可能正在使用browserbot获取测试的当前窗口或文档的句柄. 幸运的是, WebDriver总是在当前窗口的上下文中评估JS, 因此您可以直接使用\u0026quot;window\u0026quot;或\u0026quot;document\u0026rdquo;.\n另外, 您可能正在使用browserbot查找元素. 在WebDriver中, 这样做的习惯是首先找到该元素, 然后将其作为参数传递给Javascript. 从而:\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); 变成:\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); 请注意, 传入的\u0026quot;element\u0026quot;变量如何显示为JS标准\u0026quot;arguments\u0026quot;数组中的第一项.\n执行JavaScript不会返回任何内容 WebDriver的JavascriptExecutor将包装所有JS并将其评估为匿名表达式. 这意味着您需要使用\u0026quot;return\u0026quot;关键字:\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); 变成:\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;); "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/introduction/on_test_automation/",
	"title": "关于测试自动化",
	"tags": [],
	"description": "",
	"content": "首先，问问自己是否真的需要使用浏览器。 在某些情况下，如果您正在开发一个复杂的 web 应用程序， 您需要打开一个浏览器并进行实际测试，这种可能性是很大的。\n然而，诸如 Selenium 之类的功能性最终用户测试运行起来很昂贵。 此外，它们通常需要大量的基础设施才能有效运行。 经常问问自己，您想要测试的东西是否可以使用更轻量级的测试方法（如单元测试）完成， 还是使用较低级的方法完成，这是一个很好的规则。\n一旦确定您正在进行Web浏览器测试业务， 并且您的 Selenium 环境已经准备好开始编写测试， 您通常会执行以下三个步骤的组合：\n 设置数据 执行一组离散的操作 评估结果  您需要尽可能缩短这些步骤; 一到两个操作在大多数时间内应该足够了。 浏览器自动化具有“脆弱”的美誉， 但实际上那是因为用户经常对它要求过高。 在后面的章节中，我们将回到您可以使用的技术， 为了缓解测试中明显的间歇性问题， 特别是如何克服 浏览器 和 WebDriver 之间的竞争条件。\n通过保持测试简短并仅在您完全没有替代方案时使用Web浏览器，您可以用最小的代码片段来完成很多测试。\nSelenium测试的一个显著优势是，它能够从用户的角度测试应用程序的所有组件（从后端到前端）。 因此，换句话说，虽然功能测试运行起来可能很昂贵，但它们同时也包含了大量关键业务部分。\n测试要求 如前所述，Selenium 测试运行起来可能很昂贵。 在多大程度上取决于您正在运行测试的浏览器， 但历史上浏览器的行为变化太大，以至于通常是针对多个浏览器进行交叉测试的既定目标。\nSelenium 允许您在多个操作系统上的多个浏览器上运行相同的指令， 但是对所有可能的浏览器、它们的不同版本以及它们所运行的许多操作系统的枚举将很快成为一项繁重的工作。\n让我们从一个例子开始 Larry 写了一个网站，允许用户订购他们自己定制的独角兽。\n一般的工作流程(我们称之为“幸福之路”)是这样的:\n 创建一个账户 配置他们的独角兽 添加到购物车 检验并付款 给出关于他们独角兽的反馈  编写一个宏大的 Selenium 脚本来执行所有这些操作是很诱人的 — 很多人都会尝试这样做。 抵制诱惑！ 这样做会导致测试: a) 需要很长时间; b) 会受到一些与页面呈现时间问题有关的常见问题的影响; c) 如果失败，它不会给出一个简洁的、“可检查”的方法来诊断出了什么问题。\n测试此场景的首选策略是将其分解为一系列独立的、快速的测试，每个测试都有一个存在的“理由”。\n假设您想测试第二步： 配置您的独角兽。 它将执行以下操作:\n 创建一个帐户 配置一个独角兽  请注意，我们跳过了这些步骤的其余部分， 在完成这一步之后，我们将在其他小的、离散的测试用例中测试工作流的其余部分。\n首先，您需要创建一个帐户。在这里您可以做出一些选择：\n 您想使用现有帐户吗? 您想创建一个新帐户吗? 在配置开始之前，是否需要考虑有任何特殊属性的用户需要吗?  不管您如何回答这个问题， 解决方案是让它成为测试中“设置数据”部分的一部分 - 如果 Larry 公开了一个 API， 使您(或任何人)能够创建和更新用户帐户， 一定要用它来回答这个问题 请确保使用这个 API 来回答这个问题 — 如果可能的话， 您希望只有在您拥有一个用户之后才启动浏览器，您可以使用该用户的凭证进行登录。\n如果每个工作流的每个测试都是从创建用户帐户开始的，那么每个测试的执行都会增加许多秒。 调用 API 并与数据库进行通信是快速、“无头”的操作， 不需要打开浏览器、导航到正确页面、点击并等待表单提交等昂贵的过程。\n理想情况下，您可以在一行代码中处理这个设置阶段，这些代码将在任何浏览器启动之前执行:\nJava Python C# Ruby JavaScript Kotlin // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = user_factory.create_common_user() #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.get_email(), user.get_password())   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.CreateCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = LoginAs(user.Email, user.Password);   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = UserFactory.create_common_user #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.email, user.password)   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. var user = userFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. var accountPage = loginAs(user.email, user.password);   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. val user = UserFactory.createCommonUser() //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     您可以想象，UserFactory可以扩展为提供诸如createAdminUser()、createUserWithPayment()的方法。 关键是，这两行代码不会分散您对此测试的最终目的的注意力： 配置独角兽。\n页面对象模型 的复杂性将在后面的章节中讨论，但我们将在这里介绍这个概念：\n您的测试应该由操作组成，从用户的角度出发，在站点的页面上下文中执行。 这些页面被存储为对象， 其中包含关于 web 页面如何组成以及如何执行操作的特定信息 — 作为测试人员，您应该很少关注这些信息。\n您想要什么样的独角兽? 您可能想要粉红色，但不一定。 紫色最近很流行。 她需要太阳镜吗? 明星纹身? 这些选择虽然困难，但是作为测试人员， 您的主要关注点是 — 您需要确保您的订单履行中心将正确的独角兽发送给正确的人，而这就要从这些选择开始。\n请注意，我们在该段落中没有讨论按钮，字段，下拉菜单，单选按钮或 Web 表单。 您的测试也不应该！ 您希望像尝试解决问题的用户一样编写代码。 这是一种方法（从前面的例子继续）：\nJava Python C# Ruby JavaScript Kotlin // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn() # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.Purple, UnicornAccessories.Sunglasses, UnicornAdornments.StarTattoos); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.AddUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.CreateUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn.new(\u0026#39;Sparkles\u0026#39;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. var sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there.  var addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. var unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. val addUnicornPage = accountPage.addUnicorn() // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     既然您已经配置好了独角兽， 您需要进入第三步:确保它确实有效。\nJava Python C# Ruby JavaScript Kotlin // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles));   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.True(unicornConfirmationPage.Exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. expect(unicorn_confirmation_page.exists?(sparkles)).to be, \u0026#39;Sparkles should have been created, with all attributes intact\u0026#39;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assert(unicornConfirmationPage.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles))     请注意，测试人员在这段代码中除了谈论独角兽之外还没有做任何事情 — 没有按钮、定位器和浏览器控件。 这种对应用程序建模的方法允许您保持这些测试级别的命令不变， 即使 Larry 下周决定不再喜欢 Ruby-on-Rails， 并决定用最新的带有 Fortran 前端的 Haskell 绑定重新实现整个站点。\n为了符合站点的重新设计，您的页面对象需要进行一些小的维护，但是这些测试将保持不变。 采用这一基本设计，您将希望继续使用尽可能少的面向浏览器的步骤来完成您的工作流。 您的下一个工作流程将包括在购物车中添加独角兽。 您可能需要多次迭代此测试，以确保购物车正确地保持其状态： 在开始之前，购物车中是否有多个独角兽? 购物车能装多少? 如果您创建多个具有相同名称或特性，它会崩溃吗? 它将只保留现有的一个还是添加另一个?\n每次通过工作流时，您都希望尽量避免创建帐户、以用户身份登录和配置独角兽。 理想情况下，您将能够创建一个帐户，并通过 API 或数据库预先配置独角兽。 然后，您只需作为用户登录，找到 Sparkles，并将它添加到购物车中。\n是否自动化? 自动化总是有优势吗? 什么时候应该决定去自动化测试用例?\n自动化测试用例并不总是有利的. 有时候手动测试可能更合适. 例如，如果应用程序的用户界面，在不久的将来会发生很大变化，那么任何自动化都可能需要重写. 此外，有时根本没有足够的时间来构建自动化测试. 从短期来看，手动测试可能更有效. 如果应用程序的截止日期非常紧迫，当前没有可用的自动化测试，并且必须在特定时间范围内完成，那么手动测试是最好的解决方案.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/support_packages/working_with_colours/",
	"title": "同颜色一起工作",
	"tags": [],
	"description": "",
	"content": "在测试中, 您偶尔会需要验证某事物的颜色；问题是网络上的颜色定义不是个常量. 如果有一种简单的方法可以比较颜色的十六进制与RGB呈现, 或者颜色的RGBA与HSLA呈现, 岂不美哉?\n不用担心有一个解决方案：Color 类!\n首先, 您需要导入该类:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.Color    您现在可以开始创建颜色对象. 每个颜色对象都需要使用您颜色的字符串定义来创建. 支持的颜色定义如下:\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     Color类还支持在以下网址中指定的所有基本颜色定义 http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     如果元素上未设置颜色, 则有时浏览器会返回“透明”的颜色值. Color类也支持此功能:\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     现在, 您可以安全地查询元素以获取其颜色/背景色, 任何响应都将被正确解析并转换为有效的Color对象:\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)); Color loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;));   login_button_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;))   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    login_button_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;))   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)) val loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;))     然后, 您可以直接比较颜色对象:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour == HOTPINK)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.equals(HOTPINK))     或者, 您可以将颜色转换为以下格式之一并执行静态验证:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     颜色不再是问题.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/selenium_installation/installing_webdriver_binaries/",
	"title": "安装 WebDriver 二进制文件",
	"tags": [],
	"description": "",
	"content": "要执行项目并控制浏览器，需要安装特定于浏览器的 WebDriver 二进制文件。\n下载 WebDriver 二进制文件 并放入 系统 PATH 环境变量 中.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/front_matter/typographical_conventions/",
	"title": "排版协议",
	"tags": [],
	"description": "",
	"content": "标题大写 应该避免标题完全大写, 例如 A Very Fine Heading, 应该书写为 A very fine heading . 没有意义的大写字母或者无视拼写协议的标题, 通常会带来误解. 我们更倾向于使用句子首字母大写的 sentence case 的方式.\n行的长度 在编辑以plain HTML格式编写的文档来源时, 请将行的长度限制在72个字符以内.\n部分先进的贡献者, 使用了 semantic linefeeds, 这是一种不以HTML源码换行为基础的技术, 通过这种技术, 公众看到的内容将会在文章中以“自然断开”的方式进行分割. 换句话说, 句子之间在更符合语义的地方被分割. 不必多虑每个段落的行, 强迫它们都以明确的边距结尾, 而是可以将换行符添加到语义有断开的任何地方. (译者注：具体区别，对比本网页与原始md后，即可了解本段想表达的意思)\n通过git进行协作时, 这种技术会使提交的差异更显而易见, 但这不是我们强制贡献者使用的内容.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/worst_practices/file_downloads/",
	"title": "文件下载",
	"tags": [],
	"description": "",
	"content": "虽然可以通过在Selenium的控制下单击浏览器的链接来开始下载, 但是API并不会暴露下载进度, 因此这是一种不理想的测试下载文件的方式. 因为下载文件并非模拟用户与Web平台交互的重要方面. 取而代之的是, 应使用Selenium(以及任何必要的cookie)查找链接, 并将其传递给例如libcurl这样的HTTP请求库.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/grid/components_of_a_grid/",
	"title": "服务网格的组件",
	"tags": [],
	"description": "",
	"content": "转发器(hub)  中间人和管理者 接受请求 执行测试任务 接受客户端的指示并在远程节点上执行任务 管理进程  转发器(hub) 是一个接受所有所有测试任务的中心节点。 每个Selenium服务网格包含一个转发器(hub)。转发器(hub)需要能被所有的客户机（比如：持续集成服务器，开发机等等）访问到。 转发器(hub)会连接1个或者多个节点，这些节点会代理执行测试任务。\n节点  浏览器会被安装在节点上 节点会把自己注册在转发器(hub)上并申报自己作为测试代理的能力\u0008(有些什么浏览器，每个浏览器可以运行几个实例等等) 接受转发器(hub)的指示并执行这些指示  节点 和不同的Selenium实例，他们能够在特定的计算机系统上执行测试。 一个服务网格中可以有很多节点。 这些终端设备并不需要使用统一的平台(或者说操作系统)也不需要选择相同的浏览器。 一个Windows节点可以提供IE作为一个浏览器选项来执行测试，然而Linux和MAC是不可能提供的。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "第三方驱动和插件",
	"tags": [],
	"description": "",
	"content": "可以通过使用插件扩展 Selenium。这里有一些由第三方创建和维护的插件。有关如何创建插件和使用的更多信息，请参考文档。\n请注意，Selenium 项目不支持、维护、托管或认可这些插件。另外，请注意，下面列出的插件不一定是 Apache 2.0 授权的。 其中一些插件在其他的免费和开源软件许可下可用；其他的只能在私有许可下使用。关于插件及其发行许可的任何问题都需要向它的开发人员提出。\n   浏览器 最新版 变更记录 问题追踪     Mozilla GeckoDriver 最新版 变更记录 问题追踪   Google Chrome Driver 最新版 变更记录 问题追踪   Opera 最新版 - 问题追踪   Microsoft Edge Driver 最新版 - 问题追踪   SafariDriver 内置 - 问题追踪    "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/remote_webdriver/remote_webdriver_client/",
	"title": "远程WebDriver客户端",
	"tags": [],
	"description": "",
	"content": "要运行远程WebDriver客户端, 我们首先需要连接到RemoteWebDriver. 为此, 我们将URL指向运行测试的服务器的地址. 为了自定义我们的配置, 我们设置了既定的功能. 下面是一个实例化样例, 其指向我们的远程Web服务器 www.example.com 的远程WebDriver对象, 并在Firefox上运行测试.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver firefox_options = webdriver.FirefoxOptions() driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=firefox_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); var capabilities = Capabilities.firefox(); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     为了进一步自定义测试配置, 我们可以添加其他既定的功能.\n浏览器选项 例如, 假设您想使用Chrome版本67 在Windows XP上运行Chrome:\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.set_capability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chrome_options.set_capability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=chrome_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var chromeOptions = new ChromeOptions(); chromeOptions.BrowserVersion = \u0026#34;67\u0026#34;; chromeOptions.PlatformName = \u0026#34;Windows XP\u0026#34;; IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); const chrome = require(\u0026#34;selenium-webdriver/chrome\u0026#34;) var capabilities = Capabilities.chrome(); //To avoid InsecureCertificateError for selenium4-aplha5 capabilities.setAcceptInsecureCerts(true); capabilities.set(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); capabilities.set(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit();     本地文件检测器 本地文件检测器允许将文件从客户端计算机传输到远程服务器. 例如, 如果测试需要将文件上传到Web应用程序, 则远程WebDriver可以在运行时 将文件从本地计算机自动传输到远程Web服务器. 这允许从运行测试的远程计算机上载文件. 默认情况下未启用它, 可以通过以下方式启用:\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   from selenium.webdriver.remote.file_detector import LocalFileDetector driver.file_detector = LocalFileDetector()   var allowsDetection = this.driver as IAllowsFileDetection; if (allowsDetection != null) { allowsDetection.FileDetector = new LocalFileDetector(); }   @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   var remote = require(\u0026#39;selenium-webdriver/remote\u0026#39;); driver.setFileDetector(new remote.FileDetector);   driver.fileDetector = LocalFileDetector()     定义上述代码后, 您可以通过以下方式在测试中上传文件:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) driver.find_element(By.ID, \u0026#34;myfile\u0026#34;).send_keys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)   driver.Navigate().GoToUrl(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); IWebElement upload = driver.FindElement(By.Id(\u0026#34;myfile\u0026#34;)); upload.SendKeys(@\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); var upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/domain_specific_language/",
	"title": "领域特定语言",
	"tags": [],
	"description": "",
	"content": "领域特定语言 (DSL) 是一种为用户提供解决问题的表达方式的系统. 它使用户可以按照自己的术语与系统进行交互, 而不仅仅是通过程序员的语言.\n您的用户通常并不关心您网站的外观. 他们不在乎装饰, 动画或图形. 他们希望借助于您的系统, 以最小的难度使新员工融入整个流程； 他们想预订去阿拉斯加的旅行； 他们想以折扣价配置和购买独角兽. 您作为测试人员的工作应尽可能接近\u0026quot;捕捉”这种思维定势. 考虑到这一点, 我们开始着手\u0026quot;建模”您正在工作的应用程序, 以使测试脚本 (发布前用户仅有的代理) \u0026ldquo;说话”并代表用户.\n在Selenium中, DSL通常由方法表示, 其编写方式使API简单易读-它们使开发人员和干系人 (用户, 产品负责人, 商业智能专家等) 之间能够产生汇报.\n好处  可读: 业务关系人可以理解. 可写: 易于编写, 避免不必要的重复. 可扩展: 可以 (合理地) 添加功能而无需打破约定以及现有功能. 可维护: 通过将实现细节排除在测试用例之外, 您可以很好地隔离 AUT* 的修改.  Java 以下是Java中合理的DSL方法的示例. 为简便起见, 假定 driver 对象是预定义的并且可用于该方法.\n/** * Takes a username and password, fills out the fields, and clicks \u0026#34;login\u0026#34;. * @return An instance of the AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Fill out the password field. The locator we\u0026#39;re using is \u0026#34;By.id\u0026#34;, and we should  // have it defined elsewhere in the class.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Click the login button, which happens to have the id \u0026#34;submit\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Create and return a new instance of the AccountPage (via the built-in Selenium  // PageFactory).  return PageFactory.newInstance(AccountPage.class); } 此方法完全从测试代码中抽象出输入字段, 按钮, 单击甚至页面的概念. 使用这种方法, 测试人员要做的就是调用此方法. 这给您带来了维护方面的优势: 如果登录字段曾经更改过, 则只需更改此方法-而非您的测试.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Now that we\u0026#39;re logged in, do some other stuff--since we used a DSL to support  // our testers, it\u0026#39;s as easy as choosing from available methods.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Something should have been done!\u0026#34;, something.wasDone()); // Note that we still haven\u0026#39;t referred to a button or web control anywhere in this  // script... } 郑重强调: 您的主要目标之一应该是编写一个API, 该API允许您的测试解决 当前的问题, 而不是UI的问题. 用户界面是用户的次要问题–用户并不关心用户界面, 他们只是想完成工作. 您的测试脚本应该像用户希望做的事情以及他们想知道的事情的完整清单那样易于阅读. 测试不应该考虑UI如何要求您去做.\n*AUT: 待测系统\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/driver_idiosyncrasies/driver_specific_capabilities/",
	"title": "驱动特定的功能",
	"tags": [],
	"description": "",
	"content": "Firefox 使用FirefoxOptions定义功能 FirefoxOptions 是为Firefox浏览器定义功能(Capabilities)的新方法，通常应优先使用预期功能(DesiredCapabilities).\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   require \u0026#39;selenium-webdriver\u0026#39; opts = Selenium::WebDriver::Firefox::Options.new(args: [\u0026#39;-headless\u0026#39;]) driver = Selenium::WebDriver.for(:firefox, options: opts)   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.headless(); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     设置自定义配置文件 可以为Firefox创建自定义配置文件, 如下所示.\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   profile = Selenium::WebDriver::Firefox::Profile.new profile[\u0026#39;browser.download.dir\u0026#39;] = \u0026#34;/tmp/webdriver-downloads\u0026#34; options = Selenium::WebDriver::Firefox::Options.new(profile: profile) driver = Selenium::WebDriver.for :firefox, options: options   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); let profile = \u0026#39;/path to custom profile\u0026#39;; options.setProfile(profile); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer fileUploadDialogTimeout 在某些环境中, 当打开文件上传对话框时, Internet Explorer可能会超时. IEDriver的默认超时为1000毫秒, 但您可以使用fileUploadDialogTimeout功能来增加超时时间.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.waitForUploadDialogUpTo(Duration.ofSeconds(2)); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.file_upload_dialog_timeout = 2000 driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.file_upload_dialog_timeout = 2000 driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().fileUploadDialogTimeout(2000); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.waitForUploadDialogUpTo(Duration.ofSeconds(2)) val driver = RemoteWebDriver(options)     ensureCleanSession When set to true, this capability clears the Cache, Browser History and Cookies for all running instances of InternetExplorer including those started manually or by the driver. By default, it is set to false.\nUsing this capability will cause performance drop while launching the browser, as the driver will wait until the cache gets cleared before launching the IE browser.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.destructivelyEnsureCleanSession(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ensure_clean_session = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.EnsureCleanSession = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ensure_clean_session = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ensureCleanSession(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.destructivelyEnsureCleanSession() val driver = RemoteWebDriver(options)     ignoreZoomSetting InternetExplorer driver expects the browser zoom level to be 100%, else the driver will throw an exception. This default behaviour can be disabled by setting the ignoreZoomSetting to true.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.ignoreZoomSettings(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_zoom_level = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IgnoreZoomLevel = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_zoom_level = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ignoreZoomSetting(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.ignoreZoomSettings() val driver = RemoteWebDriver(options)     ignoreProtectedModeSettings Whether to skip the Protected Mode check while launching a new IE session.\nIf not set and Protected Mode settings are not same for for all zones, an exception will be thrown by the driver.\nIf capability is set to true, tests may become flaky, unresponsive, or browsers may hang. However, this is still by far a second-best choice, and the first choice should always be to actually set the Protected Mode settings of each zone manually. If a user is using this property, only a \u0026ldquo;best effort\u0026rdquo; at support will be given.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.introduceFlakinessByIgnoringSecurityDomains(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_protected_mode_settings = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IntroduceInstabilityByIgnoringProtectedModeSettings = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_protected_mode_settings = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().introduceFlakinessByIgnoringProtectedModeSettings(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.introduceFlakinessByIgnoringSecurityDomains() val driver = RemoteWebDriver(options)     silent When set to true, this capability suppresses the diagnostic output of the IEDriverServer.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.setCapability(\u0026#34;silent\u0026#34;, true); WebDriver driver = new InternetExplorerDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.set_capability(\u0026#34;silent\u0026#34;, True) driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   InternetExplorerOptions options = new InternetExplorerOptions(); options.AddAdditionalInternetExplorerOption(\u0026#34;silent\u0026#34;, true); IWebDriver driver = new InternetExplorerDriver(options);   # Please raise a PR to add code sample   const {Builder,By, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); let caps = Capabilities.ie(); caps.set(\u0026#39;silent\u0026#39;, true); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;internet explorer\u0026#39;) .withCapabilities(caps) .build(); try { await driver.get(\u0026#39;http://www.google.com/ncr\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.setCapability(\u0026#34;silent\u0026#34;, true) val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     IE Command-Line Options Internet Explorer includes several command-line options that enable you to troubleshoot and configure the browser.\nThe following describes few supported command-line options\n  -private : Used to start IE in private browsing mode. This works for IE 8 and later versions.\n  -k : Starts Internet Explorer in kiosk mode. The browser opens in a maximized window that does not display the address bar, the navigation buttons, or the status bar.\n  -extoff : Starts IE in no add-on mode. This option specifically used to troubleshoot problems with browser add-ons. Works in IE 7 and later versions.\n  Note: forceCreateProcessApi should to enabled in-order for command line arguments to work.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.add_argument(\u0026#39;-private\u0026#39;) options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; options.BrowserCommandLineArguments = \u0026#34;-k\u0026#34;; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true options.add_argument(\u0026#39;-k\u0026#39;) driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.addBrowserCommandSwitches(\u0026#39;-k\u0026#39;); options.addBrowserCommandSwitches(\u0026#39;-private\u0026#39;); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps); } finally { driver.quit(); } }     forceCreateProcessApi Forces launching Internet Explorer using the CreateProcess API. The default value is false.\nFor IE 8 and above, this option requires the \u0026ldquo;TabProcGrowth\u0026rdquo; registry value to be set to 0.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps) } finally { driver.quit(); } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/driver_requirements/",
	"title": "驱动要求",
	"tags": [],
	"description": "",
	"content": "通过 WebDriver，Selenium 支持市面上所有主流的浏览器，如 Chrom(ium)、Firefox、 Internet Explorer、Opera 和 Safari。 尽管并非所有浏览器都对远程控制提供官方支持， 但 WebDriver 尽可能使用浏览器的内置自动化支持来驱动浏览器。\nWebDriver 的目标是尽可能模拟真实用户与浏览器的交互。\n在不同的浏览器中，这可能有不同的级别。有关不同驱动程序特性的详细信息， 请参见 驱动程序特性。\n尽管所有的驱动程序共享一个面向用户的界面来控制浏览器，但它们设置浏览器会话的方式略有不同。 由于许多驱动程序实现是由第三方提供的，所以它们不包括在标准的 Selenium 发行版中。\n驱动程序实例化、配置文件管理和各种特定于浏览器的设置都是具体参数的例子，这些参数根据浏览器有 不同的需求。本节介绍了使用不同浏览器的基本要求。\n将可执行文件添加到 PATH 中 大多数驱动程序需要 Selenium 额外的可执行文件才能与浏览器通信。您可以在启动 WebDriver 之前手动指定可执行文件的存放位置，但这会使测试的可移植性降低，因为可执行文件必须位于每台 计算机上的同一位置，或包含在测试代码存储库中。\n通过将包含 WebDriver 二进制文件的文件夹添加到系统 path 环境变量中，Selenium 将能够找到其他二进制文件，而无需您的测试代码来定位驱动程序的确切位置。\n 创建一个目录来放置可执行文件，例如 C:\\WebDriver\\bin 或 /opt/WebDriver/bin 将目录添加到您的 path 中：  在 Windows 上 - 以管理员身份打开命令提示符，然后运行以下命令将目录永久添加到计算机上所有用户的路径中：    setx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34;  在 macOS 和 Linux 上的 Bash 用户 - 在终端中：  export PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile  现在您可以测试更改了。关闭所有打开的命令提示符，然后打开一个新的提示符。 输入您在上一步创建的文件夹中的某一个二进制文件的名称，例如： chromedriver  如果您的 PATH 配置正确，您将看到一些有关驱动程序启动的输出：  Starting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed. 您可以通过按 Ctrl + C重新获得对命令提示符的控制。\n快速参考    浏览器 支持的操作系统 维护者 下载 问题追踪     Chromium/Chrome Windows/macOS/Linux 谷歌 下载 问题   火狐 Windows/macOS/Linux Mozilla 下载 问题   Edge Windows 10 微软 下载 问题   Internet Explorer Windows Selenium 项目组 下载 问题   Safari macOS El Capitan 及更高版本 苹果 内置 问题   Opera Windows/macOS/Linux Opera 下载 问题    Chromium/Chrome 要驱动 Chrome 或 Chromium，您必须下载 chromedriver 并将其放在系统路径上的文件夹中。\n在 Linux 或 macOS 上，这意味着修改 PATH 环境变量。通过执行以下命令，您可以看到由冒号分隔的目录组成的系统路径：\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 要在路径上包含 chromedriver(如果还没有的话)，请确保包含 chromedriver 二进制文件的父目录。 下面的行将设置当前 PATH 环境变量的内容，在冒号后面添加一个额外的路径:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; 当您的路径上有 chromedriver 时，您应该可以从任何目录执行 chromedriver 可执行文件。\n要实例化 Chrome/Chromium 会话，您可以执行以下操作：\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #简单赋值 from selenium.webdriver import Chrome driver = Chrome() #或者使用上下文管理器 from selenium.webdriver import Chrome with Chrome() as driver: #你自己的代码放在这个缩进中   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() {let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //你的代码放在这个块中 })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     请记住，您必须设置 chromedriver 可执行文件的路径。可以使用下行代码实现：\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     chromedriver 被实现为 WebDriver 远程服务器，该服务器通过公开 Chrome 的内部自动化代理接口来指示浏览器该怎么做。\n火狐浏览器 从 Selenium 3 开始，Mozilla 通过 geckodriver 接管了火狐驱动程序的实现。火狐的新驱动程序被称为 geckodriver，可与 Firefox 48 及更高版本一起使用。 由于正在开发 Firefox WebDriver，因此 Firefox 版本越新，支持越好。\n由于 geckodriver 是默认新的启动火狐浏览器的方式，您可以像 Selenium 2 那样实例化火狐浏览器:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #简单赋值 from selenium.webdriver import Firefox driver = Firefox() #或者使用上下文管理器 from selenium.webdriver import Firefox with Firefox() as driver: #你自己的代码放在这个缩进中   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() {let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); // 你自己的代码放在这个块中 })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     如果您不想使用 PATH 设置 geckodriver 的位置，请在代码中设置 geckodriver 的位置：\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.setBinary(\u0026#34;/path/to/geckodriver\u0026#34;);   System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     也可以在运行时设置属性：\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver 当前，可以通过安装 Firefox 47.0.1 或 45 ESR 并指定 marionette 功能为 false 来还原到功能更强大的旧版 Firefox 驱动程序。Firefox 的更高版本不再兼容。\nEdge Edge 是微软最新的浏览器，内置在 Windows 10 和 Windows Server 2016 中。Edge 的更新与 Windows 的主要更新捆绑在一起，因此您需要下载一个与您当前安装的 Windows 版本的版本号匹配的二进制文件。 Edge 开发者网站 包含指向所有可用的二进制文件的链接。针对 EdgeDriver 实现的 bug 可以在 微软网站 中提出。如果您想针对 Edge 运行测试，但没有 Windows 10，微软在 Edge 开发者网站 上为测试人员提供了免费的虚拟机。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #简单赋值 from selenium.webdriver import Edge driver = Edge() #或使用上下文管理器 from selenium.webdriver import Edge with Edge() as driver: #你的代码放在这个缩进中   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() {let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); // 你的代码放在这个块中 })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     如果您的路径中没有 Edge 驱动程序，您可以使用以下行设置路径:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const edge = require(\u0026#39;selenium-webdriver/edge\u0026#39;); let service = new edge.ServiceBuilder(\u0026#34;/path/to/msedgedriver.exe\u0026#34;); (async function test() { let driver = await new Builder() .setEdgeService(service) .forBrowser(\u0026#39;MicrosoftEdge\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     IE 浏览器 在 Windows 10 之前，IE 一直是微软的默认浏览器，尽管它仍被包含在 Windows 10 中。 Internet Explorer Driver 是唯一的 Selenium 项目组旨在支持 微软认为当前 版本的驱动程序。旧版本可能可以工作，但将不受支持。\n虽然 Selenium 项目为 32 位和 64 位版本的 IE 提供了二进制文件，但是 IE 10 和 11 在 64 位驱动程序上 有一些限制， 但是使用 32 位驱动程序仍然可以很好地工作。应该注意的是，由于 IE 浏览器的首选项是根据登录用户的帐户保存的， 因此需要进行一些额外的设置。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #简单赋值 from selenium.webdriver import Ie driver = Ie() #或使用上下文管理器 from selenium.webdriver import Ie with Ie() as driver: #你的代码放在这个缩进中   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() {let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); // 你的代码放在这个块中 })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     如果 IE 浏览器驱动程序不在您的路径中，您可以使用以下行设置路径：\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let service = new ie.ServiceBuilder(\u0026#34;/path/to/IEDriverServer.exe\u0026#34;); (async function test() { let driver = await new Builder() .setIeService(service) .forBrowser(\u0026#39;internet explorer\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     微软还为 Windows 7 和 8.1 中的 IE 11 提供了一个 WebDriver 二进制版本。自 2014 年以来就没有更新过，它是基于 W3 规范的草案版本。 Jim Evans 写了一篇关于微软实现的优秀文章。\nOpera Opera 的当前版本是建立在 Chromium 引擎之上的，而 WebDriver 现在是通过闭源的 Opera Chromium 驱动程序来支持的， 它可以被添加到您的路径或作为系统属性。\n实例化一个驱动程序会话类似于 Firefox 和 Chromium：\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #简单赋值 from selenium.webdriver import Opera driver = Opera() #或使用上下文管理器 from selenium.webdriver import Opera with Opera() as driver: #你的代码放在这个缩进中   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const opera = require(\u0026#39;selenium-webdriver/opera\u0026#39;); (async function test() { let driver = await new Builder() .forBrowser(\u0026#39;opera\u0026#39;) .build(); })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari High Sierra and later:\n 首先从终端运行以下命令 时间并在提示符下键入密码以授权WebDriver  safaridriver --enable El Capitan and Sierra:\n 启用 Safari 首选项中的 Developer 菜单 从 “开发” 菜单中选择 “允许远程自动化” 选项 第一次运行时在终端输入以下命令，并在提示符处输入密码以授权 WebDriver  /usr/bin/safaridriver -p 1337\u0026lt;/ 你可以使用以下代码开始一个驱动程序会话:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #简单赋值 from selenium.webdriver import Safari driver = Safari() #或使用上下文管理器 from selenium.webdriver import Safari with Safari() as driver: #你的代码放在这个缩进中   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() {let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); // 你的代码放在这个块中 })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     那些希望在 iOS 上实现 Safari 自动化的人应该关注Appium 项目。 虽然 Safari 之前也支持 Windows，但苹果早就放弃了对它的支持，这让它成为了一个糟糕的测试平台。\n模拟浏览器 HtmlUnit HtmlUnit 是一个 “针对 Java 程序的无图形界面浏览器”。它为 HTML 文档建模，并提供一个 API， 允许您调用页面、填写表单、单击链接等。它支持 JavaScript，能够使用 AJAX 库，根据使用的配置模拟 Chrome、Firefox 或 IE。它已经迁移到一个新位置 了。 源文件保存在 svn 上。\nPhantomJS PhantomJS 是一款基于 Webkit 的无头浏览器，尽管它的版本比谷歌 Chrome 或 Safari 要老得多。虽然曾经很流行， 但现在明智的做法是避免 PhantomJS。这个项目 从 8 月 5 日起 就一直没有被维护过，所以尽管网络会继续变化，PhantomJS 也不会更新。在谷歌宣布可以无头运行 Chrome 之后，现在 Mozilla 的火狐浏览器也提供了这个功能。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/legacy_docs/html-runner/",
	"title": "HTML runner",
	"tags": [],
	"description": "",
	"content": "Selenium HTML-runner 允许您从命令行运行 Test Suites。 Test Suites 是从 Selenium IDE 或兼容工具导出的 HTML。\n公共信息   geckodriver / firefox / selenium-html-runner 版本的组合很重要。 可能在某个地方有一个软件兼容性矩阵。\n  selenium-html-runner 只运行 Test Suite（而不是 Test Case —— 例如从 Monitis Transaction Monitor 导出的东西）。一定要遵守这个规定。\n  对于没有 DISPLAY 的 Linux 用户，您需要启动具有 Virtual DISPLAY 的 html-runner （搜索 xvfb）\n  示例 Linux 环境 安装 / 下载以下软件包：\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Test Suite 示例：\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;YOUR-TEST-SCENARIO\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如何运行 selenium-html-runner headless 现在，最重要的部分，一个如何运行 selenium-html-runner 的例子！ 您的体验可能因软件组合而异 - geckodriver / FF / html-runner 版本。\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html [user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/worst_practices/http_response_codes/",
	"title": "HTTP响应码",
	"tags": [],
	"description": "",
	"content": "对于Selenium RC中的某些浏览器配置， Selenium充当了浏览器和自动化站点之间的代理. 这意味着可以捕获或操纵通过Selenium传递的所有浏览器流量. captureNetworkTraffic() 方法旨在捕获浏览器和自动化站点之间的所有网络流量，包括HTTP响应码.\nSelenium WebDriver是一种完全不同的浏览器自动化实现， 它更喜欢表现得像用户一样，这种方式来自于基于WebDriver编写测试的方式. 在自动化功能测试中，检查状态码并不是测试失败的特别重要的细节, 之前的步骤更重要.\n浏览器将始终呈现HTTP状态代码，例如404或500错误页面. 遇到这些错误页面时，一种“快速失败”的简单方法是 在每次加载页面后检查页面标题或可信赖点的内容（例如 \u0026lt;h1\u0026gt; 标签）. 如果使用的是页面对象模型，则可以将此检查置于类构造函数中或类似于期望的页面加载的位置. 有时，HTTP代码甚至可能出现在浏览器的错误页面中， 您可以使用WebDriver读取此信息并改善调试输出.\n检查网页本身的一种理想实践是符合WebDriver的呈现以及用户的视角.\n如果您坚持，捕获HTTP状态代码的高级解决方案是复刻Selenium RC的行为去使用代理. WebDriver API提供了为浏览器设置代理的功能， 并且有许多代理可以通过编程方式来操纵发送到Web服务器和从Web服务器接收的请求的内容. 使用代理可以决定如何响应重定向响应代码. 此外，并非每个浏览器都将响应代码提供给WebDriver， 因此选择使用代理可以使您拥有适用于每个浏览器的解决方案.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/selenium_installation/",
	"title": "Selenium 安装",
	"tags": [],
	"description": "",
	"content": "Selenium 安装 Selenium 设置与其他商业工具的设置完全不同。 要在自动化项目中使用 Selenium，您需要为您选择的语言安装语言绑定库。 此外，对于要自动运行并运行测试的浏览器，您将需要 WebDriver 二进制文件。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/support_packages/working_with_select_elements/",
	"title": "同选择元素一起工作",
	"tags": [],
	"description": "",
	"content": "选择元素可能需要大量样板代码才能自动化. 为了减少这种情况并使您的测试更干净, 在Selenium的support包中有一个 Select 类. 要使用它，您将需要以下导入语句:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.ui.Select     然后，您能够参考 \u0026lt;select\u0026gt; 元素，基于WebElement创建一个Select对象。\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element(By.ID,\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   IWebElement selectElement = driver.FindElement(By.Id(\u0026#34;selectElementID\u0026#34;)); var selectObject = new SelectElement(selectElement);   select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     Select对象现在将为您提供一系列命令，使您可以与 \u0026lt;select\u0026gt; 元素进行交互. 首先，有多种方法可以从 \u0026lt;select\u0026gt; 元素中选择一个选项.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 有三种方法可以从上述元素中选择第一个选项:\nJava Python C# Ruby JavaScript Kotlin // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by_index(1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by_value(\u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.SelectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.SelectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text  selectObject.SelectByText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by(:index, 1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1) // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     然后，您可以检视所有被选择的选项:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Return a WebElement referencing the first selection option found by walking down the DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Return a list[WebElement] of options that have been selected all_selected_options = select_object.all_selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected var allSelectedOptions = selectObject.AllSelectedOptions; // Return a WebElement referencing the first selection option found by walking down the DOM var firstSelectedOption = selectObject.AllSelectedOptions.FirstOrDefault();   # Return an Array[Element] of options that have been selected all_selected_options = select_object.selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected val allSelectedOptions = selectObject.allSelectedOptions // Return a WebElement referencing the first selection option found by walking down the DOM val firstSelectedOption = selectObject.firstSelectedOption     或者您可能只对 \u0026lt;select\u0026gt; 元素包含哪些 \u0026lt;option\u0026gt; 元素感兴趣:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Return a list[WebElement] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // Return a IList\u0026lt;IWebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains IList\u0026lt;IWebElement\u0026gt; allAvailableOptions = selectObject.Options;   # Return an Array[Element] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains val allAvailableOptions = selectObject.options     如果要取消选择任何元素，现在有四个选项:\nJava Python C# Ruby JavaScript Kotlin // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by_index(1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all()   // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.DeselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.DeselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.DeselectByText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.DeselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by(:index, 1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1) // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll()     最后，一些 \u0026lt;select\u0026gt; 元素允许您选择多个选项. 您可以通过使用以下命令确定您的 \u0026lt;select\u0026gt; 元素是否允许多选:\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   bool doesThisAllowMultipleSelections = selectObject.IsMultiple;   does_this_allow_multiple_selections = select_object.multiple?   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val doesThisAllowMultipleSelections = selectObject.isMultiple     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/selenium_installation/installing_standalone_server/",
	"title": "安装独立服务器",
	"tags": [],
	"description": "",
	"content": "如果您打算使用 Grid， 那么您应该下载 selenium-server-standalone JAR 文件， 但是所有的组件都可以通过 selenium-server 提供。 standalone JAR 文件包含所有内容，包括远程 Selenium 服务器和客户端绑定。 这意味着，如果在项目中使用 selenium-server-standalone JAR，则不必添加 selenium-java 或浏览器特定的 jar。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/getting_started_with_webdriver/locating_elements/",
	"title": "定位元素",
	"tags": [],
	"description": "",
	"content": "定位元素 使用 WebDriver 时要学习的最基本的技术之一是如何查找页面上的元素。 WebDriver 提供了许多内置的选择器类型，其中包括根据 id 属性查找元素:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element(By.ID, \u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     如示例所示，在 WebDriver 中定位元素是在 WebDriver 实例对象上完成的。 findElement(By) 方法返回另一个基本对象类型 WebElement。\n WebDriver 代表浏览器 WebElement 表示特定的 DOM 节点（控件，例如链接或输入栏等）  一旦你已经找到一个元素的引用，你可以通过对该对象实例使用相同的调用来缩小搜索范围：\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(By.ID, \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;) cheddar = cheese.find_element(id: \u0026#39;cheddar\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     你可以这样做是因为， WebDriver 和 WebElement 类型都实现了 搜索上下文 接口。在 WebDriver 中，这称为 基于角色的接口。基于角色的接口允许你确定特定的驱动程序实现是否支持给定的功能。这些接口定义得很清楚，并且尽量只承担单一的功能。你可以阅读更多关于 WebDriver 的设计，以及在 WebDriver 中有哪些角色被支持，在其他被命名的部分。\n因此，上面使用的 By 接口也支持许多附加的定位器策略。嵌套查找可能不是最有效的定位 cheese 的策略，因为它需要向浏览器发出两个单独的命令：首先在 DOM 中搜索 id 为“cheese”的元素，然后在较小范围的上下文中搜索“cheddar”。\n为了稍微提高性能，我们应该尝试使用一个更具体的定位器：WebDriver 支持通过 CSS 定位器查找元素，我们可以将之前的两个定位器合并到一个搜索里面:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   driver.find_element(css: \u0026#39;#cheese #cheddar\u0026#39;)   const cheddar = driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     定位多个元素 我们正在处理的文本中可能会有一个我们最喜欢的奶酪的订单列表：\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; 因为有更多的奶酪无疑是更好的，但是单独检索每一个项目是很麻烦的，检索奶酪的一个更好的方式是使用复数版本 findElements(By) 。此方法返回 web 元素的集合。如果只找到一个元素，它仍然返回(一个元素的)集合。如果没有元素被定位器匹配到，它将返回一个空列表。\nJava Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(“#cheese li”));   mucho_cheese = driver.find_elements(css: \u0026#39;#cheese li\u0026#39;)   const muchoCheese = driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))     元素选择策略 在 WebDriver 中有 8 种不同的内置元素定位策略：\n   定位器 描述     class 名称 定位类的名称中包含搜索值的元素（不允许使用复合类名）   css 选择器 定位与 CSS 选择器匹配的元素   id 定位 id 属性与搜索值匹配的元素   name 定位 name 属性与搜索值匹配的元素   链接文本 定位其可视文本与搜索值匹配的锚元素   部分链接文本 定位其可视文本与搜索值匹配的锚元素   标签名称 定位标签名称与搜索值匹配的元素   xpath 定位与 XPath 表达式匹配的元素    使用选择器的提示 一般来说，如果 HTML 的 id 是可用的、唯一的且是可预测的，那么它就是在页面上定位元素的首选方法。它们的工作速度非常快，可以避免复杂的 DOM 遍历带来的大量处理。\n如果没有唯一的 id，那么最好使用写得好的 CSS 选择器来查找元素。XPath 和 CSS 选择器一样好用，但是它语法很复杂，并且经常很难调试。尽管 XPath 选择器非常灵活，但是他们通常未经过浏览器厂商的性能测试，并且运行速度很慢。\n基于链接文本和部分链接文本的选择策略有其缺点，即只能对链接元素起作用。此外，它们在 WebDriver 内部调用 XPath 选择器。\n标签名可能是一种危险的定位元素的方法。页面上经常出现同一标签的多个元素。这在调用 findElements(By) 方法返回元素集合的时候非常有用。\n建议您尽可能保持定位器的紧凑性和可读性。使用 WebDriver 遍历 DOM 结构是一项性能花销很大的操作，搜索范围越小越好。\nRelative Locators Selenium 4 brings Relative Locators which are previously called as Friendly Locators. This functionality was added to help you locate elements that are nearby other elements. The Available Relative Locators are:\n above below toLeftOf toRightOf near  findElement method now accepts a new method withTagName() which returns a RelativeLocator.\nHow does it work Selenium uses the JavaScript function getBoundingClientRect() to find the relative elements. This function returns properties of an element such as right, left, bottom, and top.\nLet us consider the below example for understanding the relative locators.\nabove() Returns the WebElement, which appears above to the specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement passwordField= driver.findElement(By.id(\u0026#34;password\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .above(passwordField));   #from selenium.webdriver.support.relative_locator import with_tag_name passwordField = driver.find_element(By.ID, \u0026#34;password\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).above(passwordField))   //using static OpenQA.Selenium.RelativeBy; IWebElement passwordField = driver.FindElement(By.Id(\u0026#34;password\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Above(passwordField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      below() Returns the WebElement, which appears below to the specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressField= driver.findElement(By.id(\u0026#34;email\u0026#34;)); WebElement passwordField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .below(emailAddressField));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressField = driver.find_element(By.ID, \u0026#34;email\u0026#34;) passwordField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).below(emailAddressField))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressField = driver.FindElement(By.Id(\u0026#34;email\u0026#34;)); IWebElement passwordField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Below(emailAddressField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toLeftOf() Returns the WebElement, which appears to left of specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement submitButton= driver.findElement(By.id(\u0026#34;submit\u0026#34;)); WebElement cancelButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toLeftOf(submitButton));   #from selenium.webdriver.support.relative_locator import with_tag_name submitButton = driver.find_element(By.ID, \u0026#34;submit\u0026#34;) cancelButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_left_of(submitButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement submitButton = driver.FindElement(By.Id(\u0026#34;submit\u0026#34;)); IWebElement cancelButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .LeftOf(submitButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toRightOf() Returns the WebElement, which appears to right of the specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement cancelButton= driver.findElement(By.id(\u0026#34;cancel\u0026#34;)); WebElement submitButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toRightOf(cancelButton));   #from selenium.webdriver.support.relative_locator import with_tag_name cancelButton = driver.find_element(By.ID, \u0026#34;cancel\u0026#34;) submitButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_right_of(cancelButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement cancelButton = driver.FindElement(By.Id(\u0026#34;cancel\u0026#34;)); IWebElement submitButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .RightOf(cancelButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      near() Returns the WebElement, which is at most 50px away from the specified element.\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressLabel= driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .near(emailAddressLabel));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressLabel = driver.find_element(By.ID, \u0026#34;lbl-email\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;). near(emailAddressLabel))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressLabel = driver.FindElement(By.Id(\u0026#34;lbl-email\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Near(emailAddressLabel));   # Please raise a PR   // Please raise a PR    // Please raise a PR      "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/browser_manipulation/",
	"title": "操控浏览器",
	"tags": [],
	"description": "",
	"content": "Ruby 默认情况下，Ruby 没有安装在 Windows 上。下载最新版本 并运行安装程序。你可以保留所有设置的默认值，除要勾选 安装位置和可选任务 屏幕上 将 Ruby 可执行程序添加到您的系统路径 复选框外。想要驱动任何浏览器，你必须安装 selenium-webdriver Ruby gem. 打开命令提示符并输入以下命令来安装它:\ngem install selenium-webdriver 如果你使用 Bundler，添加这一行到你的应用程序的 Gemfile 中:\ngem \u0026#34;selenium-webdriver\u0026#34; 然后在命令提示符中执行以下命令：\nbundle install Internet Explorer IE 浏览器默认安装在 Windows 上，不需要再次安装。要在 Windows 上驱动 IE，您必须下载最新的 Internet Explorer 驱动程序 并将文件放入 PATH 路径中的文件夹中。要查看 PATH 路径中的目录，在命令提示符中键入 echo %PATH%。\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin 看起来是个不错的位置。解压 IEDriverServer 文件并将 IEDriverServer.exe 移动进去。\n这将打开一个新的 IE 浏览器窗口:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer 浏览器导航 打开网站 启动浏览器后你要做的第一件事就是打开你的网站。这可以通过一行代码实现:\nJava Python C# Ruby JavaScript Kotlin // 简便的方法 driver.get(\u0026#34;https://selenium.dev\u0026#34;); // 更长的方法 driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   # 简便的方法 driver.get \u0026#39;https://selenium.dev\u0026#39; # 更长的方法 driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   // 简便的方法 driver.get(\u0026#34;https://selenium.dev\u0026#34;) // 更长的方法 driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     获取当前 URL 您可以从浏览器的地址栏读取当前的 URL，使用:\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.currentUrl    后退 按下浏览器的后退按钮:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     前进 按下浏览器的前进键:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward()    刷新 刷新当前页面:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    获取标题 从浏览器中读取当前页面的标题:\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.title    窗口和标签页 WebDriver 没有区分窗口和标签页。如果你的站点打开了一个新标签页或窗口，Selenium 将允许您使用窗口句柄来处理它。 每个窗口都有一个唯一的标识符，该标识符在单个会话中保持持久性。你可以使用以下方法获得当前窗口的窗口句柄:\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.windowHandle    切换窗口或标签页 单击在 \u0026lt;a href=\u0026quot;https://seleniumhq.github.io\u0026quot;target=\u0026rdquo;_blank\u0026quot;\u0026gt;新窗口中打开链接， 则屏幕会聚焦在新窗口或新标签页上，但 WebDriver 不知道操作系统认为哪个窗口是活动的。 要使用新窗口，您需要切换到它。 如果只有两个选项卡或窗口被打开，并且你知道从哪个窗口开始， 则你可以遍历 WebDriver， 通过排除法可以看到两个窗口或选项卡，然后切换到你需要的窗口或选项卡。\n不过，Selenium 4 提供了一个新的 api NewWindow ， 它创建一个新选项卡 (或) 新窗口并自动切换到它。\nJava Python C# Ruby JavaScript Kotlin // 存储原始窗口的 ID String originalWindow = driver.getWindowHandle(); // 检查一下，我们还没有打开其他的窗口 assert driver.getWindowHandles().size() == 1; // 点击在新窗口中打开的链接 driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); // 等待新窗口或标签页 wait.until(numberOfWindowsToBe(2)); // 循环执行，直到找到一个新的窗口句柄 for (String windowHandle : driver.getWindowHandles()) {if(!originalWindow.contentEquals(windowHandle)) {driver.switchTo().window(windowHandle); break; } } // 等待新标签完成加载内容 wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # 启动驱动程序 with webdriver.Firefox() as driver: # 打开网址 driver.get(\u0026#34;https://seleniumhq.github.io\u0026#34;) # 设置等待 wait = WebDriverWait(driver, 10) # 存储原始窗口的 ID original_window = driver.current_window_handle # 检查一下，我们还没有打开其他的窗口 assert len(driver.window_handles) == 1 # 单击在新窗口中打开的链接 driver.find_element(By.LINK_TEXT, \u0026#34;new window\u0026#34;).click() # 等待新窗口或标签页 wait.until(EC.number_of_windows_to_be(2)) # 循环执行，直到找到一个新的窗口句柄 for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # 等待新标签页完成加载内容 wait.until(EC.title_is(\u0026#34;SeleniumHQ Browser Automation\u0026#34;))   // 存储原始窗口的 ID string originalWindow = driver.CurrentWindowHandle; // 检查一下，我们还没有打开其他的窗口 Assert.AreEqual(driver.WindowHandles.Count, 1); // 单击在新窗口中打开的链接 driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); // 等待新窗口或标签页 wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); // 循环执行，直到找到一个新的窗口句柄 foreach(string window in driver.WindowHandles) {if(originalWindow != window) {driver.SwitchTo().Window(window); break; } } // 等待新标签页完成加载内容 wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   # 存储原始窗口的 ID original_window = driver.window_handle #检查一下，我们还没有打开其他的窗口 assert(driver.window_handles.length == 1,\u0026#39;Expected one window\u0026#39;) #点击在新窗口中打开的链接 driver.find_element(link:\u0026#39;new window\u0026#39;).click #等待新窗口或标签页 wait.until {driver.window_handles.length == 2} #循环执行，直到找到一个新的窗口句柄 driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #等待新标签页完成加载内容 wait.until {driver.title ==\u0026#39;Selenium documentation\u0026#39;}   // 存储原始窗口的 ID const originalWindow = await driver.getWindowHandle(); // 检查一下，我们还没有打开其他的窗口 assert((await driver.getAllWindowHandles()).length === 1); // 点击在新窗口中打开的链接 await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); // 等待新窗口或标签页 await driver.wait(async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); // 循环执行，直到找到一个新的窗口句柄 const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; {if (handle !== originalWindow) {await driver.switchTo().window(handle); } }); // 等待新标签页完成加载内容 await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   // 存储原始窗口的 ID val originalWindow = driver.getWindowHandle() // 检查一下，我们还没有打开其他的窗口 assert(driver.getWindowHandles().size() === 1) // 点击在新窗口中打开的链接 driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() // 等待新窗口或标签页 wait.until(numberOfWindowsToBe(2)) // 循环执行，直到找到一个新的窗口句柄 for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } // 等待新标签页完成加载内容 wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     创建新窗口(或)新标签页并且切换 创建一个新窗口 (或) 标签页，屏幕焦点将聚焦在新窗口或标签在上。您不需要切换到新窗口 (或) 标签页。如果除了新窗口之外， 您打开了两个以上的窗口 (或) 标签页，您可以通过遍历 WebDriver 看到两个窗口或选项卡，并切换到非原始窗口。\n注意: 该特性适用于 Selenium 4 及其后续版本。\nJava Python C# Ruby JavaScript Kotlin // 打开新标签页并切换到新标签页 driver.switchTo().newWindow(WindowType.TAB); // 打开一个新窗口并切换到新窗口 driver.switchTo().newWindow(WindowType.WINDOW);   # 打开新标签页并切换到新标签页 driver.switch_to.new_window(\u0026#39;tab\u0026#39;) # 打开一个新窗口并切换到新窗口 driver.switch_to.new_window(\u0026#39;window\u0026#39;)   // 打开新标签页并切换到新标签页 driver.SwitchTo().NewWindow(WindowType.Tab) // 打开一个新窗口并切换到新窗口 driver.SwitchTo().NewWindow(WindowType.Window)   # 注意：ruby 中的 new_window 只打开一个新标签页(或)窗口，不会自动切换 # 用户必须切换到新选项卡 (或) 新窗口 # 打开新标签页并切换到新标签页 driver.manage.new_window(:tab) # 打开一个新窗口并切换到新窗口 driver.manage.new_window(:window)   // 打开新标签页并切换到新标签页 await driver.switchTo().newWindow(\u0026#39;tab\u0026#39;); // 打开一个新窗口并切换到新窗口 await driver.switchTo().newWindow(\u0026#39;window\u0026#39;);   // 打开新标签页并切换到新标签页 driver.switchTo().newWindow(WindowType.TAB) // 打开一个新窗口并切换到新窗口 driver.switchTo().newWindow(WindowType.WINDOW)     关闭窗口或标签页 当你完成了一个窗口或标签页的工作时，_并且_它不是浏览器中最后一个打开的窗口或标签页时，你应该关闭它并切换回你之前使用的窗口。 假设您遵循了前一节中的代码示例，您将把前一个窗口句柄存储在一个变量中。把这些放在一起，你会得到:\nJava Python C# Ruby JavaScript Kotlin //关闭标签页或窗口 driver.close(); //切回到之前的标签页或窗口 driver.switchTo().window(originalWindow);   #关闭标签页或窗口 driver.close() #切回到之前的标签页或窗口 driver.switch_to.window(original_window)   //关闭标签页或窗口 driver.Close(); //切回到之前的标签页或窗口 driver.SwitchTo().Window(originalWindow);   #关闭标签页或窗口 driver.close #切回到之前的标签页或窗口 driver.switch_to.window original_window   //关闭标签页或窗口 await driver.close(); //切回到之前的标签页或窗口 await driver.switchTo().window(originalWindow);   //关闭标签页或窗口 driver.close() //切回到之前的标签页或窗口 driver.switchTo().window(originalWindow)     如果在关闭一个窗口后忘记切换回另一个窗口句柄，WebDriver 将在当前关闭的页面上执行，并触发一个 No Such Window Exception 无此窗口异常。必须切换回有效的窗口句柄才能继续执行。\n在会话结束时退出浏览器 当你完成了浏览器会话，你应该调用 quit 退出，而不是 close 关闭: Java Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()   \n 退出将会  关闭所有与 WebDriver 会话相关的窗口和选项卡 结束浏览器进程 结束后台驱动进程 通知 Selenium Grid 浏览器不再使用，以便可以由另一个会话使用它(如果您正在使用 Selenium Grid)    调用 quit() 失败将留下额外的后台进程和端口运行在机器上，这可能在以后导致一些问题。\n有的测试框架提供了一些方法和注释，您可以在测试结束时放入 teardown() 方法中。\nJava Python C# Ruby JavaScript Kotlin /** * 使用 JUnit 的例子 * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() {driver.quit(); }   # unittest teardown # https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown def tearDown(self): self.driver.quit()   /* 使用 Visual Studio 的 UnitTesting 的例子 https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() {driver.Quit(); }   # UnitTest Teardown # https://www.rubydoc.info/github/test-unit/test-unit/Test/Unit/TestCase def teardown @driver.quit end   /** * 使用 Mocha 的例子 * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () {await driver.quit(); });   /** * 使用 JUnit 的例子 * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() {driver.quit() }     如果不在测试上下文中运行 WebDriver，您可以考虑使用 try / finally，这是大多数语言都提供的， 这样一个异常处理仍然可以清理 WebDriver 会话。\nJava Python C# Ruby JavaScript Kotlin try {//WebDriver 代码…} finally {driver.quit(); }   try: #WebDriver 代码… finally: driver.quit()   try {//WebDriver 代码…} finally {driver.Quit(); }   begin #WebDriver 代码… ensure driver.quit end   try {//WebDriver 代码…} finally {await driver.quit(); }   try {//WebDriver 代码…} finally {driver.quit() }     Python 的 WebDriver 现在支持 Python 上下文管理器，当使用 with 关键字时，可以在执行结束时自动退出驱动程序。\nwith webdriver.Firefox() as driver: # WebDriver 代码… # 在此缩进位置后 WebDriver 会自动退出 Frames and Iframes 框架是一种现在已被弃用的方法，用于从同一域中的多个文档构建站点布局。除非你使用的是 HTML5 之前的 webapp，否则你不太可能与他们合作。内嵌框架允许插入来自完全不同领域的文档，并且仍然经常使用。\n如果您需要使用框架或 iframe, WebDriver 允许您以相同的方式使用它们。考虑 iframe 中的一个按钮。 如果我们使用浏览器开发工具检查元素，我们可能会看到以下内容:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34;name=\u0026#34;myframe\u0026#34;src=\u0026#34;https://seleniumhq.github.io\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; 如果不是 iframe，我们可能会使用如下方式点击按钮:\nJava Python C# Ruby JavaScript Kotlin // 这不会工作 driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # 这不会工作 driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   // 这不会工作 driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # 这不会工作 driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // 这不会工作 await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   // 这不会工作 driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     但是，如果 iframe 之外没有按钮，那么您可能会得到一个 no such element 无此元素 的错误。 这是因为 Selenium 只知道顶层文档中的元素。为了与按钮进行交互，我们需要首先切换到框架， 这与切换窗口的方式类似。WebDriver 提供了三种切换到帧的方法。\n使用 WebElement 使用 WebElement 进行切换是最灵活的选择。您可以使用首选的选择器找到框架并切换到它。\nJava Python C# Ruby JavaScript Kotlin // 存储网页元素 WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); // 切换到 frame driver.switchTo().frame(iframe); // 现在可以点击按钮 driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # 存储网页元素 iframe = driver.find_element(By.CSS_SELECTOR, \u0026#34;#modal \u0026gt; iframe\u0026#34;) # 切换到选择的 iframe driver.switch_to.frame(iframe) # 单击按钮 driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   // 存储网页元素 IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); // 切换到 frame driver.SwitchTo().Frame(iframe); // 现在可以点击按钮 driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Store iframe web element iframe = driver.find_element(:css,\u0026#39;#modal\u0026gt; iframe\u0026#39;) # 切换到 frame driver.switch_to.frame iframe # 单击按钮 driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // 存储网页元素 const iframe = driver.findElement(By.css(\u0026#39;#modal\u0026gt; iframe\u0026#39;)); // 切换到 frame await driver.switchTo().frame(iframe); // 现在可以点击按钮 await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   // 存储网页元素 val iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) // 切换到 frame driver.switchTo().frame(iframe) // 现在可以点击按钮 driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     使用 name 或 id 如果您的 frame 或 iframe 具有 id 或 name 属性，则可以使用该属性。如果名称或 id 在页面上不是唯一的， 那么将切换到找到的第一个。\nJava Python C# Ruby JavaScript Kotlin // 使用 ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); // 或者使用 name 代替 driver.switchTo().frame(\u0026#34;myframe\u0026#34;); // 现在可以点击按钮 driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # 通过 id 切换框架 driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # 单击按钮 driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   // 使用 ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); // 或者使用 name 代替 driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); // 现在可以点击按钮 driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Switch by ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # 单击按钮 driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // 使用 ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // 或者使用 name 代替 await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // 现在可以点击按钮 await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   // 使用 ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) // 或者使用 name 代替 driver.switchTo().frame(\u0026#34;myframe\u0026#34;) // 现在可以点击按钮 driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     使用索引 还可以使用frame的索引， 例如可以使用JavaScript中的 window.frames 进行查询.\nJava Python C# Ruby JavaScript Kotlin // 切换到第 2 个框架 driver.switchTo().frame(1);   # 切换到第 2 个框架 driver.switch_to.frame(1)   // 切换到第 2 个框架 driver.SwitchTo().Frame(1);   # 基于索引切换到第 2 个 iframe iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # 切换到选择的 iframe driver.switch_to.frame(iframe)   // 切换到第 2 个框架 await driver.switchTo().frame(1);   // 切换到第 2 个框架 driver.switchTo().frame(1)     离开框架 离开 iframe 或 frameset，切换回默认内容，如下所示:\nJava Python C# Ruby JavaScript Kotlin // 回到顶层 driver.switchTo().defaultContent();   # 切回到默认内容 driver.switch_to.default_content()   // 回到顶层 driver.SwitchTo().DefaultContent();   # 回到顶层 driver.switch_to.default_content   // 回到顶层 await driver.switchTo().defaultContent();   // 回到顶层 driver.switchTo().defaultContent()     窗口管理 屏幕分辨率会影响 web 应用程序的呈现方式，因此 WebDriver 提供了移动和调整浏览器窗口大小的机制。\n获取窗口大小 获取浏览器窗口的大小(以像素为单位)。\nJava Python C# Ruby JavaScript Kotlin // 分别获取每个尺寸 int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); // 或者存储尺寸并在以后查询它们 Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # 分别获取每个尺寸 width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # 或者存储尺寸并在以后查询它们 size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   // 分别获取每个尺寸 int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; // 或者存储尺寸并在以后查询它们 System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # 分别获取每个尺寸 width = driver.manage.window.size.width height = driver.manage.window.size.height # 或者存储尺寸并在以后查询它们 size = driver.manage.window.size width1 = size.width height1 = size.height   // 分别获取每个尺寸 const {width, height} = await driver.manage().window().getRect(); // 或者存储尺寸并在以后查询它们 const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   // 分别获取每个尺寸 val width = driver.manage().window().size.width val height = driver.manage().window().size.height // 或者存储尺寸并在以后查询它们 val size = driver.manage().window().size val width1 = size.width val height1 = size.height     设置窗口大小 恢复窗口并设置窗口大小。 Java Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({width: 1024, height: 768});   driver.manage().window().size = Dimension(1024, 768)   \n得到窗口的位置 获取浏览器窗口左上角的坐标。\nJava Python C# Ruby JavaScript Kotlin // 分别获取每个尺寸 int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // 或者存储尺寸并在以后查询它们 Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # 分别获取每个尺寸 x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # 或者存储尺寸并在以后查询它们 position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   // 分别获取每个尺寸 int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; // 或者存储尺寸并在以后查询它们 Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   #Access each dimension individually x = driver.manage.window.position.x y = driver.manage.window.position.y # Or store the dimensions and query them later rect = driver.manage.window.rect x1 = rect.x y1 = rect.y   // 分别获取每个尺寸 const {x, y} = await driver.manage().window().getRect(); // 或者存储尺寸并在以后查询它们 const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // 分别获取每个尺寸 val x = driver.manage().window().position.x val y = driver.manage().window().position.y // 或者存储尺寸并在以后查询它们 val position = driver.manage().window().position val x1 = position.x val y1 = position.y     设置窗口位置 将窗口移动到设定的位置。\nJava Python C# Ruby JavaScript Kotlin // 将窗口移动到主显示器的左上角 driver.manage().window().setPosition(new Point(0, 0));   # 将窗口移动到主显示器的左上角 driver.set_window_position(0, 0)   // 将窗口移动到主显示器的左上角 driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // 将窗口移动到主显示器的左上角 await driver.manage().window().setRect({x: 0, y: 0});   // 将窗口移动到主显示器的左上角 driver.manage().window().position = Point(0,0)     最大化窗口 扩大窗口。对于大多数操作系统，窗口将填满屏幕，而不会阻挡操作系统自己的菜单和工具栏。\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    最小化窗口 最小化当前浏览上下文的窗口. 这种命令的精准行为将作用于各个特定的窗口管理器.\n最小化窗口通常将窗口隐藏在系统托盘中.\n注意: 此功能适用于Selenium 4以及更高版本.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().minimize();  driver.minimize_window()  driver.Manage().Window.Minimize();   driver.manage.window.minimize  await driver.manage().window().minimize();   driver.manage().window().minimize()    全屏窗口 填充整个屏幕，类似于在大多数浏览器中按下 F11。\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/introduction/types_of_testing/",
	"title": "测试的类型",
	"tags": [],
	"description": "",
	"content": "验收测试 进行这种类型的测试以确定功能或系统是否满足客户的期望和要求. 这种测试通常涉及客户的合作或反馈, 是一种验证活动, 可以用于回答以下问题：\n 我们是否在制造 正确的 产品?\n 对于Web应用程序, 可以通过模拟用户期望的行为 直接使用Selenium来完成此测试的自动化. 可以通过记录/回放, 或通过本文档中介绍的各种支持的语言来完成此类模拟. 注意：有些人可能还会提到, 验收测试是 功能测试 的子类型.\n功能测试 进行这种类型的测试是为了确定功能或系统是否正常运行而没有问题. 它会在不同级别检查系统, 以确保涵盖所有方案并且系统能够执行预期的 工作 . 这是一个验证活动, 它回答了以下问题：\n 我们是否在 正确地 制造产品？\n 这通常包括： 测试没有错误 (404, 异常…) , 以可用的方式 (正确的重定向) 正常运行, 以可访问的方式并匹配其规格 (请参见前述的 验收测试 ) .\n对于Web应用程序, 可以通过模拟预期的结果, 直接使用Selenium来完成此测试的自动化. 可以通过记录/回放或通过本文档中说明的各种支持的语言来完成此模拟.\n性能测试 顾名思义, 进行性能测试是为了衡量应用程序的性能.\n性能测试主要有两种类型:\n负载测试 进行了负载测试, 以验证应用程序在各种特定的负载 (通常是同时连接一定数量的用户) 下的运行状况\n压力测试 进行压力测试, 以验证应用程序在压力 (或高于最大支持负载) 下的运行状况.\n通常, 性能测试是通过执行一些Selenium书写的测试来完成的, 这些测试模拟了不同的用户 使用Web应用程序的特定功能 并检索了一些有意义的指标.\n通常, 这是由其他检索指标的工具完成的.\nJMeter 就是这样一种工具.\n对于Web应用程序, 要测量的详细信息包括 吞吐量、 延迟、数据丢失、单个组件加载时间\u0026hellip;\n注意1：所有浏览器的开发人员工具 均具有“性能”标签 (可通过按F12进行访问)\n注2：这属于 非功能测试 的类型, 因为它通常是按系统而不是按功能/特征进行测量.\n回归测试 此测试通常在修改, 修复或添加功能之后进行.\n为了确保所做的更改没有破坏任何现有功能, 将再次执行一些已经执行过的测试.\n重新执行的测试集可以是全部或部分, 并且可以包括几种不同的类型, 具体取决于具体的应用程序和开发团队.\n测试驱动开发 (TDD) TDD本身不是一种测试类型, 而是一种迭代开发方法, 用于测试驱动功能的设计.\n每个周期都从创建功能应通过的一组单元测试开始 (这将使首次执行失败) .\n此后, 进行开发以使测试通过. 在另一个周期开始再次执行测试, 此过程一直持续到所有测试通过为止.\n如此做的目的是基于以下情况, 既缺陷发现的时间越早成本越低, 从而加快了应用程序的开发.\n行为驱动开发 (BDD) BDD还是基于上述 (TDD) 的迭代开发方法, 其目的是让各方参与到应用程序的开发中.\n每个周期都从创建一些规范开始 (应该失败) . 然后创建会失败的单元测试 (也应该失败) , 之后着手开发.\n重复此循环, 直到所有类型的测试通过.\n为此, 使用了规范语言. 因为简单、标准和明确, 各方都应该能够理解. 大多数工具都使用 Gherkin 作为这种语言.\n目标是为了解决潜在的验收问题, 从而能够检测出比TDD还要多的错误, 并使各方之间的沟通更加顺畅.\n当前有一组工具可用于编写规范 并将其与编码功能 (例如 Cucumber 或 SpecFlow ) 匹配.\n在Selenium之上构建了一系列工具, 可通过将BDD规范直接转换为可执行代码, 使得上述过程更为迅速. 例如 JBehave, Capybara 和 Robot Framework.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/generating_application_state/",
	"title": "生成应用程序状态",
	"tags": [],
	"description": "",
	"content": "Selenium不应用于准备测试用例. 测试用例中所有重复性动作和准备工作, 都应通过其他方法来完成.\n例如, 大多数Web UI都具有身份验证 (诸如一个登录表单) . 在每次测试之前通过Web浏览器进行登录的消除, 将提高测试的速度和稳定性. 应该创建一种方法来获取对 AUT* 的访问权限 (例如, 使用API登录并设置Cookie) . 此外, 不应使用Selenium创建预加载数据来进行测试的方法.\n如前所述, 应利用现有的API为 AUT* 创建数据. ***AUT**: 待测系统\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/grid/setting_up_your_own_grid/",
	"title": "配置自己的服务网格",
	"tags": [],
	"description": "",
	"content": "使用Selenium网格， 你需要维护你自己的基础设置来作为节点使用， 这将是一个繁重的紧张的工作，很多组织使用IaaS供应商比如Amazon EC2或者Google来提供这些基础设施。\n使用Sauce Labs或者Testing Bot这类提供了Selenium网格作为云服务的供应商也是一个选择。 当然，在你自己的硬件群运行节点也是可行的。 这一章会深入探讨如何用你自己的基础设施来运行你的服务网格，\n快速开始 这个例子会向你展示如何开始Selenium 2服务网格的转发器(hub), 然后注册WebDriver节点和Selenium 1 RC节点。 我们也会向你展示如何使用Java来使用Selenium服务网格。 这个例子里转发器和节点被运行在了同一台终端机上，当然你也可以服务selenium-server-standalone到 多台终端机。\nselenium-server-standalone 包含了运行网格所需要的转发器(hub),WebDriver和legacy RC needed, _ant_已经不是必须的了. 你可以在https://selenium.dev/downloads/.下载 selenium-server-standalone.jar\n第一步: 启动转发器(hub) 转发器(hub)是接受测试请求并分发到合适的节点的中心点。 分发是基于节点的能力的，这就意味着一个有特定需求的测试仅会被分发到能提供这个需求的节点上。\n因为一个测试所期望的能力，就如字面意思，期望，并不代表转发器(hub)能够找到一个真正满足所有期望的节点。\n打开命令行窗口，来到存放selenium-server-standalone.jar文件的地方。 启动转发器(hub)并传入-role hub作为参数来启动一个独立的服务：\njava -jar selenium-server-standalone.jar -role hub 转发器(hub)默认会监听4444端口，你也可以通过打开浏览器访问http://localhost:4444/grid/console来查看转发器(hub)的状态。\n如果需要改变默认端口，你可以添加-port加上一个数字作为参数来代表你期望监听的端口， 同时，所有其他的可选参数都可以在下面这个JSON配置文件里找到。\n你已经在上面获得了一个简单命令，当然如果你希望一些更高级的配置， 方便起见，你也可以指定一个JSON格式的配置文件来配置并启动你的转发器(hub)。 你可以这么做：\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug 下面你可以看到一个配置文件hubConfig.json的例子。 我们会在第二步深入探讨怎么来提供节点配置文件。\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} 第二部: 启动节点 无论你期望你的服务网格使用新的WebDriver的功能，还是Selenium 1 RC的功能，或者2者皆有。 你都只需要使用selenium-server-standalone.jar来启动节点。\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 如果不通过-port来指定端口，会选一个可用端口。你也可以在一个终端机上运行多个节点， 但是如果你这么做了，你需要意识到当你的测试使用截屏会引发你的系统内存资源和问题。\n配置节点的可选参数 正如前面提到的，作为一个向下兼容，\u0026ldquo;wd\u0026quot;和”rc”这两个角色都是节点角色的合法的自己。 当节点同时允许RC饿WebDriver的远程链接时，这些角色限制了远程连接使用的API。\n通过在命令行中设置JVM属性(_在-jar参数前_使用-D参数)，会被传递到节点里： -Dwebdriver.chrome.driver=chromedriver.exe\n使用JSON配置节点 你也可以使用JSON配置文件来启动服务网格节点\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json 这里是一个配置文件nodeConfig.json的例子:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } 有关于-host参数的注解\n无论是转发器还是节点，如果不指定-host参数，会默认使用0.0.0.0， 这么做会绑定终端机的所有的公共IPv4接口。如果你有一些特殊网络配置或者一些组件创建的网络接口， 建议设置-host参数，来使你的转发器或节点能够被其他终端机访问。\n指定端口 转发器默认使用TCP/IP端口4444.如果你希望改端口，请用上面提到的配置方法。\n故障排查 使用日志文件 如果需要进行高级故障排查你可以指定一个日志文件来记录系统信息。 启动Selenium服务网格的转发器(hub)或节点的时候使用-log参数。下面是一个例子：\njava -jar selenium-server-standalone.jar -role hub -log log.txt 使用你习惯的文本编辑器来打开日志文件(例子里用的log.txt)，查找\u0026quot;ERROR\u0026quot;日志来定位你的问题。\n使用 -debug 参数 同时，你也可以通过使用-debug来向控制台打印debug日志。 启动Selenium服务网格的转发器(hub)或节点的时候使用-debug参数。下面是一个例子：\njava -jar selenium-server-standalone.jar -role hub -debug 提醒 Selenium服务网格需要使用合适的防火墙许可来隔离外部访问。\n如果不能有效的保护你的服务网格，可能会导致以下问题：\n 提供了一个开发的接口来访问服务网格的基础设施 你将会允许第三方来访问内部web服务和文件 你将会允许第三方来执行定制的二进制文件  请参考这篇文章Detectify, 这里给了一个很好的概要， 关于暴露一个服务网格后会如何被滥用：Don\u0026rsquo;t Leave your Grid Wide Open.\nDocker Selenium Docker提供了一个方便的途径来在容器中构建一个可扩张的Selenium服务网格基础设置， 容器是软件的标准单元，包含了所有执行应用程序需要的东西，包括所有的依赖，它以一种可靠的，可以复制的方法来在不同的终端机上运行。\nSelenium项目维护了一组Docker镜像，你可以下载并运行来快速的获得一个可用的服务网格。 Firefox和Chrome都提供了可用的镜像。你可以在Docker Selenium 找到关于如何启动服务网格的详细信息.\n前提 创建服务网格的唯一的前提是安装了Docker并能正常运行 Install Docker.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/worst_practices/gmail_email_and_facebook_logins/",
	"title": "Gmail, email 和 Facebook 登录",
	"tags": [],
	"description": "",
	"content": "由于多种原因, 不建议使用WebDriver登录Gmail和Facebook等网站. 除了违反这些网站的使用条款之外 (您可能会面临帐户被关闭的风险) , 还有其运行速度缓慢且不可靠的因素.\n理想的做法是使用电子邮件供应商提供的API, 或者对于Facebook, 使用开发者工具的服务, 该服务是被用于创建测试帐户、朋友等内容的API. 尽管使用API可能看起来有些额外的工作量, 但是您将获得基于速度、可靠性和稳定性的回报. API不会频繁更改, 但是网页和HTML定位符经常变化, 并且需要您更新测试框架的代码.\n在任何时候测试使用WebDriver登录第三方站点, 都会增加测试失败的风险, 因为这会使您的测试时间更长. 通常的经验是, 执行时间较长的测试会更加脆弱和不可靠.\n符合W3C conformant 的WebDriver实现, 也会使用 WebDriver 的属性对 navigator 对象进行注释, 用于缓解拒绝服务的攻击.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/legacy_docs/selenium_ide/",
	"title": "Legacy Selenium IDE",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests!\n Introduction The Selenium-IDE (Integrated Development Environment) is the tool you use to develop your Selenium test cases. It’s an easy-to-use Firefox plug-in and is generally the most efficient way to develop test cases. It also contains a context menu that allows you to first select a UI element from the browser’s currently displayed page and then select from a list of Selenium commands with parameters pre-defined according to the context of the selected UI element. This is not only a time-saver, but also an excellent way of learning Selenium script syntax.\nThis chapter is all about the Selenium IDE and how to use it effectively.\nInstalling the IDE Using Firefox, first, download the IDE from the SeleniumHQ downloads page\nFirefox will protect you from installing addons from unfamiliar locations, so you will need to click ‘Allow’ to proceed with the installation, as shown in the following screenshot.\nWhen downloading from Firefox, you’ll be presented with the following window.\nSelect Install Now. The Firefox Add-ons window pops up, first showing a progress bar, and when the download is complete, displays the following.\nRestart Firefox. After Firefox reboots you will find the Selenium-IDE listed under the Firefox Tools menu.\nOpening the IDE To run the Selenium-IDE, simply select it from the Firefox Tools menu. It opens as follows with an empty script-editing window and a menu for loading, or creating new test cases.\nIDE Features Menu Bar The File menu has options for Test Case and Test Suite (suite of Test Cases). Using these you can add a new Test Case, open a Test Case, save a Test Case, export Test Case in a language of your choice. You can also open the recent Test Case. All these options are also available for Test Suite.\nThe Edit menu allows copy, paste, delete, undo, and select all operations for editing the commands in your test case. The Options menu allows the changing of settings. You can set the timeout value for certain commands, add user-defined user extensions to the base set of Selenium commands, and specify the format (language) used when saving your test cases. The Help menu is the standard Firefox Help menu; only one item on this menu–UI-Element Documentation–pertains to Selenium-IDE.\nToolbar The toolbar contains buttons for controlling the execution of your test cases, including a step feature for debugging your test cases. The right-most button, the one with the red-dot, is the record button.\nSpeed Control: controls how fast your test case runs.\nRun All: Runs the entire test suite when a test suite with multiple test cases is loaded.\nRun: Runs the currently selected test. When only a single test is loaded this button and the Run All button have the same effect.\nPause/Resume: Allows stopping and re-starting of a running test case.\nStep: Allows you to “step” through a test case by running it one command at a time. Use for debugging test cases.\nTestRunner Mode: Allows you to run the test case in a browser loaded with the Selenium-Core TestRunner. The TestRunner is not commonly used now and is likely to be deprecated. This button is for evaluating test cases for backwards compatibility with the TestRunner. Most users will probably not need this button.\nApply Rollup Rules: This advanced feature allows repetitive sequences of Selenium commands to be grouped into a single action. Detailed documentation on rollup rules can be found in the UI-Element Documentation on the Help menu.\nTest Case Pane Your script is displayed in the test case pane. It has two tabs, one for displaying the command and their parameters in a readable “table” format.\nThe other tab - Source displays the test case in the native format in which the file will be stored. By default, this is HTML although it can be changed to a programming language such as Java or C#, or a scripting language like Python. See the Options menu for details. The Source view also allows one to edit the test case in its raw form, including copy, cut and paste operations.\nThe Command, Target, and Value entry fields display the currently selected command along with its parameters. These are entry fields where you can modify the currently selected command. The first parameter specified for a command in the Reference tab of the bottom pane always goes in the Target field. If a second parameter is specified by the Reference tab, it always goes in the Value field.\nIf you start typing in the Command field, a drop-down list will be populated based on the first characters you type; you can then select your desired command from the drop-down.\nLog/Reference/UI-Element/Rollup Pane The bottom pane is used for four different functions–Log, Reference, UI-Element, and Rollup–depending on which tab is selected.\nLog When you run your test case, error messages and information messages showing the progress are displayed in this pane automatically, even if you do not first select the Log tab. These messages are often useful for test case debugging. Notice the Clear button for clearing the Log. Also notice the Info button is a drop-down allowing selection of different levels of information to log.\nReference The Reference tab is the default selection whenever you are entering or modifying Selenese commands and parameters in Table mode. In Table mode, the Reference pane will display documentation on the current command. When entering or modifying commands, whether from Table or Source mode, it is critically important to ensure that the parameters specified in the Target and Value fields match those specified in the parameter list in the Reference pane. The number of parameters provided must match the number specified, the order of parameters provided must match the order specified, and the type of parameters provided must match the type specified. If there is a mismatch in any of these three areas, the command will not run correctly.\nWhile the Reference tab is invaluable as a quick reference, it is still often necessary to consult the Selenium Reference document.\nUI-Element and Rollup Detailed information on these two panes (which cover advanced features) can be found in the UI-Element Documentation on the Help menu of Selenium-IDE.\nBuilding Test Cases There are three primary methods for developing test cases. Frequently, a test developer will require all three techniques.\nRecording Many first-time users begin by recording a test case from their interactions with a website. When Selenium-IDE is first opened, the record button is ON by default. If you do not want Selenium-IDE to begin recording automatically you can turn this off by going under Options \u0026gt; Options… and deselecting “Start recording immediately on open.”\nDuring recording, Selenium-IDE will automatically insert commands into your test case based on your actions. Typically, this will include:\n clicking a link - click or clickAndWait commands entering values - type command selecting options from a drop-down listbox - select command clicking checkboxes or radio buttons - click command  Here are some “gotchas” to be aware of:\n The type command may require clicking on some other area of the web page for it to record. Following a link usually records a click command. You will often need to change this to clickAndWait to ensure your test case pauses until the new page is completely loaded. Otherwise, your test case will continue running commands before the page has loaded all its UI elements. This will cause unexpected test case failures.  Adding Verifications and Asserts With the Context Menu Your test cases will also need to check the properties of a web-page. This requires assert and verify commands. We won’t describe the specifics of these commands here; that is in the chapter on Selenium Commands – “Selenese”. Here we’ll simply describe how to add them to your test case.\nWith Selenium-IDE recording, go to the browser displaying your test application and right click anywhere on the page. You will see a context menu showing verify and/or assert commands.\nThe first time you use Selenium, there may only be one Selenium command listed. As you use the IDE however, you will find additional commands will quickly be added to this menu. Selenium-IDE will attempt to predict what command, along with the parameters, you will need for a selected UI element on the current web-page.\nLet’s see how this works. Open a web-page of your choosing and select a block of text on the page. A paragraph or a heading will work fine. Now, right-click the selected text. The context menu should give you a verifyTextPresent command and the suggested parameter should be the text itself.\nAlso, notice the Show All Available Commands menu option. This shows many, many more commands, again, along with suggested parameters, for testing your currently selected UI element.\nTry a few more UI elements. Try right-clicking an image, or a user control like a button or a checkbox. You may need to use Show All Available Commands to see options other than verifyTextPresent. Once you select these other options, the more commonly used ones will show up on the primary context menu. For example, selecting verifyElementPresent for an image should later cause that command to be available on the primary context menu the next time you select an image and right-click.\nAgain, these commands will be explained in detail in the chapter on Selenium commands. For now though, feel free to use the IDE to record and select commands into a test case and then run it. You can learn a lot about the Selenium commands simply by experimenting with the IDE.\nEditing Insert Command Table View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click on the line where you want to insert a new command. Right-click and select Insert Command; the IDE will add a blank line just ahead of the line you selected. Now use the command editing text fields to enter your new command and its parameters.\nSource View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click between the commands where you want to insert a new command, and enter the HTML tags needed to create a 3-column row containing the Command, first parameter (if one is required by the Command), and second parameter (again, if one is required to locate an element) and third parameter(again, if one is required to have a value). Example:\n\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Command\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;target (locator)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Insert Comment Comments may be added to make your test case more readable. These comments are ignored when the test case is run.\nComments may also be used to add vertical white space (one or more blank lines) in your tests; just create empty comments. An empty command will cause an error during execution; an empty comment won’t.\nTable View Select the line in your test case where you want to insert the comment. Right-click and select Insert Comment. Now use the Command field to enter the comment. Your comment will appear in purple text.\nSource View Select the point in your test case where you want to insert the comment. Add an HTML-style comment, i.e., \u0026lt;!-- your comment here --\u0026gt;.\nEdit a Command or Comment Table View Simply select the line to be changed and edit it using the Command, Target, and Value fields.\nSource View Since Source view provides the equivalent of a WYSIWYG (What You See is What You Get) editor, simply modify which line you wish–command, parameter, or comment.\nOpening and Saving a Test Case Like most programs, there are Save and Open commands under the File menu. However, Selenium distinguishes between test cases and test suites. To save your Selenium-IDE tests for later use you can either save the individual test cases, or save the test suite. If the test cases of your test suite have not been saved, you’ll be prompted to save them before saving the test suite.\nWhen you open an existing test case or suite, Selenium-IDE displays its Selenium commands in the Test Case Pane.\nRunning Test Cases The IDE allows many options for running your test case. You can run a test case all at once, stop and start it, run it one line at a time, run a single command you are currently developing, and you can do a batch run of an entire test suite. Execution of test cases is very flexible in the IDE.\nRun a Test Case\nClick the Run button to run the currently displayed test case.\nRun a Test Suite\nClick the Run All button to run all the test cases in the currently loaded test suite.\nStop and Start\nThe Pause button can be used to stop the test case while it is running. The icon of this button then changes to indicate the Resume button. To continue click Resume.\nStop in the Middle\nYou can set a breakpoint in the test case to cause it to stop on a particular command. This is useful for debugging your test case. To set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint.\nStart from the Middle\nYou can tell the IDE to begin running from a specific command in the middle of the test case. This also is used for debugging. To set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point.\nRun Any Single Command\nDouble-click any single command to run it by itself. This is useful when writing a single command. It lets you immediately test a command you are constructing, when you are not sure if it is correct. You can double-click it to see if it runs correctly. This is also available from the context menu.\nUsing Base URL to Run Test Cases in Different Domains The Base URL field at the top of the Selenium-IDE window is very useful for allowing test cases to be run across different domains. Suppose that a site named http://news.portal.com had an in-house beta site named http://beta.news.portal.com. Any test cases for these sites that begin with an open statement should specify a relative URL as the argument to open rather than an absolute URL (one starting with a protocol such as http: or https:). Selenium-IDE will then create an absolute URL by appending the open command’s argument onto the end of the value of Base URL. For example, the test case below would be run against http://news.portal.com/about.html:\nThis same test case with a modified Base URL setting would be run against http://beta.news.portal.com/about.html:\nSelenium Commands – “Selenese” Selenium commands, often called selenese, are the set of commands that run your tests. A sequence of these commands is a test script. Here we explain those commands in detail, and we present the many choices you have in testing your web application when using Selenium.\nSelenium provides a rich set of commands for fully testing your web-app in virtually any way you can imagine. The command set is often called selenese. These commands essentially create a testing language.\nIn selenese, one can test the existence of UI elements based on their HTML tags, test for specific content, test for broken links, input fields, selection list options, submitting forms, and table data among other things. In addition Selenium commands support testing of window size, mouse position, alerts, Ajax functionality, pop up windows, event handling, and many other web-application features. The Command Reference lists all the available commands.\nA command tells Selenium what to do. Selenium commands come in three “flavors”: Actions, Accessors, and Assertions.\n  Actions are commands that generally manipulate the state of the application. They do things like “click this link” and “select that option”. If an Action fails, or has an error, the execution of the current test is stopped.\nMany Actions can be called with the “AndWait” suffix, e.g. “clickAndWait”. This suffix tells Selenium that the action will cause the browser to make a call to the server, and that Selenium should wait for a new page to load.\n  Accessors examine the state of the application and store the results in variables, e.g. “storeTitle”. They are also used to automatically generate Assertions.\n  Assertions are like Accessors, but they verify that the state of the application conforms to what is expected. Examples include “make sure the page title is X” and “verify that this checkbox is checked”.\n  All Selenium Assertions can be used in 3 modes: “assert”, “verify”, and ” waitFor”. For example, you can “assertText”, “verifyText” and “waitForText”. When an “assert” fails, the test is aborted. When a “verify” fails, the test will continue execution, logging the failure. This allows a single “assert” to ensure that the application is on the correct page, followed by a bunch of “verify” assertions to test form field values, labels, etc.\n“waitFor” commands wait for some condition to become true (which can be useful for testing Ajax applications). They will succeed immediately if the condition is already true. However, they will fail and halt the test if the condition does not become true within the current timeout setting (see the setTimeout action below).\nScript Syntax Selenium commands are simple, they consist of the command and two parameters. For example:\n          verifyText //div//a[2] Login    The parameters are not always required; it depends on the command. In some cases both are required, in others one parameter is required, and in still others the command may take no parameters at all. Here are a couple more examples:\n          goBackAndWait     verifyTextPresent  Welcome to My Home Page   type id=phone (555) 666-7066   type id=address1 ${myVariableAddress}    The command reference describes the parameter requirements for each command.\nParameters vary, however they are typically:\n a locator for identifying a UI element within a page. a text pattern for verifying or asserting expected page content a text pattern or a Selenium variable for entering text in an input field or for selecting an option from an option list.  Locators, text patterns, Selenium variables, and the commands themselves are described in considerable detail in the section on Selenium Commands.\nSelenium scripts that will be run from Selenium-IDE will be stored in an HTML text file format. This consists of an HTML table with three columns. The first column identifies the Selenium command, the second is a target, and the final column contains a value. The second and third columns may not require values depending on the chosen Selenium command, but they should be present. Each table row represents a new Selenium command. Here is an example of a test that opens a page, asserts the page title and then verifies some content on the page:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;/download/\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;assertTitle\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;verifyText\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;//h2\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Rendered as a table in a browser this would look like the following:\n          open /download/    assertTitle  Downloads   verifyText //h2 Downloads    The Selenese HTML syntax can be used to write and run tests without requiring knowledge of a programming language. With a basic knowledge of selenese and Selenium-IDE you can quickly produce and run testcases.\nTest Suites A test suite is a collection of tests. Often one will run all the tests in a test suite as one continuous batch-job.\nWhen using Selenium-IDE, test suites also can be defined using a simple HTML file. The syntax again is simple. An HTML table defines a list of tests where each row defines the filesystem path to each test. An example tells it all.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Suite Function Tests - Priority 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Suite Of Tests\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./Login.html\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SearchValues.html\u0026#34;\u0026gt;Test Searching for Values\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SaveValues.html\u0026#34;\u0026gt;Test Save\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; A file similar to this would allow running the tests all at once, one after another, from the Selenium-IDE.\nTest suites can also be maintained when using Selenium-RC. This is done via programming and can be done a number of ways. Commonly Junit is used to maintain a test suite if one is using Selenium-RC with Java. Additionally, if C# is the chosen language, Nunit could be employed. If using an interpreted language like Python with Selenium-RC then some simple programming would be involved in setting up a test suite. Since the whole reason for using Selenium-RC is to make use of programming logic for your testing this usually isn’t a problem.\nCommonly Used Selenium Commands To conclude our introduction of Selenium, we’ll show you a few typical Selenium commands. These are probably the most commonly used commands for building tests.\nopen\nopens a page using a URL.\nclick/clickAndWait\nperforms a click operation, and optionally waits for a new page to load.\nverifyTitle/assertTitle\nverifies an expected page title.\nverifyTextPresent\nverifies expected text is somewhere on the page.\nverifyElementPresent\nverifies an expected UI element, as defined by its HTML tag, is present on the page.\nverifyText\nverifies expected text and its corresponding HTML tag are present on the page.\nverifyTable\nverifies a table’s expected contents.\nwaitForPageToLoad\npauses execution until an expected new page loads. Called automatically when clickAndWait is used.\nwaitForElementPresent\npauses execution until an expected UI element, as defined by its HTML tag, is present on the page.\nVerifying Page Elements Verifying UI elements on a web page is probably the most common feature of your automated tests. Selenese allows multiple ways of checking for UI elements. It is important that you understand these different methods because these methods define what you are actually testing.\nFor example, will you test that…\n an element is present somewhere on the page? specific text is somewhere on the page? specific text is at a specific location on the page?  For example, if you are testing a text heading, the text and its position at the top of the page are probably relevant for your test. If, however, you are testing for the existence of an image on the home page, and the web designers frequently change the specific image file along with its position on the page, then you only want to test that an image (as opposed to the specific image file) exists somewhere on the page.\nAssertion or Verification? Choosing between “assert” and “verify” comes down to convenience and management of failures. There’s very little point checking that the first paragraph on the page is the correct one if your test has already failed when checking that the browser is displaying the expected page. If you’re not on the correct page, you’ll probably want to abort your test case so that you can investigate the cause and fix the issue(s) promptly. On the other hand, you may want to check many attributes of a page without aborting the test case on the first failure as this will allow you to review all failures on the page and take the appropriate action. Effectively an “assert” will fail the test and abort the current test case, whereas a “verify” will fail the test and continue to run the test case.\nThe best use of this feature is to logically group your test commands, and start each group with an “assert” followed by one or more “verify” test commands. An example follows:\n   Command Target Value     open /download/    assertTitle  Downloads   verifyText //h2 Downloads   assertTable 1.2.1 Selenium IDE   verifyTable 1.2.2 June 3, 2008   verifyTable 1.2.3 1.0 beta 2    The above example first opens a page and then “asserts” that the correct page is loaded by comparing the title with the expected value. Only if this passes will the following command run and “verify” that the text is present in the expected location. The test case then “asserts” the first column in the second row of the first table contains the expected value, and only if this passed will the remaining cells in that row be “verified”.\nverifyTextPresent The command verifyTextPresent is used to verify specific text exists somewhere on the page. It takes a single argument–the text pattern to be verified. For example:\n   Command Target Value     verifyTextPresent Marketing Analysis     This would cause Selenium to search for, and verify, that the text string “Marketing Analysis” appears somewhere on the page currently being tested. Use verifyTextPresent when you are interested in only the text itself being present on the page. Do not use this when you also need to test where the text occurs on the page.\nverifyElementPresent Use this command when you must test for the presence of a specific UI element, rather than its content. This verification does not check the text, only the HTML tag. One common use is to check for the presence of an image.\n   Command Target Value     verifyElementPresent //div/p/img     This command verifies that an image, specified by the existence of an HTML tag, is present on the page, and that it follows a tag and a tag. The first (and only) parameter is a locator for telling the Selenese command how to find the element. Locators are explained in the next section.\nverifyElementPresent can be used to check the existence of any HTML tag within the page. You can check the existence of links, paragraphs, divisions , etc. Here are a few more examples.\n   Command Target Value     verifyElementPresent //div/p    verifyElementPresent //div/a    verifyElementPresent id=Login    verifyElementPresent link=Go to Marketing Research    verifyElementPresent //a[2]    verifyElementPresent //head/title     These examples illustrate the variety of ways a UI element may be tested. Again, locators are explained in the next section.\nverifyText Use verifyText when both the text and its UI element must be tested. verifyText must use a locator. If you choose an XPath or DOM locator, you can verify that specific text appears at a specific location on the page relative to other UI components on the page.\n   Command Target Value     verifyText //table/tr/td/div/p This is my text and it occurs right after the div inside the table.    Locating Elements For many Selenium commands, a target is required. This target identifies an element in the content of the web application, and consists of the location strategy followed by the location in the format locatorType=location. The locator type can be omitted in many cases. The various locator types are explained below with examples for each.\nLocating by Identifier This is probably the most common method of locating elements and is the catch-all default when no recognized locator type is used. With this strategy, the first element with the id attribute value matching the location will be used. If no element has a matching id attribute, then the first element with a name attribute matching the location will be used.\nFor instance, your page source could have id and name attributes as follows:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; The following locator strategies would return the elements from the HTML snippet above indicated by line number:\n identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)  Since the identifier type of locator is the default, the identifier= in the first three examples above is not necessary.\nLocating by Id This type of locator is more limited than the identifier locator type, but also more explicit. Use this when you know an element\u0026rsquo;s id attribute.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  id=loginForm (3)  Locating by Name The name locator type will locate the first element with a matching name attribute. If multiple elements have the same value for a name attribute, then you can use filters to further refine your location strategy. The default filter type is value (matching the value attribute).\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7)  Note: Unlike some types of XPath and DOM locators, the three types of locators above allow Selenium to test a UI element independent of its location on the page. So if the page structure and organization is altered, the test will still pass. You may or may not want to also test whether the page structure changes. In the case where web designers frequently alter the page, but its functionality must be regression tested, testing via id and name attributes, or really via any HTML property, becomes very important.\nLocating by XPath XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.\nOne of the main reasons for using XPath is when you don\u0026rsquo;t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.\nAbsolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.\nSince only xpath locators start with \u0026ldquo;//\u0026quot;, it is not necessary to include the xpath= label when specifying an XPath locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  xpath=/html/body/form[1] (3) - Absolute path (would break if the HTML was changed only slightly) //form[1] (3) - First form element in the HTML xpath=//form[@id='loginForm'] (3) - The form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; xpath=//form[input/@name='username'] (3) - First form element with an input child element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //input[@name='username'] (4) - First input element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //form[@id='loginForm']/input[1] (4) - First input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; //input[@name='continue'][@type='button'] (7) - Input with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;continue\u0026rsquo; and attribute named \u0026lsquo;type\u0026rsquo; and the value \u0026lsquo;button\u0026rsquo; //form[@id='loginForm']/input[4] (7) - Fourth input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and value \u0026lsquo;loginForm\u0026rsquo;  These examples cover some basics, but in order to learn more, the following references are recommended:\n W3Schools XPath Tutorial W3C XPath Recommendation  There are also a couple of very useful Firefox Add-ons that can assist in discovering the XPath of an element:\n XPath Checker XPath and can be used to test XPath results. [Firebug](https://addons.mozilla.org/en-US/firefox/addon/1843 - XPath suggestions are just one of the many powerful features of this very useful add-on.  Locating Hyperlinks by Link Text This is a simple method of locating a hyperlink in your web page by using the text of the link. If two links with the same text are present, then the first match will be used.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Are you sure you want to do this?\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;continue.html\u0026#34;\u0026gt;Continue\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;cancel.html\u0026#34;\u0026gt;Cancel\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  link=Continue (4) link=Cancel (5)  Locating by DOM The Document Object Model represents an HTML document and can be accessed using JavaScript. This location strategy takes JavaScript that evaluates to an element on the page, which can be simply the element\u0026rsquo;s location using the hierarchical dotted notation.\nSince only dom locators start with \u0026ldquo;document\u0026rdquo;, it is not necessary to include the dom= label when specifying a DOM locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  dom=document.getElementById('loginForm') (3) dom=document.forms['loginForm'] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements['username'] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7)  You can use Selenium itself as well as other sites and extensions to explore the DOM of your web application. A good reference exists on W3Schools.\nLocating by CSS CSS (Cascading Style Sheets) is a language for describing the rendering of HTML and XML documents. CSS uses Selectors for binding style properties to elements in the document. These Selectors can be used by Selenium as another locating strategy.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;required\u0026#34; name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;required passfield\u0026#34; name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  css=form#loginForm (3) css=input[name=\u0026quot;username\u0026quot;] (4) css=input.required[type=\u0026quot;text\u0026quot;] (4) css=input.passfield (5) css=#loginForm input[type=\u0026quot;button\u0026quot;] (7) css=#loginForm input:nth-child(2) (5)  For more information about CSS Selectors, the best place to go is the W3C publication. You\u0026rsquo;ll find additional references there.\nImplicit Locators You can choose to omit the locator type in the following situations:\n  Locators without an explicitly defined locator strategy will default to using the identifier locator strategy. See Locating by Identifier_.\n  Locators starting with \u0026ldquo;//\u0026rdquo; will use the XPath locator strategy. See Locating by XPath_.\n  Locators starting with \u0026ldquo;document\u0026rdquo; will use the DOM locator strategy. See Locating by DOM_\n  Matching Text Patterns Like locators, patterns are a type of parameter frequently required by Selenese commands. Examples of commands which require patterns are verifyTextPresent, verifyTitle, verifyAlert, assertConfirmation, verifyText, and verifyPrompt. And as has been mentioned above, link locators can utilize a pattern. Patterns allow you to describe, via the use of special characters, what text is expected rather than having to specify that text exactly.\nThere are three types of patterns: globbing, regular expressions, and exact.\nGlobbing Patterns Most people are familiar with globbing as it is utilized in filename expansion at a DOS or Unix/Linux command line such as ls *.c. In this case, globbing is used to display all the files ending with a .c extension that exist in the current directory. Globbing is fairly limited.\nOnly two special characters are supported in the Selenium implementation:\n* which translates to \u0026ldquo;match anything,\u0026rdquo; i.e., nothing, a single character, or many characters.\n[ ] (character class) which translates to \u0026ldquo;match any single character found inside the square brackets.\u0026rdquo; A dash (hyphen) can be used as a shorthand to specify a range of characters (which are contiguous in the ASCII character set). A few examples will make the functionality of a character class clear:\n[aeiou] matches any lowercase vowel\n[0-9] matches any digit\n[a-zA-Z0-9] matches any alphanumeric character\nIn most other contexts, globbing includes a third special character, the ?. However, Selenium globbing patterns only support the asterisk and character class.\nTo specify a globbing pattern parameter for a Selenese command, you can prefix the pattern with a glob: label. However, because globbing patterns are the default, you can also omit the label and specify just the pattern itself.\nBelow is an example of two commands that use globbing patterns. The actual link text on the page being tested was \u0026ldquo;Film/Television Department\u0026rdquo;; by using a pattern rather than the exact text, the click command will work even if the link text is changed to \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo; or \u0026ldquo;Film and Television Department\u0026rdquo;. The glob pattern\u0026rsquo;s asterisk will match \u0026ldquo;anything or nothing\u0026rdquo; between the word \u0026ldquo;Film\u0026rdquo; and the word \u0026ldquo;Television\u0026rdquo;.\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle glob:*Film*Television*     The actual title of the page reached by clicking on the link was \u0026ldquo;De Anza Film And Television Department - Menu\u0026rdquo;. By using a pattern rather than the exact text, the verifyTitle will pass as long as the two words \u0026ldquo;Film\u0026rdquo; and \u0026ldquo;Television\u0026rdquo; appear (in that order) anywhere in the page\u0026rsquo;s title. For example, if the page\u0026rsquo;s owner should shorten the title to just \u0026ldquo;Film \u0026amp; Television Department,\u0026rdquo; the test would still pass. Using a pattern for both a link and a simple test that the link worked (such as the verifyTitle above does) can greatly reduce the maintenance for such test cases.\nRegular Expression Patterns Regular expression patterns are the most powerful of the three types of patterns that Selenese supports. Regular expressions are also supported by most high-level programming languages, many text editors, and a host of tools, including the Linux/Unix command-line utilities grep, sed, and awk. In Selenese, regular expression patterns allow a user to perform many tasks that would be very difficult otherwise. For example, suppose your test needed to ensure that a particular table cell contained nothing but a number. regexp: [0-9]+ is a simple pattern that will match a decimal number of any length.\nWhereas Selenese globbing patterns support only the * and [ ] (character class) features, Selenese regular expression patterns offer the same wide array of special characters that exist in JavaScript. Below are a subset of those special characters:\n   PATTERN MATCH     . any single character   [ ] character class: any single character that appears inside the brackets   * quantifier: 0 or more of the preceding character (or group)   + quantifier: 1 or more of the preceding character (or group)   ? quantifier: 0 or 1 of the preceding character (or group)   {1,5} quantifier: 1 through 5 of the preceding character (or group)   | alternation: the character/group on the left or the character/group on the right   ( ) grouping: often used with alternation and/or quantifier    Regular expression patterns in Selenese need to be prefixed with either regexp: or regexpi:. The former is case-sensitive; the latter is case-insensitive.\nA few examples will help clarify how regular expression patterns can be used with Selenese commands. The first one uses what is probably the most commonly used regular expression pattern\u0026ndash;.* (\u0026ldquo;dot star\u0026rdquo;). This two-character sequence can be translated as \u0026ldquo;0 or more occurrences of any character\u0026rdquo; or more simply, \u0026ldquo;anything or nothing.\u0026rdquo; It is the equivalent of the one-character globbing pattern * (a single asterisk).\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle regexp:.*Film.*Television.*     The example above is functionally equivalent to the earlier example that used globbing patterns for this same test. The only differences are the prefix (regexp: instead of glob:) and the \u0026ldquo;anything or nothing\u0026rdquo; pattern (.* instead of just *).\nThe more complex example below tests that the Yahoo! Weather page for Anchorage, Alaska contains info on the sunrise time:\n   Command Target Value     open http://weather.yahoo.com/forecast/USAK0012.html    verifyTextPresent regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m     Let\u0026rsquo;s examine the regular expression above one part at a time:\n         Sunrise: * The string Sunrise: followed by 0 or more spaces   [0-9]{1,2} 1 or 2 digits (for the hour of the day)   : The character : (no special characters involved)   [0-9]{2} 2 digits (for the minutes) followed by a space   [ap]m \u0026ldquo;a\u0026rdquo; or \u0026ldquo;p\u0026rdquo; followed by \u0026ldquo;m\u0026rdquo; (am or pm)    Exact Patterns The exact type of Selenium pattern is of marginal usefulness. It uses no special characters at all. So, if you needed to look for an actual asterisk character (which is special for both globbing and regular expression patterns), the exact pattern would be one way to do that. For example, if you wanted to select an item labeled \u0026ldquo;Real *\u0026rdquo; from a dropdown, the following code might work or it might not. The asterisk in the glob:Real * pattern will match anything or nothing. So, if there was an earlier select option labeled \u0026ldquo;Real Numbers,\u0026rdquo; it would be the option selected rather than the \u0026ldquo;Real *\u0026rdquo; option.\n   Command Target Value     select //select glob:Real *    In order to ensure that the \u0026ldquo;Real *\u0026rdquo; item would be selected, the exact: prefix could be used to create an exact pattern as shown below:\n   Command Target Value     select //select exact:Real *    But the same effect could be achieved via escaping the asterisk in a regular expression pattern:\n   Command Target Value     select //select regexp:Real \\*    It\u0026rsquo;s rather unlikely that most testers will ever need to look for an asterisk or a set of square brackets with characters inside them (the character class for globbing patterns). Thus, globbing patterns and regular expression patterns are sufficient for the vast majority of us.\nThe \u0026ldquo;AndWait\u0026rdquo; Commands The difference between a command and its AndWait alternative is that the regular command (e.g. click) will do the action and continue with the following command as fast as it can, while the AndWait alternative (e.g. clickAndWait) tells Selenium to wait for the page to load after the action has been done.\nThe AndWait alternative is always used when the action causes the browser to navigate to another page or reload the present one.\nBe aware, if you use an AndWait command for an action that does not trigger a navigation/refresh, your test will fail. This happens because Selenium will reach the AndWait\u0026lsquo;s timeout without seeing any navigation or refresh being made, causing Selenium to raise a timeout exception.\nThe waitFor Commands in AJAX applications In AJAX driven web applications, data is retrieved from server without refreshing the page. Using andWait commands will not work as the page is not actually refreshed. Pausing the test execution for a certain period of time is also not a good approach as web element might appear later or earlier than the stipulated period depending on the system\u0026rsquo;s responsiveness, load or other uncontrolled factors of the moment, leading to test failures. The best approach would be to wait for the needed element in a dynamic period and then continue the execution as soon as the element is found.\nThis is done using waitFor commands, as waitForElementPresent or waitForVisible, which wait dynamically, checking for the desired condition every second and continuing to the next command in the script as soon as the condition is met.\nSequence of Evaluation and Flow Control When a script runs, it simply runs in sequence, one command after another.\nSelenese, by itself, does not support condition statements (if-else, etc.) or iteration (for, while, etc.). Many useful tests can be conducted without flow control. However, for a functional test of dynamic content, possibly involving multiple pages, programming logic is often needed.\nWhen flow control is needed, there are three options:\na) Run the script using Selenium-RC and a client library such as Java or PHP to utilize the programming language\u0026rsquo;s flow control features. b) Run a small JavaScript snippet from within the script using the storeEval command. c) Install the goto_sel_ide.js extension.\nMost testers will export the test script into a programming language file that uses the Selenium-RC API (see the Selenium-IDE chapter). However, some organizations prefer to run their scripts from Selenium-IDE whenever possible (for instance, when they have many junior-level people running tests for them, or when programming skills are lacking). If this is your case, consider a JavaScript snippet or the goto_sel_ide.js extension.\nStore Commands and Selenium Variables You can use Selenium variables to store constants at the beginning of a script. Also, when combined with a data-driven test design (discussed in a later section), Selenium variables can be used to store values passed to your test program from the command-line, from another program, or from a file.\nThe plain store command is the most basic of the many store commands and can be used to simply store a constant value in a Selenium variable. It takes two parameters, the text value to be stored and a Selenium variable. Use the standard variable naming conventions of only alphanumeric characters when choosing a name for your variable.\n   Command Target Value     store paul@mysite.org     Later in your script, you\u0026rsquo;ll want to use the stored value of your variable. To access the value of a variable, enclose the variable in curly brackets ({}) and precede it with a dollar sign like this.\n   Command Target Value     verifyText //div/p \\${userName}    A common use of variables is for storing input for an input field.\n   Command Target Value     type id=login \\${userName}    Selenium variables can be used in either the first or second parameter and are interpreted by Selenium prior to any other operations performed by the command. A Selenium variable may also be used within a locator expression.\nAn equivalent store command exists for each verify and assert command. Here are a couple more commonly used store commands.\nstoreElementPresent This corresponds to verifyElementPresent. It simply stores a boolean value\u0026ndash;\u0026ldquo;true\u0026rdquo; or \u0026ldquo;false\u0026rdquo;\u0026ndash;depending on whether the UI element is found.\nstoreText StoreText corresponds to verifyText. It uses a locator to identify specific page text. The text, if found, is stored in the variable. StoreText can be used to extract text from the page being tested.\nstoreEval This command takes a script as its first parameter. Embedding JavaScript within Selenese is covered in the next section. StoreEval allows the test to store the result of running the script in a variable.\nJavaScript and Selenese Parameters JavaScript can be used with two types of Selenese parameters: script and non-script (usually expressions). In most cases, you\u0026rsquo;ll want to access and/or manipulate a test case variable inside the JavaScript snippet used as a Selenese parameter. All variables created in your test case are stored in a JavaScript associative array. An associative array has string indexes rather than sequential numeric indexes. The associative array containing your test case\u0026rsquo;s variables is named storedVars. Whenever you wish to access or manipulate a variable within a JavaScript snippet, you must refer to it as storedVars[\u0026lsquo;yourVariableName\u0026rsquo;].\nJavaScript Usage with Script Parameters Several Selenese commands specify a script parameter including assertEval, verifyEval, storeEval, and waitForEval. These parameters require no special syntax. A Selenium-IDE user would simply place a snippet of JavaScript code into the appropriate field, normally the Target field (because a script parameter is normally the first or only parameter).\nThe example below illustrates how a JavaScript snippet can be used to perform a simple numerical calculation:\n   Command Target Value     store 10 hits   storeXpathCount //blockquote blockquotes   storeEval storedVars[\u0026lsquo;hits\u0026rsquo;].storedVars[\u0026lsquo;blockquotes\u0026rsquo;] paragraphs    This next example illustrates how a JavaScript snippet can include calls to methods, in this case the JavaScript String object\u0026rsquo;s toUpperCase method and toLowerCase method.\n   Command Target Value     store Edith Wharton name   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() uc   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() lc    JavaScript Usage with Non-Script Parameters JavaScript can also be used to help generate values for parameters, even when the parameter is not specified to be of type script.\nHowever, in this case, special syntax is required\u0026ndash;the entire parameter value must be prefixed by javascript{ with a trailing }, which encloses the JavaScript snippet, as in javascript{*yourCodeHere*}. Below is an example in which the type command\u0026rsquo;s second parameter value is generated via JavaScript code using this special syntax:\n   Command Target Value     store league of nations searchString   type q javascript{storedVars[\u0026lsquo;searchString\u0026rsquo;].toUpperCase()}    echo - The Selenese Print Command Selenese has a simple command that allows you to print text to your test\u0026rsquo;s output. This is useful for providing informational progress notes in your test which display on the console as your test is running. These notes also can be used to provide context within your test result reports, which can be useful for finding where a defect exists on a page in the event your test finds a problem. Finally, echo statements can be used to print the contents of Selenium variables.\n   Command Target Value     echo Testing page footer now.    echo Username is \\${userName}     Alerts, Popups, and Multiple Windows Suppose that you are testing a page that looks like this.\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function output(resultText){ document.getElementById(\u0026#39;output\u0026#39;).childNodes[0].nodeValue=resultText; } function show_confirm(){ var confirmation=confirm(\u0026#34;Chose an option.\u0026#34;); if (confirmation==true){ output(\u0026#34;Confirmed.\u0026#34;); } else{ output(\u0026#34;Rejected!\u0026#34;); } } function show_alert(){ alert(\u0026#34;I\u0026#39;m blocking!\u0026#34;); output(\u0026#34;Alert is gone.\u0026#34;); } function show_prompt(){ var response = prompt(\u0026#34;What\u0026#39;s the best web QA tool?\u0026#34;,\u0026#34;Selenium\u0026#34;); output(response); } function open_window(windowName){ window.open(\u0026#34;newWindow.html\u0026#34;,windowName); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnConfirm\u0026#34; onclick=\u0026#34;show_confirm()\u0026#34; value=\u0026#34;Show confirm box\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnAlert\u0026#34; onclick=\u0026#34;show_alert()\u0026#34; value=\u0026#34;Show alert\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPrompt\u0026#34; onclick=\u0026#34;show_prompt()\u0026#34; value=\u0026#34;Show prompt\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;newWindow.html\u0026#34; id=\u0026#34;lnkNewWindow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;New Window Link\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamelessWindow\u0026#34; onclick=\u0026#34;open_window()\u0026#34; value=\u0026#34;Open Nameless Window\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamedWindow\u0026#34; onclick=\u0026#34;open_window(\u0026#39;Mike\u0026#39;)\u0026#34; value=\u0026#34;Open Named Window\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span id=\u0026#34;output\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The user must respond to alert/confirm boxes, as well as moving focus to newly opened popup windows. Fortunately, Selenium can cover JavaScript pop-ups.\nBut before we begin covering alerts/confirms/prompts in individual detail, it is helpful to understand the commonality between them. Alerts, confirmation boxes and prompts all have variations of the following\n   Command Description     assertFoo(pattern) throws error if pattern doesn’t match the text of the pop-up   assertFooPresent throws error if pop-up is not available   assertFooNotPresent throws error if any pop-up is present   storeFoo(variable) stores the text of the pop-up in a variable   storeFooPresent(variable) stores the text of the pop-up in a variable and returns true or false    When running under Selenium, JavaScript pop-ups will not appear. This is because the function calls are actually being overridden at runtime by Selenium\u0026rsquo;s own JavaScript. However, just because you cannot see the pop-up doesn\u0026rsquo;t mean you don\u0026rsquo;t have to deal with it. To handle a pop-up, you must call its assertFoo(pattern) function. If you fail to assert the presence of a pop-up your next command will be blocked and you will get an error similar to the following [error] Error: There was an unexpected Confirmation! [Chose an option.]\nAlerts Let\u0026rsquo;s start with alerts because they are the simplest pop-up to handle. To begin, open the HTML sample above in a browser and click on the \u0026ldquo;Show alert\u0026rdquo; button. You\u0026rsquo;ll notice that after you close the alert the text \u0026ldquo;Alert is gone.\u0026rdquo; is displayed on the page. Now run through the same steps with Selenium IDE recording, and verify the text is added after you close the alert. Your test will look something like this:\n   Command Target Value     open /    click btnAlert    assertAlert I’m blocking!    verifyTextPresent Alert is gone.     You may be thinking \u0026ldquo;That\u0026rsquo;s odd, I never tried to assert that alert.\u0026rdquo; But this is Selenium-IDE handling and closing the alert for you. If you remove that step and replay the test you will get the following error [error] Error: There was an unexpected Alert! [I'm blocking!]. You must include an assertion of the alert to acknowledge its presence.\nIf you just want to assert that an alert is present but either don\u0026rsquo;t know or don\u0026rsquo;t care what text it contains, you can use assertAlertPresent. This will return true or false, with false halting the test.\nConfirmations Confirmations behave in much the same way as alerts, with assertConfirmation and assertConfirmationPresent offering the same characteristics as their alert counterparts. However, by default Selenium will select OK when a confirmation pops up. Try recording clicking on the \u0026ldquo;Show confirm box\u0026rdquo; button in the sample page, but click on the \u0026ldquo;Cancel\u0026rdquo; button in the popup, then assert the output text. Your test may look something like this:\n   Command Target Value     open /    click btnConfirm    chooseCancelOnNextConfirmation     assertConfirmation Choose an option.    verifyTextPresent Rejected     The chooseCancelOnNextConfirmation function tells Selenium that all following confirmation should return false. It can be reset by calling chooseOkOnNextConfirmation.\nYou may notice that you cannot replay this test, because Selenium complains that there is an unhandled confirmation. This is because the order of events Selenium-IDE records causes the click and chooseCancelOnNextConfirmation to be put in the wrong order (it makes sense if you think about it, Selenium can\u0026rsquo;t know that you\u0026rsquo;re cancelling before you open a confirmation) Simply switch these two commands and your test will run fine.\nPrompts Prompts behave in much the same way as alerts, with assertPrompt and assertPromptPresent offering the same characteristics as their alert counterparts. By default, Selenium will wait for you to input data when the prompt pops up. Try recording clicking on the \u0026ldquo;Show prompt\u0026rdquo; button in the sample page and enter \u0026ldquo;Selenium\u0026rdquo; into the prompt. Your test may look something like this:\n   Command Target Value     open /    answerOnNextPrompt Selenium!    click id=btnPrompt    assertPrompt What’s the best web QA tool?    verifyTextPresent Selenium!     If you choose cancel on the prompt, you may notice that answerOnNextPrompt will simply show a target of blank. Selenium treats cancel and a blank entry on the prompt basically as the same thing.\nDebugging Debugging means finding and fixing errors in your test case. This is a normal part of test case development.\nWe won\u0026rsquo;t teach debugging here as most new users to Selenium will already have some basic experience with debugging. If this is new to you, we recommend you ask one of the developers in your organization.\nBreakpoints and Startpoints The Sel-IDE supports the setting of breakpoints and the ability to start and stop the running of a test case, from any point within the test case. That is, one can run up to a specific command in the middle of the test case and inspect how the test case behaves at that point. To do this, set a breakpoint on the command just before the one to be examined.\nTo set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint. Then click the Run button to run your test case from the beginning up to the breakpoint.\nIt is also sometimes useful to run a test case from somewhere in the middle to the end of the test case or up to a breakpoint that follows the starting point.\nFor example, suppose your test case first logs into the website and then performs a series of tests and you are trying to debug one of those tests.\nHowever, you only need to login once, but you need to keep rerunning your tests as you are developing them. You can login once, then run your test case from a startpoint placed after the login portion of your test case. That will prevent you from having to manually logout each time you rerun your test case.\nTo set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point. Then click the Run button to execute the test case beginning at that startpoint.\nStepping Through a Testcase To execute a test case one command at a time (\u0026ldquo;step through\u0026rdquo; it), follow these steps:\n  Start the test case running with the Run button from the toolbar.\n  Immediately pause the executing test case with the Pause button.\n  Repeatedly select the Step button.\n  Find Button The Find button is used to see which UI element on the currently displayed webpage (in the browser) is used in the currently selected Selenium command.\nThis is useful when building a locator for a command\u0026rsquo;s first parameter (see the section on :ref:locators \u0026lt;locators-section\u0026gt; in the Selenium Commands chapter). It can be used with any command that identifies a UI element on a webpage, i.e. click, clickAndWait, type, and certain assert and verify commands, among others.\nFrom Table view, select any command that has a locator parameter. Click the Find button.\nNow look on the webpage: There should be a bright green rectangle enclosing the element specified by the locator parameter.\nPage Source for Debugging Often, when debugging a test case, you simply must look at the page source (the HTML for the webpage you\u0026rsquo;re trying to test) to determine a problem. Firefox makes this easy. Simply right-click the webpage and select \u0026lsquo;View-\u0026gt;Page Source.\nThe HTML opens in a separate window. Use its Search feature (Edit=\u0026gt;Find) to search for a keyword to find the HTML for the UI element you\u0026rsquo;re trying to test.\nAlternatively, select just that portion of the webpage for which you want to see the source. Then right-click the webpage and select View Selection Source. In this case, the separate HTML window will contain just a small amount of source, with highlighting on the portion representing your selection.\nLocator Assistance Whenever Selenium-IDE records a locator-type argument, it stores additional information which allows the user to view other possible locator-type arguments that could be used instead. This feature can be very useful for learning more about locators, and is often needed to help one build a different type of locator than the type that was recorded.\nThis locator assistance is presented on the Selenium-IDE window as a drop-down list accessible at the right end of the Target field (only when the Target field contains a recorded locator-type argument).\nBelow is a snapshot showing the contents of this drop-down for one command. Note that the first column of the drop-down provides alternative locators, whereas the second column indicates the type of each alternative.\nWriting a Test Suite A test suite is a collection of test cases which is displayed in the leftmost pane in the IDE.\nThe test suite pane can be manually opened or closed via selecting a small dot halfway down the right edge of the pane (which is the left edge of the entire Selenium-IDE window if the pane is closed).\nThe test suite pane will be automatically opened when an existing test suite is opened or when the user selects the New Test Case item from the File menu. In the latter case, the new test case will appear immediately below the previous test case.\nSelenium-IDE also supports loading pre-existing test cases by using the File -\u0026gt; Add Test Case menu option. This allows you to add existing test cases to a new test suite.\nA test suite file is an HTML file containing a one-column table. Each cell of each row in the section contains a link to a test case. The example below is of a test suite containing four test cases:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Sample Selenium Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Test Cases for De Anza A-Z Directory Links\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./a.html\u0026#34;\u0026gt;A Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./b.html\u0026#34;\u0026gt;B Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./c.html\u0026#34;\u0026gt;C Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./d.html\u0026#34;\u0026gt;D Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Note: Test case files should not have to be co-located with the test suite file that invokes them. And on Mac OS and Linux systems, that is indeed the case. However, at the time of this writing, a bug prevents Windows users from being able to place the test cases elsewhere than with the test suite that invokes them.\nUser Extensions User extensions are JavaScript files that allow one to create his or her own customizations and features to add additional functionality. Often this is in the form of customized commands although this extensibility is not limited to additional commands.\nThere are a number of useful extensions_ created by users.\nIMPORTANT: THIS SECTION IS OUT OF DATE\u0026ndash;WE WILL BE REVISING THIS SOON.\n _extensions: http://wiki.openqa.org/display/SEL/Contributed+User-Extensions  .. _goto_sel_ide.js extension:\nPerhaps the most popular of all Selenium-IDE extensions is one which provides flow control in the form of while loops and primitive conditionals. This extension is the goto_sel_ide.js_. For an example of how to use the functionality provided by this extension, look at the page_ created by its author.\nTo install this extension, put the pathname to its location on your computer in the Selenium Core extensions field of Selenium-IDE\u0026rsquo;s Options=\u0026gt;Options=\u0026gt;General tab.\nAfter selecting the OK button, you must close and reopen Selenium-IDE in order for the extensions file to be read. Any change you make to an extension will also require you to close and reopen Selenium-IDE.\nInformation on writing your own extensions can be found near the bottom of the Selenium Reference_ document.\nSometimes it can prove very useful to debug step by step Selenium IDE and your User Extension. The only debugger that appears able to debug XUL/Chrome based extensions is Venkman which is supported in Firefox until version 32 included. The step by step debug has been verified to work with Firefox 32 and Selenium IDE 2.9.0.\nFormat Format, under the Options menu, allows you to select a language for saving and displaying the test case. The default is HTML.\nIf you will be using Selenium-RC to run your test cases, this feature is used to translate your test case into a programming language. Select the language, e.g. Java, PHP, you will be using with Selenium-RC for developing your test programs. Then simply save the test case using File=\u0026gt;Export Test Case As. Your test case will be translated into a series of functions in the language you choose. Essentially, program code supporting your test is generated for you by Selenium-IDE.\nAlso, note that if the generated code does not suit your needs, you can alter it by editing a configuration file which defines the generation process.\nEach supported language has configuration settings which are editable. This is under the Options=\u0026gt;Options=\u0026gt;Formats tab.\nExecuting Selenium-IDE Tests on Different Browsers While Selenium-IDE can only run tests against Firefox, tests developed with Selenium-IDE can be run against other browsers, using a simple command-line interface that invokes the Selenium-RC server. This topic is covered in the :ref:Run Selenese tests \u0026lt;html-suite\u0026gt; section on Selenium-RC chapter. The -htmlSuite command-line option is the particular feature of interest.\nTroubleshooting Below is a list of image/explanation pairs which describe frequent sources of problems with Selenium-IDE:\nTable view is not available with this format.\nThis message can be occasionally displayed in the Table tab when Selenium IDE is launched. The workaround is to close and reopen Selenium IDE. See issue 1008. for more information. If you are able to reproduce this reliably then please provide details so that we can work on a fix.\n error loading test case: no command found\nYou\u0026rsquo;ve used File=\u0026gt;Open to try to open a test suite file. Use File=\u0026gt;Open Test Suite instead.\nAn enhancement request has been raised to improve this error message. See issue 1010.\n This type of error may indicate a timing problem, i.e., the element specified by a locator in your command wasn\u0026rsquo;t fully loaded when the command was executed. Try putting a pause 5000 before the command to determine whether the problem is indeed related to timing. If so, investigate using an appropriate waitFor* or *AndWait command before the failing command.\n Whenever your attempt to use variable substitution fails as is the case for the open command above, it indicates that you haven\u0026rsquo;t actually created the variable whose value you\u0026rsquo;re trying to access. This is sometimes due to putting the variable in the Value field when it should be in the Target field or vice versa. In the example above, the two parameters for the store command have been erroneously placed in the reverse order of what is required. For any Selenese command, the first required parameter must go in the Target field, and the second required parameter (if one exists) must go in the Value field.\n error loading test case: [Exception\u0026hellip; \u0026ldquo;Component returned failure code: 0x80520012 (NS_ERROR_FILE_NOT_FOUND) [nsIFileInputStream.init]\u0026rdquo; nresult: \u0026ldquo;0x80520012 (NS_ERROR_FILE_NOT_FOUND)\u0026rdquo; location: \u0026ldquo;JS frame :: chrome://selenium-ide/content/file-utils.js :: anonymous :: line 48\u0026rdquo; data: no]\nOne of the test cases in your test suite cannot be found. Make sure that the test case is indeed located where the test suite indicates it is located. Also, make sure that your actual test case files have the .html extension both in their filenames, and in the test suite file where they are referenced.\nAn enhancement request has been raised to improve this error message. See issue 1011.\n Your extension file\u0026rsquo;s contents have not been read by Selenium-IDE. Be sure you have specified the proper pathname to the extensions file via Options=\u0026gt;Options=\u0026gt;General in the Selenium Core extensions field. Also, Selenium-IDE must be restarted after any change to either an extensions file or to the contents of the Selenium Core extensions field.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/getting_started_with_webdriver/",
	"title": "WebDriver 入门",
	"tags": [],
	"description": "",
	"content": "WebDriver 入门 Selenium 通过使用 WebDriver 支持市场上所有主流浏览器的自动化。 Webdriver 是一个 API 和协议，它定义了一个语言中立的接口，用于控制 web 浏览器的行为。 每个浏览器都有一个特定的 WebDriver 实现，称为驱动程序。 驱动程序是负责委派给浏览器的组件，并处理与 Selenium 和浏览器之间的通信。\n这种分离是有意识地努力让浏览器供应商为其浏览器的实现负责的一部分。 Selenium 在可能的情况下使用这些第三方驱动程序， 但是在这些驱动程序不存在的情况下，它也提供了由项目自己维护的驱动程序。\nSelenium 框架通过一个面向用户的界面将所有这些部分连接在一起， 该界面允许透明地使用不同的浏览器后端， 从而实现跨浏览器和跨平台自动化。\n有关驱动程序的更多详细信息，请参阅 驱动特性.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/grid/when_to_use_grid/",
	"title": "什么时候应该使用服务网格",
	"tags": [],
	"description": "",
	"content": "通常来说，有2个原因你需要使用服务网格。\n 在多种浏览器，多种版本的浏览器，不同操作系统里的浏览器里执行你的测试 缩短完成测试的时间  服务网格通过使用多台终端机器来并行执行测试，以达到加速测试执行的目的。 比如的测试套件里包含100个测试，你的服务网格支持4种不同的终端（虚拟机或者独立的物理设备） 来执行这些测试，相比你只有一台终端来执行，你的测试套件只需要4分之1的时间。 在一些大型测试套件，或者一些长时间执行的测试比如执行大量的数据校验，这样做会节约大量的时间。 一些测试会需要几个小时。另一个改善的动力来自缩短这种耗时的测试的是为了开发人员从提交代码到获得测试结果的期间。软件开发团队实践敏捷开发时期望尽可能早的得到测试反馈，而不是一晚一晚的等测试通过。\n服务网格也会被用来支持在不同的运行环境的测试，比如，在同一实践针对不同浏览器的测试。 比如，一个由虚拟机组成的服务网格，每一个终端机可以支持一个不同的应用程序需要支持的浏览器。 比如终端1有IE8，终端2有IE9，终端3有最新的Chrmoe，终端4有最新的Firefox。当所有的测试套件都执行了， Selenium服务网格会接受每个测试浏览器组合的要求，然后安排每个测试被执行在所要求的浏览器上。\n另外，一个服务网格可以包含同样的浏览器，类型，版本。比如，你可以有一个包含4台终端，没个终端包含3个 Firefox70的实例的网格，提供了一个服务器集群提供可用的Firefox实例。当测试套件被执行的时候，每个被提交进服务网格的测试会被分发到可用的Firefox实例。在这个情况下，同一时间可以有12个测试被并行的执行， 显著的缩短的整个测试完成的时间。\n服务网格是弹性的。这2个例子可以被组合来创建多种实例的浏览器和版本。通过配置，可以提供并行执行以加速测试，或者支持多种浏览器版本的模拟2中能力。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/introduction/about_this_documentation/",
	"title": "关于这个文档",
	"tags": [],
	"description": "",
	"content": "这些文档，就像代码本身一样，100% 由 Selenium 社区中的志愿者维护。 许多人自成立以来一直在使用它，但更多人只是在短时间内使用它，并且已经花时间帮助改善新用户的入门体验。\n如果文档有问题，我们想知道！ 沟通问题的最佳方式是访问 https://github.com/seleniumhq/seleniumhq.github.io/issues 并搜索问题是否已经提交。 如果没有，请随意打开一个！\n社区的许多成员经常光顾 irc.freenode.net 的 #selenium IRC 频道。 请随时来访并提出问题，如果您得到了您认为在这些文档中可能有用的帮助，请务必添加您的贡献！ 我们可以更新这些文档，但当我们从普通提交者之外获得贡献时，对每个人来说都容易得多。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "在 AUT* 中执行",
	"tags": [],
	"description": "",
	"content": "使用 sendKeys 方法设置元素的文本，如下所示:\nJava Python C# Ruby JavaScript Kotlin String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(By.NAME, \u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);   val name = \u0026#34;Charles\u0026#34; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name)     一些 web 应用程序使用 JavaScript 库来实现拖放功能。 下面是一个简单的例子，拖动一个元素到另一个元素:\nJava Python C# Ruby JavaScript Kotlin WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element(By.ID, \u0026#34;source\u0026#34;) target = driver.find_element(By.ID, \u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();   val source = driver.findElement(By.id(\u0026#34;source\u0026#34;)) val target = driver.findElement(By.id(\u0026#34;target\u0026#34;)) Actions(driver).dragAndDrop(source, target).build().perform()     单击元素 你可以使用 click 方法单击一个元素:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element(By.CSS_SELECTOR, \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click()     *AUT: 待测试应用\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/mock_external_services/",
	"title": "模拟外部服务",
	"tags": [],
	"description": "",
	"content": "消除对外部服务的依赖性将大大提高测试的速度和稳定性.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/waits/",
	"title": "等待",
	"tags": [],
	"description": "",
	"content": "WebDriver通常可以说有一个阻塞API。因为它是一个指示浏览器做什么的进程外库，而且web平台本质上是异步的，所以WebDriver不跟踪DOM的实时活动状态。这伴随着一些我们将在这里讨论的挑战。\n根据经验，大多数由于使用Selenium和WebDriver而产生的间歇性问题都与浏览器和用户指令之间的 竞争条件 有关。例如，用户指示浏览器导航到一个页面，然后在试图查找元素时得到一个 no such element 的错误。\n考虑下面的文档：\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; 这个 WebDriver的说明可能看起来很简单:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Get and store Paragraph Text search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     这里的问题是WebDriver中使用的默认页面加载策略页面加载策略听从document.readyState在返回调用 navigate 之前将状态改为\u0026quot;complete\u0026quot; 。因为p元素是在文档完成加载之后添加的，所以这个WebDriver脚本可能是间歇性的。它“可能”间歇性是因为无法做出保证说异步触发这些元素或事件不需要显式等待或阻塞这些事件。\n幸运的是，WebElement接口上可用的正常指令集——例如 WebElement.click 和 WebElement.sendKeys—是保证同步的，因为直到命令在浏览器中被完成之前函数调用是不会返回的(或者回调是不会在回调形式的语言中触发的)。高级用户交互APIs,键盘和鼠标是例外的，因为它们被明确地设计为“按我说的做”的异步命令。\n等待是在继续下一步之前会执行一个自动化任务来消耗一定的时间。\n为了克服浏览器和WebDriver脚本之间的竞争问题，大多数Selenium客户都附带了一个 wait 包。在使用等待时，您使用的是通常所说的显式等待。\n显式等待 显示等待 是Selenium客户可以使用的命令式过程语言。它们允许您的代码暂停程序执行，或冻结线程，直到满足通过的 条件 。这个条件会以一定的频率一直被调用，直到等待超时。这意味着只要条件返回一个假值，它就会一直尝试和等待\n由于显式等待允许您等待条件的发生，所以它们非常适合在浏览器及其DOM和WebDriver脚本之间同步状态。\n为了弥补我们之前的错误指令集，我们可以使用等待来让 findElement 调用等待直到脚本中动态添加的元素被添加到DOM中:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Initialize and wait till element(link) became clickable - timeout in 10 seconds WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Print the first result System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Initialize and wait till element(link) became clickable - timeout in 10 seconds val firstResult = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Print the first result println(firstResult.text)     我们将 条件 作为函数引用传递， 等待 将会重复运行直到其返回值为true。“truthful”返回值是在当前语言中计算为boolean true的任何值，例如字符串、数字、boolean、对象(包括 WebElement )或填充(非空)的序列或列表。这意味着 空列表 的计算结果为false。当条件为true且阻塞等待终止时，条件的返回值将成为等待的返回值。\n有了这些知识，并且因为等待实用程序默认情况下会忽略 no such element 的错误，所以我们可以重构我们的指令使其更简洁:\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3)) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); }   driver.get \u0026#39;file:///race_condition.html\u0026#39; wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) ele = wait.until { driver.find_element(css: \u0026#39;p\u0026#39;)} foo = ele.text assert_match foo, \u0026#39;Hello from JavaScript\u0026#39;   let ele = await driver.wait(until.elementLocated(By.css(\u0026#39;p\u0026#39;)),10000); let foo = await ele.getText(); assert(foo == \u0026#34;Hello from JavaScript\u0026#34;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val ele = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026#34;p\u0026#34;))) assert(ele.text == \u0026#34;Hello from JavaScript!\u0026#34;)     在这个示例中，我们传递了一个匿名函数(但是我们也可以像前面那样显式地定义它，以便重用它)。传递给我们条件的第一个，也是唯一的一个参数始终是对驱动程序对象 WebDriver 的引用(在本例中称为d)。在多线程环境中，您应该小心操作传入条件的驱动程序引用，而不是外部范围中对驱动程序的引用。\n因为等待将会吞没在没有找到元素时引发的 no such element 的错误，这个条件会一直重试直到找到元素为止。然后它将获取一个 WebElement 的返回值，并将其传递回我们的脚本。\n如果条件失败，例如从未得到条件为真实的返回值，等待将会抛出/引发一个叫 timeout error 的错误/异常。\n选项 等待条件可以根据您的需要进行定制。有时候是没有必要等待缺省超时的全部范围，因为没有达到成功条件的代价可能很高。\n等待允许你传入一个参数来覆盖超时:\nJava Python C# Ruby JavaScript Kotlin new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) wait.until { driver.find_element(:id, \u0026#39;message\u0026#39;).displayed? }   await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000);   WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     预期的条件 由于必须同步DOM和指令是相当常见的情况，所以大多数客户端还附带一组预定义的 预期条件 。顾名思义，它们是为频繁等待操作预定义的条件。\n不同的语言绑定提供的条件各不相同，但这只是其中一些:\n alert is present element exists element is visible title contains title is element staleness visible text  您可以参考每个客户端绑定的API文档，以找到期望条件的详尽列表:\n Java\u0026rsquo;s org.openqa.selenium.support.ui.ExpectedConditions class Python\u0026rsquo;s selenium.webdriver.support.expected_conditions class .NET\u0026rsquo;s OpenQA.Selenium.Support.UI.ExpectedConditions type  隐式等待 还有第二种区别于显示等待 类型的 隐式等待 。通过隐式等待，WebDriver在试图查找_任何_元素时在一定时间内轮询DOM。当网页上的某些元素不是立即可用并且需要一些时间来加载时是很有用的。\n默认情况下隐式等待元素出现是禁用的，它需要在单个会话的基础上手动启用。将显式等待和隐式等待混合在一起会导致意想不到的结果，就是说即使元素可用或条件为真也要等待睡眠的最长时间。\n警告: 不要混合使用隐式和显式等待。这样做会导致不可预测的等待时间。例如，将隐式等待设置为10秒，将显式等待设置为15秒，可能会导致在20秒后发生超时。\n隐式等待是告诉WebDriver如果在查找一个或多个不是立即可用的元素时轮询DOM一段时间。默认设置为0，表示禁用。一旦设置好，隐式等待就被设置为会话的生命周期。\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element(By.ID, \u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Apply timeout for 10 seconds await driver.manage().setTimeouts( { implicit: 10000 } ); // Navigate to url await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     流畅等待 流畅等待实例定义了等待条件的最大时间量，以及检查条件的频率。\n用户可以配置等待来忽略等待时出现的特定类型的异常，例如在页面上搜索元素时出现的NoSuchElementException。\nJava Python C# Ruby JavaScript Kotlin // Waiting 30 seconds for an element to be present on the page, checking // for its presence once every 5 seconds. Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox exception = Selenium::WebDriver::Error::NoSuchElementError begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; wait = Selenium::WebDriver::Wait.new(timeout: 30, interval: 5, message: \u0026#39;Timed out after 30 sec\u0026#39;, ignore: exception) foo = wait.until { driver.find_element(id: \u0026#39;foo\u0026#39;)} ensure driver.quit end   const {Builder, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); // Waiting 30 seconds for an element to be present on the page, checking  // for its presence once every 5 seconds.  let foo = await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000, \u0026#39;Timed out after 30 seconds\u0026#39;, 5000); })();   val wait = FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/support_packages/mouse_and_keyboard_actions_in_detail/",
	"title": "鼠标动作详细信息",
	"tags": [],
	"description": "",
	"content": "Mouse表示鼠标事件. 鼠标操作是通过使用底层接口执行的, 其允许我们向Web浏览器提供虚拟化的设备输入操作.\nclickAndHold 它将移动到该元素，然后在给定元素的中间单击(不释放).\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform click-and-hold action on the element webdriver.ActionChains(driver).click_and_hold(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ClickAndHold { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.ClickAndHold(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform click-and-hold action on the element driver.action.click_and_hold(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function clickAndHold() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform mouseMove to element and mouseDown (press) action on the element  await actions.move({origin:searchBtn}).press().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform() } finally { driver.quit() } }     contextClick 此方法首先将鼠标移动到元素的位置, 然后在给定元素执行上下文点击(右键单击).\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class contextClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform context-click action on the element webdriver.ActionChains(driver).context_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ContextClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.ContextClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform context-click action on the element driver.action.context_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function contextClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform context-click action on the element  await actions.contextClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform() } finally { driver.quit() } }     doubleClick 它将移动到该元素, 并在给定元素的中间双击.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class doubleClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform double-click action on the element webdriver.ActionChains(driver).double_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DoubleClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.DoubleClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform double-click action on the element driver.action.double_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function doubleClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform double-click action on the element  await actions.doubleClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform() } finally { driver.quit() } }     moveToElement 此方法将鼠标移到元素的中间. 执行此操作时, 该元素也会滚动到视图中.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveToElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) # Performs mouse move action onto the element webdriver.ActionChains(driver).move_to_element(gmailLink).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveToElement { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.MoveToElement(gmailLink).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Performs mouse move action onto the element driver.action.move_to(gmail_link).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveToElement() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({origin:gmailLink}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform() } finally { driver.quit() } }     moveByOffset: 此方法将鼠标从其当前位置(或0,0)移动给定的偏移量. 如果坐标在视图窗口之外, 则鼠标最终将在浏览器窗口之外.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveByOffset { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture x and y offset positions of element  int xOffset = gmailLink.getRect().getX(); int yOffset = gmailLink.getRect().getY(); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.moveByOffset(xOffset, yOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) #Set x and y offset positions of element xOffset = 100 yOffset = 100 # Performs mouse move action onto the element webdriver.ActionChains(driver).move_by_offset(xOffset,yOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveByOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); // Set x and y offset positions of element  int xOffset = 100; int yOffset = 100; Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.MoveByOffset(xOffset, yOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Capture x and y offset positions of element x_offset = gmail_link.rect.x y_offset = gmail_link.rect.y # Performs mouse move action onto the offset position driver.action.move_to_location(x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveByOffset() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture offset positions of element  let offset = await gmailLink.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({x:parseInt(x),y:parseInt(y)}).pause(3000).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) // Capture x and y offset positions of element  val xOffset = gmailLink.rect.getX() val yOffset = gmailLink.rect.getY() val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveByOffset(xOffset, yOffset).build().perform() } finally { driver.quit() } }     dragAndDrop 此方法首先在源元素上单击并按住，然后移动到目标元素的位置后释放鼠标.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDrop { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs drag and drop action of sourceEle onto the targetEle webdriver.ActionChains(driver).drag_and_drop(sourceEle,targetEle).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDrop { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDrop(sourceEle, targetEle).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) # Store \u0026#39;box B\u0026#39; as source element target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Performs drag and drop action of sourceEle onto the targetEle driver.action.drag_and_drop(source_ele, target_ele).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDrop() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); // Performs drag and drop action of sourceEle onto the targetEle  await actions.dragAndDrop(sourceEle, targetEle).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform() } finally { driver.quit() } }     dragAndDropBy 此方法首先在源元素上单击并按住, 移至给定的偏移量后释放鼠标.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDropBy { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.getLocation().getX(); int targetEleYOffset = targetEle.getLocation().getY(); Actions actionProvider = new Actions(driver); // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) targetEleXOffset = targetEle.location.get(\u0026#34;x\u0026#34;) targetEleYOffset = targetEle.location.get(\u0026#34;y\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).drag_and_drop_by_offset(sourceEle, targetEleXOffset, targetEleYOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDropToOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.Location.X; int targetEleYOffset = targetEle.Location.Y; Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDropToOffset(sourceEle, targetEleXOffset, targetEleYOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Capture x and y offset positions of element x_offset = target_ele.rect.x y_offset = target_ele.rect.y # Performs dragAndDropBy onto the target element offset position driver.action.drag_and_drop_by(source_ele, x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDropBy() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); let offset = await targetEle.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs dragAndDropBy onto the target element offset position  await actions.dragAndDrop(sourceEle, {x:parseInt(x), y:parseInt(y)}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val targetEleXOffset = targetEle.location.getX() val targetEleYOffset = targetEle.location.getY() val actionProvider = Actions(driver) // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform() } finally { driver.quit() } }     release 此操作将释放按下的鼠标左键. 如果WebElement转移了, 它将释放给定WebElement上按下的鼠标左键.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class release { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform(); // Performs release event  actionProvider.release().build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).click_and_hold(sourceEle).move_to_element(targetEle).perform() #Performs release event webdriver.ActionChains(driver).release().perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class Release { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.ClickAndHold(sourceEle).MoveToElement(targetEle).Build().Perform(); // Performs release event  actionProvider.Release().Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) driver.action.click_and_hold(source_ele).move_to(target_ele).perform # Performs release event driver.action.release.perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function release() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); await actions.move({origin:sourceEle}).press().perform(); // Performs release event on target element  await actions.move({origin:targetEle}).release().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform() // Performs release event  actionProvider.release().build().perform() } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": "WebDriver WebDriver 以本地化方式驱动浏览器，就像用户在本地或使用 Selenium 服务器的远程机器上所做的那样，这标志着浏览器自动化的飞跃。\nSelenium WebDriver 指的是语言绑定和各个浏览器控制代码的实现。 这通常被称为 WebDriver。\nSelenium WebDriver 是 W3C 推荐标准\n  WebDriver 被设计成一个简单和简洁的编程接口。\n  WebDriver 是一个简洁的面向对象 API。\n  它能有效地驱动浏览器。\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/support_classes/",
	"title": "支持的类",
	"tags": [],
	"description": "",
	"content": "WebDriver提供了一些用于简化代码维护的类. 其提供了一种不错的抽象, 使得将HTML元素建模为域对象的操作, 变得更加容易, 还提供了一些更有帮助的方法, 使用此类对象时更容易操作. 我们将学到以下方法:\n Locator Strategies Events LoadableComponent ThreadGuard etc.  我们开始吧:\nThreadGuard 此类仅在Java中可用\n ThreadGuard检查是否仅从创建驱动程序的同一线程中调用了驱动程序. 线程问题 (尤其是在Parallel中运行测试时) 可能遇到神秘并且难以诊断错误. 使用此包装器可以防止此类错误,\n并且在发生此类情况时会抛出异常.\n以下的示例模拟一种线程冲突的情况:\npublic class DriverClash { //thread main (id 1) created this driver  private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;\u0026lt;Set path to your Chromedriver\u0026gt;\u0026#34;); } //Thread-1 (id 24) is calling the same driver causing the clash to happen  Runnable r1 = () -\u0026gt; {protectedDriver.get(\u0026#34;https://selenium.dev\u0026#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } 结果如下所示:\nException in thread \u0026#34;Thread-1\u0026#34; org.openqa.selenium.WebDriverException: Thread safety error; this instance of WebDriver was constructed on thread main (id 1)and is being accessed by thread Thread-1 (id 24) This is not permitted and *will* cause undefined behaviour 正如示例所示:\n protectedDriver 将在主线程中创建 我们使用Java的 Runnable 启动一个新进程, 并使用一个新的 Thread 运行该进程 这两个 Thread 都会发生冲突, 因为主线程的内存中没有 protectedDriver ThreadGuard.protect 会抛出异常  注意: 这不能代替并发运行时使用 ThreadLocal 管理驱动程序的需求.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/improved_reporting/",
	"title": "改善报告",
	"tags": [],
	"description": "",
	"content": "Selenium并非旨在报告测试用例的运行状态. 利用单元测试框架的内置报告功能是一个好的开始. 大多数单元测试框架都有可以生成xUnit或HTML格式的报告. xUnit报表很受欢迎, 可以将其结果导入到持续集成（CI）服务器, 例如Jenkins、Travis、Bamboo等. 以下是一些链接, 可获取关于几种语言报表输出的更多信息.\nNUnit 3 Console Runner\nNUnit 3 Console Command Line\nxUnit getting test results in TeamCity\nxUnit getting test results in CruiseControl.NET\nxUnit getting test results in Azure DevOps\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/worst_practices/test_dependency/",
	"title": "测试依赖",
	"tags": [],
	"description": "",
	"content": "关于自动化测试的一个常见想法和误解是关于特定的测试顺序. 您的测试应该能够以任何顺序运行，而不是依赖于完成其他测试才能成功.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/js_alerts_prompts_and_confirmations/",
	"title": "JavaScript 警告框,提示框和确认框",
	"tags": [],
	"description": "",
	"content": "WebDriver提供了一个API, 用于处理JavaScript提供的三种类型的原生弹窗消息. 这些弹窗由浏览器提供限定的样式.\nAlerts 警告框 其中最基本的称为警告框, 它显示一条自定义消息, 以及一个用于关闭该警告的按钮, 在大多数浏览器中标记为\u0026quot;确定\u0026rdquo;(OK). 在大多数浏览器中, 也可以通过按\u0026quot;关闭\u0026rdquo;(close)按钮将其关闭, 但这始终与“确定”按钮具有相同的作用. 查看样例警告框.\nWebDriver可以从弹窗获取文本并接受或关闭这些警告.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See an example alert\u0026#34;).click() # Wait for the alert to be displayed and store it in a variable alert = wait.until(expected_conditions.alert_is_present()) # Store the alert text in a variable text = alert.text # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert text in a variable string text = alert.Text; //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on OK button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the OK button await alert.accept(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Store the alert text in a variable val text = alert.getText() //Press the OK button alert.accept()     Confirm 确认框 确认框类似于警告框, 不同之处在于用户还可以选择取消消息. 查看样例确认框.\n此示例还呈现了警告的另一种实现:\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()); //Store the alert in a variable Alert alert = driver.switchTo().alert(); //Store the alert in a variable for reuse String text = alert.getText(); //Press the Cancel button alert.dismiss();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample confirm\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = driver.switch_to.alert # Store the alert text in a variable text = alert.text # Press the Cancel button alert.dismiss()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Wait for the alert to be displayed wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert in a variable IAlert alert = driver.SwitchTo().Alert(); //Store the alert in a variable for reuse string text = alert.Text; //Press the Cancel button alert.Dismiss();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on Cancel button alert.dismiss   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the Cancel button await alert.dismiss(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()) //Store the alert in a variable val alert = driver.switchTo().alert() //Store the alert in a variable for reuse val text = alert.text //Press the Cancel button alert.dismiss()     Prompt 提示框 提示框与确认框相似, 不同之处在于它们还包括文本输入. 与处理表单元素类似, 您可以使用WebDriver的sendKeys来填写响应. 这将完全替换占位符文本. 按下取消按钮将不会提交任何文本. 查看样例提示框.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample prompt\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = Alert(driver) # Type your message alert.send_keys(\u0026#34;Selenium\u0026#34;) # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Type your message alert.SendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Type a message alert.send_keys(\u0026#34;selenium\u0026#34;) # Press on Ok button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Type your message await alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button await alert.accept(); //Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;) //Press the OK button alert.accept()     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/support_packages/working_with_cookies/",
	"title": "同cookies一起工作",
	"tags": [],
	"description": "",
	"content": "Cookie是从网站发送并存储在您的计算机中的一小段数据. Cookies主要用于识别用户并加载存储的信息.\nWebDriver API提供了一种使用内置的方法与Cookie进行交互:\n添加 Cookie 这个方法常常用于将cookie添加到当前访问的上下文中. 添加Cookie仅接受一组已定义的可序列化JSON对象. 这里 是一个链接, 用于描述可接受的JSON键值的列表\n首先, 您需要位于有效Cookie的域上. 如果您在开始与网站进行交互之前尝试预设cookie, 并且您的首页很大或需要一段时间才能加载完毕, 则可以选择在网站上找到一个较小的页面 (通常404页很小, 例如 http://example.com/some404page)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Adds the cookie into current browser context  driver.manage().addCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;})   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace AddCookie { class AddCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Adds the cookie into current browser context  driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context driver.manage.add_cookie(name: \u0026#34;key\u0026#34;, value: \u0026#34;value\u0026#34;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;}); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Adds the cookie into current browser context  driver.manage().addCookie(Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit() } }     获取命名的 Cookie 此方法返回与cookie名称匹配的序列化cookie数据中所有关联的cookie.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class getCookieNamed { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  Cookie cookie1 = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); System.out.println(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bar\u0026#34;}) # Get cookie details with named cookie \u0026#39;foo\u0026#39; print(driver.get_cookie(\u0026#34;foo\u0026#34;))   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetCookieNamed { class GetCookieNamed { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  var cookie = driver.Manage().Cookies.GetCookieNamed(\u0026#34;foo\u0026#34;); System.Console.WriteLine(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;) # Get cookie details with named cookie \u0026#39;foo\u0026#39; puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;foo\u0026#39;, value: \u0026#39;bar\u0026#39;}); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  driver.manage().getCookie(\u0026#39;foo\u0026#39;).then(function (cookie) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookie); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  val cookie = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); println(cookie); } finally { driver.quit() } }     获取全部 Cookies 此方法会针对当前访问上下文返回“成功的序列化cookie数据”. 如果浏览器不再可用, 则返回错误.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Set; public class getAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Add few cookies  driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  Set\u0026lt;Cookie\u0026gt; cookies = driver.manage().getCookies(); System.out.println(cookies); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Get all available cookies print(driver.get_cookies())   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetAllCookies { class GetAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  var cookies = driver.Manage().Cookies.AllCookies; } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Get all available cookies puts driver.manage.all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  val cookies = driver.manage().cookies; println(cookies); } finally { driver.quit() } }     删除 Cookie 此方法删除与提供的cookie名称匹配的cookie数据.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); Cookie cookie1 = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); /* Selenium Java bindings also provides a way to delete cookie by passing cookie object of current browsing context */ driver.manage().deleteCookie(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Delete a cookie with name \u0026#39;test1\u0026#39; driver.delete_cookie(\u0026#34;test1\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteCookie { class DeleteCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); var cookie = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.Manage().Cookies.AddCookie(cookie); // delete a cookie with name \u0026#39;test1\u0026#39;\t driver.Manage().Cookies.DeleteCookieNamed(\u0026#34;test1\u0026#34;); // Selenium .net bindings also provides a way to delete  // cookie by passing cookie object of current browsing context  driver.Manage().Cookies.DeleteCookie(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # delete a cookie with name \u0026#39;test1\u0026#39; driver.manage.delete_cookie(\u0026#39;test1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete a cookie with name \u0026#39;test1\u0026#39;  await driver.manage().deleteCookie(\u0026#39;test1\u0026#39;); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); val cookie1 = Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;) driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); // delete cookie by passing cookie object of current browsing context.  driver.manage().deleteCookie(cookie1); } finally { driver.quit() } }     删除所有 Cookies 此方法删除当前访问上下文的所有cookie.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Deletes all cookies driver.delete_all_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteAllCookies { class DeleteAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.Manage().Cookies.DeleteAllCookies(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # deletes all cookies driver.manage.delete_all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete all cookies  await driver.manage().deleteAllCookies(); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit() } }     Same-Site Cookie属性 此属性允许用户引导浏览器控制cookie, 是否与第三方站点发起的请求一起发送. 引入其是为了防止CSRF（跨站请求伪造）攻击.\nSame-Site cookie属性接受以下两种参数作为指令\nStrict: 当sameSite属性设置为 Strict, cookie不会与来自第三方网站的请求一起发送.\nLax: 当您将cookie sameSite属性设置为 Lax, cookie将与第三方网站发起的GET请求一起发送.\n注意: 到目前为止, 此功能已适配于chrome (80+ version) 中, 并适用于Selenium 4以及更高版本.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class cookieTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); Cookie cookie = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build(); Cookie cookie1 = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build(); driver.manage().addCookie(cookie); driver.manage().addCookie(cookie1); System.out.println(cookie.getSameSite()); System.out.println(cookie1.getSameSite()); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Strict\u0026#39;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Lax\u0026#39;}) cookie1 = driver.get_cookie(\u0026#39;foo\u0026#39;) cookie2 = driver.get_cookie(\u0026#39;foo1\u0026#39;) print(cookie1) print(cookie2)   // Please raise a PR    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Strict\u0026#34;) driver.manage.add_cookie(name: \u0026#34;foo1\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Lax\u0026#34;) puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) puts driver.manage.cookie_named(\u0026#39;foo1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39;  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Strict\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Lax\u0026#39;}); console.log(await driver.manage().getCookie(\u0026#39;key\u0026#39;)); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;http://www.example.com\u0026#34;) val cookie = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build() val cookie1 = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build() driver.manage().addCookie(cookie) driver.manage().addCookie(cookie1) println(cookie.getSameSite()) println(cookie1.getSameSite()) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/worst_practices/performance_testing/",
	"title": "性能测试",
	"tags": [],
	"description": "",
	"content": "通常不建议使用Selenium和WebDriver进行性能测试. 并非因为不能做, 只是缺乏针对此类工作的优化, 因而难以得到乐观的结果.\n对于用户而言, 在用户上下文中执行性能测试似乎是自然而然的选择, 但是WebDriver的测试会受到许多外部和内部的影响而变得脆弱, 这是您无法控制的. 例如, 浏览器的启动速度, HTTP服务器的速度, 托管JavaScript或CSS的第三方服务器的响应 以及WebDriver实现本身检测的损失. 这些因素的变化会影响结果. 很难区分网站自身与外部资源之间的性能差异, 并且也很难明确浏览器中使用WebDriver对性能的影响, 尤其是在注入脚本时.\n另一个潜在的吸引点是\u0026quot;节省时间\u0026rdquo;-同时执行功能和性能测试. 但是, 功能和性能测试分别具有截然不同的目标. 要测试功能, 测试人员可能需要耐心等待加载, 但这会使性能测试结果蒙上阴影, 反之亦然.\n为了提高网站的性能, 您需要不依赖于环境的差异来分析整体性能, 识别不良代码的实践, 对单个资源 (即CSS或JavaScript) 的性能进行细分 以了解需要改进的地方. 有很多性能测试工具已经可以完成这项工作, 并且提供了报告和分析结果, 甚至可以提出改进建议.\n例如一种易于使用的 (开源) 软件包是: JMeter\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/remote_webdriver/",
	"title": "远程 WebDriver",
	"tags": [],
	"description": "",
	"content": "远程 WebDriver 您可以如本地一样, 使用远程WebDriver. 主要区别在于需要配置远程WebDriver, 以便可以在不同的计算机上运行测试.\n远程WebDriver由两部分组成：客户端和服务端. 客户端是您的WebDriver测试，而服务端仅仅是可以被托管于任何现代Java EE应用服务器的Java Servlet.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/avoid_sharing_state/",
	"title": "避免共享状态",
	"tags": [],
	"description": "",
	"content": "尽管在多个地方都提到过, 但这点仍值得被再次提及. 确保测试相互隔离.\n  不要共享测试数据. 想象一下有几个测试, 每个测试都会在选择操作执行之前查询数据库中的有效订单. 如果两个测试采用相同的顺序, 则很可能会出现意外行为.\n  清理应用程序中过时的数据, 这些数据可能会被其他测试. 例如无效的订单记录.\n  每次测试都创建一个新的WebDriver实例. 这在确保测试隔离的同时可以保障并行化更为简单.\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/http_proxies/",
	"title": "Http 代理",
	"tags": [],
	"description": "",
	"content": "代理服务器充当客户端和服务器之间的请求中介. 简述而言, 流量将通过代理服务器流向您请求的地址, 然后返回.\n使用代理服务器用于Selenium的自动化脚本, 可能对以下方面有益:\n 捕获网络流量 模拟网站后端响应 在复杂的网络拓扑结构或严格的公司限制/政策下访问目标站点.  如果您在公司环境中, 并且浏览器无法连接到URL, 则最有可能是因为环境, 需要借助代理进行访问.\nSelenium WebDriver提供了如下设置代理的方法\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Proxy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.chrome.ChromeOptions; public class proxyTest { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;); ChromeOptions options = new ChromeOptions(); options.setCapability(\u0026#34;proxy\u0026#34;, proxy); WebDriver driver = new ChromeDriver(options); driver.get(\u0026#34;https://www.google.com/\u0026#34;); driver.manage().window().maximize(); driver.quit(); } }   from selenium import webdriver PROXY = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34; webdriver.DesiredCapabilities.FIREFOX[\u0026#39;proxy\u0026#39;] = { \u0026#34;httpProxy\u0026#34;: PROXY, \u0026#34;ftpProxy\u0026#34;: PROXY, \u0026#34;sslProxy\u0026#34;: PROXY, \u0026#34;proxyType\u0026#34;: \u0026#34;MANUAL\u0026#34;, } with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://selenium.dev\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; public class ProxyTest{ public static void Main() { ChromeOptions options = new ChromeOptions(); Proxy proxy = new Proxy(); proxy.Kind = ProxyKind.Manual; proxy.IsAutoDetect = false; proxy.SslProxy = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;; options.Proxy = proxy; options.AddArgument(\u0026#34;ignore-certificate-errors\u0026#34;); IWebDriver driver = new ChromeDriver(options); driver.Navigate().GoToUrl(\u0026#34;https://www.selenium.dev/\u0026#34;); } }   # Need PR   // need PR    import org.openqa.selenium.Proxy import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions class proxyTest { fun main() { val proxy = Proxy() proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;) val options = ChromeOptions() options.setCapability(\u0026#34;proxy\u0026#34;, proxy) val driver: WebDriver = ChromeDriver(options) driver[\u0026#34;https://www.google.com/\u0026#34;] driver.manage().window().maximize() driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/",
	"title": "指南和建议",
	"tags": [],
	"description": "",
	"content": "指南和建议 关于\u0026quot;最佳实践\u0026quot;的注解：我们有意在本文档中避免使用\u0026quot;最佳实践\u0026quot;的说辞. 没有一种方法可以适用于所有情况. 我们更喜欢\u0026quot;指南和建议\u0026quot;的想法. 我们鼓励您通读这些内容, 并仔细地确定哪种方法适用于您的特定环境.\n由于许多原因, 功能测试很难正确完成. 即便应用程序的状态, 复杂性, 依赖还不够让测试变得 足够复杂, 操作浏览器（特别是跨浏览器的兼容性测试）就已经使得写一个好的测试变成一种挑战.\nSelenium提供了一些工具使得功能测试用户更简单的操作浏览器, 但是这些工具并不能帮助你来写一个好的 架构的测试套件. 这章我们会针对怎么来做web页面的功能测试的自动化给出一些忠告, 指南和建议.\n这章记录了很多历年来成功的使用Selenium的用户的常用的软件设计模式.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/test_independency/",
	"title": "测试的独立性",
	"tags": [],
	"description": "",
	"content": "将每个测试编写为独立的单元. 以不依赖于其他测试完成的方式编写测试:\n例如有一个内容管理系统, 您可以借助其创建一些自定义内容, 这些内容在发布后作为模块显示在您的网站上, 并且CMS和应用程序之间的同步可能需要一些时间.\n测试模块的一种错误方法是在测试中创建并发布内容, 然后在另一测试中检查该模块. 这是不可取的, 因为发布后内容可能无法立即用于其他测试.\n与之相反的事, 您可以创建在受影响的测试中打开和关闭的打桩内容, 并将其用于验证模块. 而且, 对于内容的创建, 您仍然可以进行单独的测试.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/worst_practices/link_spidering/",
	"title": "爬取链接",
	"tags": [],
	"description": "",
	"content": "建议您不要使用WebDriver来通过链接进行爬网， 并非因为无法完成，而是因为它绝对不是最理想的工具。 WebDriver需要一些时间来启动，并且可能要花几秒钟到一分钟的时间， 具体取决于测试的编写方式，仅仅是为了获取页面并遍历DOM.\n除了使用WebDriver之外， 您还可以通过执行 curl 命令或 使用诸如BeautifulSoup之类的库来节省大量时间， 因为这些方法不依赖于创建浏览器和导航至页面. 通过不使用WebDriver可以节省大量时间.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/worst_practices/",
	"title": "反模式",
	"tags": [],
	"description": "",
	"content": "反模式 "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/consider_using_a_fluent_api/",
	"title": "考虑使用Fluent API",
	"tags": [],
	"description": "",
	"content": "Martin Fowler创造了术语 \u0026ldquo;Fluent API\u0026rdquo;. Selenium已经在其 FluentWait 类中实现了类似的东西, 这是对标准 Wait类的替代. 您可以在页面对象中启用Fluent API设计模式, 然后使用如下代码段查询Google搜索页面:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); Google页面对象类具有这种流畅行为后可能看起来像这样:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // If load() fails, calls isLoaded() until page is finished loading  PageFactory.initElements(driver, this); // Initialize WebElements on page  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, Duration.ofSeconds(3) ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } } "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/page_loading_strategy/",
	"title": "页面加载策略",
	"tags": [],
	"description": "",
	"content": "定义当前会话的页面加载策略. 默认情况下, 当Selenium WebDriver加载页面时, 遵循 normal 的页面加载策略. 始终建议您在页面加载缓慢时, 停止下载其他资源 (例如图片, css, js) .\ndocument.readyState 属性描述当前页面的加载状态. 默认情况下, 在页面就绪状态是 complete 之前, WebDriver都将延迟 driver.get() 的响应或 driver.navigate().to() 的调用.\n在单页应用程序中 (例如Angular, react, Ember) , 一旦动态内容加载完毕 (即pageLoadStrategy状态为COMPLETE) , 则点击链接或在页面内执行某些操作的行为将不会向服务器发出新请求, 因为内容在客户端动态加载, 无需刷新页面.\n单页应用程序可以动态加载许多视图, 而无需任何服务器请求, 因此页面加载策略将始终显示为 COMPLETE 的状态, 直到我们执行新的 driver.get() 或 driver.navigate().to() 为止.\nWebDriver的 页面加载策略 支持以下内容:\nnormal 此配置使Selenium WebDriver等待整个页面的加载. 设置为 normal 时, Selenium WebDriver将保持等待, 直到 返回 load 事件\n默认情况下, 如果未设置页面加载策略, 则设置 normal 为初始策略.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;normal\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Normal; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;normal\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;normal\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     eager 这将使Selenium WebDriver保持等待, 直到完全加载并解析了HTML文档, 该策略无关样式表, 图片和subframes的加载.\n设置为 eager 时, Selenium WebDriver保持等待, 直至返回 DOMContentLoaded 事件.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;eager\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Eager; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;eager\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;eager\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     none 设置为 none 时, Selenium WebDriver仅等待至初始页面下载完成.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;none\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.None; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;none\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;none\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/grid/",
	"title": "服务网格",
	"tags": [],
	"description": "",
	"content": "服务网格 Selenium服务网格 是一个能够让Selenium的测试把命令传送到一个远程浏览器实例的职能代理服务器。 他的目的是提供一个简便的方法来在多台终端上并行的执行测试任务。\n在Selenium服务网格, 一台服务器作为转发器(hub)将JSON格式的测试命令转发到1台或多台注册的节点。 测试任务通过跟转发器(hub)的交互来操作远端浏览器实例。 转发器(hub)维护了一个可供使用的注册服务器列表，也允许我们通过转发器(hub)来控制这些实例。\nSelenium服务网格允许我们在多台节点服务器上并行执行测试， 同时也中心化的管理多个浏览器版本，多种浏览器的配置。（以替代传统的基于个人的测试）\nSelenium服务网格并不是万能的(silver bullet)。 它能够解决一些通用的代理问题和分布式的问题，但是并不能管理你的硬件，也可能不适合你的一些特殊需求。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/guidelines_and_recommendations/fresh_browser_per_test/",
	"title": "每次测试都刷新浏览器",
	"tags": [],
	"description": "",
	"content": "每次测试都从一个干净的已知状态开始. 理想情况下, 为每次测试打开一个新的虚拟机. 如果打开新虚拟机不切实际, 则至少应为每次测试启动一个新的WebDriver. 对于Firefox, 请使用您已知的配置文件去启动WebDriver.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile); "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/web_element/",
	"title": "网络元素",
	"tags": [],
	"description": "",
	"content": "WebElement表示DOM元素. 可以通过使用WebDriver实例从文档根节点进行搜索, 或者在另一个WebElement下进行搜索来找到WebElement.\nWebDriver API提供了内置方法来查找基于不同属性的WebElement (例如ID, Name, Class, XPath, CSS选择器, 链接文本等).\nFind Element 此方法用于查找元素并返回第一个匹配的单个WebElement引用, 该元素可用于进一步的元素操作.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element WebElement searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_box = driver.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_bar = driver.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element let searchBar = driver.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element val searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements 与\u0026quot;Find Element\u0026quot;相似, 但返回的是匹配WebElement列表. 要使用列表中的特定WebElement, 您需要遍历元素列表以对选定元素执行操作.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import java.util.List; public class findElementsExample { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement element : elements) { System.out.println(\u0026#34;Paragraph text:\u0026#34; + element.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() # Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using System.Collections.Generic; namespace FindElementsExample { class FindElementsExample { public static void Main(string[] args) { IWebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = driver.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await driver.findElements(By.tagName(\u0026#39;p\u0026#39;)); for(let e of elements) { console.log(await e.getText()); } } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (element in elements) { println(\u0026#34;Paragraph text:\u0026#34; + element.text) } } finally { driver.quit() } }     Find Element From Element 此方法用于在父元素的上下文中查找子元素. 为此, 父WebElement与\u0026quot;findElement\u0026quot;链接并访问子元素.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element(By.TAG_NAME, \u0026#34;form\u0026#34;) search_box = search_form.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = searchForm.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Get search box element from webElement \u0026#39;form\u0026#39; search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; let searchForm = driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Get search box element from webElement \u0026#39;form\u0026#39; let searchBar = searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements From Element 此方法用于在父元素的上下文中查找匹配子WebElement的列表. 为此, 父WebElement与\u0026quot;findElements\u0026quot;链接并访问子元素.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import java.util.List; public class findElementsFromElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  WebElement element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement e : elements) { System.out.println(e.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(By.TAG_NAME, \u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System.Collections.Generic; namespace FindElementsFromElement { class FindElementsFromElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  IWebElement element = driver.FindElement(By.TagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = element.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(:tag_name,\u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get element with tag name \u0026#39;div\u0026#39;  let element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for(let e of elements) { console.log(await e.getText()); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get element with tag name \u0026#39;div\u0026#39;  val element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (e in elements) { println(e.text) } } finally { driver.quit() } }     Get Active Element 此方法用于追溯或查找当前页面上下文中具有焦点的DOM元素.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class activeElementTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  String attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); System.out.println(attr); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.find_element(By.CSS_SELECTOR, \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#34;webElement\u0026#34;) # Get attribute of current active element attr = driver.switch_to.active_element.get_attribute(\u0026#34;title\u0026#34;) print(attr)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace ActiveElement { class ActiveElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://www.google.com\u0026#34;); driver.FindElement(By.CssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).SendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  string attr = driver.SwitchTo().ActiveElement().GetAttribute(\u0026#34;title\u0026#34;); System.Console.WriteLine(attr); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.google.com\u0026#39; driver.find_element(css: \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#39;webElement\u0026#39;) # Get attribute of current active element attr = driver.switch_to.active_element.attribute(\u0026#39;title\u0026#39;) puts attr ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); await driver.get(\u0026#39;https://www.google.com\u0026#39;); await driver.findElement(By.css(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  let attr = await driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); console.log(`${attr}`) })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;) // Get attribute of current active element  val attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); print(attr); } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/support_packages/chrome_devtools/",
	"title": "Chrome Devtools",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests!\n Selenium 4 alpha versions have much awaited native support for Chrome Dev Protocol through \u0026ldquo;DevTools\u0026rdquo; interface. This helps us getting Chrome Development properties such as Application Cache, Fetch, Network, Performance, Profiler, Resource Timing, Security and Target CDP domains etc.\nChrome DevTools is a set of web developer tools built directly into the Google Chrome browser. DevTools can help you edit pages on-the-fly and diagnose problems quickly, which ultimately helps you build better websites, faster.\nEmulate Geo Location: Some applications have different features and functionalities across different locations. Automating such applications is difficult because it is hard to emulate the geo locations in the browser using Selenium. But with the help of Devtools, we can easily emulate them. Below code snippet demonstrates that.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.devtools.DevTools; public void geoLocationTest(){ ChromeDriver driver = new ChromeDriver(); Map coordinates = new HashMap() {{ put(\u0026#34;latitude\u0026#34;, 50.2334); put(\u0026#34;longitude\u0026#34;, 0.2334); put(\u0026#34;accuracy\u0026#34;, 1); }}; driver.executeCdpCommand(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, coordinates); driver.get(\u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;); }   # Please raise a PR to add code sample   // Please raise a PR to add code sample    # Please raise a PR to add code sample   // Please raise a PR to add code sample    // Please raise a PR to add code sample      "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/webdriver/keyboard/",
	"title": "Keyboard",
	"tags": [],
	"description": "",
	"content": "Keyboard代表一个键盘事件. Keyboard操作通过使用底层接口允许我们向web浏览器提供虚拟设备输入.\nsendKeys 即使遇到修饰符键序列, sendKeys也会在DOM元素中键入键序列. Here are the list of possible keystrokes that WebDriver Supports.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.firefox.FirefoxDriver; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys driver = webdriver.Firefox() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)   using (var driver = new FirefoxDriver()) { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action  driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return ensure driver.quit end   const {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER) } finally { driver.quit() } }     keyDown keyDown用于模拟按下辅助按键(CONTROL, SHIFT, ALT)的动作.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action  driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER); Actions actionProvider = new Actions(driver); Action keydown = actionProvider.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build(); keydown.perform(); } finally { driver.quit(); }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER) # Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page webdriver.ActionChains(driver).key_down(Keys.CONTROL).send_keys(\u0026#34;a\u0026#34;).perform()   IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action  driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter); // Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page  Actions actionProvider = new Actions(driver); IAction keydown = actionProvider.KeyDown(Keys.Control).SendKeys(\u0026#34;a\u0026#34;).Build(); keydown.Perform(); } finally { driver.Quit(); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return # Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page driver.action.key_down(:control).send_keys(\u0026#39;a\u0026#39;).perform ensure driver.quit end   (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER); // Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page  await driver.actions().keyDown(Key.CONTROL).sendKeys(\u0026#39;a\u0026#39;).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action  driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER) val action = Actions(driver) // Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page  action.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build().perform(); } finally { driver.quit() } }     keyUp keyUp用于模拟辅助按键(CONTROL, SHIFT, ALT)弹起或释放的操作.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.interactions.Actions; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); Actions action = new Actions(driver); // Store google search box WebElement  WebElement search = driver.findElement(By.name(\u0026#34;q\u0026#34;)); // Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)  action.keyDown(Keys.SHIFT).sendKeys(search,\u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform(); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store google search box WebElement search = driver.find_element(By.NAME, \u0026#34;q\u0026#34;) action = webdriver.ActionChains(driver) # Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty) action.key_down(Keys.SHIFT).send_keys_to_element(search, \u0026#34;qwerty\u0026#34;).key_up(Keys.SHIFT).send_keys(\u0026#34;qwerty\u0026#34;).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace HelloSelenium { class HelloSelenium { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); Actions action = new Actions(driver); // Store google search box WebElement  IWebElement search = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); // Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)  action.KeyDown(Keys.Shift).SendKeys(search, \u0026#34;qwerty\u0026#34;).KeyUp(Keys.Shift).SendKeys(\u0026#34;qwerty\u0026#34;).Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Store google search box WebElement search = driver.find_element(name: \u0026#39;q\u0026#39;) # Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty) driver.action.key_down(:shift).send_keys(search,\u0026#39;qwerty\u0026#39;).key_up(:shift).send_keys(\u0026#34;qwerty\u0026#34;).perform ensure driver.quit end   const {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store google search box WebElement  let search = driver.findElement(By.name(\u0026#39;q\u0026#39;)); // Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)  await driver.actions().click(search).keyDown(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).keyUp(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store google search box WebElement  val search = driver.findElement(By.name(\u0026#34;q\u0026#34;)) val action = Actions(driver) // Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)  action.keyDown(Keys.SHIFT).sendKeys(search, \u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).build().perform(); } finally { driver.quit() } }     clear 清除可编辑元素的内容. 这仅适用于可编辑且可交互的元素, 否则Selenium将返回错误(无效的元素状态或元素不可交互).\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; public class clear { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://www.google.com\u0026#34;); // Store \u0026#39;SearchInput\u0026#39; element  WebElement searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchInput.sendKeys(\u0026#34;selenium\u0026#34;); // Clears the entered text  searchInput.clear(); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;SearchInput\u0026#39; element SearchInput = driver.find_element(By.NAME, \u0026#34;q\u0026#34;) SearchInput.send_keys(\u0026#34;selenium\u0026#34;) # Clears the entered text SearchInput.clear()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System; namespace SnipetProjectDelete { class Program { static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(@\u0026#34;https://www.google.com\u0026#34;); // Store \u0026#39;SearchInput\u0026#39; element  IWebElement searchInput = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchInput.SendKeys(\u0026#34;selenium\u0026#34;); // Clears the entered text  searchInput.Clear(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # store \u0026#39;search_input\u0026#39; element search_input = driver.find_element(name: \u0026#39;q\u0026#39;) search_input.send_keys(\u0026#39;selenium\u0026#39;) # Clears the entered text search_input.clear ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;SearchInput\u0026#39; element  let searchInput = driver.findElement(By.name(\u0026#39;q\u0026#39;)); await searchInput.sendKeys(\u0026#34;selenium\u0026#34;); // Clears the entered text  await searchInput.clear(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://www.google.com\u0026#34;) // Store \u0026#39;searchInput\u0026#39; element  val searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchInput.sendKeys(\u0026#34;selenium\u0026#34;) // Clears the entered text  searchInput.clear() } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/driver_idiosyncrasies/",
	"title": "驱动特性",
	"tags": [],
	"description": "",
	"content": "驱动特性 "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/support_packages/",
	"title": "支持的包",
	"tags": [],
	"description": "",
	"content": "支持的包 "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/legacy_docs/",
	"title": "Legacy",
	"tags": [],
	"description": "",
	"content": "Legacy 在此部分，您可以找到与Selenium的旧组件有关的所有文档. 这样做纯粹是出于历史原因，而不是鼓励使用已废弃的组件.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/front_matter/",
	"title": "版权页",
	"tags": [],
	"description": "",
	"content": "版权页 "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/",
	"title": "Selenium 浏览器自动化项目",
	"tags": [],
	"description": "",
	"content": "Selenium 浏览器自动化项目 Selenium 是支持 web 浏览器自动化的一系列工具和库的综合项目。\n它提供了扩展来模拟用户与浏览器的交互，用于扩展浏览器分配的分发服务器，以及用于实现 W3C WebDriver 规范 的基础结构，该 规范 允许您为所有主要 Web 浏览器编写可互换的代码。\n这个项目是由志愿者贡献者实现的，他们投入了自己数千小时的时间，并使源代码免费提供给任何人使用、享受和改进。\nSelenium 汇集了浏览器供应商，工程师和爱好者，以进一步围绕 Web 平台自动化进行公开讨论。 该项目组织了一次年度会议，以教学和培养社区。\nSelenium 的核心是 WebDriver，这是一个编写指令集的接口，可以在许多浏览器中互换运行。 这里有一个最简单的说明：\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; import java.time.Duration; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #This example requires Selenium WebDriver 3.13 or newer with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located(By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;)) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;div\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;cheese\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;div\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated import org.openqa.selenium.support.ui.WebDriverWait import java.time.Duration fun main() { val driver = FirefoxDriver() val wait = WebDriverWait(driver, Duration.ofSeconds(10)) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))) println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } }     请参阅 快速浏览 以获得运行此代码时幕后发生的事情的完整解释。 您应该继续阅读介绍，了解如何安装并成功地使用 Selenium 作为测试自动化工具，并将这样的简单测试扩展到多个浏览器上的大型分布式环境中，在多个不同的操作系统上运行。\n入门指南 如果您刚刚接触 Selenium，我们有一些资源可以帮助您快速上手。\n 快速浏览  WebDriver IDE Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.selenium.dev/documentation/zh-cn/contributing/",
	"title": "为 Selenium 文档做贡献",
	"tags": [],
	"description": "",
	"content": "Selenium是一个大型软件项目, 其网站和文档是了解事情如何工作以及学习有效利用其潜力的关键.\n该项目包含Selenium的网站和文档. 这是一项持续的工作(不针对任何特定版本), 用于提供有效使用Selenium、 如何参与以及如何为Selenium做出贡献的更新信息.\n对网站和文档的贡献遵循以下部分中有关贡献的描述. 您应该花一些时间来熟悉以下文档 查看更多.\n Selenium项目欢迎每一个人的贡献. 您可以通过多种方式提供帮助:\n上报问题 在报告新问题或评论现有问题时, 请确保讨论与Selenium的软件、 其站点与文档的具体技术问题相关.\n随着时间的推移, 所有Selenium组件的变化都非常快, 因此这可能会导致文档过时. 如前所述, 如果您确实遇到这种情况, 请不要为此担心. 您也可能知道如何更新文档, 因此请向我们发送包含相关更改的Pull Request.\n如果不确定所发现的问题是否存在, 请通过以下沟通渠道进行描述 https://selenium.dev/support.\n贡献 Selenium项目欢迎新的贡献者. 随时间做出重大贡献的个人将成为 提交者 , 并获得对该项目的提交权限.\n本指南将指导您完成贡献的过程.\n步骤 1: Fork 在 Github上Fork本项目, 并check out到您的本地\n% git clone git@github.com:seleniumhq/seleniumhq.github.io.git % cd seleniumhq.github.io 依赖: Hugo 我们使用 Hugo 来构建和渲染网站和文档. 需要在提交任何更改之前, 在本地验证所有内容, 请安装 Hugo, 熟悉它并运行本地服务器 以在本地呈现该网站(详细说明可在后续步骤中找到).\n步骤 2: 分支 创建一个功能分支并开始工作:\n% git checkout -b my-feature-branch 我们实践基于HEAD的开发模式, 这意味着所有更改都直接应用在master之上.\n步骤 3: 做出改变 仓库包含站点和文档, 这是两个独立的Hugo项目. 如果要更改站点, 请在 site_source_files 目录上工作. 要查看更改的实时预览, 请在网站的根目录上运行 hugo server 命令.\n% cd site_source_files % hugo server 要更改文档, 请切换到 docs_source_files 目录.\n% cd docs_source_files % hugo server 本文档基于英语内容, 被翻译成多种语言. 更改文件时, 请 确保 也对所有其他翻译文件进行更改. 这可能会略有不同, 例如:\n  如果将代码示例添加到 browser_manipulation.en.md 文件中后, 则还需将其添加到 browser_manipulation.es.md, browser_manipulation.ef.md, browser_manipulation.ja.md 以及所有其他的已翻译文件.\n  如果您发现可以改进的翻译, 请仅更改翻译的文件.\n  如果要添加新的语言翻译, 请添加具有适当后缀的新文件. 无需翻译所有内容即可提交PR, 可以迭代完成. 不要忘记在 config.toml 文件中检查一些必要的配置.\n  如果您用英语版本更改了文本, 请用您的更改替换翻译文件中的同一部分(是的, 用英语), 然后在文件顶部添加以下注意事项.\n  {{% notice info %}} \u0026lt;i class=\u0026#34;fas fa-language\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Page being translated from English to {LANGUAGE}. Do you speak {LANGUAGE}? Help us to translate it by sending us pull requests! {{% /notice %}} 步骤 4: 提交 首先确保git知道您的姓名和电子邮件地址:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; 编写良好的提交信息很重要. 提交信息应描述更改的内容, 原因以及已解决的参考问题(如果有). 撰写时应遵循以下规则:\n 第一行应少于或等于50个字符, 并包含对该更改的简短说明. 保持第二行空白. 在所有72列处换行. 包括 Fixes #N, 其中 N 是提交修复的问题编号(如果有).  一个好的提交信息可能看起来像这样:\nexplain commit normatively in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way `git log` will show things nicely even when it is indented. Fixes #141 第一行必须有意义, 因为这是人们在运行 git shortlog 或 git log --oneline 时看到的内容.\n步骤 5: Rebase 使用 git rebase (并非 git merge) 同步实时的工作.\n% git fetch upstream % git rebase upstream/master 步骤 6: 测试 永远记住要运行本地服务, 这样做可以确保您的更改没有破坏任何事情.\n步骤 7: Push % git push origin my-feature-branch 访问 https://github.com/yourusername/seleniumhq.github.io.git 并点击 Pull Request 以及填写表格. 请明确您已经签署了CLA (详见步骤 7).\nPull requests通常会在几天内进行审核. 如果有评论要解决, 请在新提交(最好是修正)中应用您的更改, 然后推push到同一分支.\n步骤 8: 集成 代码审查完成后, 提交者将获取您的PR并将其集成到项目的master分支中. 因为我们希望在master分支上保持线性历史记录, 所以我们通常会squash并rebase您的分支历史记录.\n沟通 有关如何与项目贡献者和整个社区进行沟通的所有详细信息, 请访问以下网址 https://selenium.dev/support\n"
}]