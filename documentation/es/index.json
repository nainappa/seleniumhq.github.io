[
{
	"uri": "https://www.selenium.dev/documentation/es/worst_practices/captchas/",
	"title": "Captchas",
	"tags": [],
	"description": "",
	"content": "CAPTCHA es la abreviatura de Completely Automated Public Turing test to tell Computers and Humans Apart o en español Prueba de Turing Completamente Automática y Pública para diferenciar Ordenadores de Humanos, está explícitamente diseñado para prevenir la automatización, ¡así que no intentes automatizarlo!\nExisten dos estrategias principales para evitar los CAPTCHAs:\n Deshabilitar los CAPTCHAs en tus entornos de pruebas. Agrega un parámetro que permita que las pruebas hagan un baipás.  "
},
{
	"uri": "https://www.selenium.dev/documentation/es/front_matter/copyright_and_attributions/",
	"title": "Derechos de autor y atribuciones",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n The Documentation of Selenium Copyright \u0026copy; 2013-2020 , Software Freedom Conservancy.\nEvery effort has been made to make this documentation as complete and as accurate as possible, but no warranty or fitness is implied. The information provided is on an “as-is” basis. The authors and the publisher shall have neither liability nor responsibility to any person or entity with respect to any loss or damages arising from the information contained in this book. No patent liability is assumed with respect to the use of the information contained herein.\nAttributions Thanks to: Selenium Main Repository Selenium IDE Docker Selenium Selenium Website \u0026amp; Docs Previous Selenium Website Previous Documentation Rewrite Project Third-Party software used by Selenium documentation project:    Software Version License     Hugo v0.59.0 Apache 2.0   Hugo Learn Theme v2.4.0 MIT   Code Tabs Style \u0026mdash; MIT    License All code and documentation originating from the Selenium project is licensed under the Apache 2.0 license, with the Software Freedom Conservancy as the copyright holder.\nThe license is included here for convenience, but you can also find it on the Apache Foundation\u0026rsquo;s websites:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. "
},
{
	"uri": "https://www.selenium.dev/documentation/es/introduction/the_selenium_project_and_tools/",
	"title": "El proyecto Selenium y sus herramientas",
	"tags": [],
	"description": "",
	"content": "Selenium controla los navegadores web Selenium significa muchas cosas pero en su núcleo, es un conjunto de herramientas para la automatización de navegadores web que utiliza las mejores técnicas disponibles para controlar remotamente las instancias de los navegadores y emular la interacción del usuario con el navegador.\nPermite a los usuarios simular interacciones básicas realizadas por los usuarios finales; insertando texto en los campos, seleccionando valores de menús desplegables y casillas de verificación, y haciendo clics en los enlaces de los documentos. También provee muchos otros controles tales como el movimiento del mouse, la ejecución arbitraria de JavaScript, y mucho más.\nA pesar de que es usado principalmente para pruebas de front-end de sitios webs, Selenium es en esencia una librería de agente de usuario para el navegador. Las interfaces son ubicuas a su aplicación, lo que fomenta la composición con otras librerías para adaptarse a su propósito.\nUna interfaz para gobernarlos a todos Uno de los principios fundamentales del proyecto es permitir una interfaz común para todas las tecnologías de los (principales) navegadores. Los navegadores web son aplicaciones increíblemente complejas y de mucha ingeniería, realizando operaciones completamente diferentes pero que usualmente se ven iguales al hacerlo. Aunque el texto se presente con las mismas fuentes, las imágenes se muestren en el mismo lugar y los enlaces te llevan al mismo destino. Lo que sucede por debajo es tan diferente como la noche y el día. Selenium abstrae estas diferencias, ocultando sus detalles y complejidades a la persona que escribe el código. Esto le permite escribir varias líneas de código para realizar un flujo de trabajo complicado, pero estas mismas líneas se ejecutarán en Firefox, Internet Explorer, Chrome y los demás navegadores compatibles.\nHerramientas y soporte El diseño minimalista de Selenium le da la versatilidad para que se pueda incluir como un componente en otras aplicaciones. La infraestructura proporcionada debajo del catálogo de Selenium te da las herramientas para que puedas ensamblar tu grid de navegadores de modo que tus pruebas se puedan ejecutar en diferentes navegadores a través de diferente sistemas operativos y plataformas.\nImagina un banco de computadores en tu sala de servidores o en un centro de datos, todos ejecutando navegadores al mismo tiempo e interactuando con los enlaces en tu sitio web, formularios, y tablas—probando tu aplicación 24 horas al día. A través de la sencilla interfaz de programación proporcionada para los lenguajes más comunes, estas pruebas se ejecutarán incansablemente en paralelo, reportando cuando ocurran errores.\nEs un objetivo ayudar a que esto sea una realidad para ti, proporcionando a los usuarios herramientas y documentación para controlar no solo los navegadores pero también para facilitar la escalabilidad e implementación de tales grids.\nQuien utiliza Selenium Muchas de las empresas más importantes del mundo han adoptado Selenium para sus pruebas basadas en navegador, a menudo reemplazando esfuerzos de años que involucran otras herramientas propietarias. A medida que ha crecido en popularidad, también se han multiplicado sus requisitos y desafíos.\nA medida que la web se vuelve más complicada y se agregan nuevas tecnologías a los sitios web, la misión de este proyecto es mantenerse al día con ellos siempre que sea posible. Siendo un proyecto de código abierto, este apoyo se sustenta a través de la donación generosa de tiempo de muchos voluntarios, cada uno de los cuales tiene un \u0026ldquo;trabajo diurno\u0026rdquo;.\nOtra misión del proyecto es alentar a más voluntarios a participar en este esfuerzo, y construir una comunidad fuerte para que el proyecto pueda seguir el ritmo de las tecnologías emergentes y seguir siendo una plataforma dominante para la automatización de pruebas funcionales.\nHistoria Cuando Selenium 1 fue lanzado en el año 2004, surgió por la necesidad de reducir el tiempo dedicado a verificar manualmente el comportamiento consistente en el front-end de una aplicación web. Hizo uso de las herramientas disponibles en ese momento y confió en gran medida en la inyección de JavaScript en la página web bajo prueba para emular la interacción de un usuario.\nSi bien JavaScript es una buena herramienta para permitirte la introspección de las propiedades del DOM y para hacer ciertas observaciones del lado del cliente que de otro modo no se podría hacer, se queda corto en la capacidad de replicar naturalmente las interacciones de un usuario como usar el mouse y el teclado.\nDesde entonces, Selenium ha crecido y ha madurado bastante, convirtiéndose en una herramienta ampliamente utilizada por muchas—o sino por la mayoría— de las organizaciones más grandes del mundo. Selenium ha pasado de ser de un kit de herramientas de automatización de pruebas de fabricación casera desarrollado en Thoughtworks para un público específico y un caso de uso específico, a la librería de facto de automatización de navegadores del mundo.\nAsí como Selenium RC hizo uso de las herramientas de oficio disponibles en ese momento, Selenium WebDriver impulsa esta tradición al llevar la parte de la interacción del navegador al territorio del proveedor del mismo y pedirles que se responsabilicen de las implementaciones de back-end orientadas al navegador. Recientemente este esfuerzo se ha convertido en un proceso de estandarización del W3C donde el objetivo es convertir el componente WebDriver en Selenium en la librería de control remoto du jour para agentes de usuario.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/getting_started/",
	"title": "Empezando",
	"tags": [],
	"description": "",
	"content": "Empezando Si eres nuevo con Selenium, tenemos una serie de recursos que te pueden ayudar a ponerte al día de inmediato\n Tour rápido  WebDriver IDE Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/understanding_the_components/",
	"title": "Entendiendo los componentes",
	"tags": [],
	"description": "",
	"content": "Construir una suite de test usando WebDriver requerirá que entiendas y uses de forma efectiva diferentes componentes. Como con todo en el desarrollo de software, la gente usa diferentes términos para la misma idea. A continuación hay un desglose de cómo los términos son usados en esa descripción.\nTerminología  API: Interfaz de Programación de Aplicaciones. Es un conjunto de \u0026ldquo;comandos\u0026rdquo; que se utilizan para manipular el WebDriver. Library: Un módulo de código que contiene las APIs y el código necesario para implementarlos. Las librerías son específicas para cada lenguaje, por ejemplo ficheros .jar en Java, ficheros .dll para .NET, etc. Driver: El responsable de controlar el navegador actual. La mayoría de los drivers son creados por los vendors del navegador. Los Drivers son generalmente módulos ejecutables que corren en el sistema con el propio navegador, no en el sistema ejecutando la suite de test. (Aunque esos pueden ser el mismo sistema.) NOTE: Algunas personas se refieren a los drivers como proxies. Framework: Una librería adicional usada como un soporte para la suites de WebDriver. Estos frameworks pueden ser test frameworks como JUnit o NUnit. También pueden ser frameworks soportando lenguaje natural como Cucumber o Robotium. Los frameworks también pueden ser escritos y usados para cosas como la manipulación o configuración del sistema bajo la prueba, creación de datos, test oracles, etc  Las Partes y las Piezas Como mínimo, el WebDriver habla con un navegador a través del driver. La comunicación es bidireccional: el WebDriver pasa comandos al navegador a través del driver, y recive la información de vuelta por la misma ruta.\nEl driver es específico para el navegador, como es ChromeDriver para Chrome/Chromium de Google, GeckoDriver para Mozilla Firefox, etc. El driver corre en el mismo sistema que el browser. Esto puede, o no puede ser, el mismo sistema donde los tests se están ejecutando.\nEste simple ejemplo anterior es de comunicación directa. La comunicación con el navegador puede ser remota a través de Selenium Server o RemoteWebdriver. Éste último corre en el mismo sistema que el driver y el browser.\nLa comunicación remota puede también hacerse usando Selenium Server o Selenium Grid, ambos a su vez hablan con el driver en el sistema anfitrión.\nDónde encaja el Framework El WebDriver tiene un trabajo y solo un trabajo: comunicarse con el navegador a través de uno de los métodos nombrados. El WebDriver no tiene que saber nada sobre testing: no sabe cómo comparar cosas, asegurar un pass o fail, y ciertamente no sabe nada acerca de reportes o sobre la gramática Given/When/Then.\nAquí es donde varios frameworks entran en juego. Como mínimo neesitarás un framework de test que compare los enlaces de idiomas, por ejempolo NUnit para .NET, JUnit para Java, RSpec para Ruby, etc.\nEl framework de test es responsable de correr y ejecutar tu WebDriver y los pasos de tus tests. Como tal, puedes pensar que se parece a la siguiente imagen.\nLos frameworks o herramientas de lenguage natural como Cucumber pueden existir como parte de la caja de Test Framework de la figura de arriba, o envolver totalmente el Test Framework en su propia implementación.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/getting_started/quick/",
	"title": "Guía rápida",
	"tags": [],
	"description": "",
	"content": "Selenium no es solo una herramienta o API, sino que compone muchas herramientas.\nWebDriver Si está comenzando con la automatización de pruebas de sitios web de escritorio, entonces va a utilizar las API de WebDriver. WebDriver utiliza las API de automatización del navegador proporcionadas por los desarrolladores de los navegadores para controlar el navegador y ejecutar pruebas. Esto es como si un usuario real estuviera manipulando el navegador. Dado que el WebDriver no requiere que su API se compile con el código de la aplicación que va a probar, no es de naturaleza intrusiva. Por lo tanto, está probando la misma aplicación que está en vivo.\nIDE IDE (Integrated Development Environment) es la herramienta que usas para desarrollar tus casos de prueba con Selenium. Es una extensión para Chrome y Firefox muy sencilla de usar y es generalmente la forma mas eficiente de desarrollar casos de prueba. Esta graba las acciones del usuario en el navegador, usando los comandos existentes en Selenium, con parámetros definidos por el contexto de cada elemento. No solo sirve para ahorrar tiempo sino que también es una forma excelente de aprender la sintaxis de scripts de Selenium.\nGrid Selenium Grid te permite ejecutar casos de prueba en diferentes maquinas a través de diferentes plataformas. La gestión que desencadena las ejecuciones de los casos de prueba se realiza en la parte local, y cuando los casos de prueba se hayan disparado, automáticamente serán ejecutados en la parte remota.\nPoco después del desarrollo de las pruebas de WebDriver, es posible que deba ejecutar sus pruebas en múltiples combinaciones de navegador y sistema operativo. Aquí es donde Grid viene al rescate.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/selenium_installation/installing_selenium_libraries/",
	"title": "Instalando las librerías de Selenium",
	"tags": [],
	"description": "",
	"content": "Primero debes instalar las librerías de enlace Selenium para tu proyecto de automatización. El proceso de instalación de las librerías depende del lenguaje que elijas usar.\nJava La instalación de las librerías Selenium para Java se puede hacer usando Maven. Agrega la dependencia de selenium-java en el pom.xml de tu proyecto:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; La dependencia selenium-java permite la ejecución de tu proyecto de automatización en todos los navegadores compatibles con Selenium. Si quieres ejecutar pruebas en un navegador en específico, puedes agregar la dependencia para ese navegador en el archivo pom.xml. Por ejemplo, debes agregar la siguiente dependencia en tu archivo pom.xml para ejecutar tus pruebas solamente en Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; De igual manera, si quieres ejecutar las pruebas solamente en Chrome, debes agregar la siguiente dependencia:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python La instalación de las librerías de Selenium en Python se puede hacer usando pip:\npip install selenium Alternativamente, puedes descargar el archivo fuente PyPI (selenium-x.x.x.tar.gz) e instalarlo usando setup.py:\npython setup.py install C# La instalación de las librerías de Selenium para C# se puede hacer usando NuGet:\n# Usando el manejador de paquetess Install-Package Selenium.WebDriver # o usando el CLI de .Net dotnet add package Selenium.WebDriver Ruby La instalación de las librerías de Selenium para Ruby se puede hacer usando gem:\ngem install selenium-webdriver JavaScript La instalación de las librerías de Selenium para JavaScript se puede hacer usando npm:\nnpm install selenium-webdriver Kotlin Debido a la falta de librerías de enlace de idioma nativas para Kotlin, debe usar las de Java, p. ej. con Maven Java\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/page_object_models/",
	"title": "Modelos de objetos de página",
	"tags": [],
	"description": "",
	"content": "Page Object (objeto de página) es un patrón de diseño que se ha vuelto popular en la automatización de pruebas para mejorar el mantenimiento de las pruebas y reducir la duplicación de código. Un objeto de página es un clase orientada a objetos que sirve como interfaz para una página de tu AUT. Las pruebas luego usan los métodos de esta clase de objeto de página cuando lo necesitan para interactuar con la interfaz de usuario de esa página. El beneficio es que si la interfaz de usuario cambia para la página, las pruebas en sí mismas no necesitan cambiar, solo el código dentro del objeto de página necesita cambiar. Posteriormente, todos los cambios para soportar esa nueva interfaz de usuario están ubicados en un solo lugar.\nEl patrón de diseño de objetos de página ofrece las siguientes ventajas:\n Existe una separación clara entre el código de prueba y el código específico de la página, como localizadores (o su uso si está utilizando un mapa de interfaz de usuario) y diseño. Existe un único repositorio para los servicios u operaciones que ofrece la página en lugar de tener estos servicios dispersos a lo largo de las pruebas.  En ambos casos, esto permite cualquier modificación requerida debido a cambios en la interfaz de usuario puedan hacerse en un solo lugar. Puedes encontrar buena información sobre esta técnica en numerosos blogs, ya que este \u0026ldquo;patrón de diseño de prueba\u0026rdquo; se está utilizando ampliamente. Nosotros animamos al lector que desea saber más a buscar blogs en Internet al respecto.\nMuchos han escrito sobre este patrón de diseño y pueden proporcionar consejos útiles más allá del alcance de esta guía del usuario. Para empezar, sin embargo, ilustraremos objetos de página con un ejemplo simple.\nPrimero, considere un ejemplo, típico de la automatización de pruebas, que no utiliza un objeto de página:\n/*** * Prueba de la funcionalidad de inicio de sesión */ public class Login { public void testLogin() { // ingresa los datos de inicio de sesión en la página de inicio de sesión  driver.findElement(By.name(\u0026#34;user_name\u0026#34;)).sendKeys(\u0026#34;testUser\u0026#34;); driver.findElement(By.name(\u0026#34;password\u0026#34;)).sendKeys(\u0026#34;my supersecret password\u0026#34;); driver.findElement(By.name(\u0026#34;sign-in\u0026#34;)).click(); // verifica que la etiqueta h1 tiene el valor \u0026#34;Hello userName\u0026#34; después de iniciar sesión  driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).isDisplayed(); assertThat(driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).getText(), is(\u0026#34;Hello userName\u0026#34;)); } } Hay dos problemas con este enfoque.\n No hay separación entre el método de prueba y los localizadores del AUT (ID en este ejemplo); ambos están entrelazados en un solo método. Si la UI del AUT cambia sus identificadores, diseño o cómo se ingresa y procesa un inicio de sesión, la prueba en sí debe cambiar. Los localizadores de ID se distribuirían en múltiples pruebas, en todas las pruebas que debían usar esta página de inicio de sesión.  Aplicando las técnicas de objeto de página, este ejemplo podría reescribirse como en el siguiente ejemplo de un objeto de página para una página de inicio de sesión.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * El objeto de página encapsula la página de inicio de sesión. */ public class SignInPage { protected static WebDriver driver; // \u0026lt;input name=\u0026#34;user_name\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By usernameBy = By.name(\u0026#34;user_name\u0026#34;); // \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By passwordBy = By.name(\u0026#34;password\u0026#34;); // \u0026lt;input name=\u0026#34;sign_in\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;SignIn\u0026#34;\u0026gt;  private By signinBy = By.name(\u0026#34;sign_in\u0026#34;); public SignInPage(WebDriver driver){ this.driver = driver; } /** * Inicia sesión como un usuario válido * * @param userName * @param password * @return HomePage object */ public HomePage loginValidUser(String userName, String password) { driver.findElement(usernameBy).sendKeys(userName); driver.findElement(passwordBy).sendKeys(password); driver.findElement(signinBy).click(); return new HomePage(driver); } } y el objeto de página para una página de inicio podría verse así.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * El objeto de página encapsula la página de inicio */ public class HomePage { protected static WebDriver driver; // \u0026lt;h1\u0026gt;Hola userName\u0026lt;/h1\u0026gt;  private By messageBy = By.tagName(\u0026#34;h1\u0026#34;); public HomePage(WebDriver driver){ this.driver = driver; if (!driver.getTitle().equals(\u0026#34;Home Page of logged in user\u0026#34;)) { throw new IllegalStateException(\u0026#34;This is not Home Page of logged in user,\u0026#34; + \u0026#34; current page is: \u0026#34; + driver.getCurrentUrl()); } } /** * Get message (h1 tag) * * @return String message text */ public String getMessageText() { return driver.findElement(messageBy).getText(); } public HomePage manageProfile() { // Encapsulación de página para administrar la funcionalidad del perfil  return new HomePage(driver); } /* Mas métodos que ofrecen los servicios representados por la página de inicio del usuario registrado. Estos métodos a su vez podrían devolver más objetos de página, por ejemplo hacer clic en el botón Redactar correo podría devolver el objeto de clase ComposeMail */ } Entonces, la prueba de inicio de sesión usaría estos dos objetos de página de la siguiente manera.\n/*** * Prueba de la funcionalidad de inicio de sesión de pruebas */ public class TestLogin { @Test public void testLogin() { SignInPage signInPage = new SignInPage(driver); HomePage homePage = signInPage.loginValidUser(\u0026#34;userName\u0026#34;, \u0026#34;password\u0026#34;); assertThat(homePage.getMessageText(), is(\u0026#34;Hello userName\u0026#34;)); } } Hay mucha flexibilidad en cómo se pueden diseñar los objetos de página, pero hay algunas reglas básicas para obtener la mantenibilidad deseada de tu código de prueba.\nLos objetos de página en sí mismos nunca deben hacer verificaciones o afirmaciones. Esto es parte de tu prueba y siempre debe estar dentro del código de la prueba, nunca en una página objeto. El objeto de página contendrá la representación de la página, y el servicios que proporciona la página a través de métodos, pero ningún código relacionado con lo que se está probado debe estar dentro del objeto de la página.\nHay una verificación única que puede y debe estar dentro del objeto de página y eso es para verificar que la página, y posiblemente elementos críticos en la página, se cargaron correctamente. Esta verificación debe hacerse mientras se instancia el objeto de la página. En los ejemplos anteriores, tanto SignInPage como los constructores de HomePage verifican que la página esperada esté disponible y lista para las solicitudes de la prueba.\nUn objeto de página no necesariamente necesita representar una página completa. El patrón de diseño de objetos de pagina podría usarse para representar componentes en una página. Si la página en el AUT tiene múltiples componentes, puede mejorar la mantenibilidad si hay un objeto de página separado para cada componente.\nExisten otros patrones de diseño que también pueden usarse en las pruebas. Algunos usan un Page Factory para crear instancias de sus objetos de página. Discutir todo esto es más allá del alcance de esta guía del usuario. Aquí, simplemente queremos presentar los conceptos para que el lector tome conciencia de algunas de las cosas que se pueden hacer. Como fue mencionado anteriormente, muchos han blogueado sobre este tema y alentamos lector para buscar blogs sobre estos temas.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/getting_started_with_webdriver/browsers/",
	"title": "Navegadores",
	"tags": [],
	"description": "",
	"content": "Navegadores para el consumidor El framework de Selenium soporta oficialmente los siguientes navegadores:\n   Navegador Mantenedor Versiones Soportadas     Chrome Chromium Todas las Versiones   Firefox Mozilla 54 y más recientes   Internet Explorer Selenium 6 y más recientes   Opera Opera Chromium / Presto 10.5 y más recientes   Safari Apple 10 y más recientes    Navegadores especializados También hay un conjunto de navegadores especializados utilizados típicamente en entornos de desarrollo. Podemos utilizar algunos de estos navegadores para fines de automatización, y Selenium proporciona apoyo a los siguientes controladores especializados:\n   Nombre del Controlador Prepósito Mantenedor     HtmlUnitDriver Emulador de navegador headless respaldado por Rhino Proyecto Selenium    "
},
{
	"uri": "https://www.selenium.dev/documentation/es/grid/purposes_and_main_functionalities/",
	"title": "Objetivos y funcionalidades principales",
	"tags": [],
	"description": "",
	"content": " Punto de entrada centralizado para todos los tests Gestión y control de los nodos / entornos donde se ejecutan los navegadores Escalado Ejecución de los tests en paralelo Testing cruzado entre diferentes sistemas operativos Balanceo de carga  "
},
{
	"uri": "https://www.selenium.dev/documentation/es/legacy_docs/selenium_rc/",
	"title": "Selenium 1 (Selenium RC)",
	"tags": [],
	"description": "",
	"content": "Introducción Selenium RC fue el principal proyecto de Selenium durante mucho tiempo, antes de que la union de WebDriver/Selenium resultaran en Selenium 2, una herramienta más poderosa. Vale la pena resaltar que Selenium 1 ya no es soportado.\nComo funciona Selenium RC Primero, describiremos cómo funcionan los componentes de Selenium RC y el papel que desempeña cada uno en la ejecución tus scripts de prueba.\nComponentes de RC Los componentes de Selenium RC son:\n El servidor Selenium que inicia y finaliza navegadores, interpreta y ejecuta los comandos Selenese pasados del programa de prueba, y actúa como un proxy HTTP, interceptando y verificando los mensajes HTTP pasados entre el navegador y el AUT. Librerías de clientes que proporcionan la interfaz entre cada lenguaje de programación y Selenium RC Server.  Aquí hay un diagrama simplificado de la arquitectura:\nEl diagrama muestra que las librerías del cliente se comunican con el el servidor pasando cada comando Selenium para su ejecución. Entonces el servidor pasa el comando Selenium al navegador utilizando los comandos JavaScript de Selenium-Core. El navegador, utilizando su intérprete de JavaScript, ejecuta el comando Selenium. Esta ejecuta la acción o verificación de Selenese que especificas en tu script de prueba.\nSelenium Server Selenium Server recibe comandos de Selenium de tu programa de prueba, los interpreta e informa a tu programa los resultados de ejecutar esas pruebas.\nEl servidor RC agrupa Selenium Core y automáticamente lo inyecta en el navegador. Esto ocurre cuando tu programa de prueba abre el navegador (utilizando una función del API de la librería del cliente). Selenium-Core es un programa de JavaScript, en realidad un conjunto de funciones JavaScript que interpretan y ejecutan comandos Selenese utilizando el intérprete de JavaScript incorporado en el navegador.\nEl servidor recibe los comandos Selenese de tu programa de prueba utilizando simples solicitudes HTTP GET/POST. Esto significa que puedes usar cualquier lenguaje de programación que pueda enviar solicitudes HTTP para automatizar pruebas de Selenium en el navegador.\nLibrerías de Clientes Las librerías del cliente proporcionan el soporte de programación que te permiten ejecutar comandos Selenium desde un programa de tu propio diseño. Hay una librería cliente diferente para cada lenguaje compatible. Una librería cliente de Selenium proporciona una interfaz de programación (API), es decir, un conjunto de funciones, que ejecuta comandos de Selenium desde tu propio programa. Dentro de cada interfaz, hay una función de programación que soporta cada comando de Selenese.\nLa librería del cliente toma un comando Selenese y lo pasa al servidor Selenium para procesar una acción o prueba específica contra la aplicación bajo prueba (AUT). La librería del cliente también recibe el resultado de ese comando y lo devuelve a tu programa. Tu programa puede recibir el resultado y almacenarlo en una variable del programa e informarlo como un éxito o un fracaso, o posiblemente tomar medidas correctivas si fue un error inesperado.\nEntonces, para crear un programa de prueba, simplemente escribe un programa que ejecute un conjunto de comandos de Selenium utilizando una API de la librería del cliente. Y, opcionalmente, si ya tienes un script de prueba Selenese creado en Selenium-IDE, puedes generar el código Selenium RC. Selenium-IDE puede traducir (utilizando los elementos del menú Exportar) tus comandos Selenium en las llamadas a la función API de un cliente-controlador. Consulta el capítulo Selenium-IDE para obtener información específica sobre la exportación de código RC de Selenium-IDE.\nInstalación La instalación es más bien un nombre inapropiado para Selenium. Selenium tiene un conjunto de librerías disponibles en el lenguaje de programación que elijas. Puedes descargarlos desde la pagina de descarga.\nUna vez que hayas elegido un lenguaje para trabajar, simplemente necesitas:\n Instalar el servidor Selenium RC. Configurar un proyecto de programación utilizando un controlador de cliente específico del lenguaje.  Instalando Selenium Server El servidor Selenium RC es simplemente un archivo Java jar (selenium-server-standalone-.jar), que no requiere una instalación especial. Simplemente descargando el archivo zip y extrayendo el servidor en el directorio deseado es suficiente.\nEjecutando Selenium Server Antes de comenzar cualquier prueba, debes iniciar el servidor. Ve al directorio donde se encuentra el servidor de Selenium RC y ejecuta lo siguiente desde una consola línea de comandos.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar Esto se puede simplificar creando un archivo ejecutable batch o shell (.bat en Windows y .sh en Linux) que contiene el comando anterior. Luego haz un acceso directo a ese ejecutable en tu escritorio y simplemente haz doble clic en el icono para iniciar el servidor.\nPara que el servidor se ejecute, necesitarás Java instalado y la variable de entorno PATH configurada correctamente para ejecutarla desde la consola. Puedes verificar que tienes Java instalado correctamente ejecutando lo siguiente en una consola\njava -version Si obtienes un número de versión (que debe ser 1.5 o posterior), estás listo para comenzar a usar Selenium RC.\nUtilizando el controlador de cliente Java  Descarga el zip del controlador del cliente Java de Selenium desde SeleniumHQ página de descargas. Extrae el archivo selenium-java-.jar Abra tu IDE de Java deseado (Eclipse, NetBeans, IntelliJ, Netweaver, etc.) Crea un proyecto java. Agregaa los archivos selenium-java-.jar a tu proyecto como referencias. Agrega a tu classpath de proyecto el archivo selenium-java-jar. Desde Selenium-IDE, exporta un script a un archivo Java e inclúyelo en tu proyecto Java, o escribe tu prueba de Selenium en Java usando la API selenium-java-client. La API se presenta más adelante en este capítulo. Puedes usar JUnit o TestNg para ejecutar tu prueba, o puedes escribir tu propio programa main() simple. Estos conceptos son explicados más adelante en esta sección. Ejecuta el servidor Selenium desde la consola. Ejecuta tu prueba desde el IDE de Java o desde la línea de comandos.  Para obtener detalles sobre la configuración del proyecto de prueba Java, consulta las secciones del Apéndice: Configuración de Selenium RC con Eclipse y Configuración de Selenium RC con IntelliJ.\nUtilizando el controlador de cliente Python  Instala Selenium via PIP, las instrucciones están en SeleniumHQ pagina de descargas Escribe tu prueba de Selenium en Python o exporta un script de Selenium-IDE a un archivo de Python. Ejecuta el servidor Selenium desde la consola. Ejecuta tu prueba desde una consola o tu IDE de Python.  Para obtener detalles sobre la configuración del controlador del cliente Python, consulte el Apéndice: Configuración del controlador del cliente Python.\nUtlizando el Controlador de Cliente .NET  Descarga Selenium RC desde SeleniumHQ página de descargas Extrae la carpeta Descargua e instala NUnit (Nota: Puedes usar NUnit como tu motor de prueba. Si aún no estás familiarizado con NUnit, también puedes escribir una función main() simple para ejecutar tus pruebas; sin embargo, NUnit es muy útil como motor de prueba). Abre tu IDE .Net deseado (Visual Studio, SharpDevelop, MonoDevelop) Crea una biblioteca de clases (.dll) Agrega referencias a las siguientes DLL: nmock.dll, nunit.core.dll, nunit. framework.dll, ThoughtWorks.Selenium.Core.dll, ThoughtWorks.Selenium.IntegrationTests.dll y ThoughtWorks.Selenium.UnitTests.dll Escribe tu prueba de Selenium en un lenguaje .Net (C #, VB.Net), o exporta un script de Selenium-IDE a un archivo C# y copia este código en el archivo de clase acabas de crear. Escribe tu propio programa main() simple o puedes incluir NUnit en tu proyecto para ejecutar tu prueba. Estos conceptos se explican más adelante en este capítulo. Ejecuta el servidor Selenium desde la consola Ejecuta tu prueba desde el IDE, desde la GUI de NUnit o desde la línea de comandos.  Para obtener detalles específicos sobre la configuración del controlador del cliente .NET con Visual Studio, consulte el apéndice Configuración del controlador del cliente .NET\nUtilizando el Controlador de Cliente Ruby  Si aún no tiene RubyGems, instálalo desde RubyForge. Ejecuta gem install selenium-client En la parte superior de tu script de prueba, agrega require \u0026quot;selenium/client\u0026quot; Escribe tu script de prueba usando cualquier arnés de prueba Ruby (por ejemplo, Test::Unit Mini::Test o RSpec). Ejecuta el servidor Selenium RC desde la consola. Ejecuta tu prueba de la misma manera que ejecutarías cualquier otro script de Ruby.  Para obtener detalles sobre la configuración del controlador del cliente Ruby, consulta la Documentación de Selenium-Client_\nDe Selenese a un Programa La tarea principal para usar Selenium RC es convertir tu Selenese en un lenguaje de programación. En esta sección, proporcionamos varios ejemplos lenguaje-específico diferentes.\nMuestra de un Script de prueba Comencemos con un ejemplo de un script de prueba de Selenese. Imagina grabar la siguiente prueba con Selenium-IDE.\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     Nota: este ejemplo funcionaría con la página de búsqueda de Google http://www.google.com\nSelenese Como Código de Programación Aquí está el script de prueba exportado (a través de Selenium-IDE) a cada uno de los lenguajes de programación soportados. Si tienes al menos un conocimiento básico de un lenguaje de programación orientado a objetos, comprenderás cómo Selenium ejecuta comandos Selenese leyendo uno de estos ejemplos. Para ver un ejemplo en un lenguaje específico, seleccione uno de estos botones.\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } } Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt; Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end En la siguiente sección explicaremos cómo construir un programa de prueba usando el código generado.\nProgramando Tu Prueba Ahora ilustraremos cómo programar tus propias pruebas usando ejemplos en cada uno de las lenguajes de programación compatibles. Hay esencialmente dos tareas:\n Generar tu script a un lenguaje de programación desde Selenium-IDE, opcionalmente modificando el resultado. Escribir un programa principal muy simple que ejecute el código generado.  Opcionalmente, puedes adoptar una plataforma de prueba como JUnit o TestNG para Java, o NUnit para .NET si estás utilizando uno de esos lenguajes.\nAquí, mostramos ejemplos específicos del lenguaje. Las API específicas del lenguaje tienden a diferir uno de otro, por lo que encontrarás una explicación separada para cada uno.\n Java C# Python Ruby Perl, PHP  Java Para Java, las personas utilizan JUnit o TestNG como plataforma de prueba. Algunos entornos de desarrollo como Eclipse tienen soporte directo para estos a través de complementos. Esto lo hace aún más fácil. Enseñar JUnit o TestNG está más allá del alcance de este documento, sin embargo, los materiales se pueden encontrar en línea y hay publicaciones disponibles. Si ya eres una \u0026ldquo;tienda de Java\u0026rdquo;, es probable que tus desarrolladores lo hagan ya tengan algo de experiencia con uno de estos frameworks de prueba.\nProbablemente desees cambiar el nombre de la clase de prueba de \u0026ldquo;NewTest\u0026rdquo; a algo de tu propia elección. Además, deberás cambiar los parámetros abrir-navegador en la declaración:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); El código generado por Selenium-IDE se verá así. Este ejemplo tiene comentarios agregados manualmente para mayor claridad.\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# El .NET Client Driver funciona con Microsoft.NET. Se puede usar con cualquier framework de prueba .NET como NUnit o Visual Studio 2005 Team System.\nSelenium-IDE asume que usará NUnit como framework de prueba. Puedes ver esto en el código generado a continuación. Incluye la declaración using para NUnit junto con los atributos de NUnit correspondientes que identifican el rol de cada función miembro de la clase de prueba.\nProbablemente desees cambiar el nombre de la clase de prueba de \u0026ldquo;NewTest\u0026rdquo; a algo de tu propia elección. Además, deberás cambiar los parámetros abrir-navegador en la declaración:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); El codigo generado se vera similar a esto.\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } } Puedes permitir que NUnit gestione la ejecución de tus pruebas. O, alternativamente, puedes escribir un simple programa main() que crea una instancia del objeto de prueba y ejecuta cada uno de los tres métodos, SetupTest(), TheNewTest() y TeardownTest() a su vez.\nPython Pyunit es el framework de prueba para usar en Python.\nLa estructura de una prueba básica es:\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Las versiones anteriores (anteriores a 2.0) de Selenium-IDE generan código Ruby que requiere el antiguo gem de Selenium. Por lo tanto, es recomendable actualizar cualquier script Ruby generado por IDE de la siguiente manera:\n  En la línea 1, cambia require \u0026quot;selenium\u0026quot; a require \u0026quot;selenium/client\u0026quot;\n  En la línea 11, cambia Selenium::SeleniumDriver.new a Selenium::Client::Driver.new\n  Probablemente también quieras cambiar el nombre de la clase a algo más informativo que \u0026ldquo;Sin título\u0026rdquo;, y cambiar el nombre del método de prueba a algo diferente de \u0026ldquo;test_untitled\u0026rdquo;.\nAquí hay un ejemplo simple creado al modificar el código Ruby generado por Selenium IDE, como se describió anteriormente.\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP Los miembros del equipo de documentación. no han utilizado Selenium RC con Perl o PHP. Si estás utilizando Selenium RC con cualquiera de estos dos lenguajes, póngase en contacto con el equipo de documentación (consulta el capítulo sobre contribuciones). Nos encantaría incluir algunos ejemplos tuyos y de tus experiencias, para apoyar a los usuarios de Perl y PHP.\nAprendiendo el API La API de Selenium RC utiliza convenciones de nomenclatura suponiendo que entiendes a Selenese, gran parte de la interfaz se explicará por sí misma. Aquí, sin embargo, explicamos los aspectos más críticos y posiblemente menos obvios.\nIniciando el Navegador CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start Cada uno de estos ejemplos abre el navegador y representa ese navegador asignando una \u0026ldquo;instancia del navegador\u0026rdquo; a una variable de programa. Esta variable de programa se utiliza entonces para llamar a los métodos desde el navegador. Estos métodos ejecutan los comandos de Selenium, es decir, comandos como open o type o verify.\nLos parámetros necesarios al crear la instancia del navegador son:\n  host Especifica la dirección IP de la computadora donde se encuentra el servidor. Por lo general, esta es la misma máquina donde se ejecuta el cliente, por lo que en este caso se pasa localhost. En algunos clientes, este es un parámetro opcional.\n  port Especifica el socket TCP/IP donde el servidor está escuchando y esperando que el cliente establezca una conexión. Esto también es opcional en algunos controladores de clientes.\n  browser El navegador en el que deseas ejecutar las pruebas. Este es un parámetro requerido.\n  url La url base de la aplicación bajo prueba. Esto es requerido por todos las librerías de cliente y es información integral para iniciar la comunicación navegador-proxy-AUT.\n  Ten en cuenta que algunas de las librerías de cliente requieren que el navegador se inicie explícitamente llamando a su método start().\nEjecutando Comandos Una vez que tienes el navegador inicializado y asignado a una variable (generalmente llamada \u0026ldquo;Selenium\u0026rdquo;) puedes hacer que ejecute comandos Selenese llamando los métodos respectivos de la variable del navegador. Por ejemplo, para llamar al método type del objeto Selenium:\nselenium.type(\u0026#34;field-id\u0026#34;,\u0026#34;string to type\u0026#34;) En segundo plano, el navegador realmente realizará una operación type, esencialmente idéntica a la entrada de un usuario escribiendo en el navegador, utilizando el localizador y la cadena que especificaste durante la llamada al método.\nReportando Resultados Selenium RC no tiene su propio mecanismo para reportar resultados. Más bien, te permite crear tus reportes personalizados según tus necesidades utilizando las funciones de tu lenguaje de programación elegido. Eso es genial, pero ¿y si simplemente quieres algo rápido que ya está hecho para ti? A menudo, una librería existente o un framework de prueba puede satisfacer tus necesidades más rápido que desarrollar tu propio código de reportes de prueba.\nHerramientas de Reportes del Framework de Prueba Los frameworks de prueba están disponibles para muchos lenguajes de programación. Estos, junto con su función principal de proporcionar un motor de prueba flexible para ejecutar tus pruebas, tambien incluyen código de librerías para reportar resultados. Por ejemplo, Java tiene dos frameworks de prueba de uso común, JUnit y TestNG. .NET también tiene el suyo, NUnit.\nAquí no enseñaremos los frameworks por sí mismos; eso está más allá del alcance de esta guía del usuario. Simplemente presentaremos las características del framework que se relacionan con Selenium junto con algunas técnicas que puedes aplicar. Hay buenos libros disponibles sobre estos frameworks prueba junto con su información en internet.\nLibrerías de Reportes de Pruebas También están disponibles las librerías de terceros creadas específicamente para generar los reportes de las pruebas en el lenguaje de programación elegido. Estos a menudo sportan una variedad de formatos como HTML o PDF.\nCuál Es El Mejor Enfoque? La mayoría de las personas cuando son nuevas en los frameworks de prueba comenzarán con las funciones de reporteria integradas en el framework. A partir de ahí, la mayoría examinará las librerías disponibles, ya que requiere menos tiempo que desarrollar una propia. Cuando comiences a usar Selenium, sin duda comenzarás a poner tus propias \u0026ldquo;declaraciones impresas\u0026rdquo; para reportar sobre el progreso. Eso puede llevarte gradualmente a desarrollar tus propios reportes, posiblemente en paralelo al uso de una librería o framework de prueba. De todos modos, después de la curva de aprendizaje inicial, naturalmente desarrollarás lo que funciona mejor para tu propia situación.\nEjemplos de Reportes de Pruebas Para ilustrarlte, te guiaremos a algunas herramientas específicas en algunos de los lenguajes soportados por Selenium. Los que se enumeran aquí son de uso común y los autores de esta guía los han usado ampliamente (y, por lo tanto, los recomiendan).\nReportes de Pruebas en Java   Si los casos de prueba de Selenium se desarrollan utilizando JUnit, se puede utilizar JUnit Report para generar reportes de prueba.\n  Si los casos de prueba de Selenium se desarrollan usando TestNG, entonces no se necesita ninguna tarea externa para generar reportes de prueba. El framework de TestNG genera un reporte HTML que enumera los detalles de las pruebas.\n  ReportNG es un complemento de reportes HTML para el framework de TestNG. Está destinado a reemplazar el reporte HTML predeterminado de TestNG. ReportNG proporciona una vista simple y codificada por colores de los resultados de las pruebas.\n  Registrar los Comandos Selenese  Logging Selenium se puede utilizar para generar un reporte de todos los comandos de Selenese en tu prueba junto con el resultado exitoso o no de cada uno. Logging Selenium extiende el controlador del cliente Java para agregar esta capacidad de registro de Selenese.  Reportes de Pruebas para Python  Al utilizar Python Client Driver, HTMLTestRunner se puede utilizar para generar un reporte de prueba.  Reportes de Pruebas para Ruby  Si el framework RSpec se utiliza para escribir los casos de prueba de Selenium en Ruby, entonces su reporte HTML se puede utilizar para generar un reporte de prueba.  Agregando Sabor a Tus Pruebas Ahora llegaremos a la razón de por que utilizar Selenium RC, agregando lógica de programación a tus pruebas. Es lo mismo que para cualquier programa. El flujo del programa se controla mediante declaraciones de condición e iteración. Además, puedes reportar la información de progreso mediante I/O. En esta sección mostraremos algunos ejemplos de cómo las construcciones del lenguaje de programación se pueden combinar con Selenium para resolver problemas comunes en las pruebas.\nEncontrarás que a medida que transicionas de pruebas simples como la existencia de elementos en una página, a pruebas de funcionalidad dinámica que involucran múltiples páginas web y datos variables, que vas a necesitar la lógica de programación para verificar los resultados esperados. Básicamente, Selenium-IDE no soporta declaraciones estándar de iteracion y de condición. Puede hacer algunas condiciones incrustando JavaScript en los parámetros Selenese, sin embargo la iteración es imposible, y la mayoría de las condiciones serán mucho más fáciles en un lenguaje de programación. Además, es posible que necesites manejo de excepciones para errores de recuperación. Por esta y otras razones, hemos escrito esta sección para ilustrar el uso de técnicas comunes de programación para brindarte mayor \u0026lsquo;poder de verificación\u0026rsquo; en tus pruebas automatizadas.\nLos ejemplos en esta sección están escritos en C # y Java, aunque el código es simple y se puede adaptar fácilmente otros lenguajes soportados. Si tienes algún conocimiento básico de un lenguaje de programación orientado a objetos no deberías tener dificultades para comprender esta sección.\nIteración La iteración es una de las cosas más comunes que las personas necesitan hacer en sus pruebas. Por ejemplo, es posible que desees ejecutar una búsqueda varias veces. O tal vez para verificar los resultados de las pruebas debs procesar un \u0026ldquo;conjunto de resultados\u0026rdquo; retornado por una base de datos.\nUtilizando el mismo ejemplo anterior de la búsqueda en Google, vamos a verificar los resultados de la búsqueda de Selenium. Esta prueba podría usar Selenese:\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     El código se ha repetido para ejecutar 3 veces los mismos pasos. Pero varias copias del mismo código no es una buena práctica de programacion ya que es más difícil de mantener. Al usar un lenguaje de programación, podemos iterar sobre los resultados de las búsquedas para obtener una solución más flexible y fácil de mantener.\nEn C# // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); } Declaraciones de Condición Para ilustrar el uso de condiciones en las pruebas comenzaremos con un ejemplo. Un problema común encontrado al ejecutar las pruebas de Selenium ocurre cuando un elemento esperado no está disponible en la página. Por ejemplo, al ejecutar la siguiente línea:\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); Si el elemento \u0026lsquo;q\u0026rsquo; no está en la pagina entonces se lanza una excepción:\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found Esto puede hacer que tu prueba sea abortada. Para algunas pruebas eso es lo que quieres. Pero a menudo eso no es deseable ya que tu script de prueba tiene que ejecutar posteriormente muchas otras pruebas.\nUn mejor enfoque es validar primero si el elemento está realmente presente y luego tomar alternativas cuando no lo está. Observemos esto utilizando Java.\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } La ventaja de este enfoque es que continua con la ejecución de la prueba, incluso si algunos elementos de la interfaz de usuario no están disponibles en la página.\nEjecutando JavaScript Desde tus Pruebas JavaScript es muy útil para utilizar una aplicación que no es directamente compatible con Selenium. El método getEval de Selenium API se puede utilizar para ejecutar JavaScript desde Selenium RC.\nConsidera una aplicación que tiene casillas de verificación sin identificadores estáticos. En este caso, uno podría evaluar JavaScript desde Selenium RC para obtener los identificadores de todas las casillas de verificación y luego utilizarles.\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } Para contar el número de imágenes en una página:\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); Recuerde usar un objeto window en caso de expresiones DOM ya que por defecto se hace referencia a la ventana de Selenium, no a la ventana de prueba.\nOpciones del Servidor Cuando se inicia el servidor,se pueden utilizar opciones de línea de comando para cambiar el comportamiento predeterminado del servidor.\nRecuerda, el servidor se inicia ejecutando lo siguiente.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar To see the list of options, run the server with the -h option.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h Verás una lista de todas las opciones que puedes utilizar con el servidor y un breve descripción de cada una. Las descripciones proporcionadas no siempre serán suficientes, así que hemos proporcionado explicaciones para algunas de las opciones más importantes.\nConfiguración del Proxy Si tu AUT está detrás de un proxy HTTP que requiere autenticación, entonces deberías configurar http.proxyHost, http.proxyPort, http.proxyUser y http.proxyPassword usando el siguiente comando.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password Modo Multi-Window Si estás utilizando Selenium 1.0, probablemente puedas omitir esta sección, ya que el modo de ventanas múltiples es el comportamiento predeterminado. Sin embargo, antes de la versión 1.0, Selenium ejecutaba la aplicación bajo prueba en un sub-marco como se muestra aquí:\nAlgunas aplicaciones no se ejecutaban correctamente en un sub-marcoo y debían ser cargadas en el marco superior de la ventana. La opción modo de ventana múltiple permitia al AUT ejecutarse en una ventana separada en lugar de en el marco predeterminado donde entonces podía tener el marco superior requerido.\nPara versiones anteriores de Selenium, debes especificar explícitamente el modo de ventanas múltiples con la siguiente opción:\n-multiwindow A partir de Selenium RC 1.0, si deseas ejecutar tu prueba dentro de un marco único (es decir, utilizando el estándar para versiones anteriores de Selenium) puedes indicar esto al servidor Selenium utilizando la opción\n-singlewindow Especificando el Perfil de Firefox Firefox no ejecutará dos instancias simultáneamente a menos que especifiques un perfil separado para cada instancia. Selenium RC 1.0 y posteriores se ejecutan en un perfil separado automáticamente, por lo que si estás utilizando Selenium 1.0, probablemente puedes omitir esta sección. Sin embargo, si estás utilizando una versión anterior de Selenium o si necesitas usar un perfil específico para tus pruebas (como agregar un certificado https o tener algunos complementos instalados), necesitas especificar explícitamente el perfil.\nPrimero, para crear un perfil separado de Firefox, sigue este procedimiento. Abre el menú Inicio de Windows, seleccione \u0026ldquo;Ejecutar\u0026rdquo;, luego escriba e ingrese uno de los siguientes:\nfirefox.exe -profilemanager firefox.exe -P Crea el nuevo perfil utilizando el cuadro de diálogo. Luego, cuando ejecutes Selenium Server, especificale que use este nuevo perfil de Firefox con la opción de línea de comandos del servidor -firefoxProfileTemplate y especifique la ruta del perfil utilizando el nombre del archivo y la ruta del directorio.\n-firefoxProfileTemplate \u0026#34;ruta del perfil\u0026#34; Advertencia: Asegúrate de poner tu perfil en una nueva carpeta separada de la predeterminada. La herramienta de administrador de perfiles de Firefox eliminará todos los archivos de una carpeta si eliminas un perfil, independientemente de si son archivos de perfil o no.\nPuedes encontrar más información sobre los perfiles de Firefox en la Base de conocimiento de Mozilla\nEjecuta Selenese Directamente Dentro del Servidor Utilizando -htmlSuite Puedes ejecutar archivos html de Selenese directamente dentro del servidor Selenium pasando el archivo html a la línea de comandso del servidor. Por ejemplo:\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; Esto iniciará automáticamente tu suite HTML, ejecutará todas las pruebas y guardará un bonito reporte HTML con los resultados.\nNota: Al usar esta opción, el servidor comenzará las pruebas y esperará un número especificado de segundos a que la prueba se complete; si la prueba no se completa dentro de ese período de tiempo, el comando saldrá con un código distinto de cero y no se generará ningún reporte de resultados.\nEsta línea de comandos es muy larga, así que ten cuidado cuando la escribas. Ten en cuenta que esto requiere que pases una suite HTML Selenese, no una sola prueba. También ten en cuenta que la opción -htmlSuite es incompatible con -interactive No puedes ejecutar ambas al mismo tiempo.\nRegistros de Selenium Server Registros del Lado del servidor Al iniciar el servidor de Selenium, la opción -log puede usarse para grabar informaciónes valiosas de depuración reportadas por el servidor Selenium a un archivo de texto.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log Este archivo de registro es más detallado que los registros de consola estándar(incluye mensajes de registro de nivel DEBUG). El archivo de registro también incluye el nombre del registrador y la ID del número del hilo que registró el mensaje. Por ejemplo:\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW El formato del mensaje es\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE Este mensaje puede ser de multiples lineas.\nRegistros del Lado del Navegador JavaScript en el lado del navegador (Selenium Core) también registra mensajes importantes; en muchos casos, estos pueden ser más útiles para el usuario final que los registros normales de Selenium Server. Para acceder a los registros del lado del navegador, pase el argumento -browserSideLog al servidor Selenium.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog debe combinarse con el argumento -log, para registrar browserSideLogs (así como todos los demás mensajes de registro de nivel DEBUG) en un archivo.\nEspecificando la Ruta a un Navegador Específico Puede especificarle a Selenium RC una ruta a un navegador específico. Esto es útil si tienes diferentes versiones del mismo navegador y deseas utilizar una en específico. Además, esto se utiliza para permitir que tus pruebas se ejecuten en un navegador no directamente apoyado por Selenium RC. Al especificar el modo de ejecución, use el especificador *custom seguido de la ruta completa al ejecutable del navegador:\n*custom \u0026lt;ruta al navegador\u0026gt; Arquitectura de Selenium RC Nota: Este tema trata de explicar la implementación técnica detrás de Selenium RC. No es fundamental para un usuario de Selenium saber esto, pero podría ser útil para comprender algunos de los problemas que pueda encontrar en el futuro.\nPara comprender en detalle cómo funciona Selenium RC Server y por qué utiliza la inyección proxy y modos aumentados de privilegios, primero debes entender la politica del mismo origen_.\nLa Política del Mismo Origen La principal restricción que enfrenta Selenium es la politica del mismo origen. Todos los navegadores en el mercado aplican esta restricción de seguridad y su objetivo es asegurar que el contenido de un sitio nunca sera accesible por un script desde otro sitio. La Política del Mismo Origen dicta que cualquier código cargado dentro de un navegador solo puede operar dentro del dominio de ese sitio web. No puede realizar funciones en otro sitio web. Entonces, por ejemplo, si el navegador carga el código JavaScript cuando carga www.mysite.com, no puede ejecutar ese código cargado contra www.mysite2.com, incluso si ese es otro de tus sitios. Si esto fuera posible, un script colocado en cualquier sitio web que abras podría leer información sobre tu cuenta bancaria si tuviera la página de la cuenta abierta en otra pestaña. Esto se llama XSS (Cross-site Scripting).\nPara trabajar dentro de esta política, Selenium-Core (y sus comandos JavaScript que hacen que ocurra toda la magia) debe colocarse en el mismo origen que la Aplicación Bajo prueba (misma URL).\nHistóricamente, Selenium-Core estaba limitado por este problema ya que se implementó en JavaScript Sin embargo, Selenium RC no está restringido por la Política del Mismo Origen. Su uso de Selenium Server como proxy evita este problema. Esencialmente, le dice al navegador quq está trabajando en un único sitio web \u0026ldquo;falso\u0026rdquo; que el servidor proporciona.\nNota: Puedes encontrar información adicional sobre este tema en paginas Wikipedia sobre la Política del mismo origen y XSS.\nInyección de Proxy El primer método utilizado por Selenium para evitar la Política del Mismo Origen fue la Inyección de Proxy. En el modo de inyección de proxy, el servidor Selenium actúa como un proxy HTTP configurado por el cliente1, que se encuentra entre el navegador y la aplicación bajo prueba 2. Luego enmascara el AUT bajo una URL ficticia (incrustando Selenium- Core y el conjunto de pruebas y entregandolas como si vinieran del mismo origen).\nAquí hay un diagrama arquitectónico.\nCuando comienza un conjunto de pruebas en tu lenguaje favorito, sucede lo siguiente:\n El cliente/controlador establece una conexión con el servidor selenium-RC. El servidor Selenium RC inicia un navegador (o reutiliza uno antiguo) con una URL que inyecta el JavaScript de Selenium-Core en la página webcargada por el navegador. El controlador de cliente pasa un comando Selenese al servidor. El servidor interpreta el comando y luego activa la ejecucion JavaScript correspondiente para ejecutar ese comando dentro del navegador. Selenium-Core indica al navegador que actúe según esa primera instrucción, normalmente abriendo una página del AUT. El navegador recibe la solicitud abierta y solicita el contenido proxy HTTP para que lo use el navegador). El servidor Selenium RC se comunica con el servidor web solicitando la página y una vez lo recibe, envía la página al navegador enmascarando el origen para buscar como si la página viniera del mismo servidor que Selenium-Core (esto permite a Selenium-Core cumplir con la Política del mismo origen). El navegador recibe la página web y la muestra en el marco/ventana reservada para ello.  Navegadores con Privilegios Aumentados Este flujo de trabajo en este método es muy similar a la Inyección de Proxy pero la principal diferencia es que los navegadores se inician en un modo especial llamado Privilegios Aumentados, que permite a los sitios web hacer cosas que normalmente no están permitidas (como hacer XSS_ o llenar entradas de carga de archivos y cosas bastante útiles para Selenium). Al usar estos modos de navegador, Selenium Core puede abrir directamente el AUT y leer/interactúar con su contenido sin tener que pasar todo el AUT a través del servidor Selenium RC.\nAquí hay un diagrama arquitectónico.\nCuando comienza un conjunto de pruebas en tu lenguaje favorito, sucede lo siguiente:\n El cliente/controlador establece una conexión con el servidor Selenium-RC. El servidor Selenium RC inicia un navegador (o reutiliza uno antiguo) conuna URL eso cargará Selenium-Core en la página web. Selenium-Core obtiene la primera instrucción del cliente/controlador (a través de otra solicitud HTTP realizada al servidor Selenium RC) Selenium-Core actúa en esa primera instrucción, generalmente abriendo una página del AUT. El navegador recibe la solicitud de apertura y le pide al servidor web página. Una vez que el navegador recibe la página web, la muestra en el marco/ventana reservada para ello.  Manejo de HTTPS y Ventanas Emergentes de Seguridad Muchas aplicaciones cambian de HTTP a usar HTTPS cuando necesitan enviar información encriptada como contraseñas o informaciónes de tarjetas de crédito. Esto es común con muchas de las aplicaciones web actuales. Selenium RC apoya esto.\nPara garantizar que el sitio HTTPS sea genuino, el navegador necesitará un certificado de seguridad .De lo contrario, cuando el navegador acceda al AUT usando HTTPS, lo hará suponiendo que la aplicación no es \u0026ldquo;confiable\u0026rdquo;. Cuando esto ocurre, el navegador muestra ventanas emergentes de seguridad, y estas ventanas emergentes no se pueden cerrar con Selenium RC.\nCuando se trata de HTTPS en una prueba de Selenium RC, debes usar un modo de ejecución que lo admita y maneje el certificado de seguridad por ti. Especificas el modo de ejecución cuando tu programa de prueba inicializa Selenium.\nEn Selenium RC 1.0 beta 2 y posteriores, utiliza *firefox o *iexplore para el modo de ejecución. En versiones anteriores, incluida Selenium RC 1.0 beta 1, utiliza *chrome o *iehta, para el modo de ejecución. Con estos modos de ejecución, no necesitarás instalar ningun certificado de seguridad especial; Selenium RC lo manejará por ti.\nEn la versión 1.0, los modos de ejecución *firefox o *iexplore son recomendados. Sin embargo, hay modos de ejecución adicionales de *iexploreproxy y *firefoxproxy. Estos se proporcionan solo para compatibilidad con versiones anteriores, y no deben usarse a menos que lo requieran los programas de prueba heredados. Su uso lo presentará limitaciones con el manejo del certificado de seguridad y con la ejecución de varias ventanas si tu aplicación abre ventanas adicionales del navegador.\nEn versiones anteriores de Selenium RC, *chrome o *iehta eran los modos de ejecución que soportaban HTTPS y el manejo de ventanas de seguridad emergentes. Estos fueron considerados modos ‘experimentales aunque se volvieron bastante estables y muchas personas los usaron. Si estas usando Selenium 1.0 no necesitas, y no debes usar, estos modos de ejecución más antiguos.\nCertificados de Seguridad Explicados Normalmente, tu navegador confiará en la aplicación que está probando instalando un certificado de seguridad que ya posee. Puedes verificar esto en las opciones de tu navegador o en las propiedades de Internet (si no conoces el certificado de seguridad de tu AUT, consulta al administrador del sistema). Cuando Selenium carga tu navegador, inyecta código para interceptar mensajes entre el navegador y el servidor. El navegador ahora piensa el software no confiable está tratando de parecerse a su aplicación. Responde alertándote con ventanas emergentes.\nPara evitar esto, Selenium RC, (nuevamente cuando se utiliza un modo de ejecución que permite esto) instalará su propio certificado de seguridad, temporalmente, en tu máquina cliente en un lugar donde el navegador pueda acceder a ella. Esto engaña al navegador haciendole creer que está accediendo a un sitio diferente de su AUT y suprime efectivamente las ventanas emergentes.\nOtro método utilizado con versiones anteriores de Selenium era instalar el certificado de seguridad de Cybervillians incluido con tu instalación de Selenium. Sin embargo, la mayoría de los usuarios ya no deberían de necesitar hacer esto; si estas ejecutando Selenium RC en modo de inyección proxy, es posible que debas instalar explícitamente este certificado de seguridad.\nSoportando Navegadores y Configuraciones de Navegador Adicionales La API de Selenium permite la ejecución en múltiples navegadores además de Internet Explorer y Mozilla Firefox. Consulta el sitio web https://selenium.dev para ver los navegadores compatibles. Además, cuando un navegador no es directamente compatible, aún puede ejecutar tus pruebas de Selenium en un navegador de tu elección usando el modo de ejecución \u0026ldquo;*custom\u0026rdquo; (es decir, en lugar de *firefox o *iexplore) cuando tu aplicación de prueba inicia el navegador. Con esto,pasas la ruta a los navegadores ejecutables dentro de la llamada al API. Esto también se puede hacer desde el Servidor en modo interactivo.\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com Ejecución de Pruebas con Diferentes Configuraciones de Navegador Normalmente, Selenium RC configura automáticamente el navegador, pero si inicias el navegador que utilizando modo de ejecución \u0026ldquo;*custom\u0026rdquo;, puedes forzar a Selenium RC a iniciar el navegador tal cual, sin usar una configuración automática.\nPor ejemplo, puedes iniciar Firefox con una configuración personalizada como esta:\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com Ten en cuenta que al iniciar el navegador de esta manera, debes configurar el navegador para que use el servidor Selenium como un proxy. Normalmente esto solo significa abrir las preferencias del navegador y especificar \u0026ldquo;localhost:4444\u0026rdquo; como un proxy HTTP, pero las instrucciones para esto pueden diferir radicalmente de un navegador a otro. Consulte la documentación de tu navegador para más detalles.\nTen en cuenta que los navegadores Mozilla pueden variar en cómo se inician y se detienen. Es posible que sea necesario configurar la variable de entorno MOZ_NO_REMOTE para hacer que los navegadores Mozilla se comporten un poco más previsiblemente. Los usuarios de Unix deben evitar iniciar el navegador usando un script de shell; generalmente es mejor usar el ejecutable binario (por ejemplo, firefox-bin) directamente.\nSolucionando Problemas Comunes Al comenzar con Selenium RC, potencialmente hay algunos problemas que comúnmente se pueden encontrar. Aquí los presentamos junto con sus soluciones .\nIncapaz de Conectarse al Servidor Cuando tu programa de prueba no puede conectarse al servidor Selenium, Selenium lanza una excepción en tu programa de prueba. Debería mostrar este mensaje o uno similar:\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2) Si ves un mensaje como este, asegúrate de haber iniciado Selenium Server. Si es asi, entonces hay un problema con la conectividad entre la Librería Selenium Client y el servidor Selenium.\nAl comenzar con Selenium RC, la mayoría de las personas comienzan ejecutando su programa de prueba (con una Librería Cliente de Selenium) y el servidor Selenium en la misma máquina. Para hacer esto utiliza \u0026ldquo;localhost\u0026rdquo; como parámetro de conexión. Recomendamos comenzar de esta manera, ya que reduce la influencia de posibles problemas de red ya que estás empezando. Asumiendo que tu sistema operativo tiene una red típica y la configuración de TCP/IP debería tener poca dificultad. En verdad, mucha gente elige ejecutar las pruebas de esta manera.\nSin embargo, si desea ejecutar Selenium Server en una máquina remota, la conectividad debería estar bien suponiendo que tenga una conectividad TCP/IP válida entre las dos máquinas.\nSi tiene dificultades para conectarse, puedes usar herramientas de red comunes como ping, telnet, ifconfig(Unix)/ipconfig (Windows), etc. para garantizar que tenga una conexión de red. Si no estás familiarizado con estos, el administrador del sistema puede ayudarte.\nIncapaz de Cargar el Navegador Ok, no es un mensaje de error amigable, lo siento, pero si el servidor Selenium no puede cargar el navegador es probable que veas este error.\n(500) Internal Server Error Esto podria ser causado por\n Firefox (anterior a Selenium 1.0) no puede iniciarse porque el navegador ya está abierto y no espicificaste un perfil separado. Consulte la sección sobre perfiles de Firefox en Opciones del Servidor. El modo de ejecución que está utilizando no coincide con ningún navegador en su máquina. Comprueba los parámetros que pasó a Selenium cuando tu programa abre el navegador. Espicificaste la ruta al navegador explícitamente (usando \u0026ldquo;*custom\u0026rdquo; -ver arriba) pero la ruta es incorrecta. Verifique que la ruta sea correcta.Tambien comprueba el grupo de usuarios para asegurarte de que no haya ningun problema conocids con tu navegador y los parámetros \u0026ldquo;*custom\u0026rdquo;.  Selenium no Puede Encontrar el AUT Si tu programa de prueba inicia el navegador con éxito, pero el navegador no muestra el sitio web que está probando, la causa más probable es que tu programa de prueba no está utilizando la URL correcta.\nEsto puede suceder fácilmente. Cuando uitlizas Selenium-IDE para exportar tu script, este inserta una URL ficticia. Debes cambiar manualmente la URL a la correcta para que tu aplicación sea probada.\nFirefox Rechazó Apagarse Mientras Preparaba un Perfil Esto ocurre con mayor frecuencia cuando ejecutas tu programa de pruebas de Selenium RC contra Firefox, pero ya tienes una sesión del navegador Firefox ejecutándose y no especificaste un perfil separado cuando inició el servidor Selenium. El error del programa de prueba se parece a esto:\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile Aqui está el error completo del servidor:\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock Para resolver esto, ve a la sección Especificando el Perfil de Firefox\nProblemas de Versionamiento Asegúrate de que tu versión de Selenium sea compatible con la versión de tu navegador. Por ejemplo, Selenium RC 0.92 no es compatible con Firefox 3. A veces puedes ser afortunado (Yo lo era). Pero no olvides comprobar qué las versiones del navegador son compatibles con la versión de Selenium que estás utilizando. Cuando estes en duda, utiliza la última versión de lanzamiento de Selenium con la versión más utilizada de su navegador\nMensaje de Error: \u0026ldquo;(Unsupported major.minor version 49.0)\u0026rdquo; Iniciando el Servidor Este error dice que no estás utilizando una versión correcta de Java. El servidor Selenium requiere Java 1.5 ó superior.\nPara verificar tu versión de Java, ejecuta esto desde la línea de comandos.\njava -version Deberias ver un mensaje mostrando la version de Java.\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) Si ves un número de versión inferior, es posible que debas actualizar el JRE, o simplemente necesitas agregarlo a tu variable de entorno PATH.\nError 404 ejecutando el comando getNewBrowserSession Si recibes un error 404 al intentar abrir una página en \u0026ldquo;http://www.google.com/selenium-server/\u0026quot;, entonces debe ser porque el Selenium Server no se configuró correctamente como proxy. El directorio “selenium-server” no existe en google.com; solo parece existir cuando el proxy es debidamente configurado. La configuración del proxy depende en gran medida de cómo es lanzado el navegador con Firefox, iexplore, Opera o custom.\n  iexplore: si el navegador se inicia usando *iexplore, podrías tener un problema con la configuración del proxy de Internet Explorer. Selenium Server intenta configurar la configuración global del proxy en el Panel de Control de Opciones de Internet. Debes asegurarte de que estén correctamente configurados cuando Selenium Server inicia el navegador. Intenta mirar en tu panel de control de Opciones de Internet. Haz clic en la pestaña \u0026ldquo;Conexiones\u0026rdquo; y haz clic en \u0026ldquo;Configuración de LAN\u0026rdquo;.\n Si necesitas usar un proxy para acceder a la aplicación que deseas probar, deberás iniciar Selenium Server con \u0026ldquo;-Dhttp.proxyHost\u0026rdquo;; consulta la Configuración de proxy_ para obtener más detalles. También puedes intentar configurar tu proxy manualmente y luego iniciar el navegador con *custom, o con el lanzador de navegadores *iehta.    custom: cuando se usa *custom, debes configurar el proxy correctamente (manualmente), de lo contrario, obtendrás un error 404. Verifica que hayas configuraste tus ajustes de proxy correctamente. Para verificar si se ha configurado el proxy correctamente intenta configurar intencionalmente el navegador de manera incorrecta. Intenta configurar el navegador para utilizar el nombre de host del servidor proxy incorrecto o el puerto incorrecto. Si configuraste correctamente la configuración del proxy incorrecto del navegador, entonces el navegador no podrá conectarse a Internet, lo que es una de las formas de asegurarse de que uno está ajustando las configuraciones relevantes.\n  Para otros navegadores (*firefox, *opera) automáticamente codificamos el proxy por ti, por lo que no hay problemas conocidos con esta funcionalidad. Si encuentras errores 404 y has seguido cuidadosamente esta guía del usuario publica tus resultados en el grupo de usuarios para obtener ayuda de la comunidad de usuarios.\n  Error Permiso Denegado La razón más común para este error es que tu sesión intenta violar la política del mismo origen al cruzar los límites del dominio (por ejemplo, accede a una página desde http://dominio1 y luego accede a una página desde http://dominio2) o al cambiar de protocolos (pasar de http://dominioX a https:// dominioX).\nEste error también puede ocurrir cuando JavaScript intenta encontrar objetos de la IU que aún no están disponibles (antes de que la página haya cargado completamente), o ya no están disponibles (después de que la página ha comenzado a descargarse). Esto se encuentra con mayor frecuencia con páginas AJAX que trabajan con secciones de una página o subtramas que se cargan y/o recargan independientemente de la página.\nEste error puede ser intermitente. A menudo es imposible reproducir el problema con un depurador porque el problema surge por condiciones de carrera que no son reproducibles cuando la sobrecarga del depurador se agrega al sistema. Problemas de permisos están cubiertos con algún detalle en el tutorial. Lee la sección sobre la La Politica del Mismo Origen_, y tambien la sección Inyección de proxy_ cuidadosamente.\nManejo de Ventanas Emergentes del Navegador Hay varios tipos de \u0026ldquo;ventanas emergentes\u0026rdquo; que puedse obtener durante una prueba de Selenium. Es posible que no puedas cerrar estas ventanas emergentes ejecutando comandos de Selenium si son iniciados por el navegador y no por tu AUT. Puedes necesitar saber cómo gestionarlos. Cada tipo de ventana emergente debe abordarse de manera diferente.\n  Diálogos de autenticación básica HTTP: estos diálogos solicitan un nombre de usuario/contraseña para iniciar sesión en el sitio. Para iniciar sesión en un sitio que requiere autenticación HTTP básica, use un nombre de usuario y contraseña en la URL, como esta descrito en RFC 1738_, así: open(\u0026ldquo;http://myusername:myuserpassword@myexample.com/blah/blah/blah\u0026quot;).\n  Advertencias del certificado SSL: Selenium RC intenta falsificar automáticamente los certificados SSL cuando está habilitado como proxy; ver más sobre esto en la sección sobre HTTPS. Si tu navegador está configurado correctamente, nunca deberías ver las advertencias del certificado SSL, pero es posible que debas configursr tu navegador para confiar en nuestra autoridad peligrosa de certificado SSL \u0026ldquo;CyberVillains\u0026rdquo;. Nuevamente, consulte la sección HTTPS para saber cómo hacer esto.\n  cuadros de diálogo de alerta/confirmación/aviso modal de JavaScript: Selenium intenta ocultarte esos diálogos (reemplazando window.alert, window.confirm y window.prompt) para que no detengan la ejecución de tu página. Si ves una ventana de alerta emergente, probablemente se deba a que se disparó durante el proceso de carga de la página, que suele ser demasiado pronto para que podamos proteger la página. Selenese contiene comandos para afirmar o verificar alertas y ventanas emergentes de confirmación. Ver las secciones sobre estos temas en el Capítulo 4.\n  En Linux, ¿por qué no se cierra la sesión de mi navegador Firefox? En Unix/Linux debes invocar \u0026ldquo;firefox-bin\u0026rdquo; directamente, así que asegúrate de que el ejecutable está en la ruta. Si ejecutas Firefox a través de un script de shell, cuando llega el momento de matar el navegador Selenium RC matará el script de shell, dejando el navegador en ejecución. Puedes especificar la ruta a firefox-bin directamente, de esta forma.\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome no funciona con un perfil personalizado Verifica el folder del perfil Firefox -\u0026gt; prefs.js -\u0026gt; user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0); Comenta esta linea de esta forma: \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; e intenta de nuevo.\nEstá bien cargar una ventana emergente personalizada mientras se carga la página principal (es decir, antes de que se ejecute la función JavaScript window.onload() de la página principal)? No. Selenium depende de los interceptores para determinar los nombres de las ventanas a medida que se cargan. Estos interceptores funcionan mejor en la captura de nuevas ventanas si las ventanas se cargan DESPUÉS la función onload(). Selenium pueda que no reconozca ventanas cargadas antes de la función onload.\nFirefox en Linux En Unix/Linux, las versiones de Selenium anteriores a la 1.0 necesitaban invocar \u0026ldquo;firefox-bin\u0026rdquo; directamente, por lo que si estás utilizando una versión anterior, asegúrate de que el ejecutable verdadero está en la ruta.\nEn la mayoría de las distribuciones de Linux, el verdadero firefox-bin se encuentra en:\n/usr/lib/firefox-x.x.x/ Donde x.x.x es el número de la versión que tiene actualmente. Entonces, para agregar esa ruta a la ruta del usuario, deberás agregar lo siguiente a tu archivo .bashrc:\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; Si es necesario, puedes especificar la ruta a firefox-bin directamente en tu prueba, de esta forma:\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IE y Atributos de Estilo Si estás ejecutando tus pruebas en Internet Explorer y no puedes localizar elementos que usan tu atributo style. Por ejemplo:\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] Esto funcionaría perfectamente en Firefox, Opera o Safari pero no con IE. IE interpreta las teclas en @style como mayúsculas. Entonces, incluso si el código fuente está en minúsculas, debes usar:\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] Esto es un problema si tu prueba está diseñada para funcionar en múltiples navegadores, pero puedes codificar fácilmente tu prueba para detectar la situación y probar el localizador alternativo que solo funciona en IE.\nError encontrado - \u0026ldquo;Cannot convert object to primitive value\u0026rdquo; con el apagado del navegador *googlechrome Para evitar este error, debes iniciar el navegador con una opción que deshabilite las mismas verificaciones de políticas de origen:\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); Error encontrado en IE - \u0026ldquo;Couldn\u0026rsquo;t open app window; is the pop-up blocker enabled?\u0026rdquo; Para evitar este error, debes configurar el navegador: desactiva el bloqueador de ventanas emergentes Y desmarque la opción \u0026lsquo;Habilitar modo protegido\u0026rsquo; en Herramientas \u0026raquo; Opciones \u0026raquo; Seguridad.\n  El proxy es una tercera persona situada en el medio que pasa la pelota entre las dos partes. Actúa como un \u0026ldquo;servidor web\u0026rdquo; que entrega el AUT al navegador. Ser un proxy le da al Selenium Server la capacidad de \u0026ldquo;mentir\u0026rdquo; sobre la URL real del AUT. \u0026#x21a9;\u0026#xfe0e;\n El navegador se inicia con un perfil de configuración que establece localhost:4444 como el proxy HTTP, es por eso que cualquier solicitud HTTP que haga el navegador pasará a través del servidor Selenium y la respuesta pasará a través de él y no desde el servidor real. \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://www.selenium.dev/documentation/es/driver_idiosyncrasies/shared_capabilities/",
	"title": "Shared capabilities",
	"tags": [],
	"description": "",
	"content": "Con el fin de crear una nueva sesión del WebDriver de Selenium, la parte local debe proveer las capacidades(capabilities) básicas a la parte remota. La parte remota usa el mismo conjunto de capacidades para crear una sesión y describir las funcionalidades de la sesión actual.\nEl WebDriver proporciona unas capacidades que cada parte remota debe apoyar en su implementación. Las siguientes capacidades son las que el WebDriver soporta:\nbrowserName: Esta capacidad es usada para fijar el browserName(nombre del navegador) para una sesión dada. Si el navegador especificado no esta instado en la parte remota, la creación la sesión fallará.\nbrowserVersion: Esta capacidad es opcional, es usada para fijar la versión disponible del navegador en la parte remota. Por ejemplo, si preguntamos por una versión 75 de Chrome en un sistema que solo tiene instalada la versión 80 instalada, la creación de la sesión fallará.\npageLoadStrategy: Cuando navegamos a una nueva pagina vía URL, por defecto Selenium esperará hasta que la pagina este cargada completamente antes de responder. Esto funciona bien para principiantes, pero puede causar largos tiempos de espera en paginas que cargan una gran cantidad de recursos externos. Usando alguna de las estrategias que no están especificadas por defecto puedes hacer que tus tests se ejecuten mas rápidamente pero también podrías llegar a introducir problemas de fiabilidad donde los elementos de la pagina cambian de posición según estos elementos van cargando.\nLa estrategia de carga de las paginas consulta el atributo document.readyState como se describe en la tabla siguiente:\n   Estrategia Estado Atributo Ready Notas     normal complete Usado por defecto, espera a que todos los recursos se descarguen   eager interactive Acceso al DOM esta listo, pero los otros recursos como imágenes pueden estar cargando   none Any No bloquea al WebDriver en absoluto    platformName Esto es usado para identificar el sistema operativo en la parte remota, buscar la capacidad platformName devuelve el sistema operativo.\nEn proveedores basados en la nube, fijar la capacidad platformName permite definir el sistema operativo de la parte remota.\nacceptInsecureCerts Esta capacidad comprueba si un certificado TLS ha vencido o es invalido esta siendo usado para navegar durante una sesión.\nSi esta capacidad esta fijada a false, un error de certificado inseguro sera devuelto cuando la navegación encuentre cualquier dominio con problemas de certificado. Si se fija a true, los certificados inválidos serán confiados por el navegador\nTodos los certificados auto-firmados serán confiables por esta capacidad por defecto. Una vez. Una vez fijado la capacidad acceptInsecureCerts tendrá efecto durante la sesión entera.\nTimeouts de sesión Una sesión del WebDriver es impuesta con un cierto intervalo de timeout de sesión durante el cual el usuario puede controlar el comportamiento de ejecutar scripts o recuperar información del navegador.\nCada timeout de sesión es configurado con una combinación diferente de timeouts como se describe a continuación:\nTimeout de script (Script Timeout): Especifica cuando interrumpir un script en ejecución en el contexto actual del navegador. Por defecto esta configurado a 30,000 cuando una nueva sesión es creada por el WebDriver.\nTimeout de tiempo de carga (Page Load Timeout): Especifica el intervalo de tiempo en el cual una pagina de web necesita ser cargada en el contexto actual del navegador. El timeout por defecto es de 300,000 para las nuevas sesiones creadas por el WebDriver. Si el tiempo de carga excede el limite marcado, el script será parado por una excepción del tipo TimeoutException.\nTimeout de esperas implicitas (Implicit Wait Timeout): Esto especifica el tiempo de espera para la estrategia de localización de elementos implicita. Por defecto el timeout es de 0, este es impuesto cuando se crea una nueva sesión a través del WebDriver.\nGestionar el comportamiento de las popups Prompt (unhandledPromptBehavior) Especifica la forma en la que el usuario puede manejar las popups prompt (user prompt handler) en la sesión actual. El valor predeterminado es dismiss and notify state\nManejo de las popups Prompt (User Prompt Handler) Esto define que acción se debe tomar cuando aparece una ventana prompt en la parte remota. Es definida por la capacidad unhandledPromptBehavior y tiene los siguientes estados:\n dismiss accept dismiss and notify accept and notify ignore  setWindowRect This command alters the size and position of the current browsing context window. This command acts as setter to getWindowRect command which accepts width, height, x, y as optional arguments.\nDuring automation, the current browsing context will be associated with window states, that describe visibility state of the browser window. The window states are\n maximized minimized normal fullscreen  Setting Width or Height does not guaranteed that the resulting window size will exactly match that which was quested. This is because some drivers may not be able to resize in single-pixel increments. Due to this, fetching the window state/details by getWindowRect may not equally match the values set to the browser.\nstrictFileInteractability The new capabilitiy indicates if strict interactability checks should be applied to input type=file elements. As strict interactability checks are off by default, there is a change in behaviour when using Element Send Keys with hidden file upload controls.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/remote_webdriver/remote_webdriver_server/",
	"title": "WebDriver remoto - servidor",
	"tags": [],
	"description": "",
	"content": "El servidor siempre se ejecutará en la máquina con el navegador que deseas probar. El servidor se puede usar desde la línea de comandos o mediante configuración de código.\nIniciar el servidor desde la línea de comando Una vez que hayas descargado selenium-server-standalone-{VERSION}.jar, colócalo en la computadora con el navegador que deseas probar. Entonces, desde el directorio con el jar, ejecuta lo siguiente:\njava -jar selenium-server-standalone-{VERSION}.jar Consideraciones para ejecutar el servidor Se espera que quien inicie la sesión termine cada sesión correctamente, llamando ya sea Selenium#stop() o WebDriver#quit.\nEl servidor de Selenium mantiene registros en memoria para cada sesión en curso, que se borran cuando se invoca Selenium#stop() o WebDriver#quit. Si olvidas finalizar estas sesiones, tu servidor puede perder memoria. Si mantienes sesiones extremadamente largas, probablemente necesitarás detener/salir de vez en cuando (o también aumentar la memoria con la opción -Xmx jvm).\nTimeouts (desde la version 2.21) El servidor tiene dos timeouts diferentes, que se pueden configurar de la siguiente manera:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  Controla cuánto tiempo se permite colgar el navegador (valor en segundos).   timeout  Controla cuánto tiempo se permite que el cliente se vaya antes de reclamar la sesión (valor en segundos).    La propiedad del sistema selenium.server.session.timeout ya no es compatible a partir de 2.21.\nTen en cuenta que el browserTimeout está pensado como un mecanismo de timeout de respaldo cuando falla el mecanismo de timeout ordinario, que debe usarse principalmente en entornos de red/servidor para garantizar que los procesos bloqueados/perdidos no permanezcan por mucho tiempo,contaminando el entorno de ejecución.\nConfiguración del servidor de manera programática En teoría, el proceso es tan simple como mapear el DriverServlet a una URL, pero también es posible alojar la página desde en un contenedor ligero, como Jetty configurado completamente en código. Pasos para hacer esto a continuación.\n Descargar selenium-server.zip y descomprimirlos Poner los JAR en el CLASSPATH Crear una nueva clase llamada AppServer. Estoy usando Jetty, por lo que deberás descargar eso también:  import org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } } "
},
{
	"uri": "https://www.selenium.dev/documentation/es/driver_idiosyncrasies/driver_specific_capabilities/",
	"title": "Capacidades específicas de los Drivers",
	"tags": [],
	"description": "",
	"content": "Firefox Define las capacidades usando FirefoxOptions FirefoxOptions es la nueva forma de definir capacidades para el navegador Firefox y debe de ser usado de manera general antes que DesriredCapabilities.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   require \u0026#39;selenium-webdriver\u0026#39; opts = Selenium::WebDriver::Firefox::Options.new(args: [\u0026#39;-headless\u0026#39;]) driver = Selenium::WebDriver.for(:firefox, options: opts)   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.headless(); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     Fijando un perfil a medida Es posible crear perfiles a medida para Firefox, como se puede ver a continuación.\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   profile = Selenium::WebDriver::Firefox::Profile.new profile[\u0026#39;browser.download.dir\u0026#39;] = \u0026#34;/tmp/webdriver-downloads\u0026#34; options = Selenium::WebDriver::Firefox::Options.new(profile: profile) driver = Selenium::WebDriver.for :firefox, options: options   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); let profile = \u0026#39;/path to custom profile\u0026#39;; options.setProfile(profile); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer Timeout ventana de selección de archivos (fileUploadDialogTimeout) En algunos entornos, Internet Explorer puede devolver un timeout cuando se abra una ventana de selección de archivos (file upload dialog). Por defecto el IEDriver tiene un timeout de 1000ms, pero puedes incrementarlo usando la capacidad fileUploadDialogTimeout.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.waitForUploadDialogUpTo(Duration.ofSeconds(2)); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.file_upload_dialog_timeout = 2000 driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.file_upload_dialog_timeout = 2000 driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().fileUploadDialogTimeout(2000); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.waitForUploadDialogUpTo(Duration.ofSeconds(2)) val driver = RemoteWebDriver(options)     ensureCleanSession When set to true, this capability clears the Cache, Browser History and Cookies for all running instances of InternetExplorer including those started manually or by the driver. By default, it is set to false.\nUsing this capability will cause performance drop while launching the browser, as the driver will wait until the cache gets cleared before launching the IE browser.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.destructivelyEnsureCleanSession(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ensure_clean_session = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.EnsureCleanSession = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ensure_clean_session = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ensureCleanSession(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.destructivelyEnsureCleanSession() val driver = RemoteWebDriver(options)     ignoreZoomSetting InternetExplorer driver expects the browser zoom level to be 100%, else the driver will throw an exception. This default behaviour can be disabled by setting the ignoreZoomSetting to true.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.ignoreZoomSettings(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_zoom_level = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IgnoreZoomLevel = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_zoom_level = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ignoreZoomSetting(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.ignoreZoomSettings() val driver = RemoteWebDriver(options)     ignoreProtectedModeSettings Whether to skip the Protected Mode check while launching a new IE session.\nIf not set and Protected Mode settings are not same for for all zones, an exception will be thrown by the driver.\nIf capability is set to true, tests may become flaky, unresponsive, or browsers may hang. However, this is still by far a second-best choice, and the first choice should always be to actually set the Protected Mode settings of each zone manually. If a user is using this property, only a \u0026ldquo;best effort\u0026rdquo; at support will be given.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.introduceFlakinessByIgnoringSecurityDomains(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_protected_mode_settings = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IntroduceInstabilityByIgnoringProtectedModeSettings = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_protected_mode_settings = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().introduceFlakinessByIgnoringProtectedModeSettings(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.introduceFlakinessByIgnoringSecurityDomains() val driver = RemoteWebDriver(options)     silent When set to true, this capability suppresses the diagnostic output of the IEDriverServer.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.setCapability(\u0026#34;silent\u0026#34;, true); WebDriver driver = new InternetExplorerDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.set_capability(\u0026#34;silent\u0026#34;, True) driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   InternetExplorerOptions options = new InternetExplorerOptions(); options.AddAdditionalInternetExplorerOption(\u0026#34;silent\u0026#34;, true); IWebDriver driver = new InternetExplorerDriver(options);   # Please raise a PR to add code sample   const {Builder,By, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); let caps = Capabilities.ie(); caps.set(\u0026#39;silent\u0026#39;, true); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;internet explorer\u0026#39;) .withCapabilities(caps) .build(); try { await driver.get(\u0026#39;http://www.google.com/ncr\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.setCapability(\u0026#34;silent\u0026#34;, true) val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     IE Command-Line Options Internet Explorer includes several command-line options that enable you to troubleshoot and configure the browser.\nThe following describes few supported command-line options\n  -private : Used to start IE in private browsing mode. This works for IE 8 and later versions.\n  -k : Starts Internet Explorer in kiosk mode. The browser opens in a maximized window that does not display the address bar, the navigation buttons, or the status bar.\n  -extoff : Starts IE in no add-on mode. This option specifically used to troubleshoot problems with browser add-ons. Works in IE 7 and later versions.\n  Note: forceCreateProcessApi should to enabled in-order for command line arguments to work.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.add_argument(\u0026#39;-private\u0026#39;) options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; options.BrowserCommandLineArguments = \u0026#34;-k\u0026#34;; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true options.add_argument(\u0026#39;-k\u0026#39;) driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.addBrowserCommandSwitches(\u0026#39;-k\u0026#39;); options.addBrowserCommandSwitches(\u0026#39;-private\u0026#39;); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps); } finally { driver.quit(); } }     forceCreateProcessApi Forces launching Internet Explorer using the CreateProcess API. The default value is false.\nFor IE 8 and above, this option requires the \u0026ldquo;TabProcGrowth\u0026rdquo; registry value to be set to 0.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps) } finally { driver.quit(); } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/grid/components_of_a_grid/",
	"title": "Componentes de un Grid",
	"tags": [],
	"description": "",
	"content": "Hub  Ejerce como mediador y administrador Acepta peticiones para ejecutar los tests Recoge instrucciones de los clientes y las ejecuta de forma remota en los nodos Gestiona los hilos  El Hub es un punto central donde se envian todos tus tests. Cada Selenium Grid consiste en exactamente un hub. El hub necesita ser accesible desde la perspectiva de los clientes (ej. Servidor de la CI, maquina del desarrollador) El hub se conectará a uno o mas nodos a los que los tests serán delegados.\nNodos  Donde se ubican los navegadores Se registra a si mismo en el hub y le comunica sus capacidades Recibe las peticiones desde el hub las ejecuta  Los nodos son diferentes instancias de Selenium que ejecutarán los tests en sistemas informáticos individuales. Puedes haber muchos nodos en un grid. Las maquinas que contienen los nodos no necesitan estar bajo el mismo sistema operativo o disponer de la misma selección de navegadores que el hub u otros nodos. Un nodo en Windows podría tener la capacidad de ofrecer Internet Explorer como opción del navegador mientras que esto no podría ser posible en Linux o Mac.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/front_matter/typographical_conventions/",
	"title": "Convenciones tipográficas",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Capitalisation of titles One should avoid title capitalisation, such as A Very Fine Heading, and instead go for A very fine heading. Gratutious capitalisation, or title case, often show a misunderstanding of – or a disregard for – orthographic conventions. We prefer what is known as sentence case, with a single initial capital to start headers.\nLine length When editing the documentation’s source, which is written in plain HTML, limit your line lengths to around 72 characters.\nSome of us take this one step further and use what is called semantic linefeeds, which is a technique whereby the HTML source lines, which are not read by the public, are split at ‘natural breaks’ in the prose. In other words, sentences are split at natural breaks between clauses. Instead of fussing with the lines of each paragraph so that they all end near the right margin, linefeeds can be added anywhere that there is a break between ideas.\nThis can make diffs very easy to read when collaborating through git, but it is not something we enforce contributors to use.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/worst_practices/file_downloads/",
	"title": "Descarga de archivos",
	"tags": [],
	"description": "",
	"content": "Mientras que es posible empezar una descarga haciendo clic en el enlace, con el navegador que este siendo controlado por Selenium, el API no expone el progreso de la descarga, haciéndolo poco ideal para probar la descarga de archivos. Esto es debido a que descargar archivos no es considerado un aspecto importante de la emulación de las interacciones de los usuarios con las plataformas web. En lugar de ello, se recomienda encontrar el enlace con Selenium (y cualquier Cookie requerida) y pasarselo a una librería que permita hacer peticiones HTTP como libcurl.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/selenium_installation/installing_webdriver_binaries/",
	"title": "Instalando los binarios de WebDriver",
	"tags": [],
	"description": "",
	"content": "Para ejecutar tu proyecto y controlar el navegador, debes tener instalados los binarios de WebDriver específicos para el navegador.\nDescarga el binario de WebDriver soportado por tu navegador y colócalo en el PATH del sistema.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/introduction/",
	"title": "Introducción",
	"tags": [],
	"description": "",
	"content": "Introducción Selenium es un proyecto que alberga un catálogo de herramientas y librerías que permiten y sustentan la automatización de navegadores web.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/domain_specific_language/",
	"title": "Lenguage de dominio específico",
	"tags": [],
	"description": "",
	"content": "Un lenguaje de dominio específico (DSL) es un sistema que proporciona al usuario un medio expresivo para resolver un problema. Permite a un usuario interactuar con el sistema en sus términos, no solo en jerga del programador.\nA tus usuarios, en general, no les importa cómo se ve su sitio. Ellos no se preocupan por la decoración, animaciones o gráficos. Ellos desean utilizar tu sistema para impulsar a sus nuevos empleados a través del proceso con mínima dificultad; quieren reservar un viaje a Alaska; quieren configurar y comprar unicornios con descuento. Tu trabajo como el probador debe acercarse lo más que pueda a \u0026ldquo;capturar\u0026rdquo; esta mentalidad. Con eso en mente, nos propusimos \u0026ldquo;modelar\u0026rdquo; la aplicación con que estas trabajando, de modo que los scripts de prueba (el único proxy pre-lanzamiento del usuario ) \u0026ldquo;hablen\u0026rdquo; por, y representen al usuario.\nCon Selenium, el DSL generalmente se representa por métodos, escritos para hacer la API simple y legible: permiten un informe entre desarrolladores y partes interesadas (usuarios, dueños de producto, especialistas en inteligencia de negocios, etc).\nBeneficios  Legible: Las partes interesadas del negocio pueden entenderlo. Escribible: Fácil de escribir, evita duplicaciones innecesarias. Extensible: Se puede agregar funcionalidad (razonablemente) sin romper los contratos y la funcionalidad existente. Mantenible: Al dejar los detalles de implementación fuera de casos de prueba, está bien aislado contra cambios en el AUT*.  Java Aquí hay un ejemplo de un método DSL razonable en Java. En aras de la brevedad, se supone que el objeto driver está predefinido y disponible para el método.\n/** * Toma un nombre de usuario y una contraseña, completa los campos y hace clic en \u0026#34;iniciar sesión\u0026#34;. * @return Una instancia de AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Completa el campo de contraseña. El localizador que estamos usando es \u0026#34;By.id\u0026#34;, y deberíamos  // tenerlo definido en otra parte de la clase.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Haz clic en el botón de inicio de sesión, que tiene el id \u0026#34;enviar\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Crea y devuelve una nueva instancia de AccountPage (a través del PageFactory  // incorporado a Selenium).  return PageFactory.newInstance(AccountPage.class); } Este método abstrae completamente los conceptos de campos de entrada, botones, clics e incluso páginas de tu código de prueba. Usando este enfoque, todo lo que un probador tiene que hacer es llamar a este método. Esto da una ventaja de mantenimiento: si los campos de inicio de sesión alguna vez cambian, solo tendrías que cambiar este método, no tus pruebas.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Ahora que hemos iniciado sesión, haz otras cosas, ya que utilizamos un DSL para admitir  // nuestros probadore, es tan fácil como elegir entre los métodos disponibles.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Something should have been done!\u0026#34;, something.wasDone()); // Ten en cuenta que todavía no nos hemos referido a un botón o control web en ninguna parte de este  // script... } Vale la pena repetirlo: uno de tus objetivos principales debe ser escribir un API que permite que tus pruebas aborden el problema en cuestión, y NO el problema de la interfaz de usuario. La interfaz de usuario es una preocupación secundaria para tus usuarios: no les importa la interfaz de usuario, solo quieren obtener su trabajo hecho. Tus scripts de prueba deben leerse como una lista de cosas el usuario quiere HACER, y las cosas que quiere SABER. Las pruebas no deben preocuparse por CÓMO la IU requiere que vayas al respecto.\n*AUT: Application under test\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/legacy_docs/migrating_from_rc_to_webdriver/",
	"title": "Migrando de RC a WebDriver",
	"tags": [],
	"description": "",
	"content": "Cómo migrar a Selenium WebDriver Una pregunta común al adoptar Selenium 2 es qué seria lo correcto al agregar nuevas pruebas a un conjunto existente de pruebas?. Los usuarios que son nuevos al framework pueden comenzar utilizando las nuevas API de WebDriver para escribir sus pruebas. ¿Pero qué pasa con los usuarios que ya tienen suites de pruebas existentes? Esta guía es diseñada para demostrar cómo migrar tus pruebas existentes a las nuevas APIs, permitiendo que todas las pruebas nuevas se escriban usando las nuevas características ofrecidas por WebDriver.\nEl método presentado aquí describe una migración gradual al WebDriver API sin necesidad de volver a trabajar todo en un solo esfuerzo masivo. Esto significa que te puedes permitir más tiempo para migrar tus pruebas existentes, lo que puede facilitarte decidir dónde dirigir tu esfuerzo.\nEsta guía está escrita usando Java, porque tiene el mejor soporte para hacer la migración. A medida que proporcionemos mejores herramientas para otros lenguajes, esta guía se ampliará para incluir esos lenguajes.\nPor qué migrar a WebDriver Mover un conjunto de pruebas de una API a otra requiere una enorme cantidad de esfuerzo. ¿Por qué tu y tu equipo considerarían hacer este movimiento? Estas son algunas razones por las que deberían considerar migrar sus pruebas de Selenium para usar WebDriver.\n API más pequeña y compacta. La API de WebDriver está más orientada a objetos que la API original de Selenium RC. Esto puede hacer que sea más fácil trabajar con él. Mejor emulación de las interacciones del usuario. Donde sea posible, WebDriver hace uso de eventos nativos para interactuar con una página web. Esto imita más de cerca la forma en que tus usuarios trabajan con tu sitio y tus aplicaciones. Adicionalmente, WebDriver ofrece las API avanzadas de interacciones de usuario que te permiten modelar interacciones complejas con tu sitio. Soporte por proveedores de navegador. Opera, Mozilla y Google son todos participantes activos en el desarrollo de WebDriver, y cada uno tiene ingenieros trabajando para mejorar el framework. A menudo, esto significa que el soporte para WebDriver está integrado en el navegador: tus pruebas se ejecutan tan rápido y tan estables como sea posible.  Antes de empezar Para que el proceso de migración sea lo menos doloroso posible, asegúrate de que todas tus pruebas se ejecuten correctamente con la última versión de Selenium. Esto puede sonar obvio, ¡pero es mejor decirlo!\nEmpezando El primer paso al comenzar la migración es cambiar la forma de obtener tu instancia de Selenium. Cuando se usa Selenium RC, esto se hace así:\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); Esto debería ser reemplazado de la siguiente manera:\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); Próximos pasos Una vez que tus pruebas se ejecutan sin errores, la siguiente etapa es migrar el código de prueba real para usar las API de WebDriver. Dependiendo de qué tan bien abstraído este tu código, esto podría ser un proceso corto o largo. En cualquier caso, el enfoque es el mismo y se puede resumir simplemente: modifique el código para usar la nueva API cuando vayas a editarlo.\nSi necesitas extraer la implementación subyacente de WebDriver de en la instancia de Selenium, simplemente puedes hacer un casteo a WrapsDriver:\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); Esto te permite continuar pasando la instancia de Selenium normalmente, pero desenvuelve la instancia de WebDriver según sea necesario.\nEn algún momento, tu código base utilizará principalmente las API más nuevas. En este punto, puedes voltear la relación, utilizando WebDriver para instanciar una instancia de Selenium según sea necesario:\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); Problemas Comunes Afortunadamente, no eres la primera persona en pasar por esta migración, Aquí hay algunos problemas comunes que otros han encontrado y cómo resolverlos.\nHacer clic y escribir es más completo Un patrón común en una prueba de Selenium RC es ver algo como:\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); Esto se basa en el hecho de que \u0026ldquo;type\u0026rdquo; simplemente reemplaza el contenido del elemento identificado sin disparar todos los eventos que normalmente serian disparados si un usuario interactúa con la página. Las invocaciones directas finales de \u0026ldquo;key*\u0026rdquo; hace que los manejadores JS se activen como se esperaba.\nCuando se usa WebDriverBackedSelenium, el resultado de completar el formulario en el campo sería \u0026ldquo;exciting texttt\u0026rdquo;: ¡no es lo que esperarías! La razón de esto es que WebDriver emula con mayor precisión el comportamiento del usuario y, por lo tanto, estaría disparando eventos todo el tiempo.\nEste mismo hecho a veces puede provocar que la carga de una página se dispare antes de lo que lo haría en una prueba de Selenium 1. Se puede decir que esto ha sucedido si WebDriver lanza un \u0026ldquo;StaleElementException\u0026rdquo;.\nWaitForPageToLoad retorna demasiado pronto Descubrir cuándo se completa la carga de una página es un negocio complicado. Acaso nos referimos a \u0026ldquo;cuando se dispara el evento de carga\u0026rdquo;, \u0026ldquo;cuando todas las solicitudes de AJAX están completas\u0026rdquo;, \u0026ldquo;cuando no hay tráfico de red\u0026rdquo;,\u0026ldquo;cuando document.readyState ha cambiado\u0026rdquo; o algo completamente diferente?\nWebDriver intenta simular el comportamiento original de Selenium, pero esto no siempre funciona perfectamente por varias razones. La razón más común es que es difícil saber la diferencia entre una carga de página que aún no ha comenzado, y un carga de página completada entre llamadas de métodos. Esto a veces significa que el control se ha retornado a tu prueba antes de que la página finalice (¡o incluso comience!) su carga.\nLa solución a esto es esperar algo específico. Comúnmente, esto podría ser el elemento con el que deseas interactuar, o que alguna variable de Javascript se establezca en un valor específico. Un ejemplo sería:\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, Duration.ofSeconds(30)); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); Donde \u0026ldquo;visibilityOfElementLocated\u0026rdquo; se implementa como:\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } Esto puede parecer complejo, pero es casi todo el codigo boiler-plate. Lo único interesante es que la \u0026ldquo;ExpectedCondition\u0026rdquo; se evaluará repetidamente hasta que el método \u0026ldquo;apply\u0026rdquo; retorne algo que no sea \u0026ldquo;nulo\u0026rdquo; ni Boolean.FALSE.\nPor supuesto, agregar todas estas llamadas de \u0026ldquo;espera\u0026rdquo; puede saturar tu código. Si ese es el caso, y tus necesidades son simples, considera usar las esperas implícitas:\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); Al hacer esto, cada vez que se localiza un elemento, si el elemento no está presente, la localización se vuelve a intentar hasta que esté presente o hasta que hayan transcurrido 30 segundos.\nEncontrar Por Xpath O CSS Selectores No Siempre Funciona, Pero Lo Hace en Selenium 1 En Selenium 1, era común que xpath usara una librería incluida en lugar de utilizar las capacidades del navegador en sí. WebDriver siempre usará los métodos nativos del navegador a menos que no haya alternativa. Eso significa que expresiones xpath complejas pueden romperse en algunos navegadores.\nLos selectores CSS en Selenium 1 se implementaron utilizando la librería Sizzle. Esta implementa un superconjunto de la especificación CSS Selector, y no siempre está claro dónde has cruzado la línea. Si estás utilizando WebDriverBackedSelenium y utilizas un localizador Sizzle en lugar de un selector CSS para encontrar elementos, se registrara una advertencia en la consola. Vale la pena tomarse el tiempo para encontrar estas ocurrencias, particularmente si las pruebas fallan por no poder encontrar elementos.\nNo hay Browserbot Selenium RC se basó en Selenium Core, por lo tanto, cuando ejecutó Javascript, pudo acceder a partes de Selenium Core para facilitar las cosas. Como WebDriver no se basa en Selenium Core, esto ya no es posible. ¿Cómo puedes saber si está usando Selenium Core? ¡Sencillo! Solo mira si tus llamadas \u0026ldquo;getEval\u0026rdquo; o similares están usando \u0026ldquo;selenium\u0026rdquo; o \u0026ldquo;browserbot\u0026rdquo; en el Javascript evaluado.\nEs posible que esté utilizando el browserbot para obtener un identificador de la ventana actual o el documento de la prueba. Afortunadamente, WebDriver siempre evalúa JS en el contexto de la ventana actual, por lo que puede usar \u0026ldquo;window\u0026rdquo; o \u0026ldquo;document\u0026rdquo; directamente.\nAlternativamente, puedes estar usando el browserbot para localizar elementos. En WebDriver, la forma para hacer esto es localizar primero el elemento, y luego pasarlo como argumento al Javascript. Así:\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); resulta en:\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); Observa cómo la variable \u0026ldquo;element\u0026rdquo; pasada aparece como el primer elemento en la matriz de \u0026ldquo;arguments\u0026rdquo; estándar de JS.\nEjecutar Javascript no retorna nada JavascriptExecutor de WebDriver envolverá todo JS y lo evaluará como una expresión anónima. Esto significa que debes usar la tecla \u0026ldquo;return\u0026rdquo;\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); resulta en:\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;); "
},
{
	"uri": "https://www.selenium.dev/documentation/es/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "Navegadores de terceros y plugins",
	"tags": [],
	"description": "",
	"content": "Selenium se puede extender mediante el uso de plugins. Aquí hay una serie de plugins creados y mantenidos por terceros. Para más información sobre cómo crear tu propio plugin o tenerlo en la lista, consulta la documentación.\nTen en cuenta que estos plugins no son compatibles, mantenidos, alojados o avalados por el proyecto Selenium. Además, ten en cuenta que los plugins enumerados a continuación no necesariamente están licenciados bajo la licencia de Apache v.2.0. Algunos de los plugins están disponibles bajo otra licencia de software libre y de código abierto. Otros solo están disponibles bajo una licencia patentada. Cualquier pregunta acerca de los plugins y su licencia de distribución deben plantearse con sus respectivo(s) desarrollador(es).\n   Navegador Más reciente Registro de cambios Seguimiento de Incidentes     Mozilla GeckoDriver más reciente registro de cambios seguimiento de incidentes   Google Chrome Driver más reciente registro de cambios seguimiento de incidentes   Opera más reciente - seguimiento de incidentes   Microsoft Edge Driver más reciente - seguimiento de incidentes   SafariDriver Incorporado - seguimiento de incidentes    "
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/driver_requirements/",
	"title": "Requerimientos de los controladores",
	"tags": [],
	"description": "",
	"content": "A través del WebDriver, Selenium es capaz de soportar los navegadores mas usados en el mercado como Chrom(ium), Firefox, Internet Explorer, Opera y Safari. WebDriver maneja los navegadores, cuando es posible, apoyándose en las propias funciones que el navegador incorpora para la automatización.\nLa finalidad del WebDriver es emular las interacciones de los usuarios reales. Esto es posible en diversos niveles en diferentes navegadores. Para mas detalles sobre las diferentes comportamientos de los controladores, ver Comportamientos del controlador.\nAunque todos los controladores comparten una única interfaz orientada al usuario para manejar los navegadores, todos ellos tienen diferentes formas de establecer las sesiones. Ya que muchas de estas implementaciones son realizadas por terceras personas y no están incluidas en la distribución estándar de Selenium.\nLa instanciación del controlador, el tratamiento de perfiles y algunos ajustes específicos de cada navegador son ejemplos de parámetros que tienen diferentes requisitos dependiendo del navegador.\nEsta sección explica los requisitos básicos para comenzar a trabajar con diferentes navegadores.\nAñadiendo los ejecutables al PATH del sistema La gran mayoría de controladores necesitan de un ejecutable extra para que Selenium pueda comunicarse con el navegador. Puedes especificar manualmente donde esta ubicado el ejecutable antes lanzar el WebDriver, pero esto hará que tus tests sean menos portables, ya que los ejecutables necesitan estar en el mismo lugar en todas las maquinas, o que este incluido en el repositorio.\nAñadir una carpeta que contenga los binarios del WebDriver a tu sistema, permitirá a Selenium localizar los binarios necesarios adicionales sin la necesidad de tener que incluir en el código de los tests la ruta exacta.\n Crea un directorio para almacenar los ejecutables en el, como C:\\WebDriver\\bin o /opt/WebDriver/bin Añade el directorio al PATH del sistema:  En Windows - Abre una terminal de comando como administrador y ejecuta el siguiente comando para añadir permanentemente el directorio a tu PATH para todos los usuarios de tu maquina:    setx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34;  En macOS y Linux ejecutar el siguiente comando en una terminal:  export PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile   Ahora puedes probar los cambios. Para ello cierra todas las terminales de comando y abre una nueva Escribe el nombre de uno de los binarios que has añadido en la carpeta en el paso previo. p. ej.:\nchromedriver   Si tu PATH ha sido configurado correctamente, verás una salida relacionada con la puesta en marcha del controlador:\n  Starting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed. Puedes recuperar el control de la consola de comandos pulsando Ctrl + CReferencia Rápida    Navegador SO Soportados Mantenido por Descargas Issues     Chromium/Chrome Windows/macOS/Linux Google Descargas Incidentes   Firefox Windows/macOS/Linux Mozilla Descargas Incidentes   Edge Windows 10 Microsoft Descargas Incidentes   Internet Explorer Windows Proyecto de Selenium Descargas Incidentes   Safari macOS El Capitan and newer Apple Integrado Incidentes   Opera Windows/macOS/Linux Opera Descargas Incidentes    Chromium/Chrome Para controlar Chrome o Chromium, tienes que descargar chromedriver y almacenarlo en una carpeta que esté en el PATH del sistema.\nEn Linux y en macOS esto significa que tienes que modificar la variable de entorno PATH.\nPuedes ver que directorios están incluidos en esta variable, los directorios se separan mediante dos puntos.\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin Para incluir el chromedriver en el PATH si no lo estuviera, hay que asegurarse que incluimos la ruta donde se almacena el binario del chromedriver. Recuerda que puedes fijar la ruta al ejecutable del chromedriver usando la siguiente linea, esto te permitirá añadir el contenido actual del PATH mas una ruta adicional después de los dos puntos:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; Cuando el chromedriver este en el PATH este podrá ser ejecutado desde cualquier directorio. Para instanciar una sesión de Chrome/Chromium puedes hacer lo siguiente:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Asignación simple from selenium.webdriver import Chrome driver = Chrome() #Como gestor de contexto from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     Recuerda que tienes que fijar la ruta al ejecutable del chromedriver. Lo puedes hacer de la siguiente forma:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     El chromedriver esta implementado como un servidor remoto el cual expone la interfaz del proxy para la automatización de chrome, enseñando asi al navegador que hacer.\nFirefox Con la salida de Selenium 3, Mozilla se ha encargado de la implementación del controlador de Firefox, a través del geckodriver. Este nuevo controlador se llama geckodriver y funciona a partir de la versión 48 de Firefox. Como este controlador sigue en desarrollo, cuanto mas nueva sea la versión de Firefox mas respaldo tendrá por parte de Mozilla.\nComo geckodriver es la nueva forma por defecto de lanzar Firefox, puedes instanciar Firefox de la misma forma en Selenium 2:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Asignación simple from selenium.webdriver import Firefox driver = Firefox() #Como gestor de contexto from selenium.webdriver import Firefox with Firefox() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     Si no quisieras fijar la ruta del geckodriver en el PATH, puedes fijar la ruta del ejecutable como propiedad del sistema:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.setBinary(\u0026#34;/path/to/geckodriver\u0026#34;);   System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     En ciertos lenguajes de programación también es posible fijar la propiedad en tiempo de ejecución:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver Actualmente también es posible revertir al controlador antiguo de Firefox, el cual es un controlador mas completo, instalando la versión 47.0.1 o 45 ESR y especificando la capacidad deseada del controlador marionette como false. Las ultimas versiones de Firefox ya no son compatibles con este controlador.\nEdge Edge es el navegador mas nuevo de Microsoft, incluido en Windows 10 y Microsoft Server 2016. Las actualizaciones de Edge están incluidas en las actualizaciones principales de Windows, es por eso que necesitaras descargar el binario que coincida con la versión que tengas en ese momento instalada de Windows. La web de desarrolladores de Edge contiene los enlaces a todos los binarios disponibles.\nLos bugs de la implementación del EdgeDriver se pueden encontrar en Microsoft.\nSi deseas lanzar los tests contra Edge pero tu sistema operativo no es Windows 10, Microsoft ofrece maquinas virtuales en la web de desarrolladores de Edge.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Asignación simple from selenium.webdriver import Edge driver = Edge() #Como gestor de contexto: from selenium.webdriver import Edge with Edge() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     Si el controlador de Edge no esta presente en el PATH, puedes añadirlo con el siguiente comando:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const edge = require(\u0026#39;selenium-webdriver/edge\u0026#39;); let service = new edge.ServiceBuilder(\u0026#34;/path/to/msedgedriver.exe\u0026#34;); (async function test() { let driver = await new Builder() .setEdgeService(service) .forBrowser(\u0026#39;MicrosoftEdge\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     Internet Explorer Internet Explorer era el navegador por defecto hasta la salida de Windows 10, aunque todavía esta incluido en Windows 10. El controlador de Internet Explorer es el único que Selenium tiene como objetivo admitir las mismas versiones que Microsoft considera como actuales. Las versiones anteriores pueden funcionar pero no serán mantenidas.\nA pesar de que Selenium proporciona los binarios para las versiones de 32 y 64 bits de Internet Explorer existen algunas limitaciones respecto a las versiones 10 y 11 para el controlador de 64-bits, en cambio el controlador de 32-bits funciona correctamente. Hay que tener en cuenta que las preferencias de Internet Explorer se guardan en la cuenta del usuario conectado, ademas es necesario realizar configuraciones adicionales\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Asignación simple from selenium.webdriver import Ie driver = Ie() #Como gestor de contexto from selenium.webdriver import Ie with Ie() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     Si el controlador de Internet Explorer no esta presente en el PATH, puedes añadirlo usando la siguiente linea:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let service = new ie.ServiceBuilder(\u0026#34;/path/to/IEDriverServer.exe\u0026#34;); (async function test() { let driver = await new Builder() .setIeService(service) .forBrowser(\u0026#39;internet explorer\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     Microsoft tambien ofrece un binario para Internet Explorer 11 en Windows 7 y 8.1. El cual no ha sido actualizado desde 2014 y está basado en una versión preeliminar de la especificación del W3C. Jim Evans hizo un informe excelente sobre la implementación del controlador.\nOpera Las versiones actuales de Opera están construidas con el motor de Chromium, y WebDriver ahora es soportado a través del controlador de código propietario de Opera el cual puede ser añadido al PATH o configurado como propiedad del sistema.\nInstanciar una sesión del controlador es similar a como se hace el Firefox y Chromium:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Asignación simple from selenium.webdriver import Opera driver = Opera() #Como gestor de contexto from selenium.webdriver import Opera with Opera() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const opera = require(\u0026#39;selenium-webdriver/opera\u0026#39;); (async function test() { let driver = await new Builder() .forBrowser(\u0026#39;opera\u0026#39;) .build(); })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari Para las versiones High Sierra y superiores:\n Al Lanzar el siguiente comando desde la terminal por primera vez se debe escribir la contraseña para autorizar al WebDriver  safaridriver --enable Para El Capitan y Sierra:\n Activar el menú desarrollador desde las preferencias de Safari Seleccionar la opción Permitir automatización desde el menú del desarrollador Ejecutar el siguiente comando desde la terminal y escribir la contraseña para autorizar al WebDriver  /usr/bin/safaridriver -p 1337\u0026lt;/ Una vez realizar podrás comenzar una sesión usando:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Asignación simple from selenium.webdriver import Safari driver = Safari() #Como gestor de contexto from selenium.webdriver import Safari with Safari() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     Aquellos que busquen automatizar Safari en iOS deberían echarle un vistazo al proyecto de Appium Aunque antes Safari estuviera disponible en Windows, Apple hace tiempo que dejo de mantenerlo, convirtiendo así a Windows en una pobre elección para la automatización de pruebas sobre Safari\nNavegadores simulados HtmlUnit HtmlUnit es un navegador sin interfaz grafica para programas basados en Java. Modela documentos HTML y proporciona un API que permite invocar las paginas, rellanar formularios, hacer clic en enlaces, etc. Soporta JavaScript y es capaz de funcionar con librerías AJAX, simulando Chrome, Firefox o Internet Explorer dependiendo de la configuración usada. Se ha migrado a una nueva web. El código fuente es mantenido con de snv.\nPhantomJS PhantomJS is un navegador sin interfaz grafica basado en Webkit, aunque la versión en la que se basa es mucho mas antigua que las usadas por Chrome o Safari. A pesar de que históricamente ha sido una elección popular actualmente no es una elección muy sabia. Ya que el proyecto esta sin soporte desde el 5 de gosto, cuando Google anunció que Chrome tendría la capacidad de ser un navegador sin interfaz grafica, algo que también ha ofrecido Firefox.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/introduction/on_test_automation/",
	"title": "Sobre automatización de pruebas",
	"tags": [],
	"description": "",
	"content": "Primero, pregúntate si realmente necesitas o no usar un navegador. Lo más probable es que, en algún momento, si estás trabajando en una aplicación web compleja, necesitarás abrir un navegador y realmente probarlo.\nSin embargo, las pruebas funcionales de usuario final, como las pruebas de Selenium son caras de ejecutar. Además, normalmente requieren que una infraestructura considerable este disponible para estas ejecutarse de manera efectiva. Es una buena regla preguntarse siempre si lo que se quiere probar se puede hacer usando enfoques de prueba más livianos como las pruebas unitarias o con un enfoque de bajo nivel.\nUna vez que hayas tomado la determinación de que estás en el negocio de hacer pruebas en el navegador, y que tengas tu ambiente de Selenium listo para empezar a escribir pruebas, generalmente realizaras alguna combinación de estos tres pasos:\n Preparar los datos Realizar un conjunto discreto de acciones Evaluar los resultados  Querrás mantener estos pasos tan cortos como sea posible; una o dos operaciones deberían ser suficientes la mayor parte del tiempo. La automatización del navegador tiene la reputación de ser \u0026ldquo;frágil\u0026rdquo;, pero en realidad, esto se debe a que los usuarios suelen exigirle demasiado. En capítulos posteriores, volveremos a las técnicas que puedes utilizar para mitigar problemas aparentemente intermitentes en las pruebas, en particular como superar race conditions entre el navegador y WebDriver.\nManteniendo tus pruebas cortas y usando el navegador web solo cuando no tienes absolutamente ninguna alternativa, Puedes tener muchas pruebas con fragilidades muy mínimas.\nUna clara ventaja de las pruebas de Selenium es su capacidad inherente para probar todos los componentes de la aplicación, desde el backend hasta el frontend, desde la perspectiva del usuario. En otras palabras, aunque las pruebas funcionales pueden ser caras de ejecutar, también abarcan a la vez grandes porciones críticas para el negocio.\nRequisitos de pruebas Como se mencionó anteriormente, las pruebas de Selenium pueden ser costosas de ejecutar. Hasta qué punto, dependerá del navegador en el que estás ejecutando las pruebas, pero históricamente el comportamiento de los navegadores ha variado tanto que a menudo ha sido un objetivo claro realizar pruebas cruzadas contra múltiples navegadores.\nSelenium te permite ejecutar las mismas instrucciones en múltiples navegadores en múltiples sistemas operativos, pero la enumeración de todos los navegadores posibles, sus diferentes versiones y los muchos sistemas operativos en los que se ejecutan se convertirá rápidamente en una misión no trivial.\nIniciemos con un ejemplo Larry ha escrito un sitio web que le permite a los usuarios ordenar unicornios personalizados.\nEl flujo de trabajo principal (que llamaremos el \u0026ldquo;camino feliz\u0026rdquo;) es algo como esto:\n Crea una cuenta Configura el unicornio Agrégalo al carrito de compras Envialo a caja y realiza el pago Dar feedback sobre el unicornio  Sería tentador escribir un gran script de Selenium para realizar todas estas operaciones, muchos lo intentarán. ¡Resiste la tentación! Hacerlo dará como resultado una prueba que a) toma mucho tiempo, b) estará sujeta a algunos problemas comunes relacionados con los problemas de tiempo de representación de la página, y c) es tal que si falla, no te dará un método conciso y \u0026ldquo;fácil de ver\u0026rdquo; para diagnosticar lo que salió mal.\nLa estrategia preferida para probar este escenario sería dividirlo en una serie de pruebas rápidas e independientes, cada una de las cuales tenga una \u0026ldquo;razón\u0026rdquo; para existir.\nSupongamos que deseas probar el segundo paso: Configurando tu unicornio. Realizará las siguientes acciones:\n Crea una cuenta Configura el unicornio  Ten en cuenta que nos estamos saltando el resto de los pasos, probaremos el resto del flujo en otros casos de prueba pequeños y discretos, después de que hayamos terminado con este.\nPara comenzar, debes crear una cuenta. Aquí tienes que tomar algunas decisiones:\n ¿Quieres usar una cuenta existente? ¿Quieres crear una nueva cuenta? ¿Hay alguna propiedad especial de dicho usuario que deba ser tomado en cuenta antes de que comience la configuración?  Independientemente de cómo respondas esta pregunta, la solución es hacer que forme parte del paso de \u0026ldquo;preparar los datos\u0026rdquo; de la prueba. Si Larry ha expuesto una API que te permite a ti (o cualquier persona) crear y actualizar cuentas de usuario, asegúrate de usar eso para responder esta pregunta. Si es posible, debes iniciar el navegador solo después de tener un usuario \u0026ldquo;en la mano\u0026rdquo;, cuyas credenciales pueden iniciar sesión.\nSi cada prueba para cada flujo de trabajo comienza con la creación de una cuenta de usuario, se agregarán muchos segundos a la ejecución de cada prueba. Llamar a una API y hablar con una base de datos son operaciones \u0026ldquo;sin cabeza\u0026rdquo; rápidas, que no requieren el costoso proceso de abrir un navegador, navegar a las páginas correctas, hacer clic y esperar que se envíen los formularios, etc.\nIdealmente, puedes abordar esta fase de configuración en una sola línea de código, que se ejecutará antes de que se inicie cualquier navegador:\nJava Python C# Ruby JavaScript Kotlin // Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas // conocerlos. User user = UserFactory.createCommonUser(); //Este método se define en otro lugar.  // Inicia sesión como este usuario. // Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // el método loginAs devuelve el objeto AccountPage, lo que le permite // realizar acciones de AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, # pero no tienen configurada la información de pago, ni tienen # privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico # la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas # conocerlos. user = user_factory.create_common_user() #Este método se define en otro lugar. # Inicia sesión como este usuario. # Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que # el método loginAs devuelve el objeto AccountPage, lo que le permite # realizar acciones de AccountPage account_page = login_as(user.get_email(), user.get_password())   // Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas // conocerlos. User user = UserFactory.CreateCommonUser(); //Este método se define en otro lugar.  // Inicia sesión como este usuario. // Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // el método loginAs devuelve el objeto AccountPage, lo que le permite // realizar acciones de AccountPage. AccountPage accountPage = LoginAs(user.Email, user.Password);   # Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, # pero no tienen configurada la información de pago, ni tienen # privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico # la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas # conocerlos. user = UserFactory.create_common_user #Este método se define en otro lugar. # Inicia sesión como este usuario. # Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que # el método loginAs devuelve el objeto AccountPage, lo que le permite # realizar acciones de AccountPage account_page = login_as(user.email, user.password)   // Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas // conocerlos. var user = userFactory.createCommonUser(); //Este método se define en otro lugar.  // Inicia sesión como este usuario. // Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // el método loginAs devuelve el objeto AccountPage, lo que le permite // realizar acciones de AccountPage. var accountPage = loginAs(user.email, user.password);   // Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas // conocerlos. val user = UserFactory.createCommonUser() //Este método se define en otro lugar.  // Inicia sesión como este usuario. // Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // el método loginAs devuelve el objeto AccountPage, lo que le permite // realizar acciones de AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     Como puedes imaginar, la UserFactory puede ampliarse para proporcionar métodos como createAdminUser() y createUserWithPayment(). El punto es, que estas dos líneas de código no te distraigan del propósito final de esta prueba: configurar un unicornio.\nLas complejidades del Modelo Page Object serán discutidas en capítulos posteriores, pero introduciremos el concepto aquí:\nTus pruebas deben estar compuestas de acciones, realizadas desde el punto de vista del usuario, dentro del contexto de las páginas en el sitio web. Estas páginas se almacenan como objetos, que contendrán información específica sobre cómo está compuesta la página web y cómo se realizan las acciones– muy poco de lo que cual debería preocuparte como probador.\n¿Qué tipo de unicornio quieres? Es posible que desees rosa, pero no necesariamente. El morado es muy popular últimamente. ¿Ella necesita gafas de sol? ¿Tatuajes de estrellas? Estas elecciones, aunque difíciles, son tu principal preocupación como probador: debes asegurarte de que tu centro de distribución de pedidos envíe el unicornio correcto a la persona correcta, y eso comienza con estas elecciones.\nObserva que en ninguna parte de este párrafo hablamos de botones, campos, menús desplegables, botones de opción o formularios web. ¡Tampoco deberían tus pruebas! Debes escribir tu código como el usuario que intenta resolver su problema. Aquí hay una forma de hacerlo (continuando con el ejemplo anterior):\nJava Python C# Ruby JavaScript Kotlin // El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de ninguna manera. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; // nos llevará allí. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a // su método createUnicorn(). Este método tomará los atributos de Sparkles, // completara el formulario y hará clic en enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. # Esto solo almacena los valores; no llena ningún formulario web ni interactúa # con el navegador de ninguna manera. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al # lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; # nos llevará allí. add_unicorn_page = account_page.add_unicorn() # Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a # su método createUnicorn(). Este método tomará los atributos de Sparkles # completara el formulario y hará clic en enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de ninguna manera. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.Purple, UnicornAccessories.Sunglasses, UnicornAdornments.StarTattoos); // Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; // nos llevará allí. AddUnicornPage addUnicornPage = accountPage.AddUnicorn(); // Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a // su método createUnicorn(). Este método tomará los atributos de Sparkles, // completara el formulario y hará clic en enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.CreateUnicorn(sparkles);   # El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. # Esto solo almacena los valores; no llena ningún formulario web ni interactúa # con el navegador de ninguna manera. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, Unicor sparkles = Unicorn.new(\u0026#39;Sparkles\u0026#39;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al # lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; # nos llevará allí. add_unicorn_page = account_page.add_unicorn # Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a # su método createUnicorn(). Este método tomará los atributos de Sparkles # completara el formulario y hará clic en enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de ninguna manera. var sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; // nos llevará allí. var addUnicornPage = accountPage.addUnicorn(); // Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a // su método createUnicorn(). Este método tomará los atributos de Sparkles, // completara el formulario y hará clic en enviar.. var unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   // El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de ninguna manera. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; // nos llevará allí.. val addUnicornPage = accountPage.addUnicorn() // Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a // su método createUnicorn(). Este método tomará los atributos de Sparkles, // completara el formulario y hará clic en enviar. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     Ahora que has configurado tu unicornio, debes avanzar al paso 3: asegurarte de que realmente funcionó.\nJava Python C# Ruby JavaScript Kotlin // El método exist() de UnicornConfirmationPage tomará el objeto // Sparkles--una especificación de los atributos que deseas ver, y los va a comparar // con los campos en la página. Assert.assertTrue(\u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;, unicornConfirmationPage.exists(sparkles));   # El método exist() de UnicornConfirmationPage tomará el objeto # Sparkles--una especificación de los atributos que deseas ver, y los va a comparar # con los campos en la página. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;   // El método exist() de UnicornConfirmationPage tomará el objeto // Sparkles--una especificación de los atributos que deseas ver, y los va a comparar // con los campos en la página. Assert.True(unicornConfirmationPage.Exists(sparkles), \u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;);   # El método exist() de UnicornConfirmationPage tomará el objeto # Sparkles--una especificación de los atributos que deseas ver, y los va a comparar # con los campos en la página. expect(unicorn_confirmation_page.exists?(sparkles)).to be, \u0026#39;Sparkles debe haberse creado, con todos los atributos intactos\u0026#39;   // El método exist() de UnicornConfirmationPage tomará el objeto // Sparkles--una especificación de los atributos que deseas ver, y los va a comparar // con los campos en la página. assert(unicornConfirmationPage.exists(sparkles), \u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;);   // El método exist() de UnicornConfirmationPage tomará el objeto // Sparkles--una especificación de los atributos que deseas ver, y los va a comparar // con los campos en la página. assertTrue(\u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;, unicornConfirmationPage.exists(sparkles))     Ten en cuenta que el probador aún no ha hecho nada más que hablar de unicornios en este código\u0026ndash; nada de botones, nada de localizadores, nada de controles del navegador. Este método de modelar la aplicación te permite mantener estos comandos de nivel-de-prueba en su lugar y sin cambios, incluso si Larry decide la próxima semana que ya no le gusta Ruby-on-Rails y decide volver a implementar todo el sitio en las últimas librerías de enlace de Haskell con un front-end de Fortran.\nLos objetos de tu página requerirán un pequeño mantenimiento para poder cumplir con el rediseño del sitio, pero estas pruebas seguirán siendo iguales. Tomando este diseño básico, querrás continuar con tus flujos de trabajo con la menor cantidad posible de pasos orientados al navegador. Tu próximo flujo de trabajo implicará agregar un unicornio al carrito de compras. Probablemente querrás muchas iteraciones de esta prueba para asegurarte de que el carrito mantiene su estado correctamente: ¿Hay más de un unicornio en el carrito antes de comenzar? ¿Cuántos pueden caber en el carrito de compras? Si crea más de uno con el mismo nombre y/o características, ¿se romperá? ¿Conservará solo el existente o agregará otro?\nCada vez que te mueves por el flujo de trabajo, deseas evitar tener que crear una cuenta, iniciar sesión como usuario y configurar el unicornio. Idealmente, podrás crear una cuenta y preconfigurar un unicornio a través de la API o de la base de datos. Luego, todo lo que tienes que hacer es iniciar sesión como usuario, ubicar Sparkles, y agrégarla al carrito.\n¿Automatizar o no automatizar? Es la automatización siempre ventajosa? Cuando uno debería decidir automatizar casos de prueba?\nNo siempre es ventajoso automatizar casos de prueba. Hay veces que las pruebas manuales pueden ser mas apropiadas. Por ejemplo, si la interface de usuario de la aplicación va a cambiar considerablemente en el futuro, entonces no habria que reescribir ninguna automatizacion. Tambien, algunas veces simplemente no hay tiempo suficiente para construir la automatización de las pruebas. A corto plazo, las pruebas manuales pueden ser mas efectivas. Si una aplicación tiene una fecha limite muy ajustada, actualmente no hay ningún tipo de automatización de pruebas, y es imperativo que las pruebas se realicen dentro de la fecha limite, entonces las pruebas es la mejor solución.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/support_packages/working_with_colours/",
	"title": "Trabajando con colores",
	"tags": [],
	"description": "",
	"content": "En algunas ocasiones es posible que sea necesario querer validar el color de algo como parte de tus tests; el problema es que las definiciones de color en la web no son constantes. ¿No estaría bien que existiese una forma sencilla de comparar una representación de color HEX con una representación de color RGB, o una representación de color RGBA con una representación de color HSLA?\nNo te preocupes. Hay una solución para esto, la clase Color\nLo primero de todo, necesitaras importar la clase:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    include Selenium::WebDriver::Support   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    import org.openqa.selenium.support.Color    Ahora puedes empezar a crear objetos de la clase Color. Cada objeto necesita ser creado a partir de la representación de una cadena de texto de tu color.\nLas representaciones de colores soportadas son:\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     La clase Color también soporta todas las definiciones base de colores especificadas en http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     En muchas ocasiones los navegadores devolverán un valor de color de transparente si no se ha establecido color en el elemento. La clase Color también soporta esto:\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     Ahora puedes consultar de forma segura un elemento para obtener su color/color de fondo sabiendo que cualquier respuesta sera correctamente parseada y convertida en un objeto Color valido.\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)); Color loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;));   login_button_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;))   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    login_button_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;))   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    val loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)) val loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;))     Puedes comparar objetos de Color directamente:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    assert(login_button_background_colour == HOTPINK)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    assert(loginButtonBackgroundColour.equals(HOTPINK))     También puedes convertir un color en uno de los siguientes formatos y después realizar una validación estática:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     Con todo esto los colores ya no serán un problema.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/remote_webdriver/remote_webdriver_client/",
	"title": "WebDriver remoto - cliente",
	"tags": [],
	"description": "",
	"content": "Para ejecutar un cliente de WebDriver remoto, primero debemos conectarnos a RemoteWebDriver. Hacemos esto apuntando la URL a la dirección del servidor que ejecuta nuestras pruebas. Para personalizar nuestra configuración, establecemos las capabilities deseadas. A continuación se muestra un ejemplo de la, instanciación de un objeto WebDriver remoto apuntando a nuestro servidor web remoto, www.example.com, ejecutando nuestras pruebas en Firefox.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver firefox_options = webdriver.FirefoxOptions() driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=firefox_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); var capabilities = Capabilities.firefox(); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     Para personalizar aún más nuestra configuración de prueba, podemos agregar otras capabilities deseadas.\nOpciones del navegador Por ejemplo, supón que deseas ejecutar Chrome en Windows XP, usando Chrome versión 67:\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.set_capability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chrome_options.set_capability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=chrome_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var chromeOptions = new ChromeOptions(); chromeOptions.BrowserVersion = \u0026#34;67\u0026#34;; chromeOptions.PlatformName = \u0026#34;Windows XP\u0026#34;; IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); const chrome = require(\u0026#34;selenium-webdriver/chrome\u0026#34;) var capabilities = Capabilities.chrome(); //To avoid InsecureCertificateError for selenium4-aplha5 capabilities.setAcceptInsecureCerts(true); capabilities.set(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); capabilities.set(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit();     Detector de archivos local El Local File Detector permite la transferencia de archivos desde la máquina del cliente al servidor remoto. Por ejemplo, si una prueba necesita cargar un archivo a una aplicación web, un WebDriver remoto puede transferir automáticamente el archivo de la máquina local al servidor web remoto durante tiempo de ejecución. Esto permite que el archivo se cargue desde la máquina remota ejecutando la prueba. No está habilitado de forma predeterminada y puede habilitarse en de la siguiente manera:\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   from selenium.webdriver.remote.file_detector import LocalFileDetector driver.file_detector = LocalFileDetector()   var allowsDetection = this.driver as IAllowsFileDetection; if (allowsDetection != null) { allowsDetection.FileDetector = new LocalFileDetector(); }   @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   var remote = require(\u0026#39;selenium-webdriver/remote\u0026#39;); driver.setFileDetector(new remote.FileDetector);   driver.fileDetector = LocalFileDetector()     Una vez que se definido el código anterior, puedes cargar un archivo en tu prueba de la siguiente manera:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) driver.find_element(By.ID, \u0026#34;myfile\u0026#34;).send_keys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)   driver.Navigate().GoToUrl(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); IWebElement upload = driver.FindElement(By.Id(\u0026#34;myfile\u0026#34;)); upload.SendKeys(@\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); var upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/grid/setting_up_your_own_grid/",
	"title": "Configurando tu propio Grid",
	"tags": [],
	"description": "",
	"content": "Para usar Selenium Grid, necesitas mantener tu propia infraestructura para los nodos. Como esto puede suponer un engorro y suponer un gran esfuerzo de tiempo, muchas organizaciones usan proveedores de IaaS (Infraestructura como servicio) como Amazon EC2 y Google Compute para proveer esta infraestructura.\nOtras opciones incluyen usar proveedores como Sauce Labs or Testing Bot los cuales proveen Selenium Grid como servicio en la nueve. Ciertamente, también es posible ejecutar los nodos en tu propio hardware. Esta capitulo abordara en detalle la opción de ejecutar tu propio Grid completo con su propia infraestructura de nodos.\nInicio rápido Este ejemplo te enseñará como poner en marcha el Grid Hub de Selenium 2 y registrar un nodo WebDriver y un nodo heredado de Selenium 1 RC. También te enseñaremos como llamar al Grid desde Java. El hub y los nodos se muestran aquí ejecutándose en la misma maquina, pero por supuesto puedes copiar selenium-server-standalone en múltiples maquinas.\nEl paquete de selenium-server-standalone incluye el hub, el WebDriver y el servidor RC heredado necesarios para ejecutar el Grid, ant ya no es necesario. Puedes descargar selenium-server-standalone.jar desde https://selenium.dev/downloads/.\nPaso 1: Iniciar el Hub El Hub es el punto central que recibirá las peticiones de los tests y las distribuirá a los nodos adecuados. La distribución se hace en función capacidades, esto significa que un test que necesite un conjunto de capacidades solo sera distribuido a los nodos que ofrezcan ese conjunto o subconjunto de capacidades.\nDebido a que las capacidades deseadas de una prueba son justo lo que el nombre implica deseadas, el hub no garantiza que se localice un nodo que coincida completamente con el conjunto de capacidades deseadas.\nAbre una ventana de navegación y navega hasta el directorio donde tienes copiado el archivo selenium-server-standalone.jar. Puedes iniciar el hub pasandole el parámetro -role hub al servidor standalone.\njava -jar selenium-server-standalone.jar -role hub El hub escuchará al puerto 4444 por defecto. Puedes ver el estado del hub abriendo una ventana del navegador y navegando a http://localhost:4444/grid/console.\nPara cambiar el puerto por defecto, puedes añadir el parámetro opcional -port asignándole un valor entero que representará el puerto a escuchar cuando se ejecute el comando. Ademas todas las otras opciones que puedes observar en el archivo de configuración JSON (mostrado a continuación) son posibles parámetros vía linea de comandos.\nCiertamente puedes trabajar solo con el comando simple que se muestra arriba, pero si necesitases una configuración mas avanzada podrías especificarla en un archivo de configuración JSON para configurar el hub con su arranque. Puedes hacerlo tal que así.\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug A continuación puedes ver un ejemplo de un archivo hubConfig.json. Iremos mas en detalle sobre como proveer archivos de configuración a los nodos en el paso 2.\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} Paso 2: Iniciar los nodos Independientemente de si quieres ejecutar un Grid con una nueva funcionalidad del WebDriver, un Grid con funcionalidades de Selenium 1 RC, o ambas al mismo tiempo se usa el mismo archivo selenium-server-standalone.jar para arrancar los nodos.\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 Si no se especifica un puerto a través del parámetro -port se elegirá un puerto libre. Puedes ejecutar múltiples nodos en una maquina pero si lo haces tienes que tener en cuenta los recursos de memoria de tus sistemas y de los problemas con las capturas de pantalla si tus tests las realizan.\nConfiguración de un nodo con opciones Como hemos mencionado, para disponer de compatibilidad con las versiones anteriores los roles \u0026ldquo;wd\u0026rdquo; y \u0026ldquo;rc\u0026rdquo; todavía son un subconjunto valido del rol en los \u0026ldquo;node\u0026rdquo;. Pero estos roles limitan el tipo de conexiones remotas a sus correspondientes APIs, mientras que el rol \u0026ldquo;node\u0026rdquo; permite conexiones remotas a ambos el RC y al WebDriver.\nPasar propiedades de la JVM (como usar el parámetro -D antes del argumento -jar) vía linea de comando permitirá a las nodos recoger y propagar estos parámetros.\n-Dwebdriver.chrome.driver=chromedriver.exe\nConfigurando un nodo via JSON Tambien se pueden ejecutar nodos que hayan sido configurados via archivos de configuración JSON.\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json Este es un ejemplo de archivo nodeConfig.json:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } Una nota sobre el parametro -host:\nPara ambos el hub y el nodo, si no se especifica el parámetro -host se usará por defecto la IP 0.0.0.0. Este se unirá a todos los interfaces IPv4 públicos (sin loopback) de la maquina. Si tienes alguna configuración de red especial o algún componente que utilice interfaces de red extra es recomendado fijar el parámetro -host con un valor que permita que el hub o los nodos sean accesibles desde maquinas diferentes.\nEspecificando el puerto El puerto TCP/IP por defecto usado por el hub es el 4444. Si necesitas cambiar el puerto por favor usa las configuraciones mencionadas arriba.\nSolución de problemas Usando un archivo log Para resolución de problemas avanzados puedes especificar un archivo de log que almacene los mensajes del sistema. Lanza el Grid de Selenium o el nodo con el argumento -log. A continuación dispone de un ejemplo:\njava -jar selenium-server-standalone.jar -role hub -log log.txt Usa tu editor de texto favorito para abrir el archivo de log (log.txt en el ejemplo) para encontrar los logs de \u0026ldquo;ERROR\u0026rdquo; si tienes problemas.\nUsando el argumento -debug También puedes usar el argumento -debug para imprimir los logs de debug en la consola. Lanza el Grid de Selenium o el nodo con el argumento -debug. A continuación dispone de un ejemplo:\njava -jar selenium-server-standalone.jar -role hub -debug Advertencia El Grid de Selenium debe estar protegido contra accesos externos mediante el uso apropiado de permisos de firewall.\nFallar a la hora de proteger el Grid puede resultar en uno o mas de los siguientes problemas:\n Proveer acceso abierto a tu infraestructura del Grid. Permitir a terceros el acceso a aplicaciones web y archivos interno. Permitir a terceros ejecutar tus ejecutables.  Puedes visitar el blog Detectify el cual te puede aportar mas información sobre los peligros de exponer tu grid públicamente. Aquí puedes visitar el articulo Don\u0026rsquo;t Leave your Grid Wide Open.\nSelenium Docker Docker provee una forma conveniente de aprovisionar y escalar la infraestructura de Selenium Grid en unidades conocidas como contenedores. Los contenedores son unidades estandarizadas de software que contienen todo lo necesario para ejecutar la aplicación deseada, incluidas todas las dependencias, en un entorno confiable y regenerable en diferentes sistemas.\nEl proyecto de Selenium mantiene un conjunto de imágenes Docker las cuales puedes descargar y ejecutar para tener un Grid funcionando rápidamente. Los nodos están disponibles para los navegadores Firefox y Chrome. Todos los detalles de como abastecer un Grid se encuentran en Docker Selenium.\nPrerequisitos El único requisito para ejecutar el Grid es tener Docker instalado y funcionando. Puedes descargar Docker en este enlace.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/worst_practices/http_response_codes/",
	"title": "Códigos de respuesta HTTP",
	"tags": [],
	"description": "",
	"content": "Para algunas configuraciones de navegadores en Selenium RC, Selenium actuaba como proxy entre el navegador y el sitio web que iba a ser automatizado. Esto significaba que todo el trafico que pasaba a través de Selenium podía ser capturado o manipulado. El método captureNetworkTraffic() pretendía capturar todo el trafico de red entre el navegador y el sitio que estaba siendo automatizado, incluyendo los códigos de respuestas HTTP.\nEl WebDriver de Selenium parte de una aproximación completamente diferente respecto a la automatización de los navegadores, prefiriendo así actuar mas como un usuario y esto se representa en la forma en la que escribes los tests con el WebDriver. Para los tests funcionales automatizados comprobar el código de respuesta no es un detalle particularmente importante en un test fallido, los pasos que se han realizado lo son mucho mas.\nEl navegador siempre representará el código de estado de respuesta HTTP, imagina por ejemplo una pagina de error para los códigos 404 o 500. Un forma simple de hacer fallar el test cuando encuentras una de estas paginas de error es validar los títulos de las paginas o algún contenido de confianza (ej. la etiqueta \u0026lt;h1\u0026gt;) después de que se haya cargado cada pagina. Si estas usando un modelo basado en el patrón page object puedes incluir esta validación en el constructor de la clase o en puntos similares donde se espere la carga de una pagina. En algunas ocasiones el código de respuesta HTTP puede llegar a ser representado en la pagina de error en el navegador e incluso podrías usar el WebDriver para leerlo y facilitar la depuración en tus tests.\nComprobar la pagina web es la linea de trabajo ideal del WebDriver representando y validando así la vista de los usuarios de los sitios web.\nSi aun así necesitases una forma de capturar los códigos de respuesta HTTP una forma avanzada es replicar el comportamiento de Selenium RC usando un proxy. El API del WebDriver provee la habilidad de configurar un proxy para un navegador, existen una gran cantidad de proxies que te permiten programaticamente manipular los contenidos de las peticiones enviadas y recibidas desde los servidores web. Usar un proxy te permite decidir como actuar frente a redirecciones. Ademas, no todos los navegadores hacen que los códigos de respuesta estén disponibles para el WebDriver, es por eso que optar por un proxy te permitirá disponer de una solución común para todos los navegadores.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/generating_application_state/",
	"title": "Generar el estado de la aplicación",
	"tags": [],
	"description": "",
	"content": "Selenium no debe usarse para preparar un caso de prueba. Todas las acciones repetitivas y los preparativos para un caso de prueba deben realizarse a través de otros métodos. Por ejemplo, la mayoría de las IU web tienen autenticación (por ejemplo, un formulario de inicio de sesión). Eliminar el inicio de sesión a través del navegador web antes de cada prueba mejora tanto la velocidad como la estabilidad de la prueba. Un método debe ser creado para obtener acceso al AUT* (por ejemplo, usando una API para iniciar sesión y establecer un cookie). Además, crear métodos para precargar datos para las pruebas no deben realizarse con Selenium. Como se mencionó previamente, las API existentes se deben aprovechar para crear datos para el AUT*.\n*AUT: Application Under Test (aplicación bajo prueba)\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/legacy_docs/html-runner/",
	"title": "HTML runner",
	"tags": [],
	"description": "",
	"content": "Selenium HTML-runner te permite ejecutar Test Suites desde una línea de comando. Las suites de prueba son exportaciones HTML de Selenium IDE o herramientas de compatibles.\nInformación común  Combinaciónes de versiones de geckodriver / firefox / selenium-html-runner importan. Puede haber una matriz de compatibilidad de software en alguna parte. selenium-html-runner solo ejecuta Test Suites (no Test Cases - por ejemplo, una exportación desde Monitis Transaction Monitor). Asegurate que cumples con esto. Para usuarios de Linux sin INTERFAZ: debes iniciar html-runner con pantalla virtual (buscar xvfb)  Ejemplo en un ambiente Linux Instala / descarga los siguientes paquetes de software:\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Ejemplo de Test Suite:\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;YOUR-TEST-SCENARIO\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Como ejecutar headless (sin interfaz visual) selenium-html-runner Ahora, la parte más importante, un ejemplo de cómo ejecutar el selenium-html-runner! Tu experiencia puede variar según combinaciones de las versiones del software - geckodriver / FF / html-runner.\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html [user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/es/selenium_installation/",
	"title": "Instalación de Selenium",
	"tags": [],
	"description": "",
	"content": "Instalación de Selenium La configuración de Selenium es bastante diferente de la configuración de otras herramientas comerciales. Para usar Selenium en tu proyecto de automatización, necesitas instalar las librerías de enlace de tu lenguaje de preferencia. Además necesitarás los binarios de WebDriver para los navegadores en los que deseas automatizar y ejecutar pruebas.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/selenium_installation/installing_standalone_server/",
	"title": "Instalación del servidor Standalone",
	"tags": [],
	"description": "",
	"content": "Si planeas usar Grid debes descargar el fichero selenium-server-standalone JAR. Todos los componentes están disponibles a través de selenium-server. El standalone JAR contiene todo, incluso el servidor remoto de Selenium y los enlaces del lado del cliente. Ésto quiere decir que si usas el selenium-server-standalone jar en tu proyecto, no tienes que añadir selenium-java o un jar de navegador específico.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/es/getting_started_with_webdriver/locating_elements/",
	"title": "Localizando elementos",
	"tags": [],
	"description": "",
	"content": "Localizando un elemento Una de las técnicas más fundamentales para aprender al usar WebDriver es cómo encontrar elementos en la página. WebDriver ofrece varios tipos de selectores integrados, entre ellos encontrar un elemento por su atributo ID:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element(By.ID, \u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     Como se ve en el ejemplo, localizar elementos en WebDriver se realiza en la instancia del objeto WebDriver. El método findElement(By) devuelve otro tipo de objeto fundamental, el WebElement.\n WebDriver representa el navegador WebElement representa un nodo particular del DOM (un control, por ejemplo un enlace o campo de entrada, etc.)  Una vez que tengas una referencia a un elemento web que se ha \u0026ldquo;encontrado\u0026rdquo;, puedes reducir el alcance de tu búsqueda utilizando la misma llamada en la instancia de ese objeto:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(By.ID, \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;) cheddar = cheese.find_element(id: \u0026#39;cheddar\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     Puedes hacer esto porque los tipos WebDriver y WebElement implementan la interfaz SearchContext. En WebDriver, esto se conoce como interfaz basada en roles. Las interfaces basadas en roles te permiten determinar si la implementación del controlador admite una característica dada. Estas interfaces están claramente definidas y tratan de cumplir con tener un solo rol de responsabilidad. Puede leer más sobre el diseño de WebDriver y qué roles son compatibles con qué controladores en Otra sección.\nEn consecuencia, la interfaz By utilizada anteriormente también permite una serie de estrategias adicionales de localización. Una búsqueda anidada podría no ser la estrategia mas efectiva para localizar cheese ya que requiere dos comandos que se emitirán al navegador; primero buscando en el DOM un elemento con ID \u0026ldquo;cheese\u0026rdquo;, luego una búsqueda de \u0026ldquo;cheddar\u0026rdquo; en un contexto reducido.\nPara mejorar ligeramente el rendimiento, deberíamos intentar utilizar un localizador más específico: WebDriver permite buscar elementos por localizadores CSS, lo que nos permite combinar los dos localizadores anteriores en una sola búsqueda:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   driver.find_element(css: \u0026#39;#cheese #cheddar\u0026#39;)   const cheddar = driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     Localizando múltiples elementos Es posible que el documento con el que estamos trabajando contenga una lista ordenada del queso que más nos gusta:\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; Dado que más queso es indiscutiblemente mejor, y sería engorroso tener que recuperar cada uno de los elementos individualmente, una técnica superior para recuperar cheese es hacer uso de la versión pluralizada findElements(By). Este método devuelve una colección de elementos web. Si solo se encuentra un elemento, aún devolverá una colección (de un elemento). Si ningún elemento coincide con el localizador, se devolverá la lista vacía. Java Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(“#cheese li”));   mucho_cheese = driver.find_elements(css: \u0026#39;#cheese li\u0026#39;)   const muchoCheese = driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))    \nEstrategias de localización de elementos Hay ocho estrategias diferentes de ubicación de elementos integradas en WebDriver:\n   Localizador Descripción     class name Localiza elementos en el que el nombre de su clase contiene el valor de la búsqueda (no se permiten nombres de clase compuestos)   css selector Localiza elementos que coinciden con un selector CSS   id Localiza elementos cuyo atributo ID coincide con el valor de la búsqueda   name Localiza elementos cuyo atributo NAME coincide con el valor de la búsqueda   link text Localiza elementos de anclaje cuyo texto visible coincide con el valor de búsqueda   partial link text Localiza elementos de anclaje cuyo texto visible coincide con el valor de búsqueda. Si varios elementos coinciden, solo se seleccionará el primero.   tag name Localiza elementos cuyo nombre de etiqueta (tagName) coincide con el valor de búsqueda   xpath Localiza elementos que coinciden con una expresión XPath    Consejos sobre el uso de selectores En general, si los ID del HTML están disponibles, son únicos y consistentemente predecibles, son el método preferido para ubicar un elemento en una página. Tienden a trabajar muy rápido y renuncian al mucho procesamiento que viene con recorridos DOM complicados.\nSi las ID únicas no están disponibles, un selector CSS bien escrito es el método preferido para localizar un elemento. XPath funciona tan bien como los selectores CSS, pero la sintaxis es complicada y con frecuencia difícil de depurar. Aunque los selectores XPath son muy flexibles, generalmente su desempeño no es probado por lo proveedores de navegadores y tienden a ser bastante lentos.\nLas estrategias de selección basadas en enlaces de texto y enlaces de texto parciales tienen el inconveniente en que solo funcionan en elementos de enlace. Además, internamente en WebDriver llaman a los selectores XPath.\nEl nombre de la etiqueta puede ser una forma peligrosa de localizar elementos. Existen frecuentemente múltiples elementos con la misma etiqueta presentes en la página. Esto es mayormente útil cuando se llama al método findElements(By) que devuelve una colección de elementos.\nLa recomendación es mantener tus localizadores tan compactos y legibles como sea posible. Pedirle a WebDriver que atraviese la estructura del DOM es una operación costosa, y cuanto más se pueda reducir el alcance de tu búsqueda, mejor.\nRelative Locators Selenium 4 brings Relative Locators which are previously called as Friendly Locators. This functionality was added to help you locate elements that are nearby other elements. The Available Relative Locators are:\n above below toLeftOf toRightOf near  findElement method now accepts a new method withTagName() which returns a RelativeLocator.\nHow does it work Selenium uses the JavaScript function getBoundingClientRect() to find the relative elements. This function returns properties of an element such as right, left, bottom, and top.\nLet us consider the below example for understanding the relative locators.\nabove() Returns the WebElement, which appears above to the specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement passwordField= driver.findElement(By.id(\u0026#34;password\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .above(passwordField));   #from selenium.webdriver.support.relative_locator import with_tag_name passwordField = driver.find_element(By.ID, \u0026#34;password\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).above(passwordField))   //using static OpenQA.Selenium.RelativeBy; IWebElement passwordField = driver.FindElement(By.Id(\u0026#34;password\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Above(passwordField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      below() Returns the WebElement, which appears below to the specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressField= driver.findElement(By.id(\u0026#34;email\u0026#34;)); WebElement passwordField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .below(emailAddressField));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressField = driver.find_element(By.ID, \u0026#34;email\u0026#34;) passwordField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).below(emailAddressField))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressField = driver.FindElement(By.Id(\u0026#34;email\u0026#34;)); IWebElement passwordField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Below(emailAddressField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toLeftOf() Returns the WebElement, which appears to left of specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement submitButton= driver.findElement(By.id(\u0026#34;submit\u0026#34;)); WebElement cancelButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toLeftOf(submitButton));   #from selenium.webdriver.support.relative_locator import with_tag_name submitButton = driver.find_element(By.ID, \u0026#34;submit\u0026#34;) cancelButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_left_of(submitButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement submitButton = driver.FindElement(By.Id(\u0026#34;submit\u0026#34;)); IWebElement cancelButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .LeftOf(submitButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toRightOf() Returns the WebElement, which appears to right of the specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement cancelButton= driver.findElement(By.id(\u0026#34;cancel\u0026#34;)); WebElement submitButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toRightOf(cancelButton));   #from selenium.webdriver.support.relative_locator import with_tag_name cancelButton = driver.find_element(By.ID, \u0026#34;cancel\u0026#34;) submitButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_right_of(cancelButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement cancelButton = driver.FindElement(By.Id(\u0026#34;cancel\u0026#34;)); IWebElement submitButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .RightOf(cancelButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      near() Returns the WebElement, which is at most 50px away from the specified element.\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressLabel= driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .near(emailAddressLabel));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressLabel = driver.find_element(By.ID, \u0026#34;lbl-email\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;). near(emailAddressLabel))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressLabel = driver.FindElement(By.Id(\u0026#34;lbl-email\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Near(emailAddressLabel));   # Please raise a PR   // Please raise a PR    // Please raise a PR      "
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/browser_manipulation/",
	"title": "Manipulación de Navegadores",
	"tags": [],
	"description": "",
	"content": "Ruby Ruby no esta instalado por defecto en Windows. Puedes descargar la ultima versión y ejecutar el instalador. Puedes dejar todos los parámetros de configuración con los valores por defecto excepto el parámetro Add Ruby executables to your PATH de la pantalla de Installation Destination and Optional Tasks. Para manejar cualquier navegador tienes que instalar la gema de Ruby selenium-webdriver. Para instalarla abre una consola de comando y ejecuta el siguiente comando.\ngem install selenium-webdriver O si usas Bundler añade esta linea al Gemfile de tu aplicación:\ngem \u0026#34;selenium-webdriver\u0026#34; Y después ejecuta el siguiente comando en el terminal:\nbundle install Internet Explorer Internet Explorer viene instalado por defecto en Windows, por lo que no es necesario realizar ninguna instalación. Para manejar Internet Explorer en Windows tienes que descargar la ultima versión del driver de Internet Explorer y añadirlo a un directorio que este incluido en el PATH del sistema. Para saber que directorios están incluidos en el PATH escribe el comando echo %PATH% en el terminal.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem Por ejemplo el directorio C:\\Ruby200\\bin parece un buen lugar. Descomprime el archivo IEDriverServer y mueve el ejecutable IEDriverServer.exe a esta carpeta.\nLas lineas que se muestran a continuación deberían abrir una nueva ventana de Internet Explorer.\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Manejo de los navegadores web Navegar hacia La primera cosa que querrás hacer después de levantar un navegador es abrir una pagina web. Esto se puede lograr en una sola linea:\nJava Python C# Ruby JavaScript Kotlin //Forma adecuada driver.get(\u0026#34;https://selenium.dev\u0026#34;); //Forma extensa driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   //Forma adecuada driver.get \u0026#39;https://selenium.dev\u0026#39; //Forma extensa driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   //Forma adecuada driver.get(\u0026#34;https://selenium.dev\u0026#34;) //Forma extensa driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     Obtener la URL actual Puedes leer la URL actual desde la barra de direcciones del navegador usando:\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.currentUrl    Retroceder Presionando el botón de retroceder del navegador:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     Avanzar Presionando el botón de avanzar del navegador:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward()    Actualizar Recargando la pagina actual:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    Obtener el título Puedes leer el título de la pagina actual desde el navegador:\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.title    Ventanas y pestañas Obtener el controlador de ventanas El WebDriver no hace distinción entre ventanas y pestañas. Si tu sitio web abre una nueva pestaña o ventana, Selenium te permitirá trabajar con ella usando un controlador de ventanas. Cada ventana tiene un identificador único el cual persiste en una sola sesión. Puedes obtener el controlador de la ventana de la ventana actual usando:\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.windowHandle    Cambiar entre ventanas o pestañas Haciendo clic en un enlace el cual abre una nueva ventanacambiará el foco a la nueva ventana o pestaña en la pantalla, pero el WebDriver no sabrá que ventana el sistema operativo considera activa. Para trabajar con la nueva ventana necesitaras cambiar a ella. Si solo tienes dos ventanas o pestañas abiertas y sabes en cual empezaste, por proceso de eliminación, puede recorrer las ventanas o pestañas que ve el WebDriver y cambiar a una de ellas que no sea la original.\nSin embargo Selenium 4 proporciona una nueva API NewWindow la cual crea una nueva pestaña o ventana y automáticamente cambia a ella.\nJava Python C# Ruby JavaScript Kotlin //Almacena el ID de la ventana original String originalWindow = driver.getWindowHandle(); //Comprueba que no existen otras ventanas abiertas previamente assert driver.getWindowHandles().size() == 1; //Haz clic en el enlace el cual abre una nueva ventana driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Espera a la nueva ventana o pestaña wait.until(numberOfWindowsToBe(2)); //Recorrelas hasta encontrar el controlador de la nueva ventana for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Espera a que la nueva ventana cargue su contenido wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Instancia el driver with webdriver.Firefox() as driver: # Abre la URL driver.get(\u0026#34;https://seleniumhq.github.io\u0026#34;) # Configura una espera para despues wait = WebDriverWait(driver, 10) # Almacena el ID de la ventana original original_window = driver.current_window_handle # Comprueba que no existen otras ventanas abiertas previamente assert len(driver.window_handles) == 1 # Haz clic en el enlace el cual abre una nueva ventana driver.find_element(By.LINK_TEXT, \u0026#34;new window\u0026#34;).click() # Espera a la nueva ventana o pestaña wait.until(EC.number_of_windows_to_be(2)) # Recorrelas hasta encontrar el controlador de la nueva ventana for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Espera a que la nueva ventana carge su contenido wait.until(EC.title_is(\u0026#34;SeleniumHQ Browser Automation\u0026#34;))   //Almacena el ID de la ventana original string originalWindow = driver.CurrentWindowHandle; //Comprueba que no existen otras ventanas abiertas previamente Assert.AreEqual(driver.WindowHandles.Count, 1); //Haz clic en el enlace el cual abre una nueva ventana driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Espera a la nueva ventana o pestaña wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Recorrelas hasta encontrar el controlador de la nueva ventana foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Espera a que la nueva ventana cargue su contenido wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Almacena el ID de la ventana original original_window = driver.window_handle #Comprueba que no existen otras ventanas abiertas previamente assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Haz clic en el enlace el cual abre una nueva ventana driver.find_element(link: \u0026#39;new window\u0026#39;).click #Espera a la nueva ventana o pestaña wait.until { driver.window_handles.length == 2 } #Recorrelas hasta encontrar el controlador de la nueva ventana driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Espera a que la nueva ventana carge su contenido wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Almacena el ID de la ventana original const originalWindow = await driver.getWindowHandle(); //Comprueba que no existen otras ventanas abiertas previamente assert((await driver.getAllWindowHandles()).length === 1); //Haz clic en el enlace el cual abre una nueva ventana await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Espera a la nueva ventana o pestaña await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Recorrelas hasta encontrar el controlador de la nueva ventana const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Espera a que la nueva ventana cargue su contenido await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   //Almacena el ID de la ventana original val originalWindow = driver.getWindowHandle() //Comprueba que no existen otras ventanas abiertas previamente assert(driver.getWindowHandles().size() === 1) //Haz clic en el enlace el cual abre una nueva ventana driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() //Espera a la nueva ventana o pestaña wait.until(numberOfWindowsToBe(2)) //Recorrelas hasta encontrar el controlador de la nueva ventana for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } //Espera a que la nueva ventana cargue su contenido wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     Crea una nueva ventana o pestaña y cambia a ella Crea una nueva ventana o pestaña y cambia el foco de la pantalla a la nueva ventana o pestaña. No necesitas cambiar el controlador para poder trabajar sobre la nueva ventana o pestaña. Si tienes mas de dos ventanas o pestañas abiertas diferentes de la nueva puedes recorrerlas y cambiar a la que no sea la original.\nNota: Esta funcionalidad es específica de Selenium 4 y versiones posteriores. Java Python C# Ruby JavaScript Kotlin // Abre una nueva pestaña y cambia el controlador a ella driver.switchTo().newWindow(WindowType.TAB); // Abre una nueva ventana y cambia el controlar a ella driver.switchTo().newWindow(WindowType.WINDOW);   # Abre una nueva pestaña y cambia el controlador a ella driver.switch_to.new_window(\u0026#39;tab\u0026#39;) # Abre una nueva ventana y cambia el controlar a ella driver.switch_to.new_window(\u0026#39;window\u0026#39;)   // Abre una nueva pestaña y cambia el controlador a ella driver.SwitchTo().NewWindow(WindowType.Tab) // Abre una nueva ventana y cambia el controlar a ella driver.SwitchTo().NewWindow(WindowType.Window)   # Nota: El API new_window en Ruby solo abre una nueva pestaña o ventana pero no # cambiará el controlador automáticamente, el usuario tiene forzar el cambio a  # la nueva pestaña o ventana  # Abre una nueva pestaña driver.manage.new_window(:tab) # Abre una nueva ventana driver.manage.new_window(:window)   // Abre una nueva pestaña y cambia el controlador a ella await driver.switchTo().newWindow(\u0026#39;tab\u0026#39;); // Abre una nueva ventana y cambia el controlar a ella await driver.switchTo().newWindow(\u0026#39;window\u0026#39;);   // Abre una nueva pestaña y cambia el controlador a ella driver.switchTo().newWindow(WindowType.TAB) // Abre una nueva ventana y cambia el controlar a ella driver.switchTo().newWindow(WindowType.WINDOW)    \nCerrando una ventana o pestaña Cuando hayas acabado con una ventana o una pestaña y no sea la única ventana o pestaña abierta en el navegador, debes cerrarla y cambiar el controlador de vuelta a la ventana o pestaña que usabas con anterioridad. Asumiendo que has seguido los ejemplos de código de la sección anterior dispondrás de una ventana almacenada en una variable. Si le añades el siguiente código obtendrás un ejemplo:\nJava Python C# Ruby JavaScript Kotlin //Cierra una ventana o pestaña driver.close(); //Cambia el controlador a la ventana o pestaña original driver.switchTo().window(originalWindow);   #Cierra una ventana o pestaña driver.close() #Cambia el controlador a la ventana o pestaña original driver.switch_to.window(original_window)   //Cierra una ventana o pestaña driver.Close(); //Cambia el controlador a la ventana o pestaña original driver.SwitchTo().Window(originalWindow);   #Cierra una ventana o pestaña driver.close #Cambia el controlador a la ventana o pestaña original driver.switch_to.window original_window   //Cierra una ventana o pestaña await driver.close(); //Cambia el controlador a la ventana o pestaña original await driver.switchTo().window(originalWindow);   //Cierra una ventana o pestaña driver.close() //Cambia el controlador a la ventana o pestaña original driver.switchTo().window(originalWindow)     Si te olvidas de cambiar el controlador de vuelta a otra ventana después de cerrarla dejará al WebDriver ejecutando una ventana o pestaña cerrada, esto devolverá la excepción No Such Window Exception. Debes de cambiar el controlador de vuelta a una ventana o pestaña valida para continuar la ejecución.\nSaliendo del navegador al final de una sesión Cuando hayas acabado una sesión del navegador debes llamar al método salir en lugar de cerrar:\nJava Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()     Salir hará:  Cerrará todas las ventanas y pestañas asociadas a esa sesión del WebDriver. Cerrará el proceso de navegador. Cerrará el proceso en segundo plano del driver. Notificará al Grid de Selenium que el navegador ya no esta en uso y que puede ser usado por otra sesión del Grid de Selenium.    Un fallo en la llamada del método salir dejará procesos corriendo en segundo plano y puertos abiertos en tu maquina lo que podría llevar a problemas en un futuro.\nAlgunos frameworks de pruebas ofrecen métodos y anotaciones a las cuales puedes llamar para salir de una sesión al finalizar las pruebas.\nJava Python C# Ruby JavaScript Kotlin /** * Ejemplo usando JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # Ejemplo usando unittest # https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown def tearDown(self): self.driver.quit()   /* Ejemplo usando UnitTesting de Visual Studio https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # Ejemplo usando UnitTest # https://www.rubydoc.info/github/test-unit/test-unit/Test/Unit/TestCase def teardown @driver.quit end   /** * Ejemplo usando Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });   /** * Ejemplo usando JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() { driver.quit() }     Si no estas ejecutando el WebDriver en un contexto que no es de tests, puedes considerar el usar try / finally los cuales son soportadas por la gran mayoría de lenguajes de programacion de esta manera cuando aparezca una excepción la sesión del WebDriver saldrá correctamente.\nJava Python C# Ruby JavaScript Kotlin try { //Código del WebDriver aquí... } finally { driver.quit(); }   try: #Código del WebDriver aquí... finally: driver.quit()   try { //Código del WebDriver aquí... } finally { driver.Quit(); }   begin #Código del WebDriver aquí... ensure driver.quit end   try { //Código del WebDriver aquí... } finally { await driver.quit(); }   try { //Código del WebDriver aquí... } finally { driver.quit() }     El WebDriver de Python ahora es soportado como gestor de contexto, lo que permite ser usado con la palabra clave with para que automáticamente se cierre al final de la ejecución.\nwith webdriver.Firefox() as driver: # Codigo del WebDriver aqui... # El WebDriver saldrá automaticamente despues de la indentacion Frames e Iframes El uso de frames esta desaprobado, estos se basaban en construir sitios desde múltiples documentos en el mismo dominio. Es poco probable que trabajes con esto a menos que estés desarrollando una aplicación web previa a la versión de HTML5. Los iframes te permiten la inserción de un documento desde un dominio diferente y aun son usados de manera común.\nSi necesitas trabajar con iframes o frames, el WebDriver te permite hacerlo de la misma forma. Considera un iframe que contiene un botón. Si inspeccionamos el elemento usando las herramientas de desarrollo del navegador podríamos ver lo siguiente:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; Si no fuera por el iframe haríamos clic en el botón de una forma como esta:\nJava Python C# Ruby JavaScript Kotlin //Esto no funcionará driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Esto no funcionará driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Esto no funcionará driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Esto no funcionará driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Esto no funcionará await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Esto no funcionará driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Sin embargo, como no existirían botones fuera del iframe obtendríamos una excepción del tipo no such element. Esto ocurriría por que Selenium solo esta al tanto de los elementos en los niveles superiores del documento. Para interactuar con el botón primero necesitaremos cambiar el foco al iframe, de una forma similar a lo que ocurría con las ventanas y pestañas. El WebDriver ofrece tres formas de cambiar el foco a un iframe.\nUsando un WebElement Cambiar usando un WebElement es la forma mas flexible de todas. Puedes encontrar el iframe usando tu selector preferido y después cambiar el foco a el.\nJava Python C# Ruby JavaScript Kotlin //Almacena el elemento web WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Cambia el foco al iframe driver.switchTo().frame(iframe); //Ahora podemos hacer clic en el botón driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Almacena el elemento web iframe = driver.find_element(By.CSS_SELECTOR, \u0026#34;#modal \u0026gt; iframe\u0026#34;) # Cambia el foco al iframe driver.switch_to.frame(iframe) # Ahora podemos hacer clic en el botón driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Almacena el elemento web IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Cambia el foco al iframe driver.SwitchTo().Frame(iframe); //Ahora podemos hacer clic en el botón driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Almacena el elemento web iframe = driver.find_element(:css,\u0026#39;#modal \u0026gt; iframe\u0026#39;) # Cambia el foco al iframe driver.switch_to.frame iframe # Ahora podemos hacer clic en el botón driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Almacena el elemento web const iframe = driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Cambia el foco al iframe await driver.switchTo().frame(iframe); // Ahora podemos hacer clic en el botón await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Almacena el elemento web val iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) //Cambia el foco al iframe driver.switchTo().frame(iframe) //Ahora podemos hacer clic en el botón driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Usando el nombre o el ID Si tu iframe o frame dispone de un atributo id o un nombre estos pueden ser usados para ello. Si los nombres o el id no fuesen únicos en la pagina este método cambiará el foco al primer iframe o frame que encuentre.\nJava Python C# Ruby JavaScript Kotlin //Usando el ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //O usando el atributo nombre driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Ahora podemos hacer clic en el botón driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Usando el ID driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # Ahora podemos hacer clic en el botón driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Usando el ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //O usando el atributo nombre driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Ahora podemos hacer clic en el botón driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Usando el ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # Ahora podemos hacer clic en el botón driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   //Usando el ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // O usando el atributo nombre await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Ahora podemos hacer clic en el botón await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Usando el ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) //O usando el atributo nombre driver.switchTo().frame(\u0026#34;myframe\u0026#34;) //Ahora podemos hacer clic en el botón driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Por indice También es posible usar el indice del iframe para cambiar el foco a el, los indices pueden ser consultados utilizando la query de JavaScript window.frames.\nJava Python C# Ruby JavaScript Kotlin // Cambia el foco al segundo frame driver.switchTo().frame(1);   # Cambia el foco al segundo frame driver.switch_to.frame(1)   // Cambia el foco al segundo frame driver.SwitchTo().Frame(1);   # Cambia el foco al segundo frame iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # Cambia el foco al iframe seleccionado driver.switch_to.frame(iframe)   //Cambia el foco al segundo frame await driver.switchTo().frame(1);   // Cambia el foco al segundo frame driver.switchTo().frame(1)     Saliendo de un frame Para salir de un iframe o un frame y volver el foco al contenido original:\nJava Python C# Ruby JavaScript Kotlin // Vuelve al nivel superior driver.switchTo().defaultContent();   # Vuelve al nivel superior driver.switch_to.default_content()   // Vuelve al nivel superior driver.SwitchTo().DefaultContent();   # Vuelve al nivel superior driver.switch_to.default_content   // Vuelve al nivel superior await driver.switchTo().defaultContent();   // Vuelve al nivel superior driver.switchTo().defaultContent()     Manejo de las ventanas La resolución de las pantallas puede impactar en como tu aplicación se renderiza es por eso que el WebDriver provee de mecanismos para mover y cambiar el tamaño de la ventana del navegador.\nObtener el tamaño de la ventana Obtiene el tamaño de la ventana del navegador en pixeles.\nJava Python C# Ruby JavaScript Kotlin //Accede a cada dimensión individualmente int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //O almacénalas para acceder a ellas mas tarde Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # Accede a cada dimensión individualmente width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # O almacénalas para acceder a ellas mas tarde size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Accede a cada dimensión individualmente int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //O almacénalas para acceder a ellas mas tarde System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # Accede a cada dimensión individualmente width = driver.manage.window.size.width height = driver.manage.window.size.height # O almacénalas para acceder a ellas mas tarde size = driver.manage.window.size width1 = size.width height1 = size.height   // Accede a cada dimensión individualmente const { width, height } = await driver.manage().window().getRect(); // O almacénalas para acceder a ellas mas tarde const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   //Accede a cada dimensión individualmente val width = driver.manage().window().size.width val height = driver.manage().window().size.height //O almacénalas para acceder a ellas mas tarde val size = driver.manage().window().size val width1 = size.width val height1 = size.height     Fija el tamaño de la ventana Recupera la ventana y fija el tamaño de esta. Java Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });   driver.manage().window().size = Dimension(1024, 768)   \nObten la posicion de la ventana Obtiene la posiciones de las coordernadas en el sistema arriba izquierda de la ventana del navegador. Java Python C# Ruby JavaScript Kotlin // Accede a cada dimensión individualmente int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // O almacénalas para acceder a ellas mas tarde Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # Accede a cada dimensión individualmente x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # O almacénalas para acceder a ellas mas tarde position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Accede a cada dimensión individualmente int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //O almacénalas para acceder a ellas mas tarde Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   #Accede a cada dimensión individualmente x = driver.manage.window.position.x y = driver.manage.window.position.y # O almacénalas para acceder a ellas mas tarde rect = driver.manage.window.rect x1 = rect.x y1 = rect.y   // Accede a cada dimensión individualmente const { x, y } = await driver.manage().window().getRect(); // O almacénalas para acceder a ellas mas tarde const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // Accede a cada dimensión individualmente val x = driver.manage().window().position.x val y = driver.manage().window().position.y // O almacénalas para acceder a ellas mas tarde val position = driver.manage().window().position val x1 = position.x val y1 = position.y    \nFija la posición de la ventana Mueve la ventana a la posición deseada.\nJava Python C# Ruby JavaScript Kotlin // Mueve la ventana arriba izquierda del monitor principal driver.manage().window().setPosition(new Point(0, 0));   # Mueve la ventana arriba izquierda del monitor principal driver.set_window_position(0, 0)   // Mueve la ventana arriba izquierda del monitor principal driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // Mueve la ventana arriba izquierda del monitor principal await driver.manage().window().setRect({ x: 0, y: 0 });   // Mueve la ventana arriba izquierda del monitor principal driver.manage().window().position = Point(0,0)     Maximizar la ventana Maximiza la ventana. Para la gran mayoría de sistemas operativos, la ventana rellenará la pantalla, sin bloquear los menús propios y barras de herramientas de los sistemas operativos.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    Minimizar la ventana Minimiza la ventana del actual contexto del navegador. El comportamiento exacto de este comando es especifico individualmente de cada gestor de ventanas.\nMinimizar la ventana típicamente oculta la ventana en la bandeja del sistema.\nNota: Esta funcionalidad es específica de Selenium 4 y versiones posteriores.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().minimize();  driver.minimize_window()  driver.Manage().Window.Minimize();   driver.manage.window.minimize  await driver.manage().window().minimize();   driver.manage().window().minimize()    Modo pantalla completa Llena la pantalla completamente, similar a presionar la tecla F11 en la gran mayoria de navegadores.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    "
},
{
	"uri": "https://www.selenium.dev/documentation/es/introduction/types_of_testing/",
	"title": "Tipos de pruebas",
	"tags": [],
	"description": "",
	"content": "Pruebas de aceptación Este tipo de prueba se realiza para determinar si una funcionalidad o un sistema cumple con las expectativas y requerimientos del cliente. Este tipo de pruebas generalmente implican la cooperación o retroalimentación del cliente, siendo una actividad de validación que responde la pregunta:\n ¿Estamos construyendo el producto correcto?.\n Para aplicaciones web, la automatización de esta prueba se puede hacer directamente con Selenium simulando el comportamiento esperado del usuario. Esta simulación podría hacerse mediante grabación/ reproducción o mediante los diferentes lenguajes soportados como se explica en esta documentación. Nota: Las pruebas de aceptación son un subtipo de pruebas funcionales, a lo que algunas personas también podrían referirse.\nPruebas funcionales Este tipo de prueba se realiza para determinar si una funcionalidad o sistema funciona correctamente y sin problemas. Se comprueba el sistema en diferentes niveles para garantizar que todos los escenarios están cubiertos y que el sistema hace lo que se supone que debe de hacer. Es una actividad de verificación que responde la pregunta:\n ¿Estamos construyendo el producto correctamente?.\n Para aplicaciones web, la automatización de esta prueba puede ser hecha directamente con Selenium simulando los retornos esperados. Esta simulación podría hacerse mediante grabación/reproducción o mediante los diferentes lenguajes soportados como se explica en esta documentación.\nPruebas de rendimiento Como su nombre indica, se realizan pruebas de rendimiento para medir qué tan bien está funcionando una aplicación.\nHay dos subtipos principales para las pruebas de rendimiento:\nPruebas de carga La prueba de carga se realiza para verificar qué tan bien la aplicación funciona bajo diferentes cargas definidas ( generalmente un número particular de usuarios conectados a la vez).\nPruebas de estrés Se realizan pruebas de estrés para verificar qué tan bien la aplicación funciona bajo estrés (o por encima de la carga máxima soportada).\nEn general, las pruebas de rendimiento se realizan ejecutando algunas pruebas de Selenium que simulan diferentes usuarios golpeando una función particular en la aplicación web y obteniendo algunas medidas significativas.\nEn general, esto lo hacen otras herramientas que obtienen las métricas. Una de esas herramientas es JMeter.\nPara una aplicación web, los detalles a medir incluyen rendimiento, latencia, pérdida de datos, tiempos de carga de componentes individuales\u0026hellip;\nNota 1: Todos los navegadores tienen una pestaña de rendimiento en su sección de herramientas para desarrolladores (accesible presionando F12)\nNota 2: es un subtipo de pruebas no funcionales ya que esto generalmente se mide por sistema y no por función/funcionalidad.\nPruebas de regresión Esta prueba generalmente se realiza después de un cambio, corrección o adición de funcionalidad.\nPara garantizar que el cambio no ha roto ninguna de las funcionalidades existentes, algunas pruebas ya ejecutadas se ejecutan nuevamente.\nEl conjunto de pruebas ejecutadas nuevamente puede ser total o parcial, y puede incluir varios tipos diferentes, dependiendo del equipo de desarrollo y la aplicación.\nDesarrollo guiado por pruebas (TDD) En lugar de un tipo de prueba per se, TDD es una metodología iterativa de desarrollo en la que las pruebas guían el diseño de una funcionalidad.\nCada ciclo comienza creando un conjunto de pruebas unitarias que la funcionalidad debería pasar finalmente (deberían fallar la primera vez que se ejecuta).\nDespués de esto, se lleva a cabo el desarrollo para pasar las pruebas. Las pruebas se ejecutan nuevamente, comenzando otro ciclo y este proceso continúa hasta que todas las pruebas pasen.\nEl objetivo es acelerar el desarrollo de una aplicación basado en el hecho de que los defectos son menos costosos cuanto más antes se encuentran.\nDesarrollo guiado por comportamiento (BDD) BDD es también una metodología de desarrollo iterativo basado en el TDD anterior, en el que el objetivo es involucrar todas las partes en el desarrollo de una aplicación.\nCada ciclo comienza creando algunas especificaciones (que deberían fallar). Luego creando las pruebas unitarias fallidas (que también deberían fallar) y luego hacer el desarrollo.\nEste ciclo se repite hasta que pasan todos los tipos de pruebas.\nPara realizar esto, se usa un lenguaje de especificación. Debe ser simple y entendible por todas las partes, estándar y explícito. La mayoría de las herramientas usan Gherkin como este lenguaje.\nEl objetivo es poder detectar aún más errores que TDD, apuntando también a posibles errores de aceptación y a facilitar la comunicación entre las partes.\nActualmente hay un conjunto de herramientas disponibles para escribir las especificaciones y relacionarlas con funciones de código, como Cucumber o SpecFlow.\nUn conjunto de herramientas se han construido encima de Selenium para realizar este proceso aún más rápido al transformar directamente las especificaciones de BDD en código ejecutable. Algunas de estas son JBehave, Capybara y Robot Framework.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/support_packages/working_with_select_elements/",
	"title": "Trabajando con elementos select",
	"tags": [],
	"description": "",
	"content": "A la hora de seleccionar elementos puede ser necesario código repetitivo para poder ser automatizado. Para reducir esto y hacer tus test mas limpios, existe un clase Select en los paquetes de soporte de Selenium. Para usarla, necesitarás importarla de la siguiente forma:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    import org.openqa.selenium.support.ui.Select     Una vez importado, ya podrás crear un objeto Select usando un WebElement que referencie a un elemento \u0026lt;select\u0026gt;.\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element(By.ID,\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   IWebElement selectElement = driver.FindElement(By.Id(\u0026#34;selectElementID\u0026#34;)); var selectObject = new SelectElement(selectElement);   select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     El objeto Select te proporcionará una serie de comandos que te permitirán interactuar con los elementos \u0026lt;select\u0026gt;. Lo primero de todo, existen diferentes formas de seleccionar una opción de un elemento \u0026lt;select\u0026gt;.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; Existen tres formas de seleccionar la primera opción del ejemplo que se muestra arriba.\nJava Python C# Ruby JavaScript Kotlin // Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; selectObject.selectByIndex(1); // Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; select_object.select_by_index(1) # Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value select_object.select_by_value(\u0026#39;value1\u0026#39;) # Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; selectObject.SelectByIndex(1); // Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value selectObject.SelectByValue(\u0026#34;value1\u0026#34;); // Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.SelectByText(\u0026#34;Bread\u0026#34;);   # Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; select_object.select_by(:index, 1) # Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    // Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; selectObject.selectByIndex(1) // Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     Puedes revisar que opciones están seleccionadas usando:\nJava Python C# Ruby JavaScript Kotlin // Devuelve una Lista de \u0026lt;WebElements\u0026gt; con las opciones que han sido seleccionadas List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Devuelve un WebElement que referencia a la primera opción seleccionada que se encontró en el DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Devuelve una Lista de [WebElements] con las opciones que han sido seleccionadas all_selected_options = select_object.all_selected_options # Devuelve un WebElement que referencia a la primera opción seleccionada que se encontró en el DOM first_selected_option = select_object.first_selected_option   // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected var allSelectedOptions = selectObject.AllSelectedOptions; // Return a WebElement referencing the first selection option found by walking down the DOM var firstSelectedOption = selectObject.AllSelectedOptions.FirstOrDefault();   # Devuelve un Array de \u0026lt;WebElements\u0026gt; con las opciones que han sido seleccionadas all_selected_options = select_object.selected_options # Devuelve un WebElement que referencia a la primera opción seleccionada que se encontró en el DOM first_selected_option = select_object.first_selected_option   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    // Devuelve una Lista de \u0026lt;WebElements\u0026gt; con las opciones que han sido seleccionadas val allSelectedOptions = selectObject.allSelectedOptions // Devuelve un WebElement que referencia a la primera opción seleccionada que se encontró en el DOM val firstSelectedOption = selectObject.firstSelectedOption     Tambien existe una forma de obtener que elementos \u0026lt;option\u0026gt; contiene un \u0026lt;select\u0026gt;:\nJava Python C# Ruby JavaScript Kotlin // Devuelve una lista de \u0026lt;WebElements\u0026gt; que contiene las opciones de un elemento \u0026lt;select\u0026gt; List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Devuelve una lista de [WebElements] que contiene las opciones de un elemento \u0026amp;lt;select\u0026amp;gt; all_available_options = select_object.options   // Devuelve una IList de \u0026lt;IWebElements\u0026gt; que contiene las opciones de un elemento \u0026lt;select\u0026gt; IList\u0026lt;IWebElement\u0026gt; allAvailableOptions = selectObject.Options;   # Devuelve un array de [WebElements] que contiene las opciones de un elemento \u0026amp;lt;select\u0026amp;gt; all_available_options = select_object.options   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    // Devuelve una lista de \u0026lt;WebElements\u0026gt; que contiene las opciones de un elemento \u0026lt;select\u0026gt; val allAvailableOptions = selectObject.options     A la hora de deseleccionar elementos dispones de cuatro opciones:\nJava Python C# Ruby JavaScript Kotlin // Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; selectObject.deselectByIndex(1); // Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados selectObject.deselectAll();   # Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; select_object.deselect_by_index(1) # Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados select_object.deselect_all()   // Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; selectObject.DeselectByIndex(1); // Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` selectObject.DeselectByValue(\u0026#34;value1\u0026#34;); // Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.DeselectByText(\u0026#34;Bread\u0026#34;); // Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados selectObject.DeselectAll();   # Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; select_object.deselect_by(:index, 1) # Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados select_object.deselect_all   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    // Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; selectObject.deselectByIndex(1) // Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados selectObject.deselectAll()     Finalmente, existen algunos elementos \u0026lt;select\u0026gt; que te permiten seleccionar mas de una opción. Puedes comprobar si tu elemento \u0026lt;select\u0026gt; es uno de estos usando:\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   bool doesThisAllowMultipleSelections = selectObject.IsMultiple;   does_this_allow_multiple_selections = select_object.multiple?   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    val doesThisAllowMultipleSelections = selectObject.isMultiple     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/support_packages/mouse_and_keyboard_actions_in_detail/",
	"title": "Acciones del ratón en detalle",
	"tags": [],
	"description": "",
	"content": "El ratón representa eventos del ratón. Las acciones del ratón son realizadas a través de una interfaz de bajo nivel la cual nos permite introducir acciones de dispositivos virtualizados al navegador web.\nclickAndHold Moverá el ratón al elemento y hará clic (sin soltar) en medio del elemento dado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción click-and-hold en el elemento  actionProvider.clickAndHold(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Realiza la acción click-and-hold en el elemento webdriver.ActionChains(driver).click_and_hold(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ClickAndHold { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción click-and-hold en el elemento  actionProvider.ClickAndHold(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Realiza la acción click-and-hold en el elemento driver.action.click_and_hold(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function clickAndHold() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción click-and-hold en el elemento  await actions.move({origin:searchBtn}).press().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción click-and-hold en el elemento  actionProvider.clickAndHold(searchBtn).build().perform() } finally { driver.quit() } }     contextClick Este método en primer lugar realiza un movimiento del ratón a la localización del elemento y realiza un clic contextual (clic derecho) en el elemento dado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class contextClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción context-click en el elemento  actionProvider.contextClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Realiza la acción context-click en el elemento webdriver.ActionChains(driver).context_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ContextClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción context-click en el elemento  actionProvider.ContextClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Realiza la acción context-click en el elemento driver.action.context_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function contextClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción context-click en el elemento  await actions.contextClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción context-click en el elemento  actionProvider.contextClick(searchBtn).build().perform() } finally { driver.quit() } }     doubleClick Moverá el ratón al elemento y realizará un clic doble en medio del elemento dado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class doubleClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción double-click en el elemento  actionProvider.doubleClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Realiza la acción double-click en el elemento webdriver.ActionChains(driver).double_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DoubleClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción double-click en el elemento  actionProvider.DoubleClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Realiza la acción double-click en el elemento driver.action.double_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function doubleClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción double-click en el elemento  await actions.doubleClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción double-click en el elemento  actionProvider.doubleClick(searchBtn).build().perform() } finally { driver.quit() } }     moveToElement Este método mueve el ratón en medio del elemento dado. El elemento ademas es desplazado hacia la vista al realizar la acción.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveToElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción move hacia el elemento  actionProvider.moveToElement(gmailLink).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39; gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) # Realiza la acción move hacia el elemento webdriver.ActionChains(driver).move_to_element(gmailLink).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveToElement { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción move hacia el elemento  actionProvider.MoveToElement(gmailLink).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39; gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Realiza la acción move hacia el elemento driver.action.move_to(gmail_link).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveToElement() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción move hacia el elemento  await actions.move({origin:gmailLink}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción move hacia el elemento  actionProvider.moveToElement(gmailLink).build().perform() } finally { driver.quit() } }     moveByOffset: Este método mueve el ratón desde su posición actual (o desde 0,0) hasta un desplazamiento dado. Si las coordenadas están fuera de la vista de la ventana, entonces el ratón terminará fuera de la ventana del navegador.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveByOffset { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Captura el desplazamiento de las posiciones x e y del elemento  int xOffset = gmailLink.getRect().getX(); int yOffset = gmailLink.getRect().getY(); Actions actionProvider = new Actions(driver); // Realiza la acción move hacia la posición del desplazamiento  actionProvider.moveByOffset(xOffset, yOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39; gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) # Captura el desplazamiento de las posiciones x e y del elemento xOffset = 100 yOffset = 100 # Realiza la acción move hacia la posición del desplazamiento webdriver.ActionChains(driver).move_by_offset(xOffset,yOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveByOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); // Captura el desplazamiento de las posiciones x e y del elemento  int xOffset = 100; int yOffset = 100; Actions actionProvider = new Actions(driver); // Realiza la acción move hacia la posición del desplazamiento  actionProvider.MoveByOffset(xOffset, yOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39; gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Captura el desplazamiento de las posiciones x e y del elemento x_offset = gmail_link.rect.x y_offset = gmail_link.rect.y # Realiza la acción move hacia la posición del desplazamiento driver.action.move_to_location(x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveByOffset() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Captura el desplazamiento de las posiciones x e y del elemento  let offset = await gmailLink.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Realiza la acción move hacia la posición del desplazamiento  await actions.move({x:parseInt(x),y:parseInt(y)}).pause(3000).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) // Captura el desplazamiento de las posiciones x e y del elemento  val xOffset = gmailLink.rect.getX() val yOffset = gmailLink.rect.getY() val actionProvider = Actions(driver) // Realiza la acción move hacia la posición del desplazamiento  actionProvider.moveByOffset(xOffset, yOffset).build().perform() } finally { driver.quit() } }     dragAndDrop Este método en primer lugar realiza una acción click-and-hold en el elemento de origen, después lo mueve a la localización del elemento de destino y por ultimo suelta el clic.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDrop { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción dragAndDrop desde el origen hacia el destino  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Guarda \u0026#39;targetEle\u0026#39; como elemento de destino targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Realiza la acción dragAndDrop desde el origen hacia el destino webdriver.ActionChains(driver).drag_and_drop(sourceEle,targetEle).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDrop { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción dragAndDrop desde el origen hacia el destino  actionProvider.DragAndDrop(sourceEle, targetEle).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Guarda \u0026#39;source_ele\u0026#39; como elemento de origen source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) # Guarda \u0026#39;target_ele\u0026#39; como elemento de destino target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Realiza la acción dragAndDrop desde el origen hacia el destino driver.action.drag_and_drop(source_ele, target_ele).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDrop() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción dragAndDrop desde el origen hacia el destino  await actions.dragAndDrop(sourceEle, targetEle).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción dragAndDrop desde el origen hacia el destino  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform() } finally { driver.quit() } }     dragAndDropBy Este metodo en primer lugar realiza un click-and-hold en el elemento origen, mueve el ratón al desplacamiento dado y luego suelta el raton.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDropBy { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.getLocation().getX(); int targetEleYOffset = targetEle.getLocation().getY(); Actions actionProvider = new Actions(driver); // Realiza la acción de dragAndDropBy hacia el desplazamiento destino  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) targetEleXOffset = targetEle.location.get(\u0026#34;x\u0026#34;) targetEleYOffset = targetEle.location.get(\u0026#34;y\u0026#34;) # Realiza la acción de dragAndDropBy hacia el desplazamiento destino webdriver.ActionChains(driver).drag_and_drop_by_offset(sourceEle, targetEleXOffset, targetEleYOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDropToOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.Location.X; int targetEleYOffset = targetEle.Location.Y; Actions actionProvider = new Actions(driver); // Realiza la acción de dragAndDropBy hacia el desplazamiento destino  actionProvider.DragAndDropToOffset(sourceEle, targetEleXOffset, targetEleYOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Guarda \u0026#39;source_ele\u0026#39; como elemento de origen source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Guarda \u0026#39;target_ele\u0026#39; como elemento de destino y obtiene las coordenadas x_offset = target_ele.rect.x y_offset = target_ele.rect.y # Realiza la acción de dragAndDropBy hacia el desplazamiento destino driver.action.drag_and_drop_by(source_ele, x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDropBy() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); let offset = await targetEle.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Realiza la acción de dragAndDropBy hacia el desplazamiento destino  await actions.dragAndDrop(sourceEle, {x:parseInt(x), y:parseInt(y)}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val targetEleXOffset = targetEle.location.getX() val targetEleYOffset = targetEle.location.getY() val actionProvider = Actions(driver) // Realiza la acción de dragAndDropBy hacia el desplazamiento destino  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform() } finally { driver.quit() } }     release Esta acción suelta el botón izquierdo del ratón. Si se le pasa un WebElement, soltará el botón izquierdo del ratón en el elemento dado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class release { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform(); // Realiza la acción release  actionProvider.release().build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Guarda \u0026#39;targetEle\u0026#39; como elemento de destino targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) webdriver.ActionChains(driver).click_and_hold(sourceEle).move_to_element(targetEle).perform() # Realiza la acción release webdriver.ActionChains(driver).release().perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class Release { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.ClickAndHold(sourceEle).MoveToElement(targetEle).Build().Perform(); // Realiza la acción release  actionProvider.Release().Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) driver.action.click_and_hold(source_ele).move_to(target_ele).perform # Realiza la acción release driver.action.release.perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function release() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); await actions.move({origin:sourceEle}).press().perform(); // Realiza la acción release  await actions.move({origin:targetEle}).release().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) //Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform() // Realiza la acción release  actionProvider.release().build().perform() } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/introduction/about_this_documentation/",
	"title": "Acerca de esta documentación",
	"tags": [],
	"description": "",
	"content": "Estos documentos, como el código en sí, son mantenidos al 100% por voluntarios dentro de la comunidad de Selenium. Muchos lo han estado usando desde su inicio, pero muchos más lo han estado usando desde hace poco y han dado su tiempo para ayudar a mejorar la experiencia de iniciación para los nuevos usuarios.\nSi hay un problema con la documentación, ¡queremos saberlo! La mejor manera de comunicar un problema es visitar https://github.com/seleniumhq/seleniumhq.github.io/issues y buscar para ver si el problema ya se ha archivado o no. Si no, ¡no dudes en abrir uno!\nMuchos miembros de la comunidad frecuentan el canal IRC #selenium en irc.freenode.net. ¡No dude en venir y hacer preguntas y si obtiene ayuda que cree que podría ser útil en estos documentos, asegúrese de agregar su contribución! Podemos actualizar estos documentos, pero es mucho más fácil para todos cuando recibimos contribuciones de fuera de los encargados normales.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/worst_practices/gmail_email_and_facebook_logins/",
	"title": "Autenticarse con Gmail, email y Facebook",
	"tags": [],
	"description": "",
	"content": "Por múltiples razones, autenticarse en sitios como Gmail y Facebook usando el WebDriver no esta recomendado. Aparte de estar en contra de los términos y condiciones de estos sitios (te expones a que te cierren la cuenta), es un proceso lento y poco fiable.\nLa practica ideal respecto a estos los sitios de emails es usar las APIs que ofrecen, en el caso de Facebook usar las herramientas para desarrolladores las cuales exponen un API para crear cuentas de prueba, amigos, etc. A pesar de que usar un API puede parecer como un esfuerzo extra, lo recuperarás en velocidad, fiabilidad y estabilidad. Ademas el API tiene muy pocas probabilidades de cambiar mientras que las paginas web y los elementos HTML cambian frecuentemente y requieren actualizar tu framework de pruebas constantemente.\nAutenticarse en sitios de terceros usando el WebDriver en cualquier punto de tus tests incrementa el riesgo de que tus pruebas fallen debido a que aumenta la duración de estas. Por regla general cuanto mas largos sean los tests mas frágiles y poco fiables son.\nLas implementaciones del WebDriver que son conformes al W3C también marcan el objecto navigator con la propiedad WebDriver para que los ataques de denegación de servicio (DoS) puedan ser mitigados.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/grid/when_to_use_grid/",
	"title": "Cuando usar el Grid",
	"tags": [],
	"description": "",
	"content": "Generalmente hablando, hay dos razones por las cuales podrías querer usar el Grid.\n Para ejecutar tus tests contra múltiples navegadores, múltiples versiones de navegadores y múltiples navegadores bajo diferentes sistemas operativos. Para reducir el tiempo que tarda en completarse la ejecución de tu suite de test.  El Grid se usa para acelerar la ejecución de los test usando múltiples maquinas para ejecutarlos en paralelo. Por ejemplo, si tienes una suite con 100 tests, pero configuras el Grid para soportar cuatro maquinas diferentes (ya sean maquinas virtuales o maquinas separadas físicamente) para ejecutar los tests, tu suite completará la ejecución en aproximadamente una cuarta parte del tiempo que habría tardado si se hubiesen ejecutado de manera secuencial en una sola maquina. Para suites de test grandes y suites de larga duración, como aquellas que realizan gran cantidad de validaciones de datos, puede suponer un gran ahorro de tiempo. Algunas suites de test pueden llegar tardar horas en ejecutarse. Otra razón puede ser acortar el tiempo de espera para recibir los resultados de los tests cuando los desarrolladores suben el código de su aplicación a los entornos de pruebas . Cada vez mas equipos de software practican metodologías de desarrollo software Agile en las cuales es necesario tener feedback tan rápido como sea posible en lugar de esperar durante toda la noche para que los tests finalicen su ejecución.\nEl Grid también es usado para soportar múltiples ejecuciones de test contra múltiples entornos, especialmente, contra diferentes navegadores al mismo tiempo. Por ejemplo, un Grid de maquinas virtuales puede ser configurado con cada una soportando un navegador diferente, estos navegadores pueden ser aquellos que la aplicación deba soportar. Así, la maquina uno tiene Internet Explorer 8, la maquina dos Internet Explorer 9, la maquina tres la ultima versión de Chrome y la maquina cuatro la ultima versión de Firefox. Cuando la suite de test es ejecutada, el Grid de Selenium recibe cada combinación de test-navegador y asigna la ejecución al navegador requerido.\nAdicionalmente, uno puede tener en el Grid los mismos navegadores, tipos y versiones. Por ejemplo podría tener en el Grid cuatro maquinas cada una ejecutando tres instancias de Firefox 70, permitiendo así tener una granja de servidores (en cierto sentido) de instancias de Firefox. De esta manera cuando se ejecute la suite, cada test es pasado al Grid el cual lo asignará a la siguiente instancia de Firefox disponible. De esta forma se obtendrían los resultados en los cuales doce tests se habrán estado ejecutando todos a mismo tiempo en paralelo, reduciendo así significativamente el tiempo que se requiere en completar la ejecución de la suite.\nEl Grid es muy flexible. Estos dos ejemplos pueden ser combinados para permitir múltiples instancias de cada tipo de navegador y versión. Configuraciones de este tipo permiten proveer una paralelización para completar las ejecuciones mas rápidamente y soportar múltiples tipos de navegadores y versiones simultáneamente.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "Ejecutando acciones en el AUT*",
	"tags": [],
	"description": "",
	"content": "Puede especificar el texto de un elemento utilizando el método sendKeys de la siguiente manera:\nJava Python C# Ruby JavaScript Kotlin String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(By.NAME, \u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);   val name = \u0026#34;Charles\u0026#34; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name)     Algunas aplicaciones web utilizan librerías de JavaScript para agregar la funcionalidad de arrastrar y soltar. El siguiente es un ejemplo básico de arrastrar un elemento hacia otro elemento:\nJava Python C# Ruby JavaScript Kotlin WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element(By.ID, \u0026#34;source\u0026#34;) target = driver.find_element(By.ID, \u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();   val source = driver.findElement(By.id(\u0026#34;source\u0026#34;)) val target = driver.findElement(By.id(\u0026#34;target\u0026#34;)) Actions(driver).dragAndDrop(source, target).build().perform()     Haciendo clic en un elemento Puedes hacer clic en un elemento utilizando el método click:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element(By.CSS_SELECTOR, \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click()     *AUT: Application Under Test (Aplicación bajo prueba)\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/waits/",
	"title": "Esperas",
	"tags": [],
	"description": "",
	"content": "Generalmente se puede decir que WebDriver posee una API de bloqueo. Porque es una biblioteca fuera-de-proceso que instruye al navegador qué hacer, y debido a que la plataforma web tiene una naturaleza intrínsecamente asíncrona, WebDriver no rastrea el estado activo y en tiempo real del DOM. Esto viene con algunos desafíos que discutiremos aquí.\nPor experiencia la mayoría de las intermitencias que surgen del uso de Selenium y WebDriver están conectadas a condiciones de carrera que ocurren entre el navegador y las instrucciones del usuario. Un ejemplo podría ser que el usuario indique al navegador que navegue a una página, luego cuando intentas encontrar un elemento obtienes el error no existe tal elemento.\nConsidera el siguiente documento:\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; Las instrucciones de WebDriver pueden parecer lo suficientemente inocentes:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navega a la URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Obtén y almacena el texto del párrafo search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     El problema aquí es que la estrategia de carga de página predeterminada utilizada en WebDriver escucha a que el document.readyState cambie a \u0026quot;complete\u0026quot; antes de retornar de la llamada a navigate. Debido a que el elemento p se agregó después de que el documento haya cargado por completo, este script de WebDriver podría ser intermitente. \u0026ldquo;Podría\u0026rdquo; ser intermitente porque no se pueden hacer garantías sobre elementos o eventos que se disparan de forma asíncrona sin esperar —o bloquear— explícitamente esos eventos.\nAfortunadamente, utilizando el conjunto normal de instrucciones disponibles en la interfaz WebElement tales como —WebElement.click y WebElement.sendKeys— que son garantizados para ser síncronos, esto es que las llamadas a funciones no retornaran (o el callback no se activará en los lenguajes de estilo callback) hasta que el comando se haya completado en el navegador. Las API avanzadas de interacción del usuario, Keyboard y Mouse, son excepciones ya que están explícitamente pensadas como comandos asíncronos \u0026ldquo;Haz lo que digo\u0026rdquo;.\nEsperar es hacer que la ejecución automatizada de la tarea transcurra una cierta cantidad de tiempo antes de continuar con el siguiente paso.\nPara superar el problema de las condiciones de carrera. entre el navegador y tu script de WebDriver, la mayoría de los clientes de Selenium se entregan con un paquete wait. Al emplear una espera, está utilizando lo que comúnmente se conoce como una explicit wait.\nExplicit wait Las esperas explícitas están disponibles para los clientes de lenguajes imperativos y procedimentales de Selenium. Permiten que tu código detenga la ejecución del programa, o congelar el hilo, hasta que la condición que le pases se resuelva. La condición se llama con cierta frecuencia, hasta que transcurra el tiempo de espera. Esto significa que mientras la condición retorne un valor falso, seguirá intentando y esperando.\nDado que las esperas explícitas te permiten esperar a que ocurra una condición, hacen una buena combinación para sincronizar el estado entre el navegador y su DOM, y tu script de WebDriver.\nPara remediar nuestro conjunto anterior de instrucciones con errores, podríamos esperar a que la llamada findElement espere hasta que el elemento agregado dinámicamente desde el script se haya agregado al DOM:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Inicializa y espera hasta que se haga clic en el element(link): tiempo de espera en 10 segundos WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Imprime en pantalla el primer resultado System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Inicializa y espera hasta que se haga clic en el element(link): tiempo de espera en 10 segundos val firstResult = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Imprime en pantalla el primer resultado println(firstResult.text)     Pasamos la condición como referencia de la función que wait ejecutará repetidamente hasta que su valor de retorno sea verdadero. Un valor de retorno \u0026ldquo;verdadero\u0026rdquo; es todo lo que se evalúa como booleano verdadero en el lenguaje en cuestión, como una cadena de caracteres, un número, un booleano, un objeto (incluido un WebElement), o una secuencia o lista poblada (no vacía). Eso significa que una lista vacía se evalúa como falsa. Cuando la condición es verdadera y se cancela el bloqueo de espera, el valor de retorno de la condición se convierte en el valor de retorno de la espera.\nCon este conocimiento, y debido a que la utilidad de espera ignora por defecto los errores no such element, podemos refactorizar nuestras instrucciones para hacerlas mas concisas:\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3)) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); }   driver.get \u0026#39;file:///race_condition.html\u0026#39; wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) ele = wait.until { driver.find_element(css: \u0026#39;p\u0026#39;)} foo = ele.text assert_match foo, \u0026#39;Hello from JavaScript\u0026#39;   let ele = await driver.wait(until.elementLocated(By.css(\u0026#39;p\u0026#39;)),10000); let foo = await ele.getText(); assert(foo == \u0026#34;Hello from JavaScript\u0026#34;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val ele = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026#34;p\u0026#34;))) assert(ele.text == \u0026#34;Hello from JavaScript!\u0026#34;)     En este ejemplo, pasamos una función anónima (pero también podríamos definirlo explícitamente como lo hicimos anteriormente para que pueda reutilizarse). El primer y único argumento que se pasa a nuestra condición siempre es una referencia a nuestro objeto controlador, WebDriver (llamado d en el ejemplo). En un entorno multiproceso, debes tener cuidado operando en la referencia del controlador pasada a la condición en lugar de la referencia al controlador en el ámbito externo.\nDebido a que la espera se tragará los errores no such element que se generan cuando no se encuentra el elemento, la condición volverá a intentar hasta que se encuentre el elemento. Luego tomará el valor de retorno, un WebElement, y lo pasara nuevamente a nuestro script.\nSi la condición falla, p.ej. nunca se alcanza un valor de retorno verdadero para la condición, la espera arrojará/generará un error/excepción llamado timeout error.\nOptions La condición de espera se puede personalizar para satisfacer tus necesidades. A veces es innecesario esperar completamente el tiempo de espera predeterminado, ya que la penalización por no alcanzar una condición exitosa puede ser costosa.\nLa espera te permite pasar un argumento para anular el tiempo de espera:\nJava Python C# Ruby JavaScript Kotlin new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) wait.until { driver.find_element(:id, \u0026#39;message\u0026#39;).displayed? }   await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000);   WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     Expected conditions Porque es una ocurrencia bastante común tener que sincronizar el DOM y tus instrucciones, La mayoría de los clientes también vienen con un conjunto de condiciones esperadas predefinidas. Como podría ser obvio por el nombre, son condiciones predefinidas para operaciones frecuentes de espera.\nLas condiciones disponibles varían en las diferentes librerias enlace de los lenguajes, pero esta es una lista no exhaustiva de algunos:\n alert is present (la alerta esta presente) element exists (el elemento existe) element is visible (el elemento es visible) title contains (el titulo contiene) title is (el titulo es) element staleness (estancamiento del elemento) visible text (texto visible)  Puedes consultar la documentación de las API para las librerias de enlace de cada cliente para encontrar una lista exhaustiva de las expected conditions:\n La clase de Java org.openqa.selenium.support.ui.ExpectedConditions La clase dePython selenium.webdriver.support.expected_conditions En .NET el tipo OpenQA.Selenium.Support.UI.ExpectedConditions  Implicit wait Hay un segundo tipo de espera que es distinto de esperas explícitas llamada implicit wait. Al esperar implícitamente, WebDriver sondea el DOM por una cierta duración al intentar encontrar cualquier elemento. Esto puede ser útil cuando ciertos elementos en la página web no están disponibles de inmediato y necesitan algo de tiempo para cargarse.\nEsperar implicitamente que aparezcan elementos está deshabilitado de forma predeterminada y deberá habilitarse manualmente por sesión. Mezclar esperas explícitas y esperas implícitas causará consecuencias no deseadas, es decir, esperara el máximo de tiempo incluso si el elemento está disponible o la condición es verdadera.\nAdvertencia: No mezcles esperas implícitas y explícitas. Hacerlo puede causar tiempos de espera impredecibles. Por ejemplo, establecer una espera implícita de 10 segundos y una espera explícita de 15 segundos podría provocar que ocurra un timeout después de 20 segundos.\nUna espera implícita es decirle a WebDriver que sondee el DOM durante un cierto período de tiempo al intentar encontrar un elemento o elementos si no están disponibles de inmediato. La configuración predeterminada es 0, lo que significa deshabilitado. Una vez establecido, la espera implícita se establece por el tiempo de vida de la sesión.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element(By.ID, \u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Aplica un tiempo de espera timeout por 10 segundos await driver.manage().setTimeouts( { implicit: 10000 } ); // Navega a la URL await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     FluentWait La instancia de FluentWait define la cantidad máxima de tiempo para esperar por una condición, así como la frecuencia con la que verificar dicha condición.\nLos usuarios pueden configurar la espera para ignorar tipos específicos de excepciones mientras esperan, como NoSuchElementException cuando buscan un elemento en la página.\nJava Python C# Ruby JavaScript Kotlin // Esperando 30 segundos a que un elemento este presente en la página, verificando // si está presente una vez cada 5 segundos  Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox exception = Selenium::WebDriver::Error::NoSuchElementError begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; wait = Selenium::WebDriver::Wait.new(timeout: 30, interval: 5, message: \u0026#39;Timed out after 30 sec\u0026#39;, ignore: exception) foo = wait.until { driver.find_element(id: \u0026#39;foo\u0026#39;)} ensure driver.quit end   const {Builder, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); // Esperando 30 segundos a que un elemento este presente en la página, chequeando  // si está presente una vez cada 5 segundos  let foo = await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000, \u0026#39;Timed out after 30 seconds\u0026#39;, 5000); })();   val wait = FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/getting_started_with_webdriver/",
	"title": "Iniciando con WebDriver",
	"tags": [],
	"description": "",
	"content": "Iniciando con WebDriver Selenium permite la automatización de todos los principales navegadores del mercado mediante el uso de WebDriver. WebDriver es una API y un protocolo que define una interfaz de idioma neutral para controlar el comportamiento de los navegadores web. Cada navegador está respaldado por una implementación específica de WebDriver, llamada controlador. El controlador es el componente responsable de delegar en el navegador, y maneja la comunicación hacia y desde Selenium y el navegador.\nEsta separación es parte de un esfuerzo consciente para hacer que los proveedores de navegadores asuman la responsabilidad de la implementación para sus navegadores. Selenium utiliza estos controladores de terceros cuando es posible, pero también proporciona sus propios controladores mantenidos por el proyecto para los casos en que esto no es una realidad.\nEl framework de Selenium unifica todas estas piezas a través de una interfaz orientada al usuario que habilita que los diferentes backends de los navegadores sean utilizados de forma transparente, permitiendo la automatización cruzada entre navegadores y plataformas diferentes.\nSe pueden encontrar más detalles sobre los controladores en Idiosincrasias del controlador.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/legacy_docs/selenium_ide/",
	"title": "Legacy Selenium IDE",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Introduction The Selenium-IDE (Integrated Development Environment) is the tool you use to develop your Selenium test cases. It’s an easy-to-use Firefox plug-in and is generally the most efficient way to develop test cases. It also contains a context menu that allows you to first select a UI element from the browser’s currently displayed page and then select from a list of Selenium commands with parameters pre-defined according to the context of the selected UI element. This is not only a time-saver, but also an excellent way of learning Selenium script syntax.\nThis chapter is all about the Selenium IDE and how to use it effectively.\nInstalling the IDE Using Firefox, first, download the IDE from the SeleniumHQ downloads page\nFirefox will protect you from installing addons from unfamiliar locations, so you will need to click ‘Allow’ to proceed with the installation, as shown in the following screenshot.\nWhen downloading from Firefox, you’ll be presented with the following window.\nSelect Install Now. The Firefox Add-ons window pops up, first showing a progress bar, and when the download is complete, displays the following.\nRestart Firefox. After Firefox reboots you will find the Selenium-IDE listed under the Firefox Tools menu.\nOpening the IDE To run the Selenium-IDE, simply select it from the Firefox Tools menu. It opens as follows with an empty script-editing window and a menu for loading, or creating new test cases.\nIDE Features Menu Bar The File menu has options for Test Case and Test Suite (suite of Test Cases). Using these you can add a new Test Case, open a Test Case, save a Test Case, export Test Case in a language of your choice. You can also open the recent Test Case. All these options are also available for Test Suite.\nThe Edit menu allows copy, paste, delete, undo, and select all operations for editing the commands in your test case. The Options menu allows the changing of settings. You can set the timeout value for certain commands, add user-defined user extensions to the base set of Selenium commands, and specify the format (language) used when saving your test cases. The Help menu is the standard Firefox Help menu; only one item on this menu–UI-Element Documentation–pertains to Selenium-IDE.\nToolbar The toolbar contains buttons for controlling the execution of your test cases, including a step feature for debugging your test cases. The right-most button, the one with the red-dot, is the record button.\nSpeed Control: controls how fast your test case runs.\nRun All: Runs the entire test suite when a test suite with multiple test cases is loaded.\nRun: Runs the currently selected test. When only a single test is loaded this button and the Run All button have the same effect.\nPause/Resume: Allows stopping and re-starting of a running test case.\nStep: Allows you to “step” through a test case by running it one command at a time. Use for debugging test cases.\nTestRunner Mode: Allows you to run the test case in a browser loaded with the Selenium-Core TestRunner. The TestRunner is not commonly used now and is likely to be deprecated. This button is for evaluating test cases for backwards compatibility with the TestRunner. Most users will probably not need this button.\nApply Rollup Rules: This advanced feature allows repetitive sequences of Selenium commands to be grouped into a single action. Detailed documentation on rollup rules can be found in the UI-Element Documentation on the Help menu.\nTest Case Pane Your script is displayed in the test case pane. It has two tabs, one for displaying the command and their parameters in a readable “table” format.\nThe other tab - Source displays the test case in the native format in which the file will be stored. By default, this is HTML although it can be changed to a programming language such as Java or C#, or a scripting language like Python. See the Options menu for details. The Source view also allows one to edit the test case in its raw form, including copy, cut and paste operations.\nThe Command, Target, and Value entry fields display the currently selected command along with its parameters. These are entry fields where you can modify the currently selected command. The first parameter specified for a command in the Reference tab of the bottom pane always goes in the Target field. If a second parameter is specified by the Reference tab, it always goes in the Value field.\nIf you start typing in the Command field, a drop-down list will be populated based on the first characters you type; you can then select your desired command from the drop-down.\nLog/Reference/UI-Element/Rollup Pane The bottom pane is used for four different functions–Log, Reference, UI-Element, and Rollup–depending on which tab is selected.\nLog When you run your test case, error messages and information messages showing the progress are displayed in this pane automatically, even if you do not first select the Log tab. These messages are often useful for test case debugging. Notice the Clear button for clearing the Log. Also notice the Info button is a drop-down allowing selection of different levels of information to log.\nReference The Reference tab is the default selection whenever you are entering or modifying Selenese commands and parameters in Table mode. In Table mode, the Reference pane will display documentation on the current command. When entering or modifying commands, whether from Table or Source mode, it is critically important to ensure that the parameters specified in the Target and Value fields match those specified in the parameter list in the Reference pane. The number of parameters provided must match the number specified, the order of parameters provided must match the order specified, and the type of parameters provided must match the type specified. If there is a mismatch in any of these three areas, the command will not run correctly.\nWhile the Reference tab is invaluable as a quick reference, it is still often necessary to consult the Selenium Reference document.\nUI-Element and Rollup Detailed information on these two panes (which cover advanced features) can be found in the UI-Element Documentation on the Help menu of Selenium-IDE.\nBuilding Test Cases There are three primary methods for developing test cases. Frequently, a test developer will require all three techniques.\nRecording Many first-time users begin by recording a test case from their interactions with a website. When Selenium-IDE is first opened, the record button is ON by default. If you do not want Selenium-IDE to begin recording automatically you can turn this off by going under Options \u0026gt; Options… and deselecting “Start recording immediately on open.”\nDuring recording, Selenium-IDE will automatically insert commands into your test case based on your actions. Typically, this will include:\n clicking a link - click or clickAndWait commands entering values - type command selecting options from a drop-down listbox - select command clicking checkboxes or radio buttons - click command  Here are some “gotchas” to be aware of:\n The type command may require clicking on some other area of the web page for it to record. Following a link usually records a click command. You will often need to change this to clickAndWait to ensure your test case pauses until the new page is completely loaded. Otherwise, your test case will continue running commands before the page has loaded all its UI elements. This will cause unexpected test case failures.  Adding Verifications and Asserts With the Context Menu Your test cases will also need to check the properties of a web-page. This requires assert and verify commands. We won’t describe the specifics of these commands here; that is in the chapter on Selenium Commands – “Selenese”. Here we’ll simply describe how to add them to your test case.\nWith Selenium-IDE recording, go to the browser displaying your test application and right click anywhere on the page. You will see a context menu showing verify and/or assert commands.\nThe first time you use Selenium, there may only be one Selenium command listed. As you use the IDE however, you will find additional commands will quickly be added to this menu. Selenium-IDE will attempt to predict what command, along with the parameters, you will need for a selected UI element on the current web-page.\nLet’s see how this works. Open a web-page of your choosing and select a block of text on the page. A paragraph or a heading will work fine. Now, right-click the selected text. The context menu should give you a verifyTextPresent command and the suggested parameter should be the text itself.\nAlso, notice the Show All Available Commands menu option. This shows many, many more commands, again, along with suggested parameters, for testing your currently selected UI element.\nTry a few more UI elements. Try right-clicking an image, or a user control like a button or a checkbox. You may need to use Show All Available Commands to see options other than verifyTextPresent. Once you select these other options, the more commonly used ones will show up on the primary context menu. For example, selecting verifyElementPresent for an image should later cause that command to be available on the primary context menu the next time you select an image and right-click.\nAgain, these commands will be explained in detail in the chapter on Selenium commands. For now though, feel free to use the IDE to record and select commands into a test case and then run it. You can learn a lot about the Selenium commands simply by experimenting with the IDE.\nEditing Insert Command Table View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click on the line where you want to insert a new command. Right-click and select Insert Command; the IDE will add a blank line just ahead of the line you selected. Now use the command editing text fields to enter your new command and its parameters.\nSource View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click between the commands where you want to insert a new command, and enter the HTML tags needed to create a 3-column row containing the Command, first parameter (if one is required by the Command), and second parameter (again, if one is required to locate an element) and third parameter(again, if one is required to have a value). Example:\n\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Command\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;target (locator)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Insert Comment Comments may be added to make your test case more readable. These comments are ignored when the test case is run.\nComments may also be used to add vertical white space (one or more blank lines) in your tests; just create empty comments. An empty command will cause an error during execution; an empty comment won’t.\nTable View Select the line in your test case where you want to insert the comment. Right-click and select Insert Comment. Now use the Command field to enter the comment. Your comment will appear in purple text.\nSource View Select the point in your test case where you want to insert the comment. Add an HTML-style comment, i.e., \u0026lt;!-- your comment here --\u0026gt;.\nEdit a Command or Comment Table View Simply select the line to be changed and edit it using the Command, Target, and Value fields.\nSource View Since Source view provides the equivalent of a WYSIWYG (What You See is What You Get) editor, simply modify which line you wish–command, parameter, or comment.\nOpening and Saving a Test Case Like most programs, there are Save and Open commands under the File menu. However, Selenium distinguishes between test cases and test suites. To save your Selenium-IDE tests for later use you can either save the individual test cases, or save the test suite. If the test cases of your test suite have not been saved, you’ll be prompted to save them before saving the test suite.\nWhen you open an existing test case or suite, Selenium-IDE displays its Selenium commands in the Test Case Pane.\nRunning Test Cases The IDE allows many options for running your test case. You can run a test case all at once, stop and start it, run it one line at a time, run a single command you are currently developing, and you can do a batch run of an entire test suite. Execution of test cases is very flexible in the IDE.\nRun a Test Case\nClick the Run button to run the currently displayed test case.\nRun a Test Suite\nClick the Run All button to run all the test cases in the currently loaded test suite.\nStop and Start\nThe Pause button can be used to stop the test case while it is running. The icon of this button then changes to indicate the Resume button. To continue click Resume.\nStop in the Middle\nYou can set a breakpoint in the test case to cause it to stop on a particular command. This is useful for debugging your test case. To set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint.\nStart from the Middle\nYou can tell the IDE to begin running from a specific command in the middle of the test case. This also is used for debugging. To set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point.\nRun Any Single Command\nDouble-click any single command to run it by itself. This is useful when writing a single command. It lets you immediately test a command you are constructing, when you are not sure if it is correct. You can double-click it to see if it runs correctly. This is also available from the context menu.\nUsing Base URL to Run Test Cases in Different Domains The Base URL field at the top of the Selenium-IDE window is very useful for allowing test cases to be run across different domains. Suppose that a site named http://news.portal.com had an in-house beta site named http://beta.news.portal.com. Any test cases for these sites that begin with an open statement should specify a relative URL as the argument to open rather than an absolute URL (one starting with a protocol such as http: or https:). Selenium-IDE will then create an absolute URL by appending the open command’s argument onto the end of the value of Base URL. For example, the test case below would be run against http://news.portal.com/about.html:\nThis same test case with a modified Base URL setting would be run against http://beta.news.portal.com/about.html:\nSelenium Commands – “Selenese” Selenium commands, often called selenese, are the set of commands that run your tests. A sequence of these commands is a test script. Here we explain those commands in detail, and we present the many choices you have in testing your web application when using Selenium.\nSelenium provides a rich set of commands for fully testing your web-app in virtually any way you can imagine. The command set is often called selenese. These commands essentially create a testing language.\nIn selenese, one can test the existence of UI elements based on their HTML tags, test for specific content, test for broken links, input fields, selection list options, submitting forms, and table data among other things. In addition Selenium commands support testing of window size, mouse position, alerts, Ajax functionality, pop up windows, event handling, and many other web-application features. The Command Reference lists all the available commands.\nA command tells Selenium what to do. Selenium commands come in three “flavors”: Actions, Accessors, and Assertions.\n  Actions are commands that generally manipulate the state of the application. They do things like “click this link” and “select that option”. If an Action fails, or has an error, the execution of the current test is stopped.\nMany Actions can be called with the “AndWait” suffix, e.g. “clickAndWait”. This suffix tells Selenium that the action will cause the browser to make a call to the server, and that Selenium should wait for a new page to load.\n  Accessors examine the state of the application and store the results in variables, e.g. “storeTitle”. They are also used to automatically generate Assertions.\n  Assertions are like Accessors, but they verify that the state of the application conforms to what is expected. Examples include “make sure the page title is X” and “verify that this checkbox is checked”.\n  All Selenium Assertions can be used in 3 modes: “assert”, “verify”, and ” waitFor”. For example, you can “assertText”, “verifyText” and “waitForText”. When an “assert” fails, the test is aborted. When a “verify” fails, the test will continue execution, logging the failure. This allows a single “assert” to ensure that the application is on the correct page, followed by a bunch of “verify” assertions to test form field values, labels, etc.\n“waitFor” commands wait for some condition to become true (which can be useful for testing Ajax applications). They will succeed immediately if the condition is already true. However, they will fail and halt the test if the condition does not become true within the current timeout setting (see the setTimeout action below).\nScript Syntax Selenium commands are simple, they consist of the command and two parameters. For example:\n          verifyText //div//a[2] Login    The parameters are not always required; it depends on the command. In some cases both are required, in others one parameter is required, and in still others the command may take no parameters at all. Here are a couple more examples:\n          goBackAndWait     verifyTextPresent  Welcome to My Home Page   type id=phone (555) 666-7066   type id=address1 ${myVariableAddress}    The command reference describes the parameter requirements for each command.\nParameters vary, however they are typically:\n a locator for identifying a UI element within a page. a text pattern for verifying or asserting expected page content a text pattern or a Selenium variable for entering text in an input field or for selecting an option from an option list.  Locators, text patterns, Selenium variables, and the commands themselves are described in considerable detail in the section on Selenium Commands.\nSelenium scripts that will be run from Selenium-IDE will be stored in an HTML text file format. This consists of an HTML table with three columns. The first column identifies the Selenium command, the second is a target, and the final column contains a value. The second and third columns may not require values depending on the chosen Selenium command, but they should be present. Each table row represents a new Selenium command. Here is an example of a test that opens a page, asserts the page title and then verifies some content on the page:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;/download/\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;assertTitle\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;verifyText\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;//h2\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Rendered as a table in a browser this would look like the following:\n          open /download/    assertTitle  Downloads   verifyText //h2 Downloads    The Selenese HTML syntax can be used to write and run tests without requiring knowledge of a programming language. With a basic knowledge of selenese and Selenium-IDE you can quickly produce and run testcases.\nTest Suites A test suite is a collection of tests. Often one will run all the tests in a test suite as one continuous batch-job.\nWhen using Selenium-IDE, test suites also can be defined using a simple HTML file. The syntax again is simple. An HTML table defines a list of tests where each row defines the filesystem path to each test. An example tells it all.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Suite Function Tests - Priority 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Suite Of Tests\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./Login.html\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SearchValues.html\u0026#34;\u0026gt;Test Searching for Values\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SaveValues.html\u0026#34;\u0026gt;Test Save\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; A file similar to this would allow running the tests all at once, one after another, from the Selenium-IDE.\nTest suites can also be maintained when using Selenium-RC. This is done via programming and can be done a number of ways. Commonly Junit is used to maintain a test suite if one is using Selenium-RC with Java. Additionally, if C# is the chosen language, Nunit could be employed. If using an interpreted language like Python with Selenium-RC then some simple programming would be involved in setting up a test suite. Since the whole reason for using Selenium-RC is to make use of programming logic for your testing this usually isn’t a problem.\nCommonly Used Selenium Commands To conclude our introduction of Selenium, we’ll show you a few typical Selenium commands. These are probably the most commonly used commands for building tests.\nopen\nopens a page using a URL.\nclick/clickAndWait\nperforms a click operation, and optionally waits for a new page to load.\nverifyTitle/assertTitle\nverifies an expected page title.\nverifyTextPresent\nverifies expected text is somewhere on the page.\nverifyElementPresent\nverifies an expected UI element, as defined by its HTML tag, is present on the page.\nverifyText\nverifies expected text and its corresponding HTML tag are present on the page.\nverifyTable\nverifies a table’s expected contents.\nwaitForPageToLoad\npauses execution until an expected new page loads. Called automatically when clickAndWait is used.\nwaitForElementPresent\npauses execution until an expected UI element, as defined by its HTML tag, is present on the page.\nVerifying Page Elements Verifying UI elements on a web page is probably the most common feature of your automated tests. Selenese allows multiple ways of checking for UI elements. It is important that you understand these different methods because these methods define what you are actually testing.\nFor example, will you test that…\n an element is present somewhere on the page? specific text is somewhere on the page? specific text is at a specific location on the page?  For example, if you are testing a text heading, the text and its position at the top of the page are probably relevant for your test. If, however, you are testing for the existence of an image on the home page, and the web designers frequently change the specific image file along with its position on the page, then you only want to test that an image (as opposed to the specific image file) exists somewhere on the page.\nAssertion or Verification? Choosing between “assert” and “verify” comes down to convenience and management of failures. There’s very little point checking that the first paragraph on the page is the correct one if your test has already failed when checking that the browser is displaying the expected page. If you’re not on the correct page, you’ll probably want to abort your test case so that you can investigate the cause and fix the issue(s) promptly. On the other hand, you may want to check many attributes of a page without aborting the test case on the first failure as this will allow you to review all failures on the page and take the appropriate action. Effectively an “assert” will fail the test and abort the current test case, whereas a “verify” will fail the test and continue to run the test case.\nThe best use of this feature is to logically group your test commands, and start each group with an “assert” followed by one or more “verify” test commands. An example follows:\n   Command Target Value     open /download/    assertTitle  Downloads   verifyText //h2 Downloads   assertTable 1.2.1 Selenium IDE   verifyTable 1.2.2 June 3, 2008   verifyTable 1.2.3 1.0 beta 2    The above example first opens a page and then “asserts” that the correct page is loaded by comparing the title with the expected value. Only if this passes will the following command run and “verify” that the text is present in the expected location. The test case then “asserts” the first column in the second row of the first table contains the expected value, and only if this passed will the remaining cells in that row be “verified”.\nverifyTextPresent The command verifyTextPresent is used to verify specific text exists somewhere on the page. It takes a single argument–the text pattern to be verified. For example:\n   Command Target Value     verifyTextPresent Marketing Analysis     This would cause Selenium to search for, and verify, that the text string “Marketing Analysis” appears somewhere on the page currently being tested. Use verifyTextPresent when you are interested in only the text itself being present on the page. Do not use this when you also need to test where the text occurs on the page.\nverifyElementPresent Use this command when you must test for the presence of a specific UI element, rather than its content. This verification does not check the text, only the HTML tag. One common use is to check for the presence of an image.\n   Command Target Value     verifyElementPresent //div/p/img     This command verifies that an image, specified by the existence of an HTML tag, is present on the page, and that it follows a tag and a tag. The first (and only) parameter is a locator for telling the Selenese command how to find the element. Locators are explained in the next section.\nverifyElementPresent can be used to check the existence of any HTML tag within the page. You can check the existence of links, paragraphs, divisions , etc. Here are a few more examples.\n   Command Target Value     verifyElementPresent //div/p    verifyElementPresent //div/a    verifyElementPresent id=Login    verifyElementPresent link=Go to Marketing Research    verifyElementPresent //a[2]    verifyElementPresent //head/title     These examples illustrate the variety of ways a UI element may be tested. Again, locators are explained in the next section.\nverifyText Use verifyText when both the text and its UI element must be tested. verifyText must use a locator. If you choose an XPath or DOM locator, you can verify that specific text appears at a specific location on the page relative to other UI components on the page.\n   Command Target Value     verifyText //table/tr/td/div/p This is my text and it occurs right after the div inside the table.    Locating Elements For many Selenium commands, a target is required. This target identifies an element in the content of the web application, and consists of the location strategy followed by the location in the format locatorType=location. The locator type can be omitted in many cases. The various locator types are explained below with examples for each.\nLocating by Identifier This is probably the most common method of locating elements and is the catch-all default when no recognized locator type is used. With this strategy, the first element with the id attribute value matching the location will be used. If no element has a matching id attribute, then the first element with a name attribute matching the location will be used.\nFor instance, your page source could have id and name attributes as follows:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; The following locator strategies would return the elements from the HTML snippet above indicated by line number:\n identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)  Since the identifier type of locator is the default, the identifier= in the first three examples above is not necessary.\nLocating by Id This type of locator is more limited than the identifier locator type, but also more explicit. Use this when you know an element\u0026rsquo;s id attribute.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  id=loginForm (3)  Locating by Name The name locator type will locate the first element with a matching name attribute. If multiple elements have the same value for a name attribute, then you can use filters to further refine your location strategy. The default filter type is value (matching the value attribute).\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7)  Note: Unlike some types of XPath and DOM locators, the three types of locators above allow Selenium to test a UI element independent of its location on the page. So if the page structure and organization is altered, the test will still pass. You may or may not want to also test whether the page structure changes. In the case where web designers frequently alter the page, but its functionality must be regression tested, testing via id and name attributes, or really via any HTML property, becomes very important.\nLocating by XPath XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.\nOne of the main reasons for using XPath is when you don\u0026rsquo;t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.\nAbsolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.\nSince only xpath locators start with \u0026ldquo;//\u0026quot;, it is not necessary to include the xpath= label when specifying an XPath locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  xpath=/html/body/form[1] (3) - Absolute path (would break if the HTML was changed only slightly) //form[1] (3) - First form element in the HTML xpath=//form[@id='loginForm'] (3) - The form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; xpath=//form[input/@name='username'] (3) - First form element with an input child element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //input[@name='username'] (4) - First input element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //form[@id='loginForm']/input[1] (4) - First input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; //input[@name='continue'][@type='button'] (7) - Input with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;continue\u0026rsquo; and attribute named \u0026lsquo;type\u0026rsquo; and the value \u0026lsquo;button\u0026rsquo; //form[@id='loginForm']/input[4] (7) - Fourth input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and value \u0026lsquo;loginForm\u0026rsquo;  These examples cover some basics, but in order to learn more, the following references are recommended:\n W3Schools XPath Tutorial W3C XPath Recommendation  There are also a couple of very useful Firefox Add-ons that can assist in discovering the XPath of an element:\n XPath Checker XPath and can be used to test XPath results. [Firebug](https://addons.mozilla.org/en-US/firefox/addon/1843 - XPath suggestions are just one of the many powerful features of this very useful add-on.  Locating Hyperlinks by Link Text This is a simple method of locating a hyperlink in your web page by using the text of the link. If two links with the same text are present, then the first match will be used.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Are you sure you want to do this?\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;continue.html\u0026#34;\u0026gt;Continue\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;cancel.html\u0026#34;\u0026gt;Cancel\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  link=Continue (4) link=Cancel (5)  Locating by DOM The Document Object Model represents an HTML document and can be accessed using JavaScript. This location strategy takes JavaScript that evaluates to an element on the page, which can be simply the element\u0026rsquo;s location using the hierarchical dotted notation.\nSince only dom locators start with \u0026ldquo;document\u0026rdquo;, it is not necessary to include the dom= label when specifying a DOM locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  dom=document.getElementById('loginForm') (3) dom=document.forms['loginForm'] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements['username'] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7)  You can use Selenium itself as well as other sites and extensions to explore the DOM of your web application. A good reference exists on W3Schools.\nLocating by CSS CSS (Cascading Style Sheets) is a language for describing the rendering of HTML and XML documents. CSS uses Selectors for binding style properties to elements in the document. These Selectors can be used by Selenium as another locating strategy.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;required\u0026#34; name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;required passfield\u0026#34; name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  css=form#loginForm (3) css=input[name=\u0026quot;username\u0026quot;] (4) css=input.required[type=\u0026quot;text\u0026quot;] (4) css=input.passfield (5) css=#loginForm input[type=\u0026quot;button\u0026quot;] (7) css=#loginForm input:nth-child(2) (5)  For more information about CSS Selectors, the best place to go is the W3C publication. You\u0026rsquo;ll find additional references there.\nImplicit Locators You can choose to omit the locator type in the following situations:\n  Locators without an explicitly defined locator strategy will default to using the identifier locator strategy. See Locating by Identifier_.\n  Locators starting with \u0026ldquo;//\u0026rdquo; will use the XPath locator strategy. See Locating by XPath_.\n  Locators starting with \u0026ldquo;document\u0026rdquo; will use the DOM locator strategy. See Locating by DOM_\n  Matching Text Patterns Like locators, patterns are a type of parameter frequently required by Selenese commands. Examples of commands which require patterns are verifyTextPresent, verifyTitle, verifyAlert, assertConfirmation, verifyText, and verifyPrompt. And as has been mentioned above, link locators can utilize a pattern. Patterns allow you to describe, via the use of special characters, what text is expected rather than having to specify that text exactly.\nThere are three types of patterns: globbing, regular expressions, and exact.\nGlobbing Patterns Most people are familiar with globbing as it is utilized in filename expansion at a DOS or Unix/Linux command line such as ls *.c. In this case, globbing is used to display all the files ending with a .c extension that exist in the current directory. Globbing is fairly limited.\nOnly two special characters are supported in the Selenium implementation:\n* which translates to \u0026ldquo;match anything,\u0026rdquo; i.e., nothing, a single character, or many characters.\n[ ] (character class) which translates to \u0026ldquo;match any single character found inside the square brackets.\u0026rdquo; A dash (hyphen) can be used as a shorthand to specify a range of characters (which are contiguous in the ASCII character set). A few examples will make the functionality of a character class clear:\n[aeiou] matches any lowercase vowel\n[0-9] matches any digit\n[a-zA-Z0-9] matches any alphanumeric character\nIn most other contexts, globbing includes a third special character, the ?. However, Selenium globbing patterns only support the asterisk and character class.\nTo specify a globbing pattern parameter for a Selenese command, you can prefix the pattern with a glob: label. However, because globbing patterns are the default, you can also omit the label and specify just the pattern itself.\nBelow is an example of two commands that use globbing patterns. The actual link text on the page being tested was \u0026ldquo;Film/Television Department\u0026rdquo;; by using a pattern rather than the exact text, the click command will work even if the link text is changed to \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo; or \u0026ldquo;Film and Television Department\u0026rdquo;. The glob pattern\u0026rsquo;s asterisk will match \u0026ldquo;anything or nothing\u0026rdquo; between the word \u0026ldquo;Film\u0026rdquo; and the word \u0026ldquo;Television\u0026rdquo;.\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle glob:*Film*Television*     The actual title of the page reached by clicking on the link was \u0026ldquo;De Anza Film And Television Department - Menu\u0026rdquo;. By using a pattern rather than the exact text, the verifyTitle will pass as long as the two words \u0026ldquo;Film\u0026rdquo; and \u0026ldquo;Television\u0026rdquo; appear (in that order) anywhere in the page\u0026rsquo;s title. For example, if the page\u0026rsquo;s owner should shorten the title to just \u0026ldquo;Film \u0026amp; Television Department,\u0026rdquo; the test would still pass. Using a pattern for both a link and a simple test that the link worked (such as the verifyTitle above does) can greatly reduce the maintenance for such test cases.\nRegular Expression Patterns Regular expression patterns are the most powerful of the three types of patterns that Selenese supports. Regular expressions are also supported by most high-level programming languages, many text editors, and a host of tools, including the Linux/Unix command-line utilities grep, sed, and awk. In Selenese, regular expression patterns allow a user to perform many tasks that would be very difficult otherwise. For example, suppose your test needed to ensure that a particular table cell contained nothing but a number. regexp: [0-9]+ is a simple pattern that will match a decimal number of any length.\nWhereas Selenese globbing patterns support only the * and [ ] (character class) features, Selenese regular expression patterns offer the same wide array of special characters that exist in JavaScript. Below are a subset of those special characters:\n   PATTERN MATCH     . any single character   [ ] character class: any single character that appears inside the brackets   * quantifier: 0 or more of the preceding character (or group)   + quantifier: 1 or more of the preceding character (or group)   ? quantifier: 0 or 1 of the preceding character (or group)   {1,5} quantifier: 1 through 5 of the preceding character (or group)   | alternation: the character/group on the left or the character/group on the right   ( ) grouping: often used with alternation and/or quantifier    Regular expression patterns in Selenese need to be prefixed with either regexp: or regexpi:. The former is case-sensitive; the latter is case-insensitive.\nA few examples will help clarify how regular expression patterns can be used with Selenese commands. The first one uses what is probably the most commonly used regular expression pattern\u0026ndash;.* (\u0026ldquo;dot star\u0026rdquo;). This two-character sequence can be translated as \u0026ldquo;0 or more occurrences of any character\u0026rdquo; or more simply, \u0026ldquo;anything or nothing.\u0026rdquo; It is the equivalent of the one-character globbing pattern * (a single asterisk).\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle regexp:.*Film.*Television.*     The example above is functionally equivalent to the earlier example that used globbing patterns for this same test. The only differences are the prefix (regexp: instead of glob:) and the \u0026ldquo;anything or nothing\u0026rdquo; pattern (.* instead of just *).\nThe more complex example below tests that the Yahoo! Weather page for Anchorage, Alaska contains info on the sunrise time:\n   Command Target Value     open http://weather.yahoo.com/forecast/USAK0012.html    verifyTextPresent regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m     Let\u0026rsquo;s examine the regular expression above one part at a time:\n         Sunrise: * The string Sunrise: followed by 0 or more spaces   [0-9]{1,2} 1 or 2 digits (for the hour of the day)   : The character : (no special characters involved)   [0-9]{2} 2 digits (for the minutes) followed by a space   [ap]m \u0026ldquo;a\u0026rdquo; or \u0026ldquo;p\u0026rdquo; followed by \u0026ldquo;m\u0026rdquo; (am or pm)    Exact Patterns The exact type of Selenium pattern is of marginal usefulness. It uses no special characters at all. So, if you needed to look for an actual asterisk character (which is special for both globbing and regular expression patterns), the exact pattern would be one way to do that. For example, if you wanted to select an item labeled \u0026ldquo;Real *\u0026rdquo; from a dropdown, the following code might work or it might not. The asterisk in the glob:Real * pattern will match anything or nothing. So, if there was an earlier select option labeled \u0026ldquo;Real Numbers,\u0026rdquo; it would be the option selected rather than the \u0026ldquo;Real *\u0026rdquo; option.\n   Command Target Value     select //select glob:Real *    In order to ensure that the \u0026ldquo;Real *\u0026rdquo; item would be selected, the exact: prefix could be used to create an exact pattern as shown below:\n   Command Target Value     select //select exact:Real *    But the same effect could be achieved via escaping the asterisk in a regular expression pattern:\n   Command Target Value     select //select regexp:Real \\*    It\u0026rsquo;s rather unlikely that most testers will ever need to look for an asterisk or a set of square brackets with characters inside them (the character class for globbing patterns). Thus, globbing patterns and regular expression patterns are sufficient for the vast majority of us.\nThe \u0026ldquo;AndWait\u0026rdquo; Commands The difference between a command and its AndWait alternative is that the regular command (e.g. click) will do the action and continue with the following command as fast as it can, while the AndWait alternative (e.g. clickAndWait) tells Selenium to wait for the page to load after the action has been done.\nThe AndWait alternative is always used when the action causes the browser to navigate to another page or reload the present one.\nBe aware, if you use an AndWait command for an action that does not trigger a navigation/refresh, your test will fail. This happens because Selenium will reach the AndWait\u0026lsquo;s timeout without seeing any navigation or refresh being made, causing Selenium to raise a timeout exception.\nThe waitFor Commands in AJAX applications In AJAX driven web applications, data is retrieved from server without refreshing the page. Using andWait commands will not work as the page is not actually refreshed. Pausing the test execution for a certain period of time is also not a good approach as web element might appear later or earlier than the stipulated period depending on the system\u0026rsquo;s responsiveness, load or other uncontrolled factors of the moment, leading to test failures. The best approach would be to wait for the needed element in a dynamic period and then continue the execution as soon as the element is found.\nThis is done using waitFor commands, as waitForElementPresent or waitForVisible, which wait dynamically, checking for the desired condition every second and continuing to the next command in the script as soon as the condition is met.\nSequence of Evaluation and Flow Control When a script runs, it simply runs in sequence, one command after another.\nSelenese, by itself, does not support condition statements (if-else, etc.) or iteration (for, while, etc.). Many useful tests can be conducted without flow control. However, for a functional test of dynamic content, possibly involving multiple pages, programming logic is often needed.\nWhen flow control is needed, there are three options:\na) Run the script using Selenium-RC and a client library such as Java or PHP to utilize the programming language\u0026rsquo;s flow control features. b) Run a small JavaScript snippet from within the script using the storeEval command. c) Install the goto_sel_ide.js extension.\nMost testers will export the test script into a programming language file that uses the Selenium-RC API (see the Selenium-IDE chapter). However, some organizations prefer to run their scripts from Selenium-IDE whenever possible (for instance, when they have many junior-level people running tests for them, or when programming skills are lacking). If this is your case, consider a JavaScript snippet or the goto_sel_ide.js extension.\nStore Commands and Selenium Variables You can use Selenium variables to store constants at the beginning of a script. Also, when combined with a data-driven test design (discussed in a later section), Selenium variables can be used to store values passed to your test program from the command-line, from another program, or from a file.\nThe plain store command is the most basic of the many store commands and can be used to simply store a constant value in a Selenium variable. It takes two parameters, the text value to be stored and a Selenium variable. Use the standard variable naming conventions of only alphanumeric characters when choosing a name for your variable.\n   Command Target Value     store paul@mysite.org     Later in your script, you\u0026rsquo;ll want to use the stored value of your variable. To access the value of a variable, enclose the variable in curly brackets ({}) and precede it with a dollar sign like this.\n   Command Target Value     verifyText //div/p \\${userName}    A common use of variables is for storing input for an input field.\n   Command Target Value     type id=login \\${userName}    Selenium variables can be used in either the first or second parameter and are interpreted by Selenium prior to any other operations performed by the command. A Selenium variable may also be used within a locator expression.\nAn equivalent store command exists for each verify and assert command. Here are a couple more commonly used store commands.\nstoreElementPresent This corresponds to verifyElementPresent. It simply stores a boolean value\u0026ndash;\u0026ldquo;true\u0026rdquo; or \u0026ldquo;false\u0026rdquo;\u0026ndash;depending on whether the UI element is found.\nstoreText StoreText corresponds to verifyText. It uses a locator to identify specific page text. The text, if found, is stored in the variable. StoreText can be used to extract text from the page being tested.\nstoreEval This command takes a script as its first parameter. Embedding JavaScript within Selenese is covered in the next section. StoreEval allows the test to store the result of running the script in a variable.\nJavaScript and Selenese Parameters JavaScript can be used with two types of Selenese parameters: script and non-script (usually expressions). In most cases, you\u0026rsquo;ll want to access and/or manipulate a test case variable inside the JavaScript snippet used as a Selenese parameter. All variables created in your test case are stored in a JavaScript associative array. An associative array has string indexes rather than sequential numeric indexes. The associative array containing your test case\u0026rsquo;s variables is named storedVars. Whenever you wish to access or manipulate a variable within a JavaScript snippet, you must refer to it as storedVars[\u0026lsquo;yourVariableName\u0026rsquo;].\nJavaScript Usage with Script Parameters Several Selenese commands specify a script parameter including assertEval, verifyEval, storeEval, and waitForEval. These parameters require no special syntax. A Selenium-IDE user would simply place a snippet of JavaScript code into the appropriate field, normally the Target field (because a script parameter is normally the first or only parameter).\nThe example below illustrates how a JavaScript snippet can be used to perform a simple numerical calculation:\n   Command Target Value     store 10 hits   storeXpathCount //blockquote blockquotes   storeEval storedVars[\u0026lsquo;hits\u0026rsquo;].storedVars[\u0026lsquo;blockquotes\u0026rsquo;] paragraphs    This next example illustrates how a JavaScript snippet can include calls to methods, in this case the JavaScript String object\u0026rsquo;s toUpperCase method and toLowerCase method.\n   Command Target Value     store Edith Wharton name   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() uc   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() lc    JavaScript Usage with Non-Script Parameters JavaScript can also be used to help generate values for parameters, even when the parameter is not specified to be of type script.\nHowever, in this case, special syntax is required\u0026ndash;the entire parameter value must be prefixed by javascript{ with a trailing }, which encloses the JavaScript snippet, as in javascript{*yourCodeHere*}. Below is an example in which the type command\u0026rsquo;s second parameter value is generated via JavaScript code using this special syntax:\n   Command Target Value     store league of nations searchString   type q javascript{storedVars[\u0026lsquo;searchString\u0026rsquo;].toUpperCase()}    echo - The Selenese Print Command Selenese has a simple command that allows you to print text to your test\u0026rsquo;s output. This is useful for providing informational progress notes in your test which display on the console as your test is running. These notes also can be used to provide context within your test result reports, which can be useful for finding where a defect exists on a page in the event your test finds a problem. Finally, echo statements can be used to print the contents of Selenium variables.\n   Command Target Value     echo Testing page footer now.    echo Username is \\${userName}     Alerts, Popups, and Multiple Windows Suppose that you are testing a page that looks like this.\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function output(resultText){ document.getElementById(\u0026#39;output\u0026#39;).childNodes[0].nodeValue=resultText; } function show_confirm(){ var confirmation=confirm(\u0026#34;Chose an option.\u0026#34;); if (confirmation==true){ output(\u0026#34;Confirmed.\u0026#34;); } else{ output(\u0026#34;Rejected!\u0026#34;); } } function show_alert(){ alert(\u0026#34;I\u0026#39;m blocking!\u0026#34;); output(\u0026#34;Alert is gone.\u0026#34;); } function show_prompt(){ var response = prompt(\u0026#34;What\u0026#39;s the best web QA tool?\u0026#34;,\u0026#34;Selenium\u0026#34;); output(response); } function open_window(windowName){ window.open(\u0026#34;newWindow.html\u0026#34;,windowName); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnConfirm\u0026#34; onclick=\u0026#34;show_confirm()\u0026#34; value=\u0026#34;Show confirm box\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnAlert\u0026#34; onclick=\u0026#34;show_alert()\u0026#34; value=\u0026#34;Show alert\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPrompt\u0026#34; onclick=\u0026#34;show_prompt()\u0026#34; value=\u0026#34;Show prompt\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;newWindow.html\u0026#34; id=\u0026#34;lnkNewWindow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;New Window Link\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamelessWindow\u0026#34; onclick=\u0026#34;open_window()\u0026#34; value=\u0026#34;Open Nameless Window\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamedWindow\u0026#34; onclick=\u0026#34;open_window(\u0026#39;Mike\u0026#39;)\u0026#34; value=\u0026#34;Open Named Window\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span id=\u0026#34;output\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The user must respond to alert/confirm boxes, as well as moving focus to newly opened popup windows. Fortunately, Selenium can cover JavaScript pop-ups.\nBut before we begin covering alerts/confirms/prompts in individual detail, it is helpful to understand the commonality between them. Alerts, confirmation boxes and prompts all have variations of the following\n   Command Description     assertFoo(pattern) throws error if pattern doesn’t match the text of the pop-up   assertFooPresent throws error if pop-up is not available   assertFooNotPresent throws error if any pop-up is present   storeFoo(variable) stores the text of the pop-up in a variable   storeFooPresent(variable) stores the text of the pop-up in a variable and returns true or false    When running under Selenium, JavaScript pop-ups will not appear. This is because the function calls are actually being overridden at runtime by Selenium\u0026rsquo;s own JavaScript. However, just because you cannot see the pop-up doesn\u0026rsquo;t mean you don\u0026rsquo;t have to deal with it. To handle a pop-up, you must call its assertFoo(pattern) function. If you fail to assert the presence of a pop-up your next command will be blocked and you will get an error similar to the following [error] Error: There was an unexpected Confirmation! [Chose an option.]\nAlerts Let\u0026rsquo;s start with alerts because they are the simplest pop-up to handle. To begin, open the HTML sample above in a browser and click on the \u0026ldquo;Show alert\u0026rdquo; button. You\u0026rsquo;ll notice that after you close the alert the text \u0026ldquo;Alert is gone.\u0026rdquo; is displayed on the page. Now run through the same steps with Selenium IDE recording, and verify the text is added after you close the alert. Your test will look something like this:\n   Command Target Value     open /    click btnAlert    assertAlert I’m blocking!    verifyTextPresent Alert is gone.     You may be thinking \u0026ldquo;That\u0026rsquo;s odd, I never tried to assert that alert.\u0026rdquo; But this is Selenium-IDE handling and closing the alert for you. If you remove that step and replay the test you will get the following error [error] Error: There was an unexpected Alert! [I'm blocking!]. You must include an assertion of the alert to acknowledge its presence.\nIf you just want to assert that an alert is present but either don\u0026rsquo;t know or don\u0026rsquo;t care what text it contains, you can use assertAlertPresent. This will return true or false, with false halting the test.\nConfirmations Confirmations behave in much the same way as alerts, with assertConfirmation and assertConfirmationPresent offering the same characteristics as their alert counterparts. However, by default Selenium will select OK when a confirmation pops up. Try recording clicking on the \u0026ldquo;Show confirm box\u0026rdquo; button in the sample page, but click on the \u0026ldquo;Cancel\u0026rdquo; button in the popup, then assert the output text. Your test may look something like this:\n   Command Target Value     open /    click btnConfirm    chooseCancelOnNextConfirmation     assertConfirmation Choose an option.    verifyTextPresent Rejected     The chooseCancelOnNextConfirmation function tells Selenium that all following confirmation should return false. It can be reset by calling chooseOkOnNextConfirmation.\nYou may notice that you cannot replay this test, because Selenium complains that there is an unhandled confirmation. This is because the order of events Selenium-IDE records causes the click and chooseCancelOnNextConfirmation to be put in the wrong order (it makes sense if you think about it, Selenium can\u0026rsquo;t know that you\u0026rsquo;re cancelling before you open a confirmation) Simply switch these two commands and your test will run fine.\nPrompts Prompts behave in much the same way as alerts, with assertPrompt and assertPromptPresent offering the same characteristics as their alert counterparts. By default, Selenium will wait for you to input data when the prompt pops up. Try recording clicking on the \u0026ldquo;Show prompt\u0026rdquo; button in the sample page and enter \u0026ldquo;Selenium\u0026rdquo; into the prompt. Your test may look something like this:\n   Command Target Value     open /    answerOnNextPrompt Selenium!    click id=btnPrompt    assertPrompt What’s the best web QA tool?    verifyTextPresent Selenium!     If you choose cancel on the prompt, you may notice that answerOnNextPrompt will simply show a target of blank. Selenium treats cancel and a blank entry on the prompt basically as the same thing.\nDebugging Debugging means finding and fixing errors in your test case. This is a normal part of test case development.\nWe won\u0026rsquo;t teach debugging here as most new users to Selenium will already have some basic experience with debugging. If this is new to you, we recommend you ask one of the developers in your organization.\nBreakpoints and Startpoints The Sel-IDE supports the setting of breakpoints and the ability to start and stop the running of a test case, from any point within the test case. That is, one can run up to a specific command in the middle of the test case and inspect how the test case behaves at that point. To do this, set a breakpoint on the command just before the one to be examined.\nTo set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint. Then click the Run button to run your test case from the beginning up to the breakpoint.\nIt is also sometimes useful to run a test case from somewhere in the middle to the end of the test case or up to a breakpoint that follows the starting point.\nFor example, suppose your test case first logs into the website and then performs a series of tests and you are trying to debug one of those tests.\nHowever, you only need to login once, but you need to keep rerunning your tests as you are developing them. You can login once, then run your test case from a startpoint placed after the login portion of your test case. That will prevent you from having to manually logout each time you rerun your test case.\nTo set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point. Then click the Run button to execute the test case beginning at that startpoint.\nStepping Through a Testcase To execute a test case one command at a time (\u0026ldquo;step through\u0026rdquo; it), follow these steps:\n  Start the test case running with the Run button from the toolbar.\n  Immediately pause the executing test case with the Pause button.\n  Repeatedly select the Step button.\n  Find Button The Find button is used to see which UI element on the currently displayed webpage (in the browser) is used in the currently selected Selenium command.\nThis is useful when building a locator for a command\u0026rsquo;s first parameter (see the section on :ref:locators \u0026lt;locators-section\u0026gt; in the Selenium Commands chapter). It can be used with any command that identifies a UI element on a webpage, i.e. click, clickAndWait, type, and certain assert and verify commands, among others.\nFrom Table view, select any command that has a locator parameter. Click the Find button.\nNow look on the webpage: There should be a bright green rectangle enclosing the element specified by the locator parameter.\nPage Source for Debugging Often, when debugging a test case, you simply must look at the page source (the HTML for the webpage you\u0026rsquo;re trying to test) to determine a problem. Firefox makes this easy. Simply right-click the webpage and select \u0026lsquo;View-\u0026gt;Page Source.\nThe HTML opens in a separate window. Use its Search feature (Edit=\u0026gt;Find) to search for a keyword to find the HTML for the UI element you\u0026rsquo;re trying to test.\nAlternatively, select just that portion of the webpage for which you want to see the source. Then right-click the webpage and select View Selection Source. In this case, the separate HTML window will contain just a small amount of source, with highlighting on the portion representing your selection.\nLocator Assistance Whenever Selenium-IDE records a locator-type argument, it stores additional information which allows the user to view other possible locator-type arguments that could be used instead. This feature can be very useful for learning more about locators, and is often needed to help one build a different type of locator than the type that was recorded.\nThis locator assistance is presented on the Selenium-IDE window as a drop-down list accessible at the right end of the Target field (only when the Target field contains a recorded locator-type argument).\nBelow is a snapshot showing the contents of this drop-down for one command. Note that the first column of the drop-down provides alternative locators, whereas the second column indicates the type of each alternative.\nWriting a Test Suite A test suite is a collection of test cases which is displayed in the leftmost pane in the IDE.\nThe test suite pane can be manually opened or closed via selecting a small dot halfway down the right edge of the pane (which is the left edge of the entire Selenium-IDE window if the pane is closed).\nThe test suite pane will be automatically opened when an existing test suite is opened or when the user selects the New Test Case item from the File menu. In the latter case, the new test case will appear immediately below the previous test case.\nSelenium-IDE also supports loading pre-existing test cases by using the File -\u0026gt; Add Test Case menu option. This allows you to add existing test cases to a new test suite.\nA test suite file is an HTML file containing a one-column table. Each cell of each row in the section contains a link to a test case. The example below is of a test suite containing four test cases:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Sample Selenium Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Test Cases for De Anza A-Z Directory Links\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./a.html\u0026#34;\u0026gt;A Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./b.html\u0026#34;\u0026gt;B Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./c.html\u0026#34;\u0026gt;C Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./d.html\u0026#34;\u0026gt;D Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Note: Test case files should not have to be co-located with the test suite file that invokes them. And on Mac OS and Linux systems, that is indeed the case. However, at the time of this writing, a bug prevents Windows users from being able to place the test cases elsewhere than with the test suite that invokes them.\nUser Extensions User extensions are JavaScript files that allow one to create his or her own customizations and features to add additional functionality. Often this is in the form of customized commands although this extensibility is not limited to additional commands.\nThere are a number of useful extensions_ created by users.\nIMPORTANT: THIS SECTION IS OUT OF DATE\u0026ndash;WE WILL BE REVISING THIS SOON.\n _extensions: http://wiki.openqa.org/display/SEL/Contributed+User-Extensions  .. _goto_sel_ide.js extension:\nPerhaps the most popular of all Selenium-IDE extensions is one which provides flow control in the form of while loops and primitive conditionals. This extension is the goto_sel_ide.js_. For an example of how to use the functionality provided by this extension, look at the page_ created by its author.\nTo install this extension, put the pathname to its location on your computer in the Selenium Core extensions field of Selenium-IDE\u0026rsquo;s Options=\u0026gt;Options=\u0026gt;General tab.\nAfter selecting the OK button, you must close and reopen Selenium-IDE in order for the extensions file to be read. Any change you make to an extension will also require you to close and reopen Selenium-IDE.\nInformation on writing your own extensions can be found near the bottom of the Selenium Reference_ document.\nSometimes it can prove very useful to debug step by step Selenium IDE and your User Extension. The only debugger that appears able to debug XUL/Chrome based extensions is Venkman which is supported in Firefox until version 32 included. The step by step debug has been verified to work with Firefox 32 and Selenium IDE 2.9.0.\nFormat Format, under the Options menu, allows you to select a language for saving and displaying the test case. The default is HTML.\nIf you will be using Selenium-RC to run your test cases, this feature is used to translate your test case into a programming language. Select the language, e.g. Java, PHP, you will be using with Selenium-RC for developing your test programs. Then simply save the test case using File=\u0026gt;Export Test Case As. Your test case will be translated into a series of functions in the language you choose. Essentially, program code supporting your test is generated for you by Selenium-IDE.\nAlso, note that if the generated code does not suit your needs, you can alter it by editing a configuration file which defines the generation process.\nEach supported language has configuration settings which are editable. This is under the Options=\u0026gt;Options=\u0026gt;Formats tab.\nExecuting Selenium-IDE Tests on Different Browsers While Selenium-IDE can only run tests against Firefox, tests developed with Selenium-IDE can be run against other browsers, using a simple command-line interface that invokes the Selenium-RC server. This topic is covered in the :ref:Run Selenese tests \u0026lt;html-suite\u0026gt; section on Selenium-RC chapter. The -htmlSuite command-line option is the particular feature of interest.\nTroubleshooting Below is a list of image/explanation pairs which describe frequent sources of problems with Selenium-IDE:\nTable view is not available with this format.\nThis message can be occasionally displayed in the Table tab when Selenium IDE is launched. The workaround is to close and reopen Selenium IDE. See issue 1008. for more information. If you are able to reproduce this reliably then please provide details so that we can work on a fix.\n error loading test case: no command found\nYou\u0026rsquo;ve used File=\u0026gt;Open to try to open a test suite file. Use File=\u0026gt;Open Test Suite instead.\nAn enhancement request has been raised to improve this error message. See issue 1010.\n This type of error may indicate a timing problem, i.e., the element specified by a locator in your command wasn\u0026rsquo;t fully loaded when the command was executed. Try putting a pause 5000 before the command to determine whether the problem is indeed related to timing. If so, investigate using an appropriate waitFor* or *AndWait command before the failing command.\n Whenever your attempt to use variable substitution fails as is the case for the open command above, it indicates that you haven\u0026rsquo;t actually created the variable whose value you\u0026rsquo;re trying to access. This is sometimes due to putting the variable in the Value field when it should be in the Target field or vice versa. In the example above, the two parameters for the store command have been erroneously placed in the reverse order of what is required. For any Selenese command, the first required parameter must go in the Target field, and the second required parameter (if one exists) must go in the Value field.\n error loading test case: [Exception\u0026hellip; \u0026ldquo;Component returned failure code: 0x80520012 (NS_ERROR_FILE_NOT_FOUND) [nsIFileInputStream.init]\u0026rdquo; nresult: \u0026ldquo;0x80520012 (NS_ERROR_FILE_NOT_FOUND)\u0026rdquo; location: \u0026ldquo;JS frame :: chrome://selenium-ide/content/file-utils.js :: anonymous :: line 48\u0026rdquo; data: no]\nOne of the test cases in your test suite cannot be found. Make sure that the test case is indeed located where the test suite indicates it is located. Also, make sure that your actual test case files have the .html extension both in their filenames, and in the test suite file where they are referenced.\nAn enhancement request has been raised to improve this error message. See issue 1011.\n Your extension file\u0026rsquo;s contents have not been read by Selenium-IDE. Be sure you have specified the proper pathname to the extensions file via Options=\u0026gt;Options=\u0026gt;General in the Selenium Core extensions field. Also, Selenium-IDE must be restarted after any change to either an extensions file or to the contents of the Selenium Core extensions field.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/mock_external_services/",
	"title": "Mock de servicios externos",
	"tags": [],
	"description": "",
	"content": "Eliminar las dependencias de servicios externos mejorará en gran medida la velocidad y la estabilidad de tus pruebas.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/support_classes/",
	"title": "Clases de apoyo",
	"tags": [],
	"description": "",
	"content": "Las clases de soporte de WebDriver son proporcionadas para simplificar el mantenimiento de tu código. Proporcionan una buena abstracción para modelar mas fácilmente elementos HTML como objetos de dominio, también proporcionando métodos de ayuda para hacer que el uso de tales objetos sea fácil de razonar. Aprenderemos acerca de:\n Estrategias de localizacion Eventos LoadableComponent ThreadGuard etc.  Iniciemos:\nThreadGuard  Esta clase solo esta disponible en la librería de enlace de Java\n ThreadGuard comprueba que se llama a un controlador solo desde el mismo hilo que lo creó. Los problemas de subprocesos, especialmente cuando se ejecutan pruebas en paralelo, pueden tener errores misteriosos y difícil de diagnosticar. El uso de este contenedor evita esta categoría de errores y generará una excepción cuando ocurran.\nEl siguiente ejemplo simula un choque de hilos:\npublic class DriverClash { //El hilo (thread) main (id 1) creó este controlador  private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;\u0026lt;Set path to your Chromedriver\u0026gt;\u0026#34;); } //Thread-1 (id 24) llama al mismo controlador causando el choque  Runnable r1 = () -\u0026gt; {protectedDriver.get(\u0026#34;https://selenium.dev\u0026#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } El resultado se muestra a continuación:\nException in thread \u0026#34;Thread-1\u0026#34; org.openqa.selenium.WebDriverException: Thread safety error; this instance of WebDriver was constructed on thread main (id 1)and is being accessed by thread Thread-1 (id 24) This is not permitted and *will* cause undefined behaviour Como puede verse en el ejemplo:\n protectedDriver Será creado en el hilo Main. Utilizamos Java Runnable para iniciar un nuevo proceso y un nuevo Thread para ejecutar el proceso. Ambos Thread chocarán porque el Thread principal no tiene protectedDriver en su memoria. ThreadGuard.protect lanzará una excepción.  Nota: Esto no reemplaza la necesidad de usar ThreadLocal para administrar los controladores cuando se ejecutan en paralelo.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/worst_practices/test_dependency/",
	"title": "Dependencia entre pruebas",
	"tags": [],
	"description": "",
	"content": "Una idea muy común y equivocada sobre la automatización de pruebas es en lo que respecta al orden de los tests. Tus tests deberían ser capaces de ejecutarse sin tener en cuenta el orden y no depender los unos de los otros para poder finalizarse satisfactoriamente.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/improved_reporting/",
	"title": "Mejores reportes",
	"tags": [],
	"description": "",
	"content": "Selenium no está diseñado para informar sobre el estado de los casos de prueba ejecutados. Aprovechando las capacidades de reporte incorporadas en la mayoría de los frameworks de pruebas unitarias es un buen comienzo. La mayoría de los frameworks de pruebas unitarias tienen utilidades que pueden generar reportes con formato xUnit o HTML. Los reportes xUnit son populares para importar resultados a una integración continua (CI) como Jenkins, Travis, Bamboo, etc. Aquí hay algunos enlaces para obtener más información sobre la generación de los reportes para varios lenguajes.\nNUnit 3 Console Runner\nNUnit 3 Console Command Line\nxUnit getting test results in TeamCity\nxUnit getting test results in CruiseControl.NET\nxUnit getting test results in Azure DevOps\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": "WebDriver WebDriver controla un navegador de forma nativa, como lo haría un usuario, ya sea localmente o en una máquina remota utilizando el servidor Selenium, marca un salto adelante en términos de automatización de navegadores.\nSelenium WebDriver se refiere tanto a los enlaces de lenguajes como también a las implementaciones individuales del código controlador del navegador. Esto se conoce comúnmente solo como WebDriver.\nSelenium WebDriver es una Recomendación W3C\n  WebDriver está diseñado como una interfaz de programación simple y más concisa.\n  WebDriver es una API compacta orientada a objetos.\n  Controla el navegador de manera efectiva.\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/js_alerts_prompts_and_confirmations/",
	"title": "Alertas, avisos y confirmaciones de JavaScript",
	"tags": [],
	"description": "",
	"content": "WebDriver proporciona una API para trabajar con los tres tipos nativos de mensajes emergentes ofrecidos por JavaScript. Estas ventanas emergentes están diseñadas por el navegador y ofrecen personalización limitada.\nAlertas El más simple de estos se conoce como alerta, que muestra unmensaje personalizado y un solo botón que descarta la alerta, etiquetado en la mayoría de los navegadores como OK. También se puede descartar en la mayoría de los navegadores presionando el botón de cerrar, pero esto siempre hará lo mismo que el presionar botón OK. Esto es una alerta de ejemplo.\nWebDriver puede obtener el texto de la ventana emergente y aceptar o descartar estas alertas.\nJava Python C# Ruby JavaScript Kotlin // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); // Espera a que se muestre la alerta y almacenala en una variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); // Almacena el texto de la alerta en una variable String text = alert.getText(); // Presiona el botón OK alert.accept();   # Haz clic en el enlace para activar la alerta driver.find_element(By.LINK_TEXT, \u0026#34;See an example alert\u0026#34;).click() # Espera a que se muestre la alerta y almacenala en una variable alert = wait.until(expected_conditions.alert_is_present()) # Almacena el texto de la alerta en una variable text = alert.text # Presiona el botón OK alert.accept()   // Haz clic en el enlace para activar la alerta driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); // Espera a que se muestre la alerta y almacenala en una variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); // Almacena el texto de la alerta en una variable string text = alert.Text; // Presiona el botón OK alert.Accept();   # Haz clic en el enlace para activar la aler driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Almacena la referencia de la alertta en una variable alert = driver.switch_to.alert # Almacena el texto de la alerta en una variable alert_text = alert.text # Presiona el botón OK alert.accept   // Haz clic en el enlace para activar la alerta await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Espera a que se muestre la alerta await driver.wait(until.alertIsPresent()); // Almacena la alerta en una variable let alert = await driver.switchTo().alert(); // Almacena el texto de la alerta en una variable let alertText = await alert.getText(); // Presiona el botón OK await alert.accept(); // Nota: Para usar await, el código mostrado arriba debe estar en una función async    // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() // Espera a que se muestre la alerta y almacenala en una variable val alert = wait.until(ExpectedConditions.alertIsPresent()) // Almacena el texto de la alerta en una variable val text = alert.getText() // Presiona el botón OK alert.accept()     Confirm Un cuadro de confirmación es similar a una alerta, excepto que el usuario también puede elegir cancelar el mensaje. Esto es un confirm de ejemplo.\nEste ejemplo también muestra un enfoque diferente para almacenar una alerta:\nJava Python C# Ruby JavaScript Kotlin // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); // Espera a que se muestre la alerta wait.until(ExpectedConditions.alertIsPresent()); // Almacena la alerta en una variable Alert alert = driver.switchTo().alert(); // Almacena la alerta en una variable para poder reusarla String text = alert.getText(); // Presiona el botón cancelar alert.dismiss();   # Haz clic en el enlace para activar la alerta driver.find_element(By.LINK_TEXT, \u0026#34;See a sample confirm\u0026#34;).click() # Espera a que se muestre la alerta wait.until(expected_conditions.alert_is_present()) # Almacena la alerta en una variable para poder reusarla alert = driver.switch_to.alert # Almacena el texto de la alerta en una variable text = alert.text # Presiona el botón cancelar alert.dismiss()   // Haz clic en el enlace para activar la alerta driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Espera a que se muestre la alerta wait.Until(ExpectedConditions.AlertIsPresent()); // Almacena la alerta en una variable IAlert alert = driver.SwitchTo().Alert(); // Almacena la alerta en una variable para poder reusarla string text = alert.Text; // Presiona el botón cancelar alert.Dismiss();   # Haz clic en el enlace para activar la alerta driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Almacena la referencia de la alertta en una variable alert = driver.switch_to.alert # Almacena el texto de la alerta en una variable alert_text = alert.text # Presiona el botón cancelar alert.dismiss   // Haz clic en el enlace para activar la alerta await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Espera a que se muestre la alerta await driver.wait(until.alertIsPresent()); // Almacena la alerta en una variable let alert = await driver.switchTo().alert(); // Almacena el texto de la alerta en una variable let alertText = await alert.getText(); // Presiona el botón cancelar await alert.dismiss(); // Nota: Para usar await, el código mostrado arriba debe estar en una función async    // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Espera a que se muestre la alerta wait.until(ExpectedConditions.alertIsPresent()) // Almacena la alerta en una variable val alert = driver.switchTo().alert() // Almacena la alerta en una variable para poder reusarla val text = alert.text //Presiona el botón cancelar alert.dismiss()     Prompt Los prompts son similares a los cuadros de confirmación, excepto que también incluyen una entrada de texto. Similar a trabajar con elementos de los formularios, puedes usar el sendKeys de WebDriver para completar una respuesta. Esto reemplazará completamente el texto por defecto. Al presionar el botón cancelar esto hará que no se envie ningún texto. Esto es un prompt de ejemplo.\nJava Python C# Ruby JavaScript Kotlin // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); // Espera a que se muestre la alerta y almacenala en una variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); // Inserta tu mensaje alert.sendKeys(\u0026#34;Selenium\u0026#34;); // Presiona el botón OK alert.accept();   # Haz clic en el enlace para activar la alerta driver.find_element(By.LINK_TEXT, \u0026#34;See a sample prompt\u0026#34;).click() # Espera a que se muestre la alerta wait.until(expected_conditions.alert_is_present()) # Almacena la alerta en una variable para poder reusarla alert = Alert(driver) # Inserta tu mensaje alert.send_keys(\u0026#34;Selenium\u0026#34;) # Presiona el botón OK alert.accept()   // Haz clic en el enlace para activar la alerta driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); // Espera a que se muestre la alerta y almacenala en una variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); // Inserta tu mensaje alert.SendKeys(\u0026#34;Selenium\u0026#34;); // Presiona el botón OK alert.Accept();   # Haz clic en el enlace para activar la alerta driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Almacena la referencia de la alerta en una variable alert = driver.switch_to.alert # Inserta tu mensaje alert.send_keys(\u0026#34;selenium\u0026#34;) # Presiona el botón OK alert.accept   // Haz clic en el enlace para activar la alerta await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Espera a que se muestre la alerta await driver.wait(until.alertIsPresent()); // Almacena la alerta en una variable let alert = await driver.switchTo().alert(); // Inserta tu mensaje await alert.sendKeys(\u0026#34;Selenium\u0026#34;); // Presiona el botón OK await alert.accept(); // Nota: Para usar await, el código mostrado arriba debe estar en una función async    // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() // Espera a que se muestre la alerta y almacenala en una variable val alert = wait.until(ExpectedConditions.alertIsPresent()) // Inserta tu mensaje alert.sendKeys(\u0026#34;Selenium\u0026#34;) // Presiona el botón OK alert.accept()     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/avoid_sharing_state/",
	"title": "Evitar compartir estados",
	"tags": [],
	"description": "",
	"content": "Aunque se menciona en varios lugares, vale la pena mencionarlo nuevamente. Asegurate de que las pruebas estén aisladas unas de otras.\n  No compartas datos de prueba. Imagina varias pruebas en la que cada una consulta a la base de datos para pedidos válidos antes de elegir uno para realizar una acción. Si dos pruebas eligen el mismo pedido es probable que obtengas un comportamiento inesperado.\n  Limpia los datos obsoletos en la aplicación que podrían ser recogidos por otra prueba p. ej. registros de pedidos inválidos.\n  Crear una nueva instancia de WebDriver por prueba. Esto ayuda a garantizar el aislamiento de la prueba y simplifica la paralelización.\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/es/worst_practices/performance_testing/",
	"title": "Pruebas de rendimiento",
	"tags": [],
	"description": "",
	"content": "Las pruebas de rendimiento usando Selenium y el WebDriver generalmente no son aconsejables. No porque Selenium sea incapaz de ello si no porque no esta optimizado para ello y es poco probable que se obtengan buenos resultados.\nPuede parecer ideal realizar pruebas de rendimiento desde el contexto de un usuario pero una suite de tests del WebDriver esta sujeta a demasiados puntos fragiles tanto internamente como externamente los cuales están fuera de nuestro control. Por ejemplo, la velocidad de puesta en marcha de los navegadores, la velocidad de los servidores HTTP, las respuestas servidores externos que alojan JavaScript o CSS, y la propia penalización debida a la instrumentación de la propia implementación del WebDriver. Cualquier cambio en alguno de estos puntos causará una variación en los resultados. Es difícil separar la diferencia entre el rendimiento de tu sitio web y el rendimiento de tus recursos externos, y también es difícil de definir el impacto negativo en el rendimiento debido al uso del WebDriver en el navegador especialmente si estas inyectando scripts.\nOtra de las principales atracciones es el \u0026ldquo;ahorrarse tiempo\u0026rdquo; llevando a cabo las pruebas funcionales y de rendimiento al mismo tiempo. Sin embargo los tests funcionales y de rendimiento tienen objetivos totalmente opuestos. A la hora de probar funcionalidades, debemos de ser pacientes y esperar a que finalice la carga esto enturbiará los resultados de las pruebas de rendimiento y viceversa.\nPara mejorar el rendimiento de tu pagina web, necesitarás ser capaz de analizar el rendimiento general, independientemente de las diferencias entre entornos, de identificar malas practicas en el código, de descomponer el rendimiento de de los diferentes recursos (ej. CSS en JavaScript) con el fin de saber donde mejorar. Existen herramientas de pruebas de rendimiento disponibles que ya pueden hacer este trabajo y las cuales pueden proveer de informes y análisis que incluso pueden hacer sugerencias de mejora.\nEste es un ejemplo de un paquete (de código libre) que se puede usar, JMeter.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/support_packages/working_with_cookies/",
	"title": "Trabajando con las cookies",
	"tags": [],
	"description": "",
	"content": "Una cookie es una pequeña pieza de datos que es enviada desde el sitio web y es almacenada en el ordenador. Las cookies son usadas principalmente para reconocer al usuario y cargar la información almacenada.\nEl API de WebDriver proporciona una forma de interactuar con las cookies a través de métodos incorporados como:\nAñadir una Cookie Este método es usado para añadir una cookie al contexto actual del navegador. Este método solo acepta un conjunto de objetos JSON serializables definidos. En este enlace esta la lista de claves valor JSON que son aceptadas.\nLo primero de todo, necesitas estar en el dominio para el que la cookie es valida. Si intentas añadir un conjunto de cookies preestablecidas antes de empezar a interactuar con el sitio web y la pagina de inicio es muy pesada o tarda demasiado en cargar una alternativa es encontrar una pagina mas pequeña en el sitio (típicamente la pagina del error 404 es liviana ej. http://example.com/some404page)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Añade una cookie al contexto actual del navegador  driver.manage().addCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Añade una cookie al contexto actual del navegador driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;})   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace AddCookie { class AddCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Añade una cookie al contexto actual del navegador  driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Añade una cookie al contexto actual del navegador driver.manage.add_cookie(name: \u0026#34;key\u0026#34;, value: \u0026#34;value\u0026#34;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade una cookie al contexto actual del navegador  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;}); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Añade una cookie al contexto actual del navegador  driver.manage().addCookie(Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit() } }     Obtener una cookie por nombre Devuelve la información de la cookie serializada que concuerda con el nombre de la cookie entre todas las cookies asociadas.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class getCookieNamed { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39;  Cookie cookie1 = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); System.out.println(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.example.com\u0026#34;) # Añade una cookie al contexto actual del navegador driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bar\u0026#34;}) # Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39; print(driver.get_cookie(\u0026#34;foo\u0026#34;))   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetCookieNamed { class GetCookieNamed { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39;  var cookie = driver.Manage().Cookies.GetCookieNamed(\u0026#34;foo\u0026#34;); System.Console.WriteLine(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;) # Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39; puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade una cookie en el dominio actual  await driver.manage().addCookie({name:\u0026#39;foo\u0026#39;, value: \u0026#39;bar\u0026#39;}); // Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39;  driver.manage().getCookie(\u0026#39;foo\u0026#39;).then(function (cookie) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookie); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39;  val cookie = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); println(cookie); } finally { driver.quit() } }     Obtener todas las cookies Devuelve la información serializada de las cookies de manera satisfactoria para el contexto actual del navegador. Si el navegador no esta disponible devolverá un error.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Set; public class getAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Añade varias cookies  driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Obtiene todas las cookies disponibles  Set\u0026lt;Cookie\u0026gt; cookies = driver.manage().getCookies(); System.out.println(cookies); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Obtiene todas las cookies disponibles print(driver.get_cookies())   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetAllCookies { class GetAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Obtiene todas las cookies disponibles  var cookies = driver.Manage().Cookies.AllCookies; } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Obtiene todas las cookies disponibles puts driver.manage.all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade varias cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Obtiene todas las cookies disponibles  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Obtiene todas las cookies disponibles  val cookies = driver.manage().cookies; println(cookies); } finally { driver.quit() } }     Borrado de una Cookie Borra la información de la cookie que coincida con el nombre de la cookie proporcionado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); Cookie cookie1 = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.manage().addCookie(cookie1); // Borra la cookie con el nombre \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); /* Selenium Java tambien proporciona una forma de borrar cookies pasando un objeto cookie del contexto actual del navegador. */ driver.manage().deleteCookie(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Borra la cookie con el nombre \u0026#39;test1\u0026#39; driver.delete_cookie(\u0026#34;test1\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteCookie { class DeleteCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); var cookie = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.Manage().Cookies.AddCookie(cookie); // Borra la cookie con el nombre \u0026#39;test1\u0026#39;  driver.Manage().Cookies.DeleteCookieNamed(\u0026#34;test1\u0026#34;); // Selenium .Net tambien proporciona una forma de borrar cookies  // pasando un objeto cookie del contexto actual del navegador.  driver.Manage().Cookies.DeleteCookie(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Borra la cookie con el nombre \u0026#39;test1\u0026#39; driver.manage.delete_cookie(\u0026#39;test1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade varias cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Borra la cookie con el nombre \u0026#39;test1\u0026#39;  await driver.manage().deleteCookie(\u0026#39;test1\u0026#39;); // Muestra todas las cookies disponibles  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); val cookie1 = Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;) driver.manage().addCookie(cookie1); // Borra la cookie con el nombre \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); // Borra una cookie pasando un objeto cookie del contexto actual del navegador.  driver.manage().deleteCookie(cookie1); } finally { driver.quit() } }R     Borra todas las Cookies Borra todas las cookies del contexto actual del navegador.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Borra todas las cookies  driver.manage().deleteAllCookies(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Borra todas las cookies driver.delete_all_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteAllCookies { class DeleteAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Borra todas las cookies  driver.Manage().Cookies.DeleteAllCookies(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Borra todas las cookies driver.manage.delete_all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade varias cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Borra todas las cookies  await driver.manage().deleteAllCookies(); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Borra todas las cookies  driver.manage().deleteAllCookies(); } finally { driver.quit() } }     El Atributo Same-Site cookie Este atributo permite al usuario enseñar a los navegadores a controlar que cookies son mandadas junto con las peticiones iniciadas por servicios externos. Esto introducido con la intención de prevenir ataques CSRF (Cross-Site Request Forgery) El atributo Same-Site acepta dos parámetros como instrucciones:\nEstricto: Cuando el atributo sameSite esta fijado como Strict (estricto en español), la cookie no será enviada junto a las peticiones iniciadas por paginas web externas.\nLaxo: Cuando el atributo sameSite se fija como Lax (Laxo en español), la cookie será enviada junto con la petición GET iniciada por paginas web externas.\nNota: Ahora mismo esta característica esta disponible en la versión 80 y superiores de chrome funcionando con Selenium 4 y versiones posteriores.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class cookieTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); Cookie cookie = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build(); Cookie cookie1 = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build(); driver.manage().addCookie(cookie); driver.manage().addCookie(cookie1); System.out.println(cookie.getSameSite()); System.out.println(cookie1.getSameSite()); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Añade la cookie en el contexto actual del navegador con el parámetro  # sameSite como \u0026#39;Strict\u0026#39; (o) \u0026#39;Lax\u0026#39; driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Strict\u0026#39;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Lax\u0026#39;}) cookie1 = driver.get_cookie(\u0026#39;foo\u0026#39;) cookie2 = driver.get_cookie(\u0026#39;foo1\u0026#39;) print(cookie1) print(cookie2)   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Strict\u0026#34;) driver.manage.add_cookie(name: \u0026#34;foo1\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Lax\u0026#34;) puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) puts driver.manage.cookie_named(\u0026#39;foo1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade la cookie en el contexto actual del navegador con el parámetro  // sameSite como \u0026#39;Strict\u0026#39; (o) \u0026#39;Lax\u0026#39;  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Strict\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Lax\u0026#39;}); console.log(await driver.manage().getCookie(\u0026#39;key\u0026#39;)); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;http://www.example.com\u0026#34;) val cookie = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build() val cookie1 = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build() driver.manage().addCookie(cookie) driver.manage().addCookie(cookie1) println(cookie.getSameSite()) println(cookie1.getSameSite()) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/remote_webdriver/",
	"title": "WebDriver remoto",
	"tags": [],
	"description": "",
	"content": "WebDriver remoto Puedes usar WebDriver de forma remota de la misma manera que lo usarías localmente. La principal diferencia es que un WebDriver remoto debe ser configurado para que pueda ejecutar tus pruebas en una máquina diferente.\nUn WebDriver remoto se compone de dos piezas: un cliente y un servidor. El cliente es tu prueba de WebDriver y el servidor es simplemente un servlet Java, que se puede alojar en cualquier servidor moderno de aplicaciones JEE.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/",
	"title": "Guías y recomendaciones",
	"tags": [],
	"description": "",
	"content": "Guías y recomendaciones Una nota sobre \u0026ldquo;Mejores prácticas\u0026rdquo;: hemos evitado intencionalmente la frase \u0026ldquo;Mejores Prácticas\u0026rdquo; en esta documentación. Ningún enfoque funciona para todas las situaciones. Preferimos la idea de \u0026ldquo;Directrices y recomendaciones\u0026rdquo;. Te alentamos a leer a través de estos y decidir cuidadosamente cuales enfoques funcionarían para ti en tu entorno particular.\nLas pruebas funcionales son difíciles de realizar por muchas razones. Como si el estado de la aplicación, la complejidad y las dependencias no dificultaran las pruebas, tratar con navegadores (especialmente con incompatibilidades entre navegadores) hace que escribir buenas pruebas sea un desafío.\nSelenium proporciona herramientas para facilitar la interacción funcional del usuario, pero no le ayuda a escribir conjuntos de pruebas bien diseñados. En este capítulo ofrecemos consejos, pautas y recomendaciones sobre cómo abordar la automatización funcional de páginas web.\nEste capítulo registra los patrones de diseño de software populares entre muchos de los usuarios de Selenium que han demostrado tener éxito a lo largo de los años.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/test_independency/",
	"title": "Independencia en las pruebas",
	"tags": [],
	"description": "",
	"content": "Escribe cada prueba como su propia unidad. Escribe las pruebas de una manera que no dependan de otras pruebas para completarse:\nDigamos que hay un sistema de gestión de contenido con el que puedes crear algún contenido personalizado que luego después publicar aparece en tu sitio web como un módulo, y puede llevar algún tiempo sincronizar entre el CMS y y la aplicación.\nUna forma incorrecta de probar tu módulo es que el contenido está creado y publicado en una prueba y luego verificando el módulo en otra prueba. Esta no es factible ya que el contenido puede no estar disponible de inmediato para otra prueba después de la publicación.\nEn cambio, puedes crear un contenido auxiliar que se puede activar y desactivar dentro de la prueba afectada y úsarla para validar el módulo. Sin embargo, para la creación de contenido, aún puedes tener una prueba por separado.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/http_proxies/",
	"title": "Proxies Http",
	"tags": [],
	"description": "",
	"content": "Un servidor proxy actúa como intermediario para solicitudes entre un cliente y un servidor. En forma simple, el tráfico fluye a través del servidor proxy en camino a la dirección solicitada y de regreso.\nUn servidor proxy para scripts de automatización con Selenium podría ser útil para:\n Captura el tráfico de la red Simular llamadas de backend realizadas por el sitio web Accede al sitio web requerido bajo topologías de red complejas o restricciones/políticas corporativas estrictas.  Si te encuentras en un entorno corporativo, y un navegador no puede conectarse a una URL, esto es muy probablemente porque el ambiente necesita un proxy para acceder.\nSelenium WebDriver proporciona una via para configurar el proxy:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Proxy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.chrome.ChromeOptions; public class proxyTest { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;); ChromeOptions options = new ChromeOptions(); options.setCapability(\u0026#34;proxy\u0026#34;, proxy); WebDriver driver = new ChromeDriver(options); driver.get(\u0026#34;https://www.google.com/\u0026#34;); driver.manage().window().maximize(); driver.quit(); } }   from selenium import webdriver PROXY = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34; webdriver.DesiredCapabilities.FIREFOX[\u0026#39;proxy\u0026#39;] = { \u0026#34;httpProxy\u0026#34;: PROXY, \u0026#34;ftpProxy\u0026#34;: PROXY, \u0026#34;sslProxy\u0026#34;: PROXY, \u0026#34;proxyType\u0026#34;: \u0026#34;MANUAL\u0026#34;, } with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://selenium.dev\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; public class ProxyTest{ public static void Main() { ChromeOptions options = new ChromeOptions(); Proxy proxy = new Proxy(); proxy.Kind = ProxyKind.Manual; proxy.IsAutoDetect = false; proxy.SslProxy = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;; options.Proxy = proxy; options.AddArgument(\u0026#34;ignore-certificate-errors\u0026#34;); IWebDriver driver = new ChromeDriver(options); driver.Navigate().GoToUrl(\u0026#34;https://www.selenium.dev/\u0026#34;); } }   # Need PR   // need PR    import org.openqa.selenium.Proxy import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions class proxyTest { fun main() { val proxy = Proxy() proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;) val options = ChromeOptions() options.setCapability(\u0026#34;proxy\u0026#34;, proxy) val driver: WebDriver = ChromeDriver(options) driver[\u0026#34;https://www.google.com/\u0026#34;] driver.manage().window().maximize() driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/worst_practices/link_spidering/",
	"title": "Rastreo de enlaces",
	"tags": [],
	"description": "",
	"content": "Usando WebDriver para arañar una web a través de enlaces no es una práctica recomendada, no porque no se pueda hacer, pero porque definitivamente no es la herramienta más ideal. WebDriver necesita tiempo para iniciarse, y puede tomar varios de segundos hasta un minuto dependiendo de cómo se escriba tu prueba, solo para llegar a la página y atravesar el DOM.\nEn lugar de usar WebDriver para esto, podrías ahorrar un montón de tiempo ejecutando un comando curl, o usando una librería como BeautifulSoup ya que estos métodos no se basan en crear un navegador y navegar a una página. Estás ahorrando toneladas de tiempo al no utilizar WebDriver para esta tarea.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/consider_using_a_fluent_api/",
	"title": "Considerar el uso de un API fluída",
	"tags": [],
	"description": "",
	"content": "Martin Fowler acuñó el término \u0026ldquo;API fluido\u0026rdquo;. Selenium ya implementa algo como esto en su clase FluentWait, que se entiende como una alternativa a la clase estándar Wait. Puedes habilitar el patrón de diseño Fluent API en tu objeto de página y luego consulta la página de búsqueda de Google con un fragmento de código como este:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); La clase de objeto de página de Google con este comportamiento fluido podría verse así:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // Si load() falla, se llama a isLoaded() hasta que la página termine de cargarse  PageFactory.initElements(driver, this); // Inicializa los WebElements en la pagina  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, Duration.ofSeconds(3) ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } } "
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/page_loading_strategy/",
	"title": "Estrategia de carga de página",
	"tags": [],
	"description": "",
	"content": "Define la estrategia de carga de la página en la sesión actual. Por defecto, cuando Selenium WebDriver carga una página, sigue la pageLoadStrategy normal. Siempre se recomienda detener la descarga de más recursos adicionales (como imágenes, css, js) cuando la carga de la página lleva mucho tiempo.\nLa propiedad document.readyState de un documento describe el estado de carga del documento actual. Por defecto, WebDriver esperará responder a una llamada driver.get() (o) driver.navigate().to() hasta que el estado de documento listo esté completo\nEn aplicaciones SPA (como Angular, react, Ember) una vez que el contenido dinámico ya está cargado (es decir, una vez que el estado de pageLoadStrategy es COMPLETO), hacer clic en un enlace o realizar alguna acción dentro de la página no hará una nueva solicitud al servidor ya que el contenido se carga dinámicamente en el lado del cliente sin una actualización de la página.\nLas aplicaciones de SPA pueden cargar muchas vistas dinámicamente sin ninguna solicitud del servidor, por lo que pageLoadStrategy siempre mostrará el estado \u0026lsquo;COMPLETO\u0026rsquo; hasta que hagamos un nuevo driver.get() y driver.navigate().to()\nWebDriver pageLoadStrategy permite los siguientes valores:\nnormal Esto hará que Selenium WebDriver espere a que se cargue toda la página. Cuando se establece en normal, Selenium WebDriver espera hasta que se dispare el evento load y sea retornado.\nPor defecto normal se establece en el navegador si no se proporciona ninguno.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;normal\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Normal; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;normal\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;normal\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     eager Esto hará que Selenium WebDriver espere hasta que el documento HTML inicial se haya cargado y analizado por completo, y descarta la carga de hojas de estilo, imágenes y sub marcos.\nCuando se establece en eager, Selenium WebDriver espera hasta que se dispare el evento DOMContentLoaded y sea retornado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;eager\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Eager; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;eager\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;eager\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     none Cuando se establece en none Selenium WebDriver solo espera hasta que se descargue la página inicial.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;none\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.None; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;none\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;none\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/worst_practices/",
	"title": "Malas prácticas",
	"tags": [],
	"description": "",
	"content": "Malas prácticas "
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/web_element/",
	"title": "Elemento web",
	"tags": [],
	"description": "",
	"content": "WebElement representa un elemento del DOM. Los WebElements se pueden encontrar buscando desde la raíz del documento utilizando una instancia de WebDriver o buscando en otra WebElement.\nEl API WebDriver proporciona métodos integrados para encontrar los elementos web que son basados en diferentes propiedades como ID, Nombre, Clase, XPath, Selectores CSS, Texto de enlace, etc.\nFind Element Se utiliza para encontrar un elemento y devuelve la primera referencia única de WebElement que coincide, que puede usarse para acciones futuras con el elemento\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); // Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element WebElement searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_box = driver.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navega a la URL driver.get \u0026#39;https://google.com\u0026#39; # Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element search_bar = driver.find_element(name: \u0026#39;q\u0026#39;) # Ejecuta una acción utilizando WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ // Navega a la URL await driver.get(\u0026#39;http://www.google.com\u0026#39;); // Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element let searchBar = driver.findElement(By.name(\u0026#39;q\u0026#39;)); // Ejecuta una acción utilizando WebElemen await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element val searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements Similar a \u0026lsquo;Find Element\u0026rsquo;, pero devuelve una lista de elementos web coincidentes. Para usar un WebElement particular de la lista, debes recorrerla lista de elementos para realizar acciones con el elemento seleccionado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import java.util.List; public class findElementsExample { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement element : elements) { System.out.println(\u0026#34;Paragraph text:\u0026#34; + element.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() # Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using System.Collections.Generic; namespace FindElementsExample { class FindElementsExample { public static void Main(string[] args) { IWebDriver driver = new FirefoxDriver(); try { // Navega a la Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = driver.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navega a la Url driver.get \u0026#39;https://www.example.com\u0026#39; # Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39; elements = driver.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  let elements = await driver.findElements(By.tagName(\u0026#39;p\u0026#39;)); for(let e of elements) { console.log(await e.getText()); } } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  val elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (element in elements) { println(\u0026#34;Paragraph text:\u0026#34; + element.text) } } finally { driver.quit() } }     Find Element desde Element Se utiliza para encontrar un elemento hijo dentro del contexto del elemento padre. Para lograr esto, el WebElement primario se encadena con \u0026lsquo;findElement\u0026rsquo; para acceder a elementos secundarios.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element(By.TAG_NAME, \u0026#34;form\u0026#34;) search_box = search_form.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = searchForm.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navega a la URL driver.get \u0026#39;https://google.com\u0026#39; # Obtén y almacena el elemento DOM `\u0026lt;form\u0026gt;` search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Obtén el elemento de caja de búsqueda del elemento `form` search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Ejecuta una acción usando WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navega a la URL await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Obtén y alamacena el elemento DOM `\u0026lt;form\u0026gt;` let searchForm = driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Obtén el elemento de caja de búsqueda del elemento `form` let searchBar = searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Ejecuta una acción usando WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements desde Element Se utiliza para encontrar una lista de elementos hijos dentro del contexto del elemento padre. Para lograr esto, el WebElement primario se encadena con \u0026lsquo;findElements\u0026rsquo;para acceder a elementos secundarios.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import java.util.List; public class findElementsFromElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39;  WebElement element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement e : elements) { System.out.println(e.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(By.TAG_NAME, \u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System.Collections.Generic; namespace FindElementsFromElement { class FindElementsFromElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39;  IWebElement element = driver.FindElement(By.TagName(\u0026#34;div\u0026#34;)); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = element.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.example.com\u0026#39; # Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39; element = driver.find_element(:tag_name,\u0026#39;div\u0026#39;) # Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39; elements = element.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39;  let element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  let elements = await element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for(let e of elements) { console.log(await e.getText()); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39;  val element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)) // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  val elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (e in elements) { println(e.text) } } finally { driver.quit() } }     Get Active Element Se utiliza para rastrear (o) encontrar el elemento DOM que tiene el foco en el contexto de navegación actual.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class activeElementTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;); // Obtener el atributo del elemento activo actual  String attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); System.out.println(attr); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.find_element(By.CSS_SELECTOR, \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#34;webElement\u0026#34;) # Obtener el atributo del elemento activo actual attr = driver.switch_to.active_element.get_attribute(\u0026#34;title\u0026#34;) print(attr)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace ActiveElement { class ActiveElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://www.google.com\u0026#34;); driver.FindElement(By.CssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).SendKeys(\u0026#34;webElement\u0026#34;); // Obtener el atributo del elemento activo actual  string attr = driver.SwitchTo().ActiveElement().GetAttribute(\u0026#34;title\u0026#34;); System.Console.WriteLine(attr); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.google.com\u0026#39; driver.find_element(css: \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#39;webElement\u0026#39;) # Obtener el atributo del elemento activo actual attr = driver.switch_to.active_element.attribute(\u0026#39;title\u0026#39;) puts attr ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); await driver.get(\u0026#39;https://www.google.com\u0026#39;); await driver.findElement(By.css(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;)).sendKeys(\u0026#34;webElement\u0026#34;); // Obtener el atributo del elemento activo actual  let attr = await driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); console.log(`${attr}`) })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;) // Obtener el atributo del elemento activo actual  val attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); print(attr); } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/es/grid/",
	"title": "Grid",
	"tags": [],
	"description": "",
	"content": "Grid Selenium Grid es un servidor inteligente que efectúa de proxy que permite a los tests de Selenium enrutar sus comandos hacia instancias remotas de navegadores web. La intención de esto es proporcionar una forma sencilla de ejecutar los tests en paralelo en múltiple maquinas.\nCon Selenium Grid un servidor actúa como el centro de actividad (hub) encargado de enrutar los comandos de los tests en formato JSON hacia uno o mas nodos registrados en el Grid. Los tests contactan con el hub para obtener acceso a las instancias remotas de los navegadores.\nSelenium Grid te permite ejecutar los tests en paralelo en múltiples maquinas y también te permite gestionar diferentes versiones de navegadores y diferentes configuraciones de navegadores de manera centralizada (en lugar de hacerlo de manera individual en cada test)\nSelenium Grid no es una solución mágica para todos tus problemas. Permite resolver un subconjunto de problemas comunes de delegación y distribución, pero, por ejemplo, no administrará su infraestructura y podría no satisfacer sus necesidades personales.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/guidelines_and_recommendations/fresh_browser_per_test/",
	"title": "Nueva instancia del navegador por prueba",
	"tags": [],
	"description": "",
	"content": "Comienza cada prueba desde un estado limpio conocido. Idealmente, ejecuta una nueva máquina virtual para cada prueba. Si ejecutar una nueva máquina virtual no es práctico, al menos inicia un nuevo WebDriver para cada prueba. Para Firefox, inicia un WebDriver con su perfil conocido.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile); "
},
{
	"uri": "https://www.selenium.dev/documentation/es/support_packages/chrome_devtools/",
	"title": "Chrome Devtools",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Selenium 4 alpha versions have much awaited native support for Chrome Dev Protocol through \u0026ldquo;DevTools\u0026rdquo; interface. This helps us getting Chrome Development properties such as Application Cache, Fetch, Network, Performance, Profiler, Resource Timing, Security and Target CDP domains etc.\nChrome DevTools is a set of web developer tools built directly into the Google Chrome browser. DevTools can help you edit pages on-the-fly and diagnose problems quickly, which ultimately helps you build better websites, faster.\nEmulate Geo Location: Some applications have different features and functionalities across different locations. Automating such applications is difficult because it is hard to emulate the geo locations in the browser using Selenium. But with the help of Devtools, we can easily emulate them. Below code snippet demonstrates that.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.devtools.DevTools; public void geoLocationTest(){ ChromeDriver driver = new ChromeDriver(); Map coordinates = new HashMap() {{ put(\u0026#34;latitude\u0026#34;, 50.2334); put(\u0026#34;longitude\u0026#34;, 0.2334); put(\u0026#34;accuracy\u0026#34;, 1); }}; driver.executeCdpCommand(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, coordinates); driver.get(\u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;); }   # Please raise a PR to add code sample   // Please raise a PR to add code sample    # Please raise a PR to add code sample   // Please raise a PR to add code sample    // Please raise a PR to add code sample      "
},
{
	"uri": "https://www.selenium.dev/documentation/es/driver_idiosyncrasies/",
	"title": "Comportamientos del controlador",
	"tags": [],
	"description": "",
	"content": "Comportamientos del controlador "
},
{
	"uri": "https://www.selenium.dev/documentation/es/webdriver/keyboard/",
	"title": "Teclado",
	"tags": [],
	"description": "",
	"content": "Keyboard representa un evento del teclado. Las acciones del teclado se realizan mediante el uso de una interfaz de bajo nivel que nos permite proporcionar entradas de un dispositivo virtualizado al navegador web.\nsendKeys El sendKeys escribe una secuencia de teclas en el elemento del DOM incluso si se encuentra una secuencia de teclas modificadoras. Here are the list of possible keystrokes that WebDriver Supports.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Inserta el texto \u0026#34;q\u0026#34; y ejecuta la accion del teclado \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER);\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Firefox()\r# Navega a la URL\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r \rusing (var driver = new FirefoxDriver())\r{\r// Navega a la URL\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :firefox\rbegin\r# Navega a la URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navega a la URL\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.firefox.FirefoxDriver\rfun main() {\rval driver = FirefoxDriver()\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Inserta el texto \u0026#34;q\u0026#34; y ejecuta la accion del teclado \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER)\r} finally {\rdriver.quit()\r}\r}\r \r  keyDown KeyDown se usa para simular la acción de presionar una tecla modificadora (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver();\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER);\rActions actionProvider = new Actions(driver);\rAction keydown = actionProvider.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build();\rkeydown.perform();\r} finally {\rdriver.quit();\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navega a la URL\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r# Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r webdriver.ActionChains(driver).key_down(Keys.CONTROL).send_keys(\u0026#34;a\u0026#34;).perform()\r \rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navega a la URL\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r// Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r Actions actionProvider = new Actions(driver);\rIAction keydown = actionProvider.KeyDown(Keys.Control).SendKeys(\u0026#34;a\u0026#34;).Build();\rkeydown.Perform();\r}\rfinally\r{\rdriver.Quit();\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navega a la URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\r# Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r driver.action.key_down(:control).send_keys(\u0026#39;a\u0026#39;).perform\rensure\rdriver.quit\rend\r \r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navega a la URL\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r// Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r await driver.actions().keyDown(Key.CONTROL).sendKeys(\u0026#39;a\u0026#39;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\rval action = Actions(driver)\r// Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r action.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  keyUp KeyUp se usa para simular la acción de liberar (o) desbloqueo de una tecla modificadora (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rimport org.openqa.selenium.interactions.Actions;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Almacena el WebElement del cuadro de búsqueda de Google  WebElement search = driver.findElement(By.name(\u0026#34;q\u0026#34;));\r// Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)  action.keyDown(Keys.SHIFT).sendKeys(search,\u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navega a la URL\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Almacena el WebElement del cuadro de búsqueda de Google  search = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\raction = webdriver.ActionChains(driver)\r# Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r action.key_down(Keys.SHIFT).send_keys_to_element(search, \u0026#34;qwerty\u0026#34;).key_up(Keys.SHIFT).send_keys(\u0026#34;qwerty\u0026#34;).perform()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing OpenQA.Selenium.Interactions;\rnamespace HelloSelenium\r{\rclass HelloSelenium\r{\rpublic static void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navega a la URL\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Almacena el WebElement del cuadro de búsqueda de Google  IWebElement search = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\r// Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r action.KeyDown(Keys.Shift).SendKeys(search, \u0026#34;qwerty\u0026#34;).KeyUp(Keys.Shift).SendKeys(\u0026#34;qwerty\u0026#34;).Perform();\r}\rfinally {\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navega a la URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Almacena el WebElement del cuadro de búsqueda de Google  search = driver.find_element(name: \u0026#39;q\u0026#39;)\r# Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r driver.action.key_down(:shift).send_keys(search,\u0026#39;qwerty\u0026#39;).key_up(:shift).send_keys(\u0026#34;qwerty\u0026#34;).perform\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navega a la URL\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Almacena el WebElement del cuadro de búsqueda de Google  let search = driver.findElement(By.name(\u0026#39;q\u0026#39;));\r// Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r await driver.actions().click(search).keyDown(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).keyUp(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Almacena el WebElement del cuadro de búsqueda de Google  val search = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rval action = Actions(driver)\r// Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search, \u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  clear Borra el contenido de un elemento editable. Esto solo se aplica a los elementos que son editables e interactuables, de lo contrario, Selenium devuelve el error (invalid element state (or) Element not interactable)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.chrome.ChromeDriver;\rpublic class clear {\rpublic static void main(String[] args) {\rWebDriver driver = new ChromeDriver();\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://www.google.com\u0026#34;);\r// Almacena el elemento \u0026#39;SearchInput\u0026#39;\r WebElement searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;));\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Borra el texto ingresado\r searchInput.clear();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rdriver = webdriver.Chrome()\r# Navega a la URL\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Almacena el elemento \u0026#39;SearchInput\u0026#39;\r SearchInput = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\rSearchInput.send_keys(\u0026#34;selenium\u0026#34;)\r# Borra el texto ingresado\r SearchInput.clear()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing System;\rnamespace SnipetProjectDelete\r{\rclass Program\r{\rstatic void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navega a la URL\r driver.Navigate().GoToUrl(@\u0026#34;https://www.google.com\u0026#34;);\r// Almacena el elemento \u0026#39;SearchInput\u0026#39;\r IWebElement searchInput = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\rsearchInput.SendKeys(\u0026#34;selenium\u0026#34;);\r// Borra el texto ingresado\r searchInput.Clear();\r}\rfinally\r{\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navega a la URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Almacena el elemento \u0026#39;SearchInput\u0026#39;t\r search_input = driver.find_element(name: \u0026#39;q\u0026#39;)\rsearch_input.send_keys(\u0026#39;selenium\u0026#39;)\r# Borra el texto ingresado\r search_input.clear\rensure\rdriver.quit\rend\r \rconst {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navega a la URL\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Almacena el elemento \u0026#39;SearchInput\u0026#39;\r let searchInput = driver.findElement(By.name(\u0026#39;q\u0026#39;));\rawait searchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Borra el texto ingresado\r await searchInput.clear();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.chrome.ChromeDriver\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://www.google.com\u0026#34;)\r// Almacena el elemento \u0026#39;SearchInput\u0026#39;\r val searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;)\r// Borra el texto ingresado\r searchInput.clear()\r} finally {\rdriver.quit()\r}\r}\r \r  "
},
{
	"uri": "https://www.selenium.dev/documentation/es/support_packages/",
	"title": "Paquetes de soporte",
	"tags": [],
	"description": "",
	"content": "Paquetes de soporte "
},
{
	"uri": "https://www.selenium.dev/documentation/es/legacy_docs/",
	"title": "Legacy",
	"tags": [],
	"description": "",
	"content": "Legacy En esta sección puedes encontrar toda la documentación relacionada con los componentes legacy (heredados) de Selenium. Esto está destinado a mantenerse únicamente por razones históricas y no como un incentivo para utilizar componentes en desuso.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/front_matter/",
	"title": "Texto preliminar",
	"tags": [],
	"description": "",
	"content": "Texto preliminar "
},
{
	"uri": "https://www.selenium.dev/documentation/es/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.selenium.dev/documentation/es/contributing/",
	"title": "Contributing to the Selenium Site &amp; Documentation",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Selenium is a big software project, its site and documentation are key to understanding how things work and learning effective ways to exploit its potential.\nThis project contains both Selenium\u0026rsquo;s site and documentation. This is an ongoing effort (not targeted at any specific release) to provide updated information on how to use Selenium effectively, how to get involved and how to contribute to Selenium.\nContributions toward the site and docs follow the process described in the below section about contributions. You should spend some time familiarising yourself with the documentation by reading more about it.\n The Selenium project welcomes contributions from everyone. There are a number of ways you can help:\nReport an issue When reporting a new issues or commenting on existing issues please make sure discussions are related to concrete technical issues with the Selenium software, its site and/or documentation.\nAll of the Selenium components change quite fast over time, so this might cause the documentation to be out of date. If you find this to be the case, as mentioned, don\u0026rsquo;t doubt to create an issue for that. It also might be possible that you know how to bring up to date the documentation, so please send us a pull request with the related changes.\nIf you are not sure about what you have found is an issue or not, please ask through the communication channels described at https://selenium.dev/support.\nContributions The Selenium project welcomes new contributors. Individuals making significant and valuable contributions over time are made Committers and given commit-access to the project.\nThis guide will guide you through the contribution process.\nStep 1: Fork Fork the project on Github and check out your copy locally.\n% git clone git@github.com:seleniumhq/seleniumhq.github.io.git % cd seleniumhq.github.io Dependencies: Hugo We use Hugo to build and render the site and docs. To verify everything locally before even committing any changes, please install Hugo, get familiar with it and run the local server to render the site locally (detailed instructions can be found in the next steps).\nStep 2: Branch Create a feature branch and start hacking:\n% git checkout -b my-feature-branch We practice HEAD-based development, which means all changes are applied directly on top of master.\nStep 3: Make changes The repository contains the site and docs, which are two separate Hugo projects. If you want to make changes to the site, work on the site_source_files directory. To see a live preview of your changes, run hugo server on the site\u0026rsquo;s root directory.\n% cd site_source_files % hugo server To make changes to the docs, switch to the docs_source_files directory.\n% cd docs_source_files % hugo server The docs are translated into several languages, and translations are based on the English content. When you are changing a file, be sure to make your changes in all the other translated files as well. This might differ depending on the change, for example:\n If you add a code example to the browser_manipulation.en.md file, also add it to browser_manipulation.es.md, browser_manipulation.ef.md, browser_manipulation.ja.md, and all other translated files. If you find a translation that can be improved, only change the translated file. If you are adding a new language translation, add the new files with the appropriate suffix. There is no need to have everything translated to submit a PR, it can be done iteratively. Don\u0026rsquo;t forget to check some needed configuration values in the config.toml file. If you make text changes in the English version, replace the same section in the translated files with your change (yes, in English), and add the following notice at the top of the file.  {{% notice info %}} \u0026lt;i class=\u0026#34;fas fa-language\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Page being translated from English to {LANGUAGE}. Do you speak {LANGUAGE}? Help us to translate it by sending us pull requests! {{% /notice %}} Step 4: Commit First make sure git knows your name and email address:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; Writing good commit messages is important. A commit message should describe what changed, why, and reference issues fixed (if any). Follow these guidelines when writing one:\n The first line should be around 50 characters or less and contain a short description of the change. Keep the second line blank. Wrap all other lines at 72 columns. Include Fixes #N, where N is the issue number the commit fixes, if any.  A good commit message can look like this:\nexplain commit normatively in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way `git log` will show things nicely even when it is indented. Fixes #141 The first line must be meaningful as it\u0026rsquo;s what people see when they run git shortlog or git log --oneline.\nStep 5: Rebase Use git rebase (not git merge) to sync your work from time to time.\n% git fetch upstream % git rebase upstream/master Step 6: Test Always remember to run the local server, with this you can be safe that your changes have not broken anything.\nStep 7: Push % git push origin my-feature-branch Go to https://github.com/yourusername/seleniumhq.github.io.git and press the Pull Request and fill out the form. Please indicate that you\u0026rsquo;ve signed the CLA (see Step 7).\nPull requests are usually reviewed within a few days. If there are comments to address, apply your changes in new commits (preferably fixups) and push to the same branch.\nStep 8: Integration When code review is complete, a committer will take your PR and integrate it on the repository\u0026rsquo;s master branch. Because we like to keep a linear history on the master branch, we will normally squash and rebase your branch history.\nCommunication All details on how to communicate with the project contributors and the community overall can be found at https://selenium.dev/support\n"
},
{
	"uri": "https://www.selenium.dev/documentation/es/",
	"title": "Selenium, el proyecto para automatizar navegadores",
	"tags": [],
	"description": "",
	"content": "Selenium, el proyecto para automatizar navegadores Selenium es un proyecto que alberga un abanico de herramientas y librerías que permiten y apoyan la automatización de navegadores web.\nProporciona extensiones que permiten emular las interacciones que realizan los usuarios con los navegadores, un servidor que permite distribuir la asignación de navegadores de forma escalable, y la infraestructura necesaria para las implementaciones de la especificación del WebDriver del W3C, el cual permite escribir código intercambiable para los navegadores web mas usados.\nEste proyecto es posible gracias a los colaboradores voluntarios, los cuales han dedicado miles de horas de su propio tiempo haciendo así que el código fuente esté disponible de manera gratuita para que cualquiera pueda usarlo, disfrutarlo y mejorarlo.\nSelenium conecta a proveedores de navegadores web, ingenieros y entusiastas para promover un debate abierto sobre la automatización de plataformas web. El proyecto organiza una conferencia anual con el fin de enseñar y nutrir a la comunidad.\nEl corazón de Selenium es el WebDriver, una interfaz que permite escribir conjuntos de instrucciones que se pueden ejecutar de manera indistinta en muchos navegadores.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; import java.time.Duration; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #This example requires Selenium WebDriver 3.13 or newer with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located(By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;)) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;div\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Añade el texto \u0026#34;cheese\u0026#34; y efectúa la acción de la tecla \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;div\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated import org.openqa.selenium.support.ui.WebDriverWait import java.time.Duration fun main() { val driver = FirefoxDriver() val wait = WebDriverWait(driver, Duration.ofSeconds(10)) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))) println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } }     Puedes ver este tour rápido para una explicación completa de lo que sucede entre bastidores cuando se ejecuta el código. Es recomendable continuar con el planteamiento que ofrece esta documentación para entender como se puede instalar y usar correctamente Selenium como herramienta de automatización de pruebas, y como se puede escalar pruebas simples como el ejemplo anterior, en grandes entornos con múltiples navegadores en diferentes sistemas operativos.\nEmpezando Si eres nuevo con Selenium, tenemos una serie de recursos que te pueden ayudar a ponerte al día de inmediato\n Tour rápido  WebDriver IDE Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/es/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]