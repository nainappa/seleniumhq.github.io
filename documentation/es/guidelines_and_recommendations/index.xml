<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Guías y recomendaciones on Documentación de Selenium</title>
    <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/</link>
    <description>Recent content in Guías y recomendaciones on Documentación de Selenium</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>2013-{year}</copyright>
    
	<atom:link href="https://www.selenium.dev/documentation/es/guidelines_and_recommendations/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Modelos de objetos de página</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/page_object_models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/page_object_models/</guid>
      <description>Page Object (objeto de página) es un patrón de diseño que se ha vuelto popular en la automatización de pruebas para mejorar el mantenimiento de las pruebas y reducir la duplicación de código. Un objeto de página es un clase orientada a objetos que sirve como interfaz para una página de tu AUT. Las pruebas luego usan los métodos de esta clase de objeto de página cuando lo necesitan para interactuar con la interfaz de usuario de esa página.</description>
    </item>
    
    <item>
      <title>Lenguage de dominio específico</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/domain_specific_language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/domain_specific_language/</guid>
      <description>Un lenguaje de dominio específico (DSL) es un sistema que proporciona al usuario un medio expresivo para resolver un problema. Permite a un usuario interactuar con el sistema en sus términos, no solo en jerga del programador.
A tus usuarios, en general, no les importa cómo se ve su sitio. Ellos no se preocupan por la decoración, animaciones o gráficos. Ellos desean utilizar tu sistema para impulsar a sus nuevos empleados a través del proceso con mínima dificultad; quieren reservar un viaje a Alaska; quieren configurar y comprar unicornios con descuento.</description>
    </item>
    
    <item>
      <title>Generar el estado de la aplicación</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/generating_application_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/generating_application_state/</guid>
      <description>Selenium no debe usarse para preparar un caso de prueba. Todas las acciones repetitivas y los preparativos para un caso de prueba deben realizarse a través de otros métodos. Por ejemplo, la mayoría de las IU web tienen autenticación (por ejemplo, un formulario de inicio de sesión). Eliminar el inicio de sesión a través del navegador web antes de cada prueba mejora tanto la velocidad como la estabilidad de la prueba.</description>
    </item>
    
    <item>
      <title>Mock de servicios externos</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/mock_external_services/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/mock_external_services/</guid>
      <description>Eliminar las dependencias de servicios externos mejorará en gran medida la velocidad y la estabilidad de tus pruebas.</description>
    </item>
    
    <item>
      <title>Mejores reportes</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/improved_reporting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/improved_reporting/</guid>
      <description>Selenium no está diseñado para informar sobre el estado de los casos de prueba ejecutados. Aprovechando las capacidades de reporte incorporadas en la mayoría de los frameworks de pruebas unitarias es un buen comienzo. La mayoría de los frameworks de pruebas unitarias tienen utilidades que pueden generar reportes con formato xUnit o HTML. Los reportes xUnit son populares para importar resultados a una integración continua (CI) como Jenkins, Travis, Bamboo, etc.</description>
    </item>
    
    <item>
      <title>Evitar compartir estados</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/avoid_sharing_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/avoid_sharing_state/</guid>
      <description>Aunque se menciona en varios lugares, vale la pena mencionarlo nuevamente. Asegurate de que las pruebas estén aisladas unas de otras.
  No compartas datos de prueba. Imagina varias pruebas en la que cada una consulta a la base de datos para pedidos válidos antes de elegir uno para realizar una acción. Si dos pruebas eligen el mismo pedido es probable que obtengas un comportamiento inesperado.
  Limpia los datos obsoletos en la aplicación que podrían ser recogidos por otra prueba p.</description>
    </item>
    
    <item>
      <title>Independencia en las pruebas</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/test_independency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/test_independency/</guid>
      <description>Escribe cada prueba como su propia unidad. Escribe las pruebas de una manera que no dependan de otras pruebas para completarse:
Digamos que hay un sistema de gestión de contenido con el que puedes crear algún contenido personalizado que luego después publicar aparece en tu sitio web como un módulo, y puede llevar algún tiempo sincronizar entre el CMS y y la aplicación.
Una forma incorrecta de probar tu módulo es que el contenido está creado y publicado en una prueba y luego verificando el módulo en otra prueba.</description>
    </item>
    
    <item>
      <title>Considerar el uso de un API fluída</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/consider_using_a_fluent_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/consider_using_a_fluent_api/</guid>
      <description>Martin Fowler acuñó el término &amp;ldquo;API fluido&amp;rdquo;. Selenium ya implementa algo como esto en su clase FluentWait, que se entiende como una alternativa a la clase estándar Wait. Puedes habilitar el patrón de diseño Fluent API en tu objeto de página y luego consulta la página de búsqueda de Google con un fragmento de código como este:
driver.get( &amp;#34;http://www.google.com/webhp?hl=en&amp;amp;amp;tab=ww&amp;#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); La clase de objeto de página de Google con este comportamiento fluido podría verse así:</description>
    </item>
    
    <item>
      <title>Nueva instancia del navegador por prueba</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/fresh_browser_per_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/fresh_browser_per_test/</guid>
      <description>Comienza cada prueba desde un estado limpio conocido. Idealmente, ejecuta una nueva máquina virtual para cada prueba. Si ejecutar una nueva máquina virtual no es práctico, al menos inicia un nuevo WebDriver para cada prueba. Para Firefox, inicia un WebDriver con su perfil conocido.
FirefoxProfile profile = new FirefoxProfile(new File(&amp;#34;pathToFirefoxProfile&amp;#34;)); WebDriver driver = new FirefoxDriver(profile); </description>
    </item>
    
  </channel>
</rss>