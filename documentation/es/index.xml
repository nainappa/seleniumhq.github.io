<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Selenium, el proyecto para automatizar navegadores on Documentación de Selenium</title>
    <link>https://www.selenium.dev/documentation/es/</link>
    <description>Recent content in Selenium, el proyecto para automatizar navegadores on Documentación de Selenium</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>2013-{year}</copyright>
    
	<atom:link href="https://www.selenium.dev/documentation/es/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Captchas</title>
      <link>https://www.selenium.dev/documentation/es/worst_practices/captchas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/worst_practices/captchas/</guid>
      <description>CAPTCHA es la abreviatura de Completely Automated Public Turing test to tell Computers and Humans Apart o en español Prueba de Turing Completamente Automática y Pública para diferenciar Ordenadores de Humanos, está explícitamente diseñado para prevenir la automatización, ¡así que no intentes automatizarlo!
Existen dos estrategias principales para evitar los CAPTCHAs:
 Deshabilitar los CAPTCHAs en tus entornos de pruebas. Agrega un parámetro que permita que las pruebas hagan un baipás.</description>
    </item>
    
    <item>
      <title>Derechos de autor y atribuciones</title>
      <link>https://www.selenium.dev/documentation/es/front_matter/copyright_and_attributions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/front_matter/copyright_and_attributions/</guid>
      <description>Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!
 The Documentation of Selenium Copyright &amp;copy; 2013-2020 , Software Freedom Conservancy.
Every effort has been made to make this documentation as complete and as accurate as possible, but no warranty or fitness is implied. The information provided is on an “as-is” basis. The authors and the publisher shall have neither liability nor responsibility to any person or entity with respect to any loss or damages arising from the information contained in this book.</description>
    </item>
    
    <item>
      <title>El proyecto Selenium y sus herramientas</title>
      <link>https://www.selenium.dev/documentation/es/introduction/the_selenium_project_and_tools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/introduction/the_selenium_project_and_tools/</guid>
      <description>Selenium controla los navegadores web Selenium significa muchas cosas pero en su núcleo, es un conjunto de herramientas para la automatización de navegadores web que utiliza las mejores técnicas disponibles para controlar remotamente las instancias de los navegadores y emular la interacción del usuario con el navegador.
Permite a los usuarios simular interacciones básicas realizadas por los usuarios finales; insertando texto en los campos, seleccionando valores de menús desplegables y casillas de verificación, y haciendo clics en los enlaces de los documentos.</description>
    </item>
    
    <item>
      <title>Entendiendo los componentes</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/understanding_the_components/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/understanding_the_components/</guid>
      <description>Construir una suite de test usando WebDriver requerirá que entiendas y uses de forma efectiva diferentes componentes. Como con todo en el desarrollo de software, la gente usa diferentes términos para la misma idea. A continuación hay un desglose de cómo los términos son usados en esa descripción.
Terminología  API: Interfaz de Programación de Aplicaciones. Es un conjunto de &amp;ldquo;comandos&amp;rdquo; que se utilizan para manipular el WebDriver. Library: Un módulo de código que contiene las APIs y el código necesario para implementarlos.</description>
    </item>
    
    <item>
      <title>Guía rápida</title>
      <link>https://www.selenium.dev/documentation/es/getting_started/quick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/getting_started/quick/</guid>
      <description>Selenium no es solo una herramienta o API, sino que compone muchas herramientas.
WebDriver Si está comenzando con la automatización de pruebas de sitios web de escritorio, entonces va a utilizar las API de WebDriver. WebDriver utiliza las API de automatización del navegador proporcionadas por los desarrolladores de los navegadores para controlar el navegador y ejecutar pruebas. Esto es como si un usuario real estuviera manipulando el navegador. Dado que el WebDriver no requiere que su API se compile con el código de la aplicación que va a probar, no es de naturaleza intrusiva.</description>
    </item>
    
    <item>
      <title>Instalando las librerías de Selenium</title>
      <link>https://www.selenium.dev/documentation/es/selenium_installation/installing_selenium_libraries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/selenium_installation/installing_selenium_libraries/</guid>
      <description>Primero debes instalar las librerías de enlace Selenium para tu proyecto de automatización. El proceso de instalación de las librerías depende del lenguaje que elijas usar.
Java La instalación de las librerías Selenium para Java se puede hacer usando Maven. Agrega la dependencia de selenium-java en el pom.xml de tu proyecto:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.seleniumhq.selenium&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;selenium-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.X&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; La dependencia selenium-java permite la ejecución de tu proyecto de automatización en todos los navegadores compatibles con Selenium.</description>
    </item>
    
    <item>
      <title>Modelos de objetos de página</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/page_object_models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/page_object_models/</guid>
      <description>Page Object (objeto de página) es un patrón de diseño que se ha vuelto popular en la automatización de pruebas para mejorar el mantenimiento de las pruebas y reducir la duplicación de código. Un objeto de página es un clase orientada a objetos que sirve como interfaz para una página de tu AUT. Las pruebas luego usan los métodos de esta clase de objeto de página cuando lo necesitan para interactuar con la interfaz de usuario de esa página.</description>
    </item>
    
    <item>
      <title>Navegadores</title>
      <link>https://www.selenium.dev/documentation/es/getting_started_with_webdriver/browsers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/getting_started_with_webdriver/browsers/</guid>
      <description>Navegadores para el consumidor El framework de Selenium soporta oficialmente los siguientes navegadores:
   Navegador Mantenedor Versiones Soportadas     Chrome Chromium Todas las Versiones   Firefox Mozilla 54 y más recientes   Internet Explorer Selenium 6 y más recientes   Opera Opera Chromium / Presto 10.5 y más recientes   Safari Apple 10 y más recientes    Navegadores especializados También hay un conjunto de navegadores especializados utilizados típicamente en entornos de desarrollo.</description>
    </item>
    
    <item>
      <title>Objetivos y funcionalidades principales</title>
      <link>https://www.selenium.dev/documentation/es/grid/purposes_and_main_functionalities/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/grid/purposes_and_main_functionalities/</guid>
      <description> Punto de entrada centralizado para todos los tests Gestión y control de los nodos / entornos donde se ejecutan los navegadores Escalado Ejecución de los tests en paralelo Testing cruzado entre diferentes sistemas operativos Balanceo de carga  </description>
    </item>
    
    <item>
      <title>Selenium 1 (Selenium RC)</title>
      <link>https://www.selenium.dev/documentation/es/legacy_docs/selenium_rc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/legacy_docs/selenium_rc/</guid>
      <description>Introducción Selenium RC fue el principal proyecto de Selenium durante mucho tiempo, antes de que la union de WebDriver/Selenium resultaran en Selenium 2, una herramienta más poderosa. Vale la pena resaltar que Selenium 1 ya no es soportado.
Como funciona Selenium RC Primero, describiremos cómo funcionan los componentes de Selenium RC y el papel que desempeña cada uno en la ejecución tus scripts de prueba.
Componentes de RC Los componentes de Selenium RC son:</description>
    </item>
    
    <item>
      <title>Shared capabilities</title>
      <link>https://www.selenium.dev/documentation/es/driver_idiosyncrasies/shared_capabilities/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/driver_idiosyncrasies/shared_capabilities/</guid>
      <description>Con el fin de crear una nueva sesión del WebDriver de Selenium, la parte local debe proveer las capacidades(capabilities) básicas a la parte remota. La parte remota usa el mismo conjunto de capacidades para crear una sesión y describir las funcionalidades de la sesión actual.
El WebDriver proporciona unas capacidades que cada parte remota debe apoyar en su implementación. Las siguientes capacidades son las que el WebDriver soporta:
browserName: Esta capacidad es usada para fijar el browserName(nombre del navegador) para una sesión dada.</description>
    </item>
    
    <item>
      <title>WebDriver remoto - servidor</title>
      <link>https://www.selenium.dev/documentation/es/remote_webdriver/remote_webdriver_server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/remote_webdriver/remote_webdriver_server/</guid>
      <description>El servidor siempre se ejecutará en la máquina con el navegador que deseas probar. El servidor se puede usar desde la línea de comandos o mediante configuración de código.
Iniciar el servidor desde la línea de comando Una vez que hayas descargado selenium-server-standalone-{VERSION}.jar, colócalo en la computadora con el navegador que deseas probar. Entonces, desde el directorio con el jar, ejecuta lo siguiente:
java -jar selenium-server-standalone-{VERSION}.jar Consideraciones para ejecutar el servidor Se espera que quien inicie la sesión termine cada sesión correctamente, llamando ya sea Selenium#stop() o WebDriver#quit.</description>
    </item>
    
    <item>
      <title>Capacidades específicas de los Drivers</title>
      <link>https://www.selenium.dev/documentation/es/driver_idiosyncrasies/driver_specific_capabilities/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/driver_idiosyncrasies/driver_specific_capabilities/</guid>
      <description>Firefox Define las capacidades usando FirefoxOptions FirefoxOptions es la nueva forma de definir capacidades para el navegador Firefox y debe de ser usado de manera general antes que DesriredCapabilities.
Java Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(&amp;#34;network.proxy.type&amp;#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.</description>
    </item>
    
    <item>
      <title>Componentes de un Grid</title>
      <link>https://www.selenium.dev/documentation/es/grid/components_of_a_grid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/grid/components_of_a_grid/</guid>
      <description>Hub  Ejerce como mediador y administrador Acepta peticiones para ejecutar los tests Recoge instrucciones de los clientes y las ejecuta de forma remota en los nodos Gestiona los hilos  El Hub es un punto central donde se envian todos tus tests. Cada Selenium Grid consiste en exactamente un hub. El hub necesita ser accesible desde la perspectiva de los clientes (ej. Servidor de la CI, maquina del desarrollador) El hub se conectará a uno o mas nodos a los que los tests serán delegados.</description>
    </item>
    
    <item>
      <title>Convenciones tipográficas</title>
      <link>https://www.selenium.dev/documentation/es/front_matter/typographical_conventions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/front_matter/typographical_conventions/</guid>
      <description>Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!
 Capitalisation of titles One should avoid title capitalisation, such as A Very Fine Heading, and instead go for A very fine heading. Gratutious capitalisation, or title case, often show a misunderstanding of – or a disregard for – orthographic conventions. We prefer what is known as sentence case, with a single initial capital to start headers.</description>
    </item>
    
    <item>
      <title>Descarga de archivos</title>
      <link>https://www.selenium.dev/documentation/es/worst_practices/file_downloads/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/worst_practices/file_downloads/</guid>
      <description>Mientras que es posible empezar una descarga haciendo clic en el enlace, con el navegador que este siendo controlado por Selenium, el API no expone el progreso de la descarga, haciéndolo poco ideal para probar la descarga de archivos. Esto es debido a que descargar archivos no es considerado un aspecto importante de la emulación de las interacciones de los usuarios con las plataformas web. En lugar de ello, se recomienda encontrar el enlace con Selenium (y cualquier Cookie requerida) y pasarselo a una librería que permita hacer peticiones HTTP como libcurl.</description>
    </item>
    
    <item>
      <title>Instalando los binarios de WebDriver</title>
      <link>https://www.selenium.dev/documentation/es/selenium_installation/installing_webdriver_binaries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/selenium_installation/installing_webdriver_binaries/</guid>
      <description>Para ejecutar tu proyecto y controlar el navegador, debes tener instalados los binarios de WebDriver específicos para el navegador.
Descarga el binario de WebDriver soportado por tu navegador y colócalo en el PATH del sistema.</description>
    </item>
    
    <item>
      <title>Lenguage de dominio específico</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/domain_specific_language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/domain_specific_language/</guid>
      <description>Un lenguaje de dominio específico (DSL) es un sistema que proporciona al usuario un medio expresivo para resolver un problema. Permite a un usuario interactuar con el sistema en sus términos, no solo en jerga del programador.
A tus usuarios, en general, no les importa cómo se ve su sitio. Ellos no se preocupan por la decoración, animaciones o gráficos. Ellos desean utilizar tu sistema para impulsar a sus nuevos empleados a través del proceso con mínima dificultad; quieren reservar un viaje a Alaska; quieren configurar y comprar unicornios con descuento.</description>
    </item>
    
    <item>
      <title>Migrando de RC a WebDriver</title>
      <link>https://www.selenium.dev/documentation/es/legacy_docs/migrating_from_rc_to_webdriver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/legacy_docs/migrating_from_rc_to_webdriver/</guid>
      <description>Cómo migrar a Selenium WebDriver Una pregunta común al adoptar Selenium 2 es qué seria lo correcto al agregar nuevas pruebas a un conjunto existente de pruebas?. Los usuarios que son nuevos al framework pueden comenzar utilizando las nuevas API de WebDriver para escribir sus pruebas. ¿Pero qué pasa con los usuarios que ya tienen suites de pruebas existentes? Esta guía es diseñada para demostrar cómo migrar tus pruebas existentes a las nuevas APIs, permitiendo que todas las pruebas nuevas se escriban usando las nuevas características ofrecidas por WebDriver.</description>
    </item>
    
    <item>
      <title>Navegadores de terceros y plugins</title>
      <link>https://www.selenium.dev/documentation/es/getting_started_with_webdriver/third_party_drivers_and_plugins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/getting_started_with_webdriver/third_party_drivers_and_plugins/</guid>
      <description>Selenium se puede extender mediante el uso de plugins. Aquí hay una serie de plugins creados y mantenidos por terceros. Para más información sobre cómo crear tu propio plugin o tenerlo en la lista, consulta la documentación.
Ten en cuenta que estos plugins no son compatibles, mantenidos, alojados o avalados por el proyecto Selenium. Además, ten en cuenta que los plugins enumerados a continuación no necesariamente están licenciados bajo la licencia de Apache v.</description>
    </item>
    
    <item>
      <title>Requerimientos de los controladores</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/driver_requirements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/driver_requirements/</guid>
      <description>A través del WebDriver, Selenium es capaz de soportar los navegadores mas usados en el mercado como Chrom(ium), Firefox, Internet Explorer, Opera y Safari. WebDriver maneja los navegadores, cuando es posible, apoyándose en las propias funciones que el navegador incorpora para la automatización.
La finalidad del WebDriver es emular las interacciones de los usuarios reales. Esto es posible en diversos niveles en diferentes navegadores. Para mas detalles sobre las diferentes comportamientos de los controladores, ver Comportamientos del controlador.</description>
    </item>
    
    <item>
      <title>Sobre automatización de pruebas</title>
      <link>https://www.selenium.dev/documentation/es/introduction/on_test_automation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/introduction/on_test_automation/</guid>
      <description>Primero, pregúntate si realmente necesitas o no usar un navegador. Lo más probable es que, en algún momento, si estás trabajando en una aplicación web compleja, necesitarás abrir un navegador y realmente probarlo.
Sin embargo, las pruebas funcionales de usuario final, como las pruebas de Selenium son caras de ejecutar. Además, normalmente requieren que una infraestructura considerable este disponible para estas ejecutarse de manera efectiva. Es una buena regla preguntarse siempre si lo que se quiere probar se puede hacer usando enfoques de prueba más livianos como las pruebas unitarias o con un enfoque de bajo nivel.</description>
    </item>
    
    <item>
      <title>Trabajando con colores</title>
      <link>https://www.selenium.dev/documentation/es/support_packages/working_with_colours/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/support_packages/working_with_colours/</guid>
      <description>En algunas ocasiones es posible que sea necesario querer validar el color de algo como parte de tus tests; el problema es que las definiciones de color en la web no son constantes. ¿No estaría bien que existiese una forma sencilla de comparar una representación de color HEX con una representación de color RGB, o una representación de color RGBA con una representación de color HSLA?
No te preocupes. Hay una solución para esto, la clase Color</description>
    </item>
    
    <item>
      <title>WebDriver remoto - cliente</title>
      <link>https://www.selenium.dev/documentation/es/remote_webdriver/remote_webdriver_client/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/remote_webdriver/remote_webdriver_client/</guid>
      <description>Para ejecutar un cliente de WebDriver remoto, primero debemos conectarnos a RemoteWebDriver. Hacemos esto apuntando la URL a la dirección del servidor que ejecuta nuestras pruebas. Para personalizar nuestra configuración, establecemos las capabilities deseadas. A continuación se muestra un ejemplo de la, instanciación de un objeto WebDriver remoto apuntando a nuestro servidor web remoto, www.example.com, ejecutando nuestras pruebas en Firefox.
Java Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(&amp;#34;http://www.</description>
    </item>
    
    <item>
      <title>Configurando tu propio Grid</title>
      <link>https://www.selenium.dev/documentation/es/grid/setting_up_your_own_grid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/grid/setting_up_your_own_grid/</guid>
      <description>Para usar Selenium Grid, necesitas mantener tu propia infraestructura para los nodos. Como esto puede suponer un engorro y suponer un gran esfuerzo de tiempo, muchas organizaciones usan proveedores de IaaS (Infraestructura como servicio) como Amazon EC2 y Google Compute para proveer esta infraestructura.
Otras opciones incluyen usar proveedores como Sauce Labs or Testing Bot los cuales proveen Selenium Grid como servicio en la nueve. Ciertamente, también es posible ejecutar los nodos en tu propio hardware.</description>
    </item>
    
    <item>
      <title>Códigos de respuesta HTTP</title>
      <link>https://www.selenium.dev/documentation/es/worst_practices/http_response_codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/worst_practices/http_response_codes/</guid>
      <description>Para algunas configuraciones de navegadores en Selenium RC, Selenium actuaba como proxy entre el navegador y el sitio web que iba a ser automatizado. Esto significaba que todo el trafico que pasaba a través de Selenium podía ser capturado o manipulado. El método captureNetworkTraffic() pretendía capturar todo el trafico de red entre el navegador y el sitio que estaba siendo automatizado, incluyendo los códigos de respuestas HTTP.
El WebDriver de Selenium parte de una aproximación completamente diferente respecto a la automatización de los navegadores, prefiriendo así actuar mas como un usuario y esto se representa en la forma en la que escribes los tests con el WebDriver.</description>
    </item>
    
    <item>
      <title>Generar el estado de la aplicación</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/generating_application_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/generating_application_state/</guid>
      <description>Selenium no debe usarse para preparar un caso de prueba. Todas las acciones repetitivas y los preparativos para un caso de prueba deben realizarse a través de otros métodos. Por ejemplo, la mayoría de las IU web tienen autenticación (por ejemplo, un formulario de inicio de sesión). Eliminar el inicio de sesión a través del navegador web antes de cada prueba mejora tanto la velocidad como la estabilidad de la prueba.</description>
    </item>
    
    <item>
      <title>HTML runner</title>
      <link>https://www.selenium.dev/documentation/es/legacy_docs/html-runner/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/legacy_docs/html-runner/</guid>
      <description>Selenium HTML-runner te permite ejecutar Test Suites desde una línea de comando. Las suites de prueba son exportaciones HTML de Selenium IDE o herramientas de compatibles.
Información común  Combinaciónes de versiones de geckodriver / firefox / selenium-html-runner importan. Puede haber una matriz de compatibilidad de software en alguna parte. selenium-html-runner solo ejecuta Test Suites (no Test Cases - por ejemplo, una exportación desde Monitis Transaction Monitor). Asegurate que cumples con esto.</description>
    </item>
    
    <item>
      <title>Instalación del servidor Standalone</title>
      <link>https://www.selenium.dev/documentation/es/selenium_installation/installing_standalone_server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/selenium_installation/installing_standalone_server/</guid>
      <description>Si planeas usar Grid debes descargar el fichero selenium-server-standalone JAR. Todos los componentes están disponibles a través de selenium-server. El standalone JAR contiene todo, incluso el servidor remoto de Selenium y los enlaces del lado del cliente. Ésto quiere decir que si usas el selenium-server-standalone jar en tu proyecto, no tienes que añadir selenium-java o un jar de navegador específico.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.seleniumhq.selenium&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;selenium-server&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.X&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; </description>
    </item>
    
    <item>
      <title>Localizando elementos</title>
      <link>https://www.selenium.dev/documentation/es/getting_started_with_webdriver/locating_elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/getting_started_with_webdriver/locating_elements/</guid>
      <description>Localizando un elemento Una de las técnicas más fundamentales para aprender al usar WebDriver es cómo encontrar elementos en la página. WebDriver ofrece varios tipos de selectores integrados, entre ellos encontrar un elemento por su atributo ID:
Java Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(&amp;#34;cheese&amp;#34;));   driver.find_element(By.ID, &amp;#34;cheese&amp;#34;)   IWebElement element = driver.FindElement(By.Id(&amp;#34;cheese&amp;#34;));   cheese = driver.find_element(id: &amp;#39;cheese&amp;#39;)   const cheese = driver.findElement(By.id(&amp;#39;cheese&amp;#39;));   val cheese: WebElement = driver.</description>
    </item>
    
    <item>
      <title>Manipulación de Navegadores</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/browser_manipulation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/browser_manipulation/</guid>
      <description>Ruby Ruby no esta instalado por defecto en Windows. Puedes descargar la ultima versión y ejecutar el instalador. Puedes dejar todos los parámetros de configuración con los valores por defecto excepto el parámetro Add Ruby executables to your PATH de la pantalla de Installation Destination and Optional Tasks. Para manejar cualquier navegador tienes que instalar la gema de Ruby selenium-webdriver. Para instalarla abre una consola de comando y ejecuta el siguiente comando.</description>
    </item>
    
    <item>
      <title>Tipos de pruebas</title>
      <link>https://www.selenium.dev/documentation/es/introduction/types_of_testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/introduction/types_of_testing/</guid>
      <description>Pruebas de aceptación Este tipo de prueba se realiza para determinar si una funcionalidad o un sistema cumple con las expectativas y requerimientos del cliente. Este tipo de pruebas generalmente implican la cooperación o retroalimentación del cliente, siendo una actividad de validación que responde la pregunta:
 ¿Estamos construyendo el producto correcto?.
 Para aplicaciones web, la automatización de esta prueba se puede hacer directamente con Selenium simulando el comportamiento esperado del usuario.</description>
    </item>
    
    <item>
      <title>Trabajando con elementos select</title>
      <link>https://www.selenium.dev/documentation/es/support_packages/working_with_select_elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/support_packages/working_with_select_elements/</guid>
      <description>A la hora de seleccionar elementos puede ser necesario código repetitivo para poder ser automatizado. Para reducir esto y hacer tus test mas limpios, existe un clase Select en los paquetes de soporte de Selenium. Para usarla, necesitarás importarla de la siguiente forma:
Java Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    import org.</description>
    </item>
    
    <item>
      <title>Acciones del ratón en detalle</title>
      <link>https://www.selenium.dev/documentation/es/support_packages/mouse_and_keyboard_actions_in_detail/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/support_packages/mouse_and_keyboard_actions_in_detail/</guid>
      <description>El ratón representa eventos del ratón. Las acciones del ratón son realizadas a través de una interfaz de bajo nivel la cual nos permite introducir acciones de dispositivos virtualizados al navegador web.
clickAndHold Moverá el ratón al elemento y hará clic (sin soltar) en medio del elemento dado.
Java Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.</description>
    </item>
    
    <item>
      <title>Acerca de esta documentación</title>
      <link>https://www.selenium.dev/documentation/es/introduction/about_this_documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/introduction/about_this_documentation/</guid>
      <description>Estos documentos, como el código en sí, son mantenidos al 100% por voluntarios dentro de la comunidad de Selenium. Muchos lo han estado usando desde su inicio, pero muchos más lo han estado usando desde hace poco y han dado su tiempo para ayudar a mejorar la experiencia de iniciación para los nuevos usuarios.
Si hay un problema con la documentación, ¡queremos saberlo! La mejor manera de comunicar un problema es visitar https://github.</description>
    </item>
    
    <item>
      <title>Autenticarse con Gmail, email y Facebook</title>
      <link>https://www.selenium.dev/documentation/es/worst_practices/gmail_email_and_facebook_logins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/worst_practices/gmail_email_and_facebook_logins/</guid>
      <description>Por múltiples razones, autenticarse en sitios como Gmail y Facebook usando el WebDriver no esta recomendado. Aparte de estar en contra de los términos y condiciones de estos sitios (te expones a que te cierren la cuenta), es un proceso lento y poco fiable.
La practica ideal respecto a estos los sitios de emails es usar las APIs que ofrecen, en el caso de Facebook usar las herramientas para desarrolladores las cuales exponen un API para crear cuentas de prueba, amigos, etc.</description>
    </item>
    
    <item>
      <title>Cuando usar el Grid</title>
      <link>https://www.selenium.dev/documentation/es/grid/when_to_use_grid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/grid/when_to_use_grid/</guid>
      <description>Generalmente hablando, hay dos razones por las cuales podrías querer usar el Grid.
 Para ejecutar tus tests contra múltiples navegadores, múltiples versiones de navegadores y múltiples navegadores bajo diferentes sistemas operativos. Para reducir el tiempo que tarda en completarse la ejecución de tu suite de test.  El Grid se usa para acelerar la ejecución de los test usando múltiples maquinas para ejecutarlos en paralelo. Por ejemplo, si tienes una suite con 100 tests, pero configuras el Grid para soportar cuatro maquinas diferentes (ya sean maquinas virtuales o maquinas separadas físicamente) para ejecutar los tests, tu suite completará la ejecución en aproximadamente una cuarta parte del tiempo que habría tardado si se hubiesen ejecutado de manera secuencial en una sola maquina.</description>
    </item>
    
    <item>
      <title>Ejecutando acciones en el AUT*</title>
      <link>https://www.selenium.dev/documentation/es/getting_started_with_webdriver/performing_actions_on_the_aut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/getting_started_with_webdriver/performing_actions_on_the_aut/</guid>
      <description>Puede especificar el texto de un elemento utilizando el método sendKeys de la siguiente manera:
Java Python C# Ruby JavaScript Kotlin String name = &amp;#34;Charles&amp;#34;; driver.findElement(By.name(&amp;#34;name&amp;#34;)).sendKeys(name);   name = &amp;#34;Charles&amp;#34; driver.find_element(By.NAME, &amp;#34;name&amp;#34;).send_keys(name)   string name = &amp;#34;Charles&amp;#34;; driver.FindElement(By.Name(&amp;#34;name&amp;#34;)).SendKeys(name);   name = &amp;#34;Charles&amp;#34; driver.find_element(name: &amp;#34;name&amp;#34;).send_keys(name)   const name = &amp;#34;Charles&amp;#34;; await driver.findElement(By.name(&amp;#39;name&amp;#39;)).sendKeys(name);   val name = &amp;#34;Charles&amp;#34; driver.findElement(By.name(&amp;#34;name&amp;#34;)).sendKeys(name)     Algunas aplicaciones web utilizan librerías de JavaScript para agregar la funcionalidad de arrastrar y soltar.</description>
    </item>
    
    <item>
      <title>Esperas</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/waits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/waits/</guid>
      <description>Generalmente se puede decir que WebDriver posee una API de bloqueo. Porque es una biblioteca fuera-de-proceso que instruye al navegador qué hacer, y debido a que la plataforma web tiene una naturaleza intrínsecamente asíncrona, WebDriver no rastrea el estado activo y en tiempo real del DOM. Esto viene con algunos desafíos que discutiremos aquí.
Por experiencia la mayoría de las intermitencias que surgen del uso de Selenium y WebDriver están conectadas a condiciones de carrera que ocurren entre el navegador y las instrucciones del usuario.</description>
    </item>
    
    <item>
      <title>Legacy Selenium IDE</title>
      <link>https://www.selenium.dev/documentation/es/legacy_docs/selenium_ide/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/legacy_docs/selenium_ide/</guid>
      <description>Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!
 Introduction The Selenium-IDE (Integrated Development Environment) is the tool you use to develop your Selenium test cases. It’s an easy-to-use Firefox plug-in and is generally the most efficient way to develop test cases. It also contains a context menu that allows you to first select a UI element from the browser’s currently displayed page and then select from a list of Selenium commands with parameters pre-defined according to the context of the selected UI element.</description>
    </item>
    
    <item>
      <title>Mock de servicios externos</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/mock_external_services/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/mock_external_services/</guid>
      <description>Eliminar las dependencias de servicios externos mejorará en gran medida la velocidad y la estabilidad de tus pruebas.</description>
    </item>
    
    <item>
      <title>Clases de apoyo</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/support_classes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/support_classes/</guid>
      <description>Las clases de soporte de WebDriver son proporcionadas para simplificar el mantenimiento de tu código. Proporcionan una buena abstracción para modelar mas fácilmente elementos HTML como objetos de dominio, también proporcionando métodos de ayuda para hacer que el uso de tales objetos sea fácil de razonar. Aprenderemos acerca de:
 Estrategias de localizacion Eventos LoadableComponent ThreadGuard etc.  Iniciemos:
ThreadGuard  Esta clase solo esta disponible en la librería de enlace de Java</description>
    </item>
    
    <item>
      <title>Dependencia entre pruebas</title>
      <link>https://www.selenium.dev/documentation/es/worst_practices/test_dependency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/worst_practices/test_dependency/</guid>
      <description>Una idea muy común y equivocada sobre la automatización de pruebas es en lo que respecta al orden de los tests. Tus tests deberían ser capaces de ejecutarse sin tener en cuenta el orden y no depender los unos de los otros para poder finalizarse satisfactoriamente.</description>
    </item>
    
    <item>
      <title>Mejores reportes</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/improved_reporting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/improved_reporting/</guid>
      <description>Selenium no está diseñado para informar sobre el estado de los casos de prueba ejecutados. Aprovechando las capacidades de reporte incorporadas en la mayoría de los frameworks de pruebas unitarias es un buen comienzo. La mayoría de los frameworks de pruebas unitarias tienen utilidades que pueden generar reportes con formato xUnit o HTML. Los reportes xUnit son populares para importar resultados a una integración continua (CI) como Jenkins, Travis, Bamboo, etc.</description>
    </item>
    
    <item>
      <title>Alertas, avisos y confirmaciones de JavaScript</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/js_alerts_prompts_and_confirmations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/js_alerts_prompts_and_confirmations/</guid>
      <description>WebDriver proporciona una API para trabajar con los tres tipos nativos de mensajes emergentes ofrecidos por JavaScript. Estas ventanas emergentes están diseñadas por el navegador y ofrecen personalización limitada.
Alertas El más simple de estos se conoce como alerta, que muestra unmensaje personalizado y un solo botón que descarta la alerta, etiquetado en la mayoría de los navegadores como OK. También se puede descartar en la mayoría de los navegadores presionando el botón de cerrar, pero esto siempre hará lo mismo que el presionar botón OK.</description>
    </item>
    
    <item>
      <title>Evitar compartir estados</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/avoid_sharing_state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/avoid_sharing_state/</guid>
      <description>Aunque se menciona en varios lugares, vale la pena mencionarlo nuevamente. Asegurate de que las pruebas estén aisladas unas de otras.
  No compartas datos de prueba. Imagina varias pruebas en la que cada una consulta a la base de datos para pedidos válidos antes de elegir uno para realizar una acción. Si dos pruebas eligen el mismo pedido es probable que obtengas un comportamiento inesperado.
  Limpia los datos obsoletos en la aplicación que podrían ser recogidos por otra prueba p.</description>
    </item>
    
    <item>
      <title>Pruebas de rendimiento</title>
      <link>https://www.selenium.dev/documentation/es/worst_practices/performance_testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/worst_practices/performance_testing/</guid>
      <description>Las pruebas de rendimiento usando Selenium y el WebDriver generalmente no son aconsejables. No porque Selenium sea incapaz de ello si no porque no esta optimizado para ello y es poco probable que se obtengan buenos resultados.
Puede parecer ideal realizar pruebas de rendimiento desde el contexto de un usuario pero una suite de tests del WebDriver esta sujeta a demasiados puntos fragiles tanto internamente como externamente los cuales están fuera de nuestro control.</description>
    </item>
    
    <item>
      <title>Trabajando con las cookies</title>
      <link>https://www.selenium.dev/documentation/es/support_packages/working_with_cookies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/support_packages/working_with_cookies/</guid>
      <description>Una cookie es una pequeña pieza de datos que es enviada desde el sitio web y es almacenada en el ordenador. Las cookies son usadas principalmente para reconocer al usuario y cargar la información almacenada.
El API de WebDriver proporciona una forma de interactuar con las cookies a través de métodos incorporados como:
Añadir una Cookie Este método es usado para añadir una cookie al contexto actual del navegador. Este método solo acepta un conjunto de objetos JSON serializables definidos.</description>
    </item>
    
    <item>
      <title>Independencia en las pruebas</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/test_independency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/test_independency/</guid>
      <description>Escribe cada prueba como su propia unidad. Escribe las pruebas de una manera que no dependan de otras pruebas para completarse:
Digamos que hay un sistema de gestión de contenido con el que puedes crear algún contenido personalizado que luego después publicar aparece en tu sitio web como un módulo, y puede llevar algún tiempo sincronizar entre el CMS y y la aplicación.
Una forma incorrecta de probar tu módulo es que el contenido está creado y publicado en una prueba y luego verificando el módulo en otra prueba.</description>
    </item>
    
    <item>
      <title>Proxies Http</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/http_proxies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/http_proxies/</guid>
      <description>Un servidor proxy actúa como intermediario para solicitudes entre un cliente y un servidor. En forma simple, el tráfico fluye a través del servidor proxy en camino a la dirección solicitada y de regreso.
Un servidor proxy para scripts de automatización con Selenium podría ser útil para:
 Captura el tráfico de la red Simular llamadas de backend realizadas por el sitio web Accede al sitio web requerido bajo topologías de red complejas o restricciones/políticas corporativas estrictas.</description>
    </item>
    
    <item>
      <title>Rastreo de enlaces</title>
      <link>https://www.selenium.dev/documentation/es/worst_practices/link_spidering/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/worst_practices/link_spidering/</guid>
      <description>Usando WebDriver para arañar una web a través de enlaces no es una práctica recomendada, no porque no se pueda hacer, pero porque definitivamente no es la herramienta más ideal. WebDriver necesita tiempo para iniciarse, y puede tomar varios de segundos hasta un minuto dependiendo de cómo se escriba tu prueba, solo para llegar a la página y atravesar el DOM.
En lugar de usar WebDriver para esto, podrías ahorrar un montón de tiempo ejecutando un comando curl, o usando una librería como BeautifulSoup ya que estos métodos no se basan en crear un navegador y navegar a una página.</description>
    </item>
    
    <item>
      <title>Considerar el uso de un API fluída</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/consider_using_a_fluent_api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/consider_using_a_fluent_api/</guid>
      <description>Martin Fowler acuñó el término &amp;ldquo;API fluido&amp;rdquo;. Selenium ya implementa algo como esto en su clase FluentWait, que se entiende como una alternativa a la clase estándar Wait. Puedes habilitar el patrón de diseño Fluent API en tu objeto de página y luego consulta la página de búsqueda de Google con un fragmento de código como este:
driver.get( &amp;#34;http://www.google.com/webhp?hl=en&amp;amp;amp;tab=ww&amp;#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); La clase de objeto de página de Google con este comportamiento fluido podría verse así:</description>
    </item>
    
    <item>
      <title>Estrategia de carga de página</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/page_loading_strategy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/page_loading_strategy/</guid>
      <description>Define la estrategia de carga de la página en la sesión actual. Por defecto, cuando Selenium WebDriver carga una página, sigue la pageLoadStrategy normal. Siempre se recomienda detener la descarga de más recursos adicionales (como imágenes, css, js) cuando la carga de la página lleva mucho tiempo.
La propiedad document.readyState de un documento describe el estado de carga del documento actual. Por defecto, WebDriver esperará responder a una llamada driver.get() (o) driver.</description>
    </item>
    
    <item>
      <title>Elemento web</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/web_element/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/web_element/</guid>
      <description>WebElement representa un elemento del DOM. Los WebElements se pueden encontrar buscando desde la raíz del documento utilizando una instancia de WebDriver o buscando en otra WebElement.
El API WebDriver proporciona métodos integrados para encontrar los elementos web que son basados en diferentes propiedades como ID, Nombre, Clase, XPath, Selectores CSS, Texto de enlace, etc.
Find Element Se utiliza para encontrar un elemento y devuelve la primera referencia única de WebElement que coincide, que puede usarse para acciones futuras con el elemento</description>
    </item>
    
    <item>
      <title>Nueva instancia del navegador por prueba</title>
      <link>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/fresh_browser_per_test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/guidelines_and_recommendations/fresh_browser_per_test/</guid>
      <description>Comienza cada prueba desde un estado limpio conocido. Idealmente, ejecuta una nueva máquina virtual para cada prueba. Si ejecutar una nueva máquina virtual no es práctico, al menos inicia un nuevo WebDriver para cada prueba. Para Firefox, inicia un WebDriver con su perfil conocido.
FirefoxProfile profile = new FirefoxProfile(new File(&amp;#34;pathToFirefoxProfile&amp;#34;)); WebDriver driver = new FirefoxDriver(profile); </description>
    </item>
    
    <item>
      <title>Chrome Devtools</title>
      <link>https://www.selenium.dev/documentation/es/support_packages/chrome_devtools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/support_packages/chrome_devtools/</guid>
      <description>Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!
 Selenium 4 alpha versions have much awaited native support for Chrome Dev Protocol through &amp;ldquo;DevTools&amp;rdquo; interface. This helps us getting Chrome Development properties such as Application Cache, Fetch, Network, Performance, Profiler, Resource Timing, Security and Target CDP domains etc.
Chrome DevTools is a set of web developer tools built directly into the Google Chrome browser.</description>
    </item>
    
    <item>
      <title>Teclado</title>
      <link>https://www.selenium.dev/documentation/es/webdriver/keyboard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/webdriver/keyboard/</guid>
      <description>Keyboard representa un evento del teclado. Las acciones del teclado se realizan mediante el uso de una interfaz de bajo nivel que nos permite proporcionar entradas de un dispositivo virtualizado al navegador web.
sendKeys El sendKeys escribe una secuencia de teclas en el elemento del DOM incluso si se encuentra una secuencia de teclas modificadoras. Here are the list of possible keystrokes that WebDriver Supports.
Java Python C# Ruby JavaScript Kotlin import org.</description>
    </item>
    
    <item>
      <title>Contributing to the Selenium Site &amp; Documentation</title>
      <link>https://www.selenium.dev/documentation/es/contributing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/es/contributing/</guid>
      <description>Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!
 Selenium is a big software project, its site and documentation are key to understanding how things work and learning effective ways to exploit its potential.
This project contains both Selenium&amp;rsquo;s site and documentation. This is an ongoing effort (not targeted at any specific release) to provide updated information on how to use Selenium effectively, how to get involved and how to contribute to Selenium.</description>
    </item>
    
  </channel>
</rss>