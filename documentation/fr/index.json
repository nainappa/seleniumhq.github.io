[
{
	"uri": "https://www.selenium.dev/documentation/fr/driver_idiosyncrasies/shared_capabilities/",
	"title": "Capabilities partagées",
	"tags": [],
	"description": "",
	"content": "Afin de créer une nouvelle session par Selenium WebDriver, l\u0026rsquo;extrémité locale doit fournir les capacités de base à l\u0026rsquo;extrémité distante. L\u0026rsquo;extrémité distante utilise le même ensemble de capacités pour créer une session et décrit les fonctionnalités de la session actuelle.\nWebDriver offre des capacités que chaque télécommande fin soutiendra/devrait soutenir la mise en œuvre. Voici les fonctionnalités prises en charge par WebDriver:\nbrowserName: Cette capacité est utilisée pour définir le browserName pour une session donnée. Si le navigateur spécifié n\u0026rsquo;est pas installé sur le extrémité distante, la création de la session échouera\nbrowserVersion: Cette capacité est facultative, elle est utilisée pour définissez la version de navigateur disponible à l\u0026rsquo;extrémité distante. Par exemple, si vous demandez Chrome version 75 sur un système qui n\u0026rsquo;a que 80 installés, la création de session échouera.\npageLoadStrategy: Lors de la navigation vers une nouvelle page via URL, par défaut, Selenium attendra jusqu'à ce que la page soit entièrement chargée avant de répondre. Cela fonctionne bien pour débutants, mais peut entraîner de longs temps d\u0026rsquo;attente sur les pages qui chargent une grande nombre de ressources tierces. L’utilisation d’une stratégie autre que celle par défaut peut tester l\u0026rsquo;exécution plus rapidement dans des cas comme celui-ci, mais peut également introduire une fragilité où les éléments de la page changent de position lorsque les éléments se chargent et changent Taille.\nLa stratégie de chargement de page interroge le document.readyState comme décrit dans le tableau ci-dessous:\n   Strategy Ready State Notes     normal complete Utilisé par défaut, attend le téléchargement de toutes les ressources   eager interactive L\u0026rsquo;accès au DOM est prêt, mais d\u0026rsquo;autres ressources comme les images peuvent encore se charger   none Any Ne bloque pas du tout WebDriver    platformName Cela identifie le système d\u0026rsquo;exploitation à l\u0026rsquo;extrémité distante, la récupération de platformName renvoie le nom du système d\u0026rsquo;exploitation.\nDans les fournisseurs basés sur le cloud, la définition de platformName définit le système d\u0026rsquo;exploitation à l\u0026rsquo;extrémité distante.\nacceptInsecureCerts Cette capacité vérifie si un (ou) expiré un certificat TLS non valide est utilisé lors de la navigation pendant une session.\nSi la capacité est définie sur \u0026ldquo;false\u0026rdquo;, un erreur de certificat non sécurisé sera retourné car la navigation rencontre n\u0026rsquo;importe quel domaine problèmes de certificat. S\u0026rsquo;il est défini sur true, un certificat non valide sera approuvé par le navigateur.\nTous les certificats auto-signés seront approuvés par cette fonctionnalité par défaut. Une fois définie, la capacité acceptInsecureCerts aura un effet pour toute la session.\nSession timeouts Une session WebDriver est imposée avec un certain délai d'expiration de session intervalle, pendant lequel l\u0026rsquo;utilisateur peut contrôler le comportement d\u0026rsquo;exécuter des scripts ou de récupérer des informations à partir du navigateur.\nChaque délai d\u0026rsquo;expiration de session est configuré avec combinaison de différents timeouts comme décrit ci-dessous:\nScript Timeout: Spécifie quand interrompre un script en cours d\u0026rsquo;exécution dans un contexte de navigation actuel. Délai d\u0026rsquo;expiration par défaut 30,000 est imposé lorsqu\u0026rsquo;une nouvelle session est créée par WebDriver.\nPage Load Timeout: Spécifie l\u0026rsquo;intervalle de temps dans lequel la page Web doit être chargé dans un contexte de navigation actuel. Le délai d\u0026rsquo;attente par défaut 300,000 est imposé lorsqu\u0026rsquo;un une nouvelle session est créée par WebDriver. Si les limites de chargement de page un laps de temps donné / par défaut, le script sera arrêté par TimeoutException.\nImplicit Wait Timeout: Cela spécifie le temps d\u0026rsquo;attente stratégie de localisation implicite des éléments lorsque éléments de localisation. Le délai d\u0026rsquo;expiration par défaut 0 est imposé lorsqu\u0026rsquo;une nouvelle session est créée par WebDriver.\nunhandledPromptBehavior Spécifie l'état du gestionnaire d'invite utilisateur de la session en cours. Par défaut, ignorer et notifier l'état.\nUser Prompt Handler: Cela définit les mesures à prendre lorsqu\u0026rsquo;un rencontres d\u0026rsquo;invite utilisateur à l\u0026rsquo;extrémité distante. Ceci est défini par unhandledPromptBehavior et a les états suivants:\n dismiss accept dismiss and notify accept and notify ignore  setWindowRect Cette commande modifie la taille et la position du courant fenêtre contextuelle de navigation. Cette commande agit en tant que setter à la commande getWindowRect qui accepte width, height, x, y comme arguments optional.\nLors de l\u0026rsquo;automatisation, le contexte de navigation actuel sera associé avec des états de fenêtre, qui décrivent la visibilité état de la fenêtre du navigateur. Les états des fenêtres sont\n maximized minimized normal fullscreen  La définition de Width ou Height ne garantit pas que le résultat la taille de la fenêtre correspondra exactement à celle recherchée. Ceci est dû au fait certains pilotes peuvent ne pas être en mesure de redimensionner par incréments d\u0026rsquo;un pixel. Pour cette raison, la récupération de l'état/des détails de la fenêtre par getWindowRect peut ne pas correspondre également aux valeurs définies pour le navigateur.\nstrictFileInteractability The new capabilitiy indicates if strict interactability checks should be applied to input type=file elements. As strict interactability checks are off by default, there is a change in behaviour when using Element Send Keys with hidden file upload controls.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/worst_practices/captchas/",
	"title": "Captchas",
	"tags": [],
	"description": "",
	"content": "CAPTCHA, abréviation de Completely Automated Public Turing test to tell Computers and Humans Apart, est explicitement conçu pour empêcher l\u0026rsquo;automatisation, alors n\u0026rsquo;essayez pas! Il existe deux stratégies principales pour contourner les chèques CAPTCHA:\n Désactivez CAPTCHA dans votre environnement de test Ajoutez un crochet pour permettre aux tests de contourner le CAPTCHA  "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/understanding_the_components/",
	"title": "Comprendre les composants",
	"tags": [],
	"description": "",
	"content": "Pour créer une suite de tests à l\u0026rsquo;aide de WebDriver, vous devrez comprendre et utiliser efficacement un certain nombre de composants différents. logiciel, différentes personnes utilisent des termes différents pour la même idée. une ventilation de la façon dont les termes sont utilisés dans cette description.\nTerminologie  API: Interface de programmation d\u0026rsquo;application. Il s\u0026rsquo;agit de l\u0026rsquo;ensemble des \u0026ldquo;commandes\u0026rdquo; vous utilisez pour manipuler WebDriver. Bibliothèque: Un module de code qui contient les API et le code nécessaires Les bibliothèques sont spécifiques à chaque liaison de langue, par exemple .jar fichiers pour Java, fichiers .dll pour .NET, etc. Pilote: Responsable du contrôle du navigateur actuel. sont créés par les fournisseurs de navigateurs eux-mêmes. modules exécutables qui s\u0026rsquo;exécutent sur le système avec le navigateur lui-même, pas sur le système exécutant la suite de tests (bien que ceux-ci puissent être même système.) NOTE: Certaines personnes se réfèrent aux pilotes en tant que proxies. Framework: Une bibliothèque supplémentaire utilisée comme support pour WebDriver Ces cadres peuvent être des cadres de test tels que JUnit ou NUnit. Il peut également s\u0026rsquo;agir de cadres prenant en charge les fonctionnalités du langage naturel telles que comme Cucumber ou Robotium.Frameworks peut également être écrit et utilisé pour des choses telles que la manipulation ou la configuration du système sous test, les données création, test d\u0026rsquo;oracles, etc.  Les pièces et pièces Au minimum, WebDriver communique avec un navigateur via un pilote. est à double sens: WebDriver passe des commandes au navigateur via le pilote, et reçoit des informations via le même itinéraire.\nLe pilote est spécifique au navigateur, tel que ChromeDriver pour Google Chrome / Chrome, GeckoDriver pour Firefox de Mozilla, etc. Le pilote fonctionne sur le même système que le navigateur. Il peut s\u0026rsquo;agir ou non du même système sur lequel les tests eux-mêmes sont en cours d\u0026rsquo;exécution.\nCet exemple simple ci-dessus est la communication directe. le navigateur peut également être une communication à distance via Selenium Server ou RemoteWebDriver. RemoteWebDriver fonctionne sur le même système que le pilote et le navigateur.\nLa communication à distance peut également avoir lieu à l\u0026rsquo;aide de Selenium Server ou Selenium Grille, qui à son tour parlent au conducteur sur le système hôte\nOù les cadres s\u0026rsquo;intègrent WebDriver a un seul travail et un seul travail: communiquez avec le navigateur via des méthodes ci-dessus.WebDriver ne sait rien du test: il ne sait pas savoir comparer les choses, affirmer réussir ou échouer, et il ne sait certainement pas une chose à propos de la grammaire Reporting ou Given / When / Then.\nC\u0026rsquo;est là que divers frameworks entrent en jeu. Au minimum, vous aurez besoin d\u0026rsquo;un cadre de test qui correspond aux liaisons de langage, par exemple NUnit pour .NET, JUnit pour Java, RSpec pour Ruby, etc.\nLe framework de test est responsable de l\u0026rsquo;exécution et de l\u0026rsquo;exécution de votre WebDriver et les étapes connexes dans vos tests. En tant que tel, vous pouvez penser qu\u0026rsquo;il ressemble à à l\u0026rsquo;image suivante.\nDes cadres / outils en langage naturel tels que le concombre peuvent exister dans le cadre de cette Test Framework cadre dans la figure ci-dessus, ou ils peuvent envelopper le Test Framework entièrement dans leur propre mise en œuvre.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/front_matter/copyright_and_attributions/",
	"title": "Copyright et attributions",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n The Documentation of Selenium Copyright \u0026copy; 2013-2020 , Software Freedom Conservancy.\nEvery effort has been made to make this documentation as complete and as accurate as possible, but no warranty or fitness is implied. The information provided is on an “as-is” basis. The authors and the publisher shall have neither liability nor responsibility to any person or entity with respect to any loss or damages arising from the information contained in this book. No patent liability is assumed with respect to the use of the information contained herein.\nAttributions Thanks to: Selenium Main Repository Selenium IDE Docker Selenium Selenium Website \u0026amp; Docs Previous Selenium Website Previous Documentation Rewrite Project Third-Party software used by Selenium documentation project:    Software Version License     Hugo v0.59.0 Apache 2.0   Hugo Learn Theme v2.4.0 MIT   Code Tabs Style \u0026mdash; MIT    License All code and documentation originating from the Selenium project is licensed under the Apache 2.0 license, with the Software Freedom Conservancy as the copyright holder.\nThe license is included here for convenience, but you can also find it on the Apache Foundation\u0026rsquo;s websites:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/selenium_installation/installing_selenium_libraries/",
	"title": "Installer les librairies Selenium",
	"tags": [],
	"description": "",
	"content": "Vous devez d\u0026rsquo;abord installer les fixations Selenium pour votre projet d\u0026rsquo;automatisation. Le processus d\u0026rsquo;installation des bibliothèques dépend de la langue que vous choisissez d\u0026rsquo;utiliser.\nJava L\u0026rsquo;installation des bibliothèques Selenium pour Java peut être effectuée à l\u0026rsquo;aide de Maven. Ajoutez la dépendance selenium-java dans votre projet pom.xml:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; La dépendance selenium-java prend en charge l\u0026rsquo;exécution de votre automatisation projet avec tous les navigateurs pris en charge par Selenium. Si vous souhaitez exécuter des tests uniquement dans un navigateur spécifique, vous pouvez ajouter la dépendance pour ce navigateur dans votre fichier pom.xml. Par exemple, vous devez ajouter la dépendance suivante dans votre pom.xml fichier pour exécuter vos tests uniquement dans Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; De la même manière, si vous souhaitez exécuter des tests uniquement dans Chrome, vous devez ajouter la dépendance suivante:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python L\u0026rsquo;installation des bibliothèques Selenium pour Python peut être effectuée à l\u0026rsquo;aide de pip:\npip install selenium Vous pouvez également télécharger l\u0026rsquo;archive source PyPI (selenium-x.x.x.tar.gz) et installez-le à l\u0026rsquo;aide de setup.py:\npython setup.py install C# L\u0026rsquo;installation des bibliothèques Selenium pour C # peut être effectuée à l\u0026rsquo;aide de NuGet:\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby L\u0026rsquo;installation des bibliothèques Selenium pour Ruby peut être effectuée à l\u0026rsquo;aide de gem:\ngem install selenium-webdriver JavaScript L\u0026rsquo;installation des bibliothèques Selenium pour JavaScript peut être effectuée à l\u0026rsquo;aide de npm:\nnpm install selenium-webdriver "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/introduction/the_selenium_project_and_tools/",
	"title": "Le projet Selenium et les outils",
	"tags": [],
	"description": "",
	"content": "Selenium contrôle les navigateurs Web Selenium est beaucoup de choses, mais à la base, c\u0026rsquo;est un ensemble d\u0026rsquo;outils pour l\u0026rsquo;automatisation du navigateur Web qui utilise les meilleures techniques disponibles pour contrôler à distance les instances du navigateur et émuler l\u0026rsquo;interaction d\u0026rsquo;un utilisateur avec le navigateur.\nIl permet aux utilisateurs de simuler les activités courantes effectuées par les utilisateurs finaux; saisir du texte dans les champs, sélectionner des valeurs déroulantes et cocher des cases, et cliquer sur les liens dans les documents. Il fournit également de nombreux autres contrôles tels que le mouvement de la souris, l\u0026rsquo;exécution arbitraire de JavaScript et bien plus encore.\nBien qu\u0026rsquo;utilisé principalement pour les tests frontaux des sites Web, Selenium est à la base une bibliothèque d\u0026rsquo;agent utilisateur de navigateur. Les interfaces sont omniprésentes à leur application, qui encourage la composition avec d\u0026rsquo;autres bibliothèques en fonction de votre objectif.\nUne interface pour les gouverner tous Un des principes directeurs du projet est de prendre en charge une interface commune pour toutes les (principales) technologies de navigateur. Les navigateurs Web sont des applications incroyablement complexes et hautement conçues, effectuer leurs opérations de manière complètement différente mais qui se ressemblent souvent en le faisant. Même si le texte est rendu dans les mêmes polices, les images sont affichées au même endroit et les liens vous mènent à la même destination. Ce qui se passe en dessous est aussi différent que la nuit et le jour. Le sélénium «résume» ces différences, cacher leurs détails et leurs subtilités à la personne qui écrit le code. Cela vous permet d'écrire plusieurs lignes de code pour effectuer un workflow compliqué, mais ces mêmes lignes s\u0026rsquo;exécuteront sur Firefox, Internet Explorer, Chrome et tous les autres navigateurs pris en charge.\nOutils et support L\u0026rsquo;approche de conception minimaliste de Selenium lui confère polyvalence à inclure en tant que composant dans des applications plus importantes. L\u0026rsquo;infrastructure environnante fournie sous l'égide du sélénium vous donne les outils pour assembler votre [grille de navigateurs] (/grid/) afin que les tests puissent être exécutés sur différents navigateurs et plusieurs systèmes d\u0026rsquo;exploitation sur une gamme de machines.\nImaginez une banque d\u0026rsquo;ordinateurs dans votre salle de serveurs ou votre centre de données allumer tous les navigateurs en même temps frapper les liens, les formulaires de votre site, et tables \u0026amp; mdash; tester votre application 24h / 24. Grâce à l\u0026rsquo;interface de programmation simple fourni pour les langues les plus courantes, ces tests se dérouleront sans relâche en parallèle, vous faire rapport en cas d\u0026rsquo;erreur.\nC\u0026rsquo;est un objectif pour aider à en faire une réalité pour vous, en fournissant aux utilisateurs des outils et de la documentation pour non seulement contrôler les navigateurs, mais pour faciliter la mise à l'échelle et le déploiement de telles grilles.\nQui utilise le sélénium Beaucoup des entreprises les plus importantes au monde ont adopté Selenium pour leurs tests sur navigateur, remplaçant souvent des efforts de plusieurs années impliquant d\u0026rsquo;autres outils propriétaires. À mesure qu\u0026rsquo;elle gagne en popularité, ses exigences et ses défis se multiplient.\nAlors que le Web devient plus compliqué et de nouvelles technologies sont ajoutées aux sites Web, c\u0026rsquo;est la mission de ce projet de les suivre autant que possible. Être un projet open source, ce soutien est assuré grâce au généreux don de temps de nombreux bénévoles, chacun a un \u0026ldquo;travail de jour\u0026rdquo;.\nUne autre mission du projet est d\u0026rsquo;encourager plus de volontaires pour participer à cet effort, et construire une communauté forte afin que le projet puisse continuer à suivre les technologies émergentes et restent une plate-forme dominante pour l\u0026rsquo;automatisation des tests fonctionnels.\nHistoire Lorsque Selenium 1 est sorti en 2004, il n'était pas nécessaire de réduire le temps passé vérification manuelle d\u0026rsquo;un comportement cohérent dans le front-end d\u0026rsquo;une application Web. Il a utilisé les outils disponibles à l'époque et s\u0026rsquo;est fortement appuyé sur l\u0026rsquo;injection de JavaScript dans la page Web testée pour émuler l\u0026rsquo;interaction d\u0026rsquo;un utilisateur.\nBien que JavaScript soit un bon outil pour vous permettre d\u0026rsquo;introspecter les propriétés du DOM et de faire certaines observations côté client que vous ne seriez pas en mesure de faire autrement, il ne répond pas à la capacité de reproduire naturellement les interactions d\u0026rsquo;un utilisateur comme si la souris et le clavier étaient utilisés.\nDepuis lors, le sélénium a grandi et mûri beaucoup, dans un outil largement utilisé par de nombreux \u0026amp; mdash; sinon la plupart des \u0026amp; mdash; les plus grandes organisations du monde. Selenium est passé d\u0026rsquo;une boîte à outils d\u0026rsquo;automatisation de tests homebrewed développée à Thoughtworks pour un public niché et un cas d\u0026rsquo;utilisation spécifique, à la bibliothèque d\u0026rsquo;automatisation du navigateur de facto du monde.\nTout comme Selenium RC utilisait les outils du commerce disponibles à l'époque, [Selenium WebDriver] (/webdriver/) perpétue cette tradition en prenant la partie d\u0026rsquo;interaction du navigateur avec le gazon du vendeur du navigateur et en leur demandant de prendre la responsabilité des implémentations back-end, orientées navigateur. Récemment, ce travail est devenu un processus de normalisation du W3C où l\u0026rsquo;objectif est de transformer le composant WebDriver dans Selenium dans la bibliothèque de contrôle à distance du jeur pour les agents utilisateurs.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/remote_webdriver/remote_webdriver_server/",
	"title": "Le serveur Remote WebDriver",
	"tags": [],
	"description": "",
	"content": "Le serveur fonctionnera toujours sur la machine avec le navigateur que vous souhaitez tester. Le serveur peut être utilisé à partir de la ligne de commande ou via du code configuration.\nDémarrage du serveur à partir de la ligne de commande Une fois que vous avez téléchargé selenium-server-standalone-{VERSION}.jar, placez-le sur l\u0026rsquo;ordinateur avec le navigateur que vous souhaitez tester. Ensuite, à partir de le répertoire avec le pot, exécutez ce qui suit:\njava -jar selenium-server-standalone-{VERSION}.jar Considérations pour exécuter le serveur L’appelant doit terminer correctement chaque session, appelant soit Selenium#stop() ou WebDriver#quit.\nLe \u0026lsquo;Selenium-Server\u0026rsquo; conserve des journaux en mémoire pour chaque session en cours, qui sont effacés lorsque Selenium#stop() ou WebDriver#quit est appelé. Si vous oubliez de mettre fin à ces sessions, votre serveur peut perdre de la mémoire. Si vous gardez des sessions extrêmement longues, vous devrez probablement arrêtez/quittez de temps en temps (ou augmentez la mémoire avec l\u0026rsquo;option -Xmx jvm).\nTimeouts (à partir de la version 2.21) Le serveur a deux délais d\u0026rsquo;expiration différents, qui peuvent être définis comme suit:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  Contrôle la durée pendant laquelle le navigateur est autorisé à se bloquer (valeur en secondes).   timeout  Contrôle la durée pendant laquelle le client est autorisé à partir avant la récupération de la session (valeur en secondes).    La propriété système selenium.server.session.timeout n\u0026rsquo;est plus pris en charge à partir de la version 2.21.\nVeuillez noter que le browserTimeout est conçu comme un mécanisme de temporisation de sauvegarde lorsque le mécanisme de temporisation ordinaire échoue, qui devrait être utilisé principalement dans des environnements de grille/serveur pour garantir que les processus bloqués/perdus ne restent pas trop longtemps, polluant l\u0026rsquo;environnement d\u0026rsquo;exécution.\nConfiguration du serveur par programmation En théorie, le processus est aussi simple que de mapper le DriverServlet à une URL, mais il est également possible d\u0026rsquo;héberger la page dans un format léger conteneur, tel que Jetty configuré entièrement en code. Étapes à suivre pour ce faire suivre.\n Téléchargez selenium-server.zip et décompressez. Placez les JAR sur le CLASSPATH. Créez une nouvelle classe appelée AppServer. Ici, j\u0026rsquo;utilise Jetty, vous devrez donc télécharger cela aussi:  import org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } } "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/getting_started_with_webdriver/browsers/",
	"title": "Navigateurs",
	"tags": [],
	"description": "",
	"content": "Navigateurs consommateurs Le framework Selenium supporte officiellement les navigateurs suivants:\n   Navigateur Mainteneur Versions supportées     Chrome Chromium Toutes versions   Firefox Mozilla 54 and plus récentes   Internet Explorer Selenium 6 et plus récentes   Opera Opera Chromium / Presto 10.5 et plus récentes   Safari Apple 10 et plus récentes    Navigateurs spécialisés Il existe également un ensemble de navigateurs spécialisés, utilisés typiquement dans des environnements de développement.\nIls peuvent également être utilisés à des fins d\u0026rsquo;automatisation, et Selenium fournit un support pour les navigateurs spécialisés suivants:\n   Nom Driver Utilisation Mainteneur     HtmlUnitDriver Emulateur de navigateur headless supproté par Rhino Projet Selenium    "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/grid/purposes_and_main_functionalities/",
	"title": "Objectifs et fonctionnalitées",
	"tags": [],
	"description": "",
	"content": " Point d\u0026rsquo;entrée central pour tous les tests Gestion et contrôle des nœuds / environnement où s\u0026rsquo;exécutent les navigateurs Mise à l'échelle Exécution de tests en parallèle Test multiplateforme L'équilibrage de charge  "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/page_object_models/",
	"title": "Page object models",
	"tags": [],
	"description": "",
	"content": "L\u0026rsquo;objet de page est un modèle de conception qui est devenu populaire dans l\u0026rsquo;automatisation des tests pour améliorer la maintenance des tests et réduire la duplication de code. Un objet page est un classe orientée objet qui sert d\u0026rsquo;interface à une page de votre AUT. le les tests utilisent ensuite les méthodes de cette classe d\u0026rsquo;objets de page chaque fois qu\u0026rsquo;ils ont besoin de interagir avec l\u0026rsquo;interface utilisateur de cette page. L\u0026rsquo;avantage est que si l\u0026rsquo;interface utilisateur change pour la page, les tests eux-mêmes n\u0026rsquo;ont pas besoin de changer, seul le code dans le l\u0026rsquo;objet de page doit changer. Par la suite, tous les changements pour prendre en charge cette nouvelle interface utilisateur sont situés en un seul endroit.\nLe modèle de conception d\u0026rsquo;objet de page offre les avantages suivants:\n Il existe une séparation nette entre le code de test et le code spécifique à la page, tel que les localisateurs (ou leur utilisation si vous utilisez une carte d\u0026rsquo;interface utilisateur) et la mise en page. Il existe un référentiel unique pour les services ou opérations proposés par la page plutôt que d\u0026rsquo;avoir ces services dispersés tout au long des tests.  Dans les deux cas, cela permet toutes les modifications requises en raison des modifications de l\u0026rsquo;interface utilisateur à tous être fait en un seul endroit. Vous trouverez des informations utiles sur cette technique sur nombreux blogs car ce «modèle de conception de test» est de plus en plus utilisé. nous encourager le lecteur qui souhaite en savoir plus à rechercher des blogs sur Internet à propos de ce sujet. Beaucoup ont écrit sur ce modèle de conception et peuvent fournir des conseils utiles dépassant le cadre de ce guide de l\u0026rsquo;utilisateur. Pour vous aider à démarrer, cependant, nous allons illustrer les objets de page avec un exemple simple.\nPrenons d\u0026rsquo;abord un exemple, typique de l\u0026rsquo;automatisation des tests, qui n\u0026rsquo;utilise pas de objet page:\n/*** * Tests login feature */ public class Login { public void testLogin() { // fill login data on sign-in page  driver.findElement(By.name(\u0026#34;user_name\u0026#34;)).sendKeys(\u0026#34;testUser\u0026#34;); driver.findElement(By.name(\u0026#34;password\u0026#34;)).sendKeys(\u0026#34;my supersecret password\u0026#34;); driver.findElement(By.name(\u0026#34;sign-in\u0026#34;)).click(); // verify h1 tag is \u0026#34;Hello userName\u0026#34; after login  driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).isDisplayed(); assertThat(driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).getText(), is(\u0026#34;Hello userName\u0026#34;)); } } Il y a deux problèmes avec cette approche.\n Il n\u0026rsquo;y a pas de séparation entre la méthode de test et les localisateurs de l\u0026rsquo;AUT (ID dans cet exemple); les deux sont entrelacés dans une seule méthode. Si l\u0026rsquo;interface utilisateur de l\u0026rsquo;AUT change ses identifiants, sa disposition ou la manière dont une connexion est entrée et traitée, le test lui-même doit changer. Les localisateurs d\u0026rsquo;ID seraient répartis dans plusieurs tests, dans tous les tests qui devaient utilisez cette page de connexion.  En appliquant les techniques d\u0026rsquo;objet de page, cet exemple pourrait être réécrit comme ceci dans l\u0026rsquo;exemple suivant d\u0026rsquo;un objet de page pour une page de connexion.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Sign-in page. */ public class SignInPage { protected static WebDriver driver; // \u0026lt;input name=\u0026#34;user_name\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By usernameBy = By.name(\u0026#34;user_name\u0026#34;); // \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By passwordBy = By.name(\u0026#34;password\u0026#34;); // \u0026lt;input name=\u0026#34;sign_in\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;SignIn\u0026#34;\u0026gt;  private By signinBy = By.name(\u0026#34;sign_in\u0026#34;); public SignInPage(WebDriver driver){ this.driver = driver; } /** * Login as valid user * * @param userName * @param password * @return HomePage object */ public HomePage loginValidUser(String userName, String password) { driver.findElement(usernameBy).sendKeys(userName); driver.findElement(passwordBy).sendKeys(password); driver.findElement(signinBy).click(); return new HomePage(driver); } } et l\u0026rsquo;objet de page pour une page d\u0026rsquo;accueil pourrait ressembler à ceci.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Home Page */ public class HomePage { protected static WebDriver driver; // \u0026lt;h1\u0026gt;Hello userName\u0026lt;/h1\u0026gt;  private By messageBy = By.tagName(\u0026#34;h1\u0026#34;); public HomePage(WebDriver driver){ this.driver = driver; if (!driver.getTitle().equals(\u0026#34;Home Page of logged in user\u0026#34;)) { throw new IllegalStateException(\u0026#34;This is not Home Page of logged in user,\u0026#34; + \u0026#34; current page is: \u0026#34; + driver.getCurrentUrl()); } } /** * Get message (h1 tag) * * @return String message text */ public String getMessageText() { return driver.findElement(messageBy).getText(); } public HomePage manageProfile() { // Page encapsulation to manage profile functionality  return new HomePage(driver); } /* More methods offering the services represented by Home Page of Logged User. These methods in turn might return more Page Objects for example click on Compose mail button could return ComposeMail class object */ } Alors maintenant, le test de connexion utiliserait ces deux objets de page comme suit.\n/*** * Tests login feature */ public class TestLogin { @Test public void testLogin() { SignInPage signInPage = new SignInPage(driver); HomePage homePage = signInPage.loginValidUser(\u0026#34;userName\u0026#34;, \u0026#34;password\u0026#34;); assertThat(homePage.getMessageText(), is(\u0026#34;Hello userName\u0026#34;)); } } Il y a beaucoup de flexibilité dans la façon dont les objets de page peuvent être conçus, mais il existe quelques règles de base pour obtenir la maintenabilité souhaitée de votre code de test.\nLes objets de page eux-mêmes ne doivent jamais faire de vérifications ou d\u0026rsquo;assertions. C\u0026rsquo;est partie de votre test et doit toujours être dans le code du test, jamais dans une page objet. L\u0026rsquo;objet page contiendra la représentation de la page et le services fournis par la page via des méthodes mais aucun code lié à ce qui est testé doit se trouver dans l\u0026rsquo;objet page.\nIl y a une seule vérification qui peut et doit être dans la page objet et qui est de vérifier que la page, et éventuellement les éléments critiques sur la page, ont été chargés correctement. Cette vérification doit être effectuée pendant instancier l\u0026rsquo;objet page. Dans les exemples ci-dessus, SignInPage et Les constructeurs de HomePage vérifient que la page attendue est disponible et prête pour demandes du test.\nUn objet de page n\u0026rsquo;a pas nécessairement besoin de représenter une page entière. La page Le modèle de conception d\u0026rsquo;objet peut être utilisé pour représenter des composants sur une page. Si un La page de l\u0026rsquo;AUT comporte plusieurs composants, elle peut améliorer la maintenabilité si il existe un objet page distinct pour chaque composant.\nIl existe d\u0026rsquo;autres modèles de conception qui peuvent également être utilisés dans les tests. Certains utilisent un Page Factory pour instancier leurs objets de page. Discuter de tout cela est au-delà de la portée de ce guide de l\u0026rsquo;utilisateur. Ici, nous voulons simplement introduire le concepts pour sensibiliser le lecteur à certaines des choses qui peuvent être faites. Comme a été mentionné plus tôt, beaucoup ont blogué sur ce sujet et nous encourageons lecteur pour rechercher des blogs sur ces sujets.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/getting_started/",
	"title": "Pour débuter",
	"tags": [],
	"description": "",
	"content": "Pour débuter Si Selenium est nouveau pour vous, nous vous proposons quelques ressources qui pourront vous aider à vous mettre à niveau très rapidement.\n Tour rapide  WebDriver IDE Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/legacy_docs/selenium_rc/",
	"title": "Selenium 1 (Selenium RC)",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Introduction Selenium RC was the main Selenium project for a long time, before the WebDriver/Selenium merge brought up Selenium 2, a more powerful tool. It is worth to highlight that Selenium 1 is not supported anymore.\nHow Selenium RC Works First, we will describe how the components of Selenium RC operate and the role each plays in running your test scripts.\nRC Components Selenium RC components are:\n The Selenium Server which launches and kills browsers, interprets and runs the Selenese commands passed from the test program, and acts as an HTTP proxy, intercepting and verifying HTTP messages passed between the browser and the AUT. Client libraries which provide the interface between each programming language and the Selenium RC Server.  Here is a simplified architecture diagram:\nThe diagram shows the client libraries communicate with the Server passing each Selenium command for execution. Then the server passes the Selenium command to the browser using Selenium-Core JavaScript commands. The browser, using its JavaScript interpreter, executes the Selenium command. This runs the Selenese action or verification you specified in your test script.\nSelenium Server Selenium Server receives Selenium commands from your test program, interprets them, and reports back to your program the results of running those tests.\nThe RC server bundles Selenium Core and automatically injects it into the browser. This occurs when your test program opens the browser (using a client library API function). Selenium-Core is a JavaScript program, actually a set of JavaScript functions which interprets and executes Selenese commands using the browser\u0026rsquo;s built-in JavaScript interpreter.\nThe Server receives the Selenese commands from your test program using simple HTTP GET/POST requests. This means you can use any programming language that can send HTTP requests to automate Selenium tests on the browser.\nClient Libraries The client libraries provide the programming support that allows you to run Selenium commands from a program of your own design. There is a different client library for each supported language. A Selenium client library provides a programming interface (API), i.e., a set of functions, which run Selenium commands from your own program. Within each interface, there is a programming function that supports each Selenese command.\nThe client library takes a Selenese command and passes it to the Selenium Server for processing a specific action or test against the application under test (AUT). The client library also receives the result of that command and passes it back to your program. Your program can receive the result and store it into a program variable and report it as a success or failure, or possibly take corrective action if it was an unexpected error.\nSo to create a test program, you simply write a program that runs a set of Selenium commands using a client library API. And, optionally, if you already have a Selenese test script created in the Selenium-IDE, you can generate the Selenium RC code. The Selenium-IDE can translate (using its Export menu item) its Selenium commands into a client-driver\u0026rsquo;s API function calls. See the Selenium-IDE chapter for specifics on exporting RC code from Selenium-IDE.\nInstallation Installation is rather a misnomer for Selenium. Selenium has a set of libraries available in the programming language of your choice. You could download them from the downloads page.\nOnce you\u0026rsquo;ve chosen a language to work with, you simply need to:\n Install the Selenium RC Server. Set up a programming project using a language specific client driver.  Installing Selenium Server The Selenium RC server is simply a Java jar file (selenium-server-standalone-.jar), which doesn\u0026rsquo;t require any special installation. Just downloading the zip file and extracting the server in the desired directory is sufficient.\nRunning Selenium Server Before starting any tests you must start the server. Go to the directory where Selenium RC\u0026rsquo;s server is located and run the following from a command-line console.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar This can be simplified by creating a batch or shell executable file (.bat on Windows and .sh on Linux) containing the command above. Then make a shortcut to that executable on your desktop and simply double-click the icon to start the server.\nFor the server to run you\u0026rsquo;ll need Java installed and the PATH environment variable correctly configured to run it from the console. You can check that you have Java correctly installed by running the following on a console.\njava -version If you get a version number (which needs to be 1.5 or later), you\u0026rsquo;re ready to start using Selenium RC.\nUsing the Java Client Driver  Download Selenium java client driver zip from the SeleniumHQ downloads page. Extract selenium-java-.jar file Open your desired Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.) Create a java project. Add the selenium-java-.jar files to your project as references. Add to your project classpath the file selenium-java-.jar. From Selenium-IDE, export a script to a Java file and include it in your Java project, or write your Selenium test in Java using the selenium-java-client API. The API is presented later in this chapter. You can either use JUnit, or TestNg to run your test, or you can write your own simple main() program. These concepts are explained later in this section. Run Selenium server from the console. Execute your test from the Java IDE or from the command-line.  For details on Java test project configuration, see the Appendix sections Configuring Selenium RC With Eclipse and Configuring Selenium RC With Intellij.\nUsing the Python Client Driver  Install Selenium via PIP, instructions linked at SeleniumHQ downloads page Either write your Selenium test in Python or export a script from Selenium-IDE to a python file. Run Selenium server from the console Execute your test from a console or your Python IDE  For details on Python client driver configuration, see the appendix Python Client Driver Configuration.\nUsing the .NET Client Driver  Download Selenium RC from the SeleniumHQ downloads page Extract the folder Download and install NUnit ( Note: You can use NUnit as your test engine. If you\u0026rsquo;re not familiar yet with NUnit, you can also write a simple main() function to run your tests; however NUnit is very useful as a test engine.) Open your desired .Net IDE (Visual Studio, SharpDevelop, MonoDevelop) Create a class library (.dll) Add references to the following DLLs: nmock.dll, nunit.core.dll, nunit. framework.dll, ThoughtWorks.Selenium.Core.dll, ThoughtWorks.Selenium.IntegrationTests.dll and ThoughtWorks.Selenium.UnitTests.dll Write your Selenium test in a .Net language (C#, VB.Net), or export a script from Selenium-IDE to a C# file and copy this code into the class file you just created. Write your own simple main() program or you can include NUnit in your project for running your test. These concepts are explained later in this chapter. Run Selenium server from console Run your test either from the IDE, from the NUnit GUI or from the command line  For specific details on .NET client driver configuration with Visual Studio, see the appendix .NET client driver configuration.\nUsing the Ruby Client Driver  If you do not already have RubyGems, install it from RubyForge. Run gem install selenium-client At the top of your test script, add require \u0026quot;selenium/client\u0026quot; Write your test script using any Ruby test harness (eg Test::Unit, Mini::Test or RSpec). Run Selenium RC server from the console. Execute your test in the same way you would run any other Ruby script.  For details on Ruby client driver configuration, see the Selenium-Client documentation_\nFrom Selenese to a Program The primary task for using Selenium RC is to convert your Selenese into a programming language. In this section, we provide several different language-specific examples.\nSample Test Script Let\u0026rsquo;s start with an example Selenese test script. Imagine recording the following test with Selenium-IDE.\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     Note: This example would work with the Google search page http://www.google.com\nSelenese as Programming Code Here is the test script exported (via Selenium-IDE) to each of the supported programming languages. If you have at least basic knowledge of an object- oriented programming language, you will understand how Selenium runs Selenese commands by reading one of these examples. To see an example in a specific language, select one of these buttons.\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } } Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt; Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end In the next section we\u0026rsquo;ll explain how to build a test program using the generated code.\nProgramming Your Test Now we\u0026rsquo;ll illustrate how to program your own tests using examples in each of the supported programming languages. There are essentially two tasks:\n Generate your script into a programming language from Selenium-IDE, optionally modifying the result. Write a very simple main program that executes the generated code.  Optionally, you can adopt a test engine platform like JUnit or TestNG for Java, or NUnit for .NET if you are using one of those languages.\nHere, we show language-specific examples. The language-specific APIs tend to differ from one to another, so you\u0026rsquo;ll find a separate explanation for each.\n Java C# Python Ruby Perl, PHP  Java For Java, people use either JUnit or TestNG as the test engine.\nSome development environments like Eclipse have direct support for these via plug-ins. This makes it even easier. Teaching JUnit or TestNG is beyond the scope of this document however materials may be found online and there are publications available. If you are already a \u0026ldquo;java-shop\u0026rdquo; chances are your developers will already have some experience with one of these test frameworks.\nYou will probably want to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); The Selenium-IDE generated code will look like this. This example has comments added manually for additional clarity.\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# The .NET Client Driver works with Microsoft.NET. It can be used with any .NET testing framework like NUnit or the Visual Studio 2005 Team System.\nSelenium-IDE assumes you will use NUnit as your testing framework. You can see this in the generated code below. It includes the using statement for NUnit along with corresponding NUnit attributes identifying the role for each member function of the test class.\nYou will probably have to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); The generated code will look similar to this.\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } } You can allow NUnit to manage the execution of your tests. Or alternatively, you can write a simple main() program that instantiates the test object and runs each of the three methods, SetupTest(), TheNewTest(), and TeardownTest() in turn.\nPython Pyunit is the test framework to use for Python.\nThe basic test structure is:\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Old (pre 2.0) versions of Selenium-IDE generate Ruby code that requires the old Selenium gem. Therefore, it is advisable to update any Ruby scripts generated by the IDE as follows:\n  On line 1, change require \u0026quot;selenium\u0026quot; to require \u0026quot;selenium/client\u0026quot;\n  On line 11, change Selenium::SeleniumDriver.new to Selenium::Client::Driver.new\n  You probably also want to change the class name to something more informative than \u0026ldquo;Untitled,\u0026rdquo; and change the test method\u0026rsquo;s name to something other than \u0026ldquo;test_untitled.\u0026rdquo;\nHere is a simple example created by modifying the Ruby code generated by Selenium IDE, as described above.\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP The members of the documentation team have not used Selenium RC with Perl or PHP. If you are using Selenium RC with either of these two languages please contact the Documentation Team (see the chapter on contributing). We would love to include some examples from you and your experiences, to support Perl and PHP users.\nLearning the API The Selenium RC API uses naming conventions that, assuming you understand Selenese, much of the interface\nwill be self-explanatory. Here, however, we explain the most critical and possibly less obvious aspects.\nStarting the Browser CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start Each of these examples opens the browser and represents that browser by assigning a \u0026ldquo;browser instance\u0026rdquo; to a program variable. This program variable is then used to call methods from the browser. These methods execute the Selenium commands, i.e. like open or type or the verify commands.\nThe parameters required when creating the browser instance are:\n  host Specifies the IP address of the computer where the server is located. Usually, this is the same machine as where the client is running, so in this case localhost is passed. In some clients this is an optional parameter.\n  port Specifies the TCP/IP socket where the server is listening waiting for the client to establish a connection. This also is optional in some client drivers.\n  browser The browser in which you want to run the tests. This is a required parameter.\n  url The base url of the application under test. This is required by all the client libs and is integral information for starting up the browser-proxy-AUT communication.\n  Note that some of the client libraries require the browser to be started explicitly by calling its start() method.\nRunning Commands Once you have the browser initialized and assigned to a variable (generally named \u0026ldquo;selenium\u0026rdquo;) you can make it run Selenese commands by calling the respective methods from the browser variable. For example, to call the type method of the selenium object:\nselenium.type(\u0026#34;field-id\u0026#34;,\u0026#34;string to type\u0026#34;) In the background the browser will actually perform a type operation, essentially identical to a user typing input into the browser, by\nusing the locator and the string you specified during the method call.\nReporting Results Selenium RC does not have its own mechanism for reporting results. Rather, it allows you to build your reporting customized to your needs using features of your chosen programming language. That\u0026rsquo;s great, but what if you simply want something quick that\u0026rsquo;s already done for you? Often an existing library or test framework can meet your needs faster than developing your own test reporting code.\nTest Framework Reporting Tools Test frameworks are available for many programming languages. These, along with their primary function of providing a flexible test engine for executing your tests, include library code for reporting results. For example, Java has two commonly used test frameworks, JUnit and TestNG. .NET also has its own, NUnit.\nWe won\u0026rsquo;t teach the frameworks themselves here; that\u0026rsquo;s beyond the scope of this user guide. We will simply introduce the framework features that relate to Selenium along with some techniques you can apply. There are good books available on these test frameworks however along with information on the internet.\nTest Report Libraries Also available are third-party libraries specifically created for reporting test results in your chosen programming language. These often support a variety of formats such as HTML or PDF.\nWhat\u0026rsquo;s The Best Approach? Most people new to the testing frameworks will begin with the framework\u0026rsquo;s built-in reporting features. From there most will examine any available libraries as that\u0026rsquo;s less time consuming than developing your own. As you begin to use Selenium no doubt you will start putting in your own \u0026ldquo;print statements\u0026rdquo; for reporting progress. That may gradually lead to you developing your own reporting, possibly in parallel to using a library or test framework. Regardless, after the initial, but short, learning curve you will naturally develop what works best for your own situation.\nTest Reporting Examples To illustrate, we\u0026rsquo;ll direct you to some specific tools in some of the other languages supported by Selenium. The ones listed here are commonly used and have been used extensively (and therefore recommended) by the authors of this guide.\nTest Reports in Java   If Selenium Test cases are developed using JUnit then JUnit Report can be used to generate test reports.\n  If Selenium Test cases are developed using TestNG then no external task is required to generate test reports. The TestNG framework generates an HTML report which list details of tests.\n  ReportNG is a HTML reporting plug-in for the TestNG framework. It is intended as a replacement for the default TestNG HTML report. ReportNG provides a simple, colour-coded view of the test results.\n  Logging the Selenese Commands  Logging Selenium can be used to generate a report of all the Selenese commands in your test along with the success or failure of each. Logging Selenium extends the Java client driver to add this Selenese logging ability.  Test Reports for Python  When using Python Client Driver then HTMLTestRunner can be used to generate a Test Report.  Test Reports for Ruby  If RSpec framework is used for writing Selenium Test Cases in Ruby then its HTML report can be used to generate a test report.  Adding Some Spice to Your Tests Now we\u0026rsquo;ll get to the whole reason for using Selenium RC, adding programming logic to your tests. It\u0026rsquo;s the same as for any program. Program flow is controlled using condition statements and iteration. In addition you can report progress information using I/O. In this section we\u0026rsquo;ll show some examples of how programming language constructs can be combined with Selenium to solve common testing problems.\nYou will find as you transition from the simple tests of the existence of page elements to tests of dynamic functionality involving multiple web-pages and varying data that you will require programming logic for verifying expected results. Basically, the Selenium-IDE does not support iteration and standard condition statements. You can do some conditions by embedding JavaScript in Selenese parameters, however iteration is impossible, and most conditions will be much easier in a\nprogramming language. In addition, you may need exception handling for error recovery. For these reasons and others, we have written this section to illustrate the use of common programming techniques to give you greater \u0026lsquo;verification power\u0026rsquo; in your automated testing.\nThe examples in this section are written in C# and Java, although the code is simple and can be easily adapted to the other supported languages. If you have some basic knowledge of an object-oriented programming language you shouldn\u0026rsquo;t have difficulty understanding this section.\nIteration Iteration is one of the most common things people need to do in their tests. For example, you may want to to execute a search multiple times. Or, perhaps for verifying your test results you need to process a \u0026ldquo;result set\u0026rdquo; returned from a database.\nUsing the same Google search example we used earlier, let\u0026rsquo;s check the Selenium search results. This test could use the Selenese:\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     The code has been repeated to run the same steps 3 times. But multiple copies of the same code is not good program practice because it\u0026rsquo;s more work to maintain. By using a programming language, we can iterate over the search results for a more flexible and maintainable solution.\nIn C# // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); } Condition Statements To illustrate using conditions in tests we\u0026rsquo;ll start with an example. A common problem encountered while running Selenium tests occurs when an expected element is not available on page. For example, when running the following line:\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); If element \u0026lsquo;q\u0026rsquo; is not on the page then an exception is thrown:\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found This can cause your test to abort. For some tests that\u0026rsquo;s what you want. But often that is not desirable as your test script has many other subsequent tests to perform.\nA better approach is to first validate whether the element is really present and then take alternatives when it it is not. Let\u0026rsquo;s look at this using Java.\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } The advantage of this approach is to continue with test execution even if some UI elements are not available on page.\nExecuting JavaScript from Your Test JavaScript comes very handy in exercising an application which is not directly supported by Selenium. The getEval method of Selenium API can be used to execute JavaScript from Selenium RC.\nConsider an application having check boxes with no static identifiers. In this case one could evaluate JavaScript from Selenium RC to get ids of all check boxes and then exercise them.\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } To count number of images on a page:\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); Remember to use window object in case of DOM expressions as by default selenium window is referred to, not the test window.\nServer Options When the server is launched, command line options can be used to change the default server behaviour.\nRecall, the server is started by running the following.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar To see the list of options, run the server with the -h option.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h You\u0026rsquo;ll see a list of all the options you can use with the server and a brief description of each. The provided descriptions will not always be enough, so we\u0026rsquo;ve provided explanations for some of the more important options.\nProxy Configuration If your AUT is behind an HTTP proxy which requires authentication then you should configure http.proxyHost, http.proxyPort, http.proxyUser and http.proxyPassword using the following command.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password Multi-Window Mode If you are using Selenium 1.0 you can probably skip this section, since multiwindow mode is the default behavior. However, prior to version 1.0, Selenium by default ran the application under test in a sub frame as shown here.\nSome applications didn\u0026rsquo;t run correctly in a sub frame, and needed to be loaded into the top frame of the window. The multi-window mode option allowed the AUT to run in a separate window rather than in the default frame where it could then have the top frame it required.\nFor older versions of Selenium you must specify multiwindow mode explicitly with the following option:\n-multiwindow As of Selenium RC 1.0, if you want to run your test within a single frame (i.e. using the standard for earlier Selenium versions) you can state this to the Selenium Server using the option\n-singlewindow Specifying the Firefox Profile Firefox will not run two instances simultaneously unless you specify a separate profile for each instance. Selenium RC 1.0 and later runs in a separate profile automatically, so if you are using Selenium 1.0, you can probably skip this section. However, if you\u0026rsquo;re using an older version of Selenium or if you need to use a specific profile for your tests (such as adding an https certificate or having some addons installed), you will need to explicitly specify the profile.\nFirst, to create a separate Firefox profile, follow this procedure. Open the Windows Start menu, select \u0026ldquo;Run\u0026rdquo;, then type and enter one of the following:\nfirefox.exe -profilemanager firefox.exe -P Create the new profile using the dialog. Then when you run Selenium Server, tell it to use this new Firefox profile with the server command-line option -firefoxProfileTemplate and specify the path to the profile using its filename and directory path.\n-firefoxProfileTemplate \u0026#34;path to the profile\u0026#34; Warning: Be sure to put your profile in a new folder separate from the default!!! The Firefox profile manager tool will delete all files in a folder if you delete a profile, regardless of whether they are profile files or not.\nMore information about Firefox profiles can be found in Mozilla\u0026rsquo;s Knowledge Base\nRun Selenese Directly Within the Server Using -htmlSuite You can run Selenese html files directly within the Selenium Server by passing the html file to the server\u0026rsquo;s command line. For instance:\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; This will automatically launch your HTML suite, run all the tests and save a nice HTML report with the results.\nNote: When using this option, the server will start the tests and wait for a specified number of seconds for the test to complete; if the test doesn\u0026rsquo;t complete within that amount of time, the command will exit with a non-zero exit code and no results file will be generated.\nThis command line is very long so be careful when you type it. Note this requires you to pass in an HTML Selenese suite, not a single test. Also be aware the -htmlSuite option is incompatible with -interactive You cannot run both at the same time.\nSelenium Server Logging Server-Side Logs When launching Selenium server the -log option can be used to record valuable debugging information reported by the Selenium Server to a text file.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log This log file is more verbose than the standard console logs (it includes DEBUG level logging messages). The log file also includes the logger name, and the ID number of the thread that logged the message. For example:\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW The message format is\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE This message may be multiline.\nBrowser-Side Logs JavaScript on the browser side (Selenium Core) also logs important messages; in many cases, these can be more useful to the end-user than the regular Selenium Server logs. To access browser-side logs, pass the -browserSideLog argument to the Selenium Server.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog must be combined with the -log argument, to log browserSideLogs (as well as all other DEBUG level logging messages) to a file.\nSpecifying the Path to a Specific Browser You can specify to Selenium RC a path to a specific browser. This is useful if you have different versions of the same browser and you wish to use a specific one. Also, this is used to allow your tests to run against a browser not directly supported by Selenium RC. When specifying the run mode, use the *custom specifier followed by the full path to the browser\u0026rsquo;s executable:\n*custom \u0026lt;path to browser\u0026gt; Selenium RC Architecture Note: This topic tries to explain the technical implementation behind Selenium RC. It\u0026rsquo;s not fundamental for a Selenium user to know this, but could be useful for understanding some of the problems you might find in the future.\nTo understand in detail how Selenium RC Server works and why it uses proxy injection and heightened privilege modes you must first understand the same origin policy_.\nThe Same Origin Policy The main restriction that Selenium faces is the Same Origin Policy. This security restriction is applied by every browser in the market and its objective is to ensure that a site\u0026rsquo;s content will never be accessible by a script from another site. The Same Origin Policy dictates that any code loaded within the browser can only operate within that website\u0026rsquo;s domain. It cannot perform functions on another website. So for example, if the browser loads JavaScript code when it loads www.mysite.com, it cannot run that loaded code against www.mysite2.com\u0026ndash;even if that\u0026rsquo;s another of your sites. If this were possible, a script placed on any website you open would be able to read information on your bank account if you had the account page opened on other tab. This is called XSS (Cross-site Scripting).\nTo work within this policy, Selenium-Core (and its JavaScript commands that make all the magic happen) must be placed in the same origin as the Application Under Test (same URL).\nHistorically, Selenium-Core was limited by this problem since it was implemented in JavaScript. Selenium RC is not, however, restricted by the Same Origin Policy. Its use of the Selenium Server as a proxy avoids this problem. It, essentially, tells the browser that the browser is working on a single \u0026ldquo;spoofed\u0026rdquo; website that the Server provides.\nNote: You can find additional information about this topic on Wikipedia pages about Same Origin Policy and XSS.\nProxy Injection The first method Selenium used to avoid the The Same Origin Policy was Proxy Injection. In Proxy Injection Mode, the Selenium Server acts as a client-configured HTTP proxy1, that sits between the browser and the Application Under Test2. It then masks the AUT under a fictional URL (embedding Selenium-Core and the set of tests and delivering them as if they were coming from the same origin).\nHere is an architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that injects Selenium-Core\u0026rsquo;s JavaScript into the browser-loaded web page. The client-driver passes a Selenese command to the server. The Server interprets the command and then triggers the corresponding JavaScript execution to execute that command within the browser. Selenium-Core instructs the browser to act on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks for the website\u0026rsquo;s content from the Selenium RC server (set as the HTTP proxy for the browser to use). Selenium RC server communicates with the Web server asking for the page and once it receives it, it sends the page to the browser masking the origin to look like the page comes from the same server as Selenium-Core (this allows Selenium-Core to comply with the Same Origin Policy). The browser receives the web page and renders it in the frame/window reserved for it.  Heightened Privileges Browsers This workflow in this method is very similar to Proxy Injection but the main difference is that the browsers are launched in a special mode called Heightened Privileges, which allows websites to do things that are not commonly permitted (as doing XSS_, or filling file upload inputs and pretty useful stuff for Selenium). By using these browser modes, Selenium Core is able to directly open the AUT and read/interact with its content without having to pass the whole AUT through the Selenium RC server.\nHere is the architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that will load Selenium-Core in the web page. Selenium-Core gets the first instruction from the client/driver (via another HTTP request made to the Selenium RC Server). Selenium-Core acts on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks the Web Server for the page. Once the browser receives the web page, renders it in the frame/window reserved for it.  Handling HTTPS and Security Popups Many applications switch from using HTTP to HTTPS when they need to send encrypted information such as passwords or credit card information. This is common with many of today\u0026rsquo;s web applications. Selenium RC supports this.\nTo ensure the HTTPS site is genuine, the browser will need a security certificate. Otherwise, when the browser accesses the AUT using HTTPS, it will assume that application is not \u0026lsquo;trusted\u0026rsquo;. When this occurs the browser displays security popups, and these popups cannot be closed using Selenium RC.\nWhen dealing with HTTPS in a Selenium RC test, you must use a run mode that supports this and handles the security certificate for you. You specify the run mode when your test program initializes Selenium.\nIn Selenium RC 1.0 beta 2 and later use *firefox or *iexplore for the run mode. In earlier versions, including Selenium RC 1.0 beta 1, use *chrome or *iehta, for the run mode. Using these run modes, you will not need to install any special security certificates; Selenium RC will handle it for you.\nIn version 1.0 the run modes *firefox or *iexplore are recommended. However, there are additional run modes of *iexploreproxy and *firefoxproxy. These are provided for backwards compatibility only, and should not be used unless required by legacy test programs. Their use will present limitations with security certificate handling and with the running of multiple windows if your application opens additional browser windows.\nIn earlier versions of Selenium RC, *chrome or *iehta were the run modes that supported HTTPS and the handling of security popups. These were considered ‘experimental modes although they became quite stable and many people used them. If you are using Selenium 1.0 you do not need, and should not use, these older run modes.\nSecurity Certificates Explained Normally, your browser will trust the application you are testing by installing a security certificate which you already own. You can check this in your browser\u0026rsquo;s options or Internet properties (if you don\u0026rsquo;t know your AUT\u0026rsquo;s security certificate ask your system administrator). When Selenium loads your browser it injects code to intercept messages between the browser and the server. The browser now thinks untrusted software is trying to look like your application. It responds by alerting you with popup messages.\nTo get around this, Selenium RC, (again when using a run mode that support this) will install its own security certificate, temporarily, to your client machine in a place where the browser can access it. This tricks the browser into thinking it\u0026rsquo;s accessing a site different from your AUT and effectively suppresses the popups.\nAnother method used with earlier versions of Selenium was to install the Cybervillians security certificate provided with your Selenium installation. Most users should no longer need to do this however; if you are running Selenium RC in proxy injection mode, you may need to explicitly install this security certificate.\nSupporting Additional Browsers and Browser Configurations The Selenium API supports running against multiple browsers in addition to Internet Explorer and Mozilla Firefox. See the https://selenium.dev website for supported browsers. In addition, when a browser is not directly supported, you may still run your Selenium tests against a browser of your choosing by using the \u0026ldquo;*custom\u0026rdquo; run-mode (i.e. in place of *firefox or *iexplore) when your test application starts the browser. With this, you pass in the path to the browsers executable within the API call. This can also be done from the Server in interactive mode.\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com Running Tests with Different Browser Configurations Normally Selenium RC automatically configures the browser, but if you launch the browser using the \u0026ldquo;*custom\u0026rdquo; run mode, you can force Selenium RC to launch the browser as-is, without using an automatic configuration.\nFor example, you can launch Firefox with a custom configuration like this:\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com Note that when launching the browser this way, you must manually configure the browser to use the Selenium Server as a proxy. Normally this just means opening your browser preferences and specifying \u0026ldquo;localhost:4444\u0026rdquo; as an HTTP proxy, but instructions for this can differ radically from browser to browser. Consult your browser\u0026rsquo;s documentation for details.\nBe aware that Mozilla browsers can vary in how they start and stop. One may need to set the MOZ_NO_REMOTE environment variable to make Mozilla browsers behave a little more predictably. Unix users should avoid launching the browser using a shell script; it\u0026rsquo;s generally better to use the binary executable (e.g. firefox-bin) directly.\nTroubleshooting Common Problems When getting started with Selenium RC there\u0026rsquo;s a few potential problems that are commonly encountered. We present them along with their solutions here.\nUnable to Connect to Server When your test program cannot connect to the Selenium Server, Selenium throws an exception in your test program. It should display this message or a similar one:\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2) If you see a message like this, be sure you started the Selenium Server. If so, then there is a problem with the connectivity between the Selenium Client Library and the Selenium Server.\nWhen starting with Selenium RC, most people begin by running their test program (with a Selenium Client Library) and the Selenium Server on the same machine. To do this use \u0026ldquo;localhost\u0026rdquo; as your connection parameter. We recommend beginning this way since it reduces the influence of potential networking problems which you\u0026rsquo;re getting started. Assuming your operating system has typical networking and TCP/IP settings you should have little difficulty. In truth, many people choose to run the tests this way.\nIf, however, you do want to run Selenium Server on a remote machine, the connectivity should be fine assuming you have valid TCP/IP connectivity between the two machines.\nIf you have difficulty connecting, you can use common networking tools like ping, telnet, ifconfig(Unix)/ipconfig (Windows), etc to ensure you have a valid network connection. If unfamilar with these, your system administrator can assist you.\nUnable to Load the Browser Ok, not a friendly error message, sorry, but if the Selenium Server cannot load the browser you will likely see this error.\n(500) Internal Server Error This could be caused by\n Firefox (prior to Selenium 1.0) cannot start because the browser is already open and you did not specify a separate profile. See the section on Firefox profiles under Server Options. The run mode you\u0026rsquo;re using doesn\u0026rsquo;t match any browser on your machine. Check the parameters you passed to Selenium when you program opens the browser. You specified the path to the browser explicitly (using \u0026ldquo;*custom\u0026rdquo;\u0026ndash;see above) but the path is incorrect. Check to be sure the path is correct. Also check the user group to be sure there are no known issues with your browser and the \u0026ldquo;*custom\u0026rdquo; parameters.  Selenium Cannot Find the AUT If your test program starts the browser successfully, but the browser doesn\u0026rsquo;t display the website you\u0026rsquo;re testing, the most likely cause is your test program is not using the correct URL.\nThis can easily happen. When you use Selenium-IDE to export your script, it inserts a dummy URL. You must manually change the URL to the correct one for your application to be tested.\nFirefox Refused Shutdown While Preparing a Profile This most often occurs when you run your Selenium RC test program against Firefox, but you already have a Firefox browser session running and, you didn\u0026rsquo;t specify a separate profile when you started the Selenium Server. The error from the test program looks like this:\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile Here\u0026rsquo;s the complete error message from the server:\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock To resolve this, see the section on Specifying a Separate Firefox Profile\nVersioning Problems Make sure your version of Selenium supports the version of your browser. For example, Selenium RC 0.92 does not support Firefox 3. At times you may be lucky (I was). But don\u0026rsquo;t forget to check which browser versions are supported by the version of Selenium you are using. When in doubt, use the latest release version of Selenium with the most widely used version of your browser.\nError message: \u0026ldquo;(Unsupported major.minor version 49.0)\u0026rdquo; while starting server This error says you\u0026rsquo;re not using a correct version of Java. The Selenium Server requires Java 1.5 or higher.\nTo check double-check your java version, run this from the command line.\njava -version You should see a message showing the Java version.\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) If you see a lower version number, you may need to update the JRE, or you may simply need to add it to your PATH environment variable.\n404 error when running the getNewBrowserSession command If you\u0026rsquo;re getting a 404 error while attempting to open a page on \u0026ldquo;http://www.google.com/selenium-server/\u0026quot;, then it must be because the Selenium Server was not correctly configured as a proxy. The \u0026ldquo;selenium-server\u0026rdquo; directory doesn\u0026rsquo;t exist on google.com; it only appears to exist when the proxy is properly configured. Proxy Configuration highly depends on how the browser is launched with firefox, iexplore, opera, or custom.\n  iexplore: If the browser is launched using *iexplore, you could be having a problem with Internet Explorer\u0026rsquo;s proxy settings. Selenium Server attempts To configure the global proxy settings in the Internet Options Control Panel. You must make sure that those are correctly configured when Selenium Server launches the browser. Try looking at your Internet Options control panel. Click on the \u0026ldquo;Connections\u0026rdquo; tab and click on \u0026ldquo;LAN Settings\u0026rdquo;.\n If you need to use a proxy to access the application you want to test, you\u0026rsquo;ll need to start Selenium Server with \u0026ldquo;-Dhttp.proxyHost\u0026rdquo;; see the Proxy Configuration_ for more details. You may also try configuring your proxy manually and then launching the browser with *custom, or with *iehta browser launcher.    custom: When using *custom you must configure the proxy correctly(manually), otherwise you\u0026rsquo;ll get a 404 error. Double-check that you\u0026rsquo;ve configured your proxy settings correctly. To check whether you\u0026rsquo;ve configured the proxy correctly is to attempt to intentionally configure the browser incorrectly. Try configuring the browser to use the wrong proxy server hostname, or the wrong port. If you had successfully configured the browser\u0026rsquo;s proxy settings incorrectly, then the browser will be unable to connect to the Internet, which is one way to make sure that one is adjusting the relevant settings.\n  For other browsers (*firefox, *opera) we automatically hard-code the proxy for you, and so there are no known issues with this functionality. If you\u0026rsquo;re encountering 404 errors and have followed this user guide carefully post your results to user group for some help from the user community.\n  Permission Denied Error The most common reason for this error is that your session is attempting to violate the same-origin policy by crossing domain boundaries (e.g., accesses a page from http://domain1 and then accesses a page from http://domain2) or switching protocols (moving from http://domainX to https://domainX).\nThis error can also occur when JavaScript attempts to find UI objects which are not yet available (before the page has completely loaded), or are no longer available (after the page has started to be unloaded). This is most typically encountered with AJAX pages which are working with sections of a page or subframes that load and/or reload independently of the larger page.\nThis error can be intermittent. Often it is impossible to reproduce the problem with a debugger because the trouble stems from race conditions which are not reproducible when the debugger\u0026rsquo;s overhead is added to the system. Permission issues are covered in some detail in the tutorial. Read the section about the The Same Origin Policy_, Proxy Injection_ carefully.\nHandling Browser Popup Windows There are several kinds of \u0026ldquo;Popups\u0026rdquo; that you can get during a Selenium test. You may not be able to close these popups by running Selenium commands if they are initiated by the browser and not your AUT. You may need to know how to manage these. Each type of popup needs to be addressed differently.\n  HTTP basic authentication dialogs: These dialogs prompt for a username/password to login to the site. To login to a site that requires HTTP basic authentication, use a username and password in the URL, as described in RFC 1738_, like this: open(\u0026ldquo;http://myusername:myuserpassword@myexample.com/blah/blah/blah\u0026quot;).\n  SSL certificate warnings: Selenium RC automatically attempts to spoof SSL certificates when it is enabled as a proxy; see more on this in the section on HTTPS. If your browser is configured correctly, you should never see SSL certificate warnings, but you may need to configure your browser to trust our dangerous \u0026ldquo;CyberVillains\u0026rdquo; SSL certificate authority. Again, refer to the HTTPS section for how to do this.\n  modal JavaScript alert/confirmation/prompt dialogs: Selenium tries to conceal those dialogs from you (by replacing window.alert, window.confirm and window.prompt) so they won\u0026rsquo;t stop the execution of your page. If you\u0026rsquo;re seeing an alert pop-up, it\u0026rsquo;s probably because it fired during the page load process, which is usually too early for us to protect the page. Selenese contains commands for asserting or verifying alert and confirmation popups. See the sections on these topics in Chapter 4.\n  On Linux, why isn\u0026rsquo;t my Firefox browser session closing? On Unix/Linux you must invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so make sure that executable is on the path. If executing Firefox through a shell script, when it comes time to kill the browser Selenium RC will kill the shell script, leaving the browser running. You can specify the path to firefox-bin directly, like this.\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome doesn\u0026rsquo;t work with custom profile Check Firefox profile folder -\u0026gt; prefs.js -\u0026gt; user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0); Comment this line like this: \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; and try again.\nIs it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page\u0026rsquo;s javascript window.onload() function runs)? No. Selenium relies on interceptors to determine window names as they are being loaded. These interceptors work best in catching new windows if the windows are loaded AFTER the onload() function. Selenium may not recognize windows loaded before the onload function.\nFirefox on Linux On Unix/Linux, versions of Selenium before 1.0 needed to invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so if you are using a previous version, make sure that the real executable is on the path.\nOn most Linux distributions, the real firefox-bin is located on:\n/usr/lib/firefox-x.x.x/ Where the x.x.x is the version number you currently have. So, to add that path to the user\u0026rsquo;s path. you will have to add the following to your .bashrc file:\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; If necessary, you can specify the path to firefox-bin directly in your test, like this:\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IE and Style Attributes If you are running your tests on Internet Explorer and you cannot locate elements using their style attribute. For example:\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] This would work perfectly in Firefox, Opera or Safari but not with IE. IE interprets the keys in @style as uppercase. So, even if the source code is in lowercase, you should use:\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] This is a problem if your test is intended to work on multiple browsers, but you can easily code your test to detect the situation and try the alternative locator that only works in IE.\nError encountered - \u0026ldquo;Cannot convert object to primitive value\u0026rdquo; with shut down of *googlechrome browser To avoid this error you have to start browser with an option that disables same origin policy checks:\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); Error encountered in IE - \u0026ldquo;Couldn\u0026rsquo;t open app window; is the pop-up blocker enabled?\u0026rdquo; To avoid this error you have to configure the browser: disable the popup blocker AND uncheck \u0026lsquo;Enable Protected Mode\u0026rsquo; option in Tools \u0026raquo; Options \u0026raquo; Security.\n  The proxy is a third person in the middle that passes the ball between the two parts. It acts as a \u0026ldquo;web server\u0026rdquo; that delivers the AUT to the browser. Being a proxy gives Selenium Server the capability of \u0026ldquo;lying\u0026rdquo; about the AUT\u0026rsquo;s real URL. \u0026#x21a9;\u0026#xfe0e;\n The browser is launched with a configuration profile that has set localhost:4444 as the HTTP proxy, this is why any HTTP request that the browser does will pass through Selenium server and the response will pass through it and not from the real server. \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/getting_started/quick/",
	"title": "Tour rapide",
	"tags": [],
	"description": "",
	"content": "Selenium n\u0026rsquo;est pas juste un outil ou une API mais est composé de nombreux outils.\nWebDriver Si vous débutez dans l\u0026rsquo;automatisation de test de site web desktop vous allez utiliser les APIs WebDriver. WebDriver utilise les APIs d\u0026rsquo;automatisation fournies par les distributeurs de navigateur pour les contrôler et exécuter les tests. C\u0026rsquo;est comme si un utilisateur réel utilisait le navigateur. Puisque WebDriver n\u0026rsquo;a pas besoin que ses APIs soient compilées avec le code de l\u0026rsquo;application testée, il est non intrusif par nature. Ainsi vous testez exactement l\u0026rsquo;application qui sera en production.\nIDE IDE (Integrated Development Environment) est l\u0026rsquo;outil que vous utilisez pour développer vos cas de test Selenium. Il s\u0026rsquo;agit d\u0026rsquo;un Chrome facile à utiliser et l\u0026rsquo;extension Firefox et est généralement le moyen le plus efficace de développer cas de test. Il enregistre pour vous les actions des utilisateurs dans le navigateur, en utilisant commandes Selenium existantes, avec des paramètres définis par le contexte de cet élément. Ce n\u0026rsquo;est pas seulement un gain de temps, mais aussi un excellent moyen d\u0026rsquo;apprentissage de la syntaxe du script Selenium.\nGrid Selenium Grid allows you to run test cases in different machines across different platforms. The control of triggering the test cases is on the local end, and when the test cases are triggered, they are automatically executed by the remote end.\nAfter the development of the WebDriver tests, you may face the need of running your tests on multiple browser and operating system combinations. This is where Grid comes into the picture.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/introduction/on_test_automation/",
	"title": "A propos du test automatisé",
	"tags": [],
	"description": "",
	"content": "Commencez par vous demander si vous avez vraiment besoin ou non d\u0026rsquo;un navigateur. Il est probable qu'à un moment donné, si vous travaillez sur une application Web complexe, vous devrez ouvrir un navigateur et le tester.\nLes tests fonctionnels pour l\u0026rsquo;utilisateur final, tels que les tests au sélénium, sont cependant coûteux à exécuter. En outre, ils nécessitent généralement une infrastructure substantielle être en place pour fonctionner efficacement. C\u0026rsquo;est une bonne règle de toujours se demander si ce que l\u0026rsquo;on veut tester peut être fait en utilisant des approches de test plus légères telles que des tests unitaires ou avec une approche de niveau inférieur.\nUne fois que vous avez déterminé que vous êtes dans le domaine des tests de navigateurs Web, et vous avez votre environnement Selenium prêt à commencer à écrire des tests, vous effectuerez généralement une combinaison de trois étapes:\n Configurer les données Effectuer un ensemble discret d\u0026rsquo;actions Évaluez les résultats  Vous voudrez garder ces étapes aussi courtes que possible; une ou deux opérations devraient suffire la plupart du temps. L\u0026rsquo;automatisation des navigateurs a la réputation d'être \u0026ldquo;feuilletée\u0026rdquo;, mais en réalité, c\u0026rsquo;est parce que les utilisateurs en demandent souvent trop. Dans les chapitres suivants, nous reviendrons sur les techniques que vous pouvez utiliser pour atténuer les problèmes intermittents apparents dans les tests, en particulier sur la façon de surmonter les conditions de course entre le navigateur et WebDriver.\nGarder vos tests courts et en utilisant le navigateur Web uniquement lorsque vous n\u0026rsquo;avez absolument aucune alternative, vous pouvez avoir de nombreuses tâches avec un flocon de neige minimal.\nUn avantage distinct des tests au sélénium est leur capacité inhérente à tester tous les composants de l\u0026rsquo;application, du backend au frontend, du point de vue d\u0026rsquo;un utilisateur. En d\u0026rsquo;autres termes, alors que les tests fonctionnels peuvent être coûteux à exécuter, ils englobent également de grandes portions critiques pour l\u0026rsquo;entreprise à la fois.\nExigences de test Comme mentionné précédemment, les tests au sélénium peuvent être coûteux à exécuter. Dans quelle mesure cela dépend du navigateur sur lequel vous exécutez les tests, mais historiquement, le comportement des navigateurs a tellement varié qu\u0026rsquo;il a souvent était un objectif déclaré de contre-tester avec plusieurs navigateurs.\nSelenium vous permet d\u0026rsquo;exécuter les mêmes instructions sur plusieurs navigateurs sur plusieurs systèmes d\u0026rsquo;exploitation, mais l'énumération de tous les navigateurs possibles, leurs différentes versions et les nombreux systèmes d\u0026rsquo;exploitation sur lesquels ils s\u0026rsquo;exécutent deviendra rapidement une entreprise non triviale.\nCommençons par un exemple Larry a écrit un site Web qui permet aux utilisateurs de commander leur licornes personnalisées.\nLe flux de travail général (ce que nous appellerons le \u0026ldquo;chemin heureux\u0026rdquo;) est quelque chose comme ça:\n Créer un compte Configurer la licorne Ajoutez-le au panier Vérifiez et payez Donnez votre avis sur la licorne  Il serait tentant d'écrire un grand script Selenium pour effectuer toutes ces opérations, beaucoup essaieront. Résister à la tentation! Cela entraînera un test qui a) prend beaucoup de temps, b) sera soumis à des problèmes courants concernant les problèmes de synchronisation du rendu de page, et c) est telle qu\u0026rsquo;en cas d'échec, il ne vous donnera pas une méthode concise et \u0026ldquo;lisible\u0026rdquo; pour diagnostiquer ce qui a mal tourné.\nLa stratégie préférée pour tester ce scénario serait pour le décomposer en une série de tests indépendants et rapides, chacun a une «raison» d\u0026rsquo;exister.\nImaginons que vous souhaitiez tester la deuxième étape: Configuration de votre licorne. Il effectuera les actions suivantes:\n Créer un compte Configurer une licorne  Notez que nous ignorons le reste de ces étapes, nous testerons le reste du workflow dans d\u0026rsquo;autres petits cas de test discrets après avoir fini avec celui-ci.\nPour commencer, vous devez créer un compte. Vous avez ici quelques choix à faire:\n Voulez-vous utiliser un compte existant? Voulez-vous créer un nouveau compte? Y a-t-il des propriétés spéciales d\u0026rsquo;un tel utilisateur qui doivent être pris en compte avant le début de la configuration?  Quelle que soit la façon dont vous répondez à cette question, la solution consiste à l\u0026rsquo;intégrer à la partie \u0026ldquo;configurer les données\u0026rdquo; du test. Si Larry a exposé une API qui vous permet (ou n\u0026rsquo;importe qui) pour créer et mettre à jour des comptes utilisateurs, assurez-vous de l\u0026rsquo;utiliser pour répondre à cette question. Si possible, vous souhaitez lancer le navigateur uniquement après avoir un utilisateur \u0026ldquo;en main\u0026rdquo;, dont vous pouvez simplement vous connecter avec les informations d\u0026rsquo;identification.\nSi chaque test pour chaque workflow commence par la création d\u0026rsquo;un compte utilisateur, plusieurs secondes seront ajoutées à l\u0026rsquo;exécution de chaque test. Appeler une API et parler à une base de données sont rapides, Opérations \u0026ldquo;sans tête\u0026rdquo; qui ne nécessitent pas le processus coûteux de ouvrir un navigateur, naviguer vers les bonnes pages, cliquer et attendre que les formulaires soient soumis, etc.\nIdéalement, vous pouvez traiter cette phase de configuration en une seule ligne de code, qui s\u0026rsquo;exécutera avant le lancement de tout navigateur:\nJava Python C# Ruby JavaScript Kotlin // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = user_factory.create_common_user() #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.get_email(), user.get_password())   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.CreateCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = LoginAs(user.Email, user.Password);   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = UserFactory.create_common_user #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.email, user.password)   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. var user = userFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. var accountPage = loginAs(user.email, user.password);   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. val user = UserFactory.createCommonUser() //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     Comme vous pouvez l\u0026rsquo;imaginer, la UserFactory peut être étendue pour fournir des méthodes telles que createAdminUser () et createUserWithPayment (). Le fait est que ces deux lignes de code ne vous distraient pas du but ultime de ce test: configurer une licorne.\nLes subtilités du modèle d\u0026rsquo;objet de page sera discuté dans les chapitres suivants, mais nous présenterons le concept ici:\nVos tests doivent être composés d\u0026rsquo;actions, réalisée du point de vue de l\u0026rsquo;utilisateur, dans le cadre des pages du site. Ces pages sont stockées en tant qu\u0026rsquo;objets, qui contiendra des informations spécifiques sur la composition de la page Web et comment les actions sont effectuées - dont très peu devrait vous concerner en tant que testeur.\nQuel genre de licorne veux-tu? Vous voudrez peut-être du rose, mais pas nécessairement. Le violet a été assez populaire ces derniers temps. A-t-elle besoin de lunettes de soleil? Tatouages ​​étoiles? Ces choix, bien que difficiles, sont votre principale préoccupation en tant que testeur - vous devez vous assurer que votre centre de traitement des commandes envoie la bonne licorne à la bonne personne, et cela commence par ces choix.\nNotez que nulle part dans ce paragraphe nous ne parlons de boutons, des champs, des listes déroulantes, des boutons radio ou des formulaires Web. Vos tests ne devraient pas non plus! Vous voulez écrire votre code comme l\u0026rsquo;utilisateur essayant de résoudre son problème. Voici une façon de procéder (à partir de l\u0026rsquo;exemple précédent):\nJava Python C# Ruby JavaScript Kotlin // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn() # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.Purple, UnicornAccessories.Sunglasses, UnicornAdornments.StarTattoos); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.AddUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.CreateUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn.new(\u0026#39;Sparkles\u0026#39;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. var sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there.  var addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. var unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. val addUnicornPage = accountPage.addUnicorn() // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     Maintenant que vous avez configuré votre licorne, vous devez passer à l'étape 3: vous assurer que cela a réellement fonctionné.\nJava Python C# Ruby JavaScript Kotlin // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles));   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.True(unicornConfirmationPage.Exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. expect(unicorn_confirmation_page.exists?(sparkles)).to be, \u0026#39;Sparkles should have been created, with all attributes intact\u0026#39;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assert(unicornConfirmationPage.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles))     Notez que le testeur n\u0026rsquo;a toujours rien fait d\u0026rsquo;autre que parler des licornes dans ce code - pas de boutons, pas de localisateurs, pas de commandes de navigateur. Cette méthode de modélisation de l\u0026rsquo;application vous permet de garder ces commandes de niveau test en place et immuables, même si Larry décide la semaine prochaine qu\u0026rsquo;il n\u0026rsquo;aime plus Ruby-on-Rails et décide de réimplémenter l\u0026rsquo;ensemble du site dans les dernières fixations Haskell avec un frontal Fortran.\nVos objets de page nécessiteront une petite maintenance afin de se conformer à la refonte du site, mais ces tests resteront les mêmes. En prenant cette conception de base, vous souhaiterez continuer à parcourir vos workflows avec le moins d'étapes possibles face au navigateur. Votre prochain workflow impliquera l\u0026rsquo;ajout d\u0026rsquo;une licorne au panier d\u0026rsquo;achat. Vous voudrez probablement de nombreuses itérations de ce test afin de vous assurer que le chariot conserve correctement son état: Y a-t-il plus d\u0026rsquo;une licorne dans le panier avant de commencer? Combien peuvent tenir dans le panier? Si vous en créez plusieurs avec le même nom et / ou les mêmes fonctionnalités, est-ce que cela cassera? Gardera-t-il seulement celui existant ou en ajoutera-t-il un autre?\nChaque fois que vous vous déplacez dans le flux de travail, vous voulez éviter d\u0026rsquo;avoir à créer un compte, connectez-vous en tant qu\u0026rsquo;utilisateur et configurez la licorne. Idéalement, vous pourrez créer un compte et pré-configurer une licorne via l\u0026rsquo;API ou la base de données. Il vous suffit ensuite de vous connecter en tant qu\u0026rsquo;utilisateur, de localiser Sparkles, et l\u0026rsquo;ajouter au panier.\nAutomatiser ou ne pas automatiser? L\u0026rsquo;automatisation est-elle toujours avantageuse? Quand faut-il décider d\u0026rsquo;automatiser le test cas?\nIl n\u0026rsquo;est pas toujours avantageux d\u0026rsquo;automatiser les cas de test. Il y a des moments où des tests manuels peuvent être plus appropriés. Par exemple, si l\u0026rsquo;utilisateur de l\u0026rsquo;application l\u0026rsquo;interface changera considérablement dans un avenir proche, alors toute automatisation pourrait avoir besoin d'être réécrit de toute façon. De plus, parfois, il n\u0026rsquo;y a tout simplement pas assez le temps de construire l\u0026rsquo;automatisation des tests. À court terme, les tests manuels peuvent être plus efficace. Si une demande a un délai très serré, il n’existe actuellement aucun l\u0026rsquo;automatisation des tests est disponible, et il est impératif que les tests soient effectués dans les ce délai, puis le test manuel est la meilleure solution.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/driver_idiosyncrasies/driver_specific_capabilities/",
	"title": "Capabilities spécifiques du Driver",
	"tags": [],
	"description": "",
	"content": "Firefox Définir les Capabilities à l\u0026rsquo;aide de \u0026ldquo;FirefoxOptions\u0026rdquo; FirefoxOptions est la nouvelle façon de définir les capacités de Firefox navigateur et doit généralement être utilisé de préférence à DesiredCapabilities.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   require \u0026#39;selenium-webdriver\u0026#39; opts = Selenium::WebDriver::Firefox::Options.new(args: [\u0026#39;-headless\u0026#39;]) driver = Selenium::WebDriver.for(:firefox, options: opts)   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.headless(); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     Définition d\u0026rsquo;un profil personnalisé Il est possible de créer un profil personnalisé pour Firefox comme illustré ci-dessous.\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   profile = Selenium::WebDriver::Firefox::Profile.new profile[\u0026#39;browser.download.dir\u0026#39;] = \u0026#34;/tmp/webdriver-downloads\u0026#34; options = Selenium::WebDriver::Firefox::Options.new(profile: profile) driver = Selenium::WebDriver.for :firefox, options: options   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); let profile = \u0026#39;/path to custom profile\u0026#39;; options.setProfile(profile); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer fileUploadDialogTimeout Dans certains environnements, Internet Explorer peut expirer lors de l\u0026rsquo;ouverture du Boîte de dialogue Téléchargement de fichier. IEDriver a un délai d\u0026rsquo;expiration par défaut de 1000 ms, mais vous peut augmenter le délai d\u0026rsquo;expiration à l\u0026rsquo;aide de la fonction fileUploadDialogTimeout.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.waitForUploadDialogUpTo(Duration.ofSeconds(2)); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.file_upload_dialog_timeout = 2000 driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.file_upload_dialog_timeout = 2000 driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().fileUploadDialogTimeout(2000); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.waitForUploadDialogUpTo(Duration.ofSeconds(2)) val driver = RemoteWebDriver(options)     ensureCleanSession When set to true, this capability clears the Cache, Browser History and Cookies for all running instances of InternetExplorer including those started manually or by the driver. By default, it is set to false.\nUsing this capability will cause performance drop while launching the browser, as the driver will wait until the cache gets cleared before launching the IE browser.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.destructivelyEnsureCleanSession(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ensure_clean_session = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.EnsureCleanSession = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ensure_clean_session = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ensureCleanSession(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.destructivelyEnsureCleanSession() val driver = RemoteWebDriver(options)     ignoreZoomSetting InternetExplorer driver expects the browser zoom level to be 100%, else the driver will throw an exception. This default behaviour can be disabled by setting the ignoreZoomSetting to true.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.ignoreZoomSettings(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_zoom_level = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IgnoreZoomLevel = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_zoom_level = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ignoreZoomSetting(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.ignoreZoomSettings() val driver = RemoteWebDriver(options)     ignoreProtectedModeSettings Whether to skip the Protected Mode check while launching a new IE session.\nIf not set and Protected Mode settings are not same for for all zones, an exception will be thrown by the driver.\nIf capability is set to true, tests may become flaky, unresponsive, or browsers may hang. However, this is still by far a second-best choice, and the first choice should always be to actually set the Protected Mode settings of each zone manually. If a user is using this property, only a \u0026ldquo;best effort\u0026rdquo; at support will be given.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.introduceFlakinessByIgnoringSecurityDomains(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_protected_mode_settings = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IntroduceInstabilityByIgnoringProtectedModeSettings = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_protected_mode_settings = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().introduceFlakinessByIgnoringProtectedModeSettings(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.introduceFlakinessByIgnoringSecurityDomains() val driver = RemoteWebDriver(options)     silent When set to true, this capability suppresses the diagnostic output of the IEDriverServer.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.setCapability(\u0026#34;silent\u0026#34;, true); WebDriver driver = new InternetExplorerDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.set_capability(\u0026#34;silent\u0026#34;, True) driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   InternetExplorerOptions options = new InternetExplorerOptions(); options.AddAdditionalInternetExplorerOption(\u0026#34;silent\u0026#34;, true); IWebDriver driver = new InternetExplorerDriver(options);   # Please raise a PR to add code sample   const {Builder,By, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); let caps = Capabilities.ie(); caps.set(\u0026#39;silent\u0026#39;, true); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;internet explorer\u0026#39;) .withCapabilities(caps) .build(); try { await driver.get(\u0026#39;http://www.google.com/ncr\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.setCapability(\u0026#34;silent\u0026#34;, true) val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     IE Command-Line Options Internet Explorer includes several command-line options that enable you to troubleshoot and configure the browser.\nThe following describes few supported command-line options\n  -private : Used to start IE in private browsing mode. This works for IE 8 and later versions.\n  -k : Starts Internet Explorer in kiosk mode. The browser opens in a maximized window that does not display the address bar, the navigation buttons, or the status bar.\n  -extoff : Starts IE in no add-on mode. This option specifically used to troubleshoot problems with browser add-ons. Works in IE 7 and later versions.\n  Note: forceCreateProcessApi should to enabled in-order for command line arguments to work.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.add_argument(\u0026#39;-private\u0026#39;) options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; options.BrowserCommandLineArguments = \u0026#34;-k\u0026#34;; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true options.add_argument(\u0026#39;-k\u0026#39;) driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.addBrowserCommandSwitches(\u0026#39;-k\u0026#39;); options.addBrowserCommandSwitches(\u0026#39;-private\u0026#39;); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps); } finally { driver.quit(); } }     forceCreateProcessApi Forces launching Internet Explorer using the CreateProcess API. The default value is false.\nFor IE 8 and above, this option requires the \u0026ldquo;TabProcGrowth\u0026rdquo; registry value to be set to 0.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps) } finally { driver.quit(); } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/grid/components_of_a_grid/",
	"title": "Composant d&#39;une Grid",
	"tags": [],
	"description": "",
	"content": "Hub  Intermédiaire et gestionnaire Accepte les demandes d\u0026rsquo;exécution de tests Prend les instructions du client et les exécute à distance sur les nœuds Gère les threads  Un Hub est un point central où tous vos tests sont envoyés. Chaque grille de sélénium se compose exactement d\u0026rsquo;un concentrateur. Le hub doit être accessible des clients respectifs (c.-à-d. serveur CI, machine développeur, etc.) Le concentrateur connectera un ou plusieurs nœuds auquel les tests seront délégués.\nNodes  Où vivent les navigateurs S\u0026rsquo;enregistre auprès du hub et communique ses capacités Reçoit les demandes du hub et les exécute  Nodes sont différentes instances de Selenium qui exécutera des tests sur des systèmes informatiques individuels. Il peut y avoir plusieurs nœuds dans une grille. Les machines qui sont des nœuds n\u0026rsquo;ont pas besoin d'être la même plate-forme ou avoir la même sélection de navigateur que celle du concentrateur ou des autres nœuds. Un nœud sous Windows peut avoir la capacité de offrant Internet Explorer comme option de navigateur, alors que cela ne serait pas possible sur Linux ou Mac.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/front_matter/typographical_conventions/",
	"title": "Conventions typographique",
	"tags": [],
	"description": "",
	"content": "Capitalisation des titres Il faut éviter la capitalisation du titre, comme A Very Fine Heading, et optez plutôt pour un titre très fin. Capitalisation gratuite ou casse de titre, montrent souvent un malentendu - ou un mépris pour - conventions orthographiques. Nous préférons ce que l\u0026rsquo;on appelle le \u0026ldquo;cas de peine\u0026rdquo;, avec un seul capital initial pour démarrer les en-têtes.\nLongueur de la ligne Lors de la modification de la source de la documentation, qui est écrit en HTML simple, limitez la longueur de vos lignes à environ 72 caractères.\nCertains d\u0026rsquo;entre nous vont encore plus loin et utiliser ce qu\u0026rsquo;on appelle semantic linefeeds, qui est une technique par laquelle les lignes source HTML, qui ne sont pas lus par le public, sont divisés à des \u0026ldquo;ruptures naturelles\u0026rdquo; dans la prose. En d\u0026rsquo;autres termes, les phrases sont divisées aux pauses naturelles entre les clauses. Au lieu de s\u0026rsquo;embêter avec les lignes de chaque paragraphe de sorte qu\u0026rsquo;ils se terminent tous près de la marge droite, les sauts de ligne peuvent être ajoutés n\u0026rsquo;importe où qu\u0026rsquo;il y a une rupture entre les idées.\nCela peut rendre les différences très faciles à lire lors de la collaboration via git, mais ce n\u0026rsquo;est pas quelque chose que nous imposons aux contributeurs d\u0026rsquo;utiliser.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "Driver tiers et plugins",
	"tags": [],
	"description": "",
	"content": "Selenium peut être étendu à travers l\u0026rsquo;utilisation de plugins. Vous trouverez ici un certain nombre de plugins créés et maintenus par des tierces parties. Pour de plus amples information sur la création de plugin ou pour en ajouter à la liste, consultez la documentation.\nVeuillez noter que ces plugins ne sont pas supportés, maintenus ou hébergés par le projet Selenium. De plus, soyez avertis que les plugins listés ci-dessous ne sont pas nécessairement sous Apache License v.2.0. Certains de ces plugins sont disponibles sous une autre licence libre et gratuite; d\u0026rsquo;autres ne sont disponibles que sous licence propriétaire. Toute question à propos de ces plugins et de leur licence de distribution doit être évoquée avec leur(s) développeur(s) respectif.\n   Browser Latest Change log Issue Tracker     Mozilla GeckoDriver latest change log issue tracker   Google Chrome Driver latest change log issue tracker   Opera latest - issue tracker   Microsoft Edge Driver latest - issue tracker   SafariDriver Built in - issue tracker    "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/selenium_installation/installing_webdriver_binaries/",
	"title": "Installer les binaires WebDriver",
	"tags": [],
	"description": "",
	"content": "Pour exécuter votre projet et contrôler le navigateur, vous devez installer des binaires WebDriver spécifiques au navigateur.\nTéléchargez le binaire WebDriver pris en charge par votre navigateur et placez-le dans le CHEMIN système.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction Selenium est un projet englobant un ensemble d\u0026rsquo;outil et de librairies rendant possible l\u0026rsquo;automatisation de navigateur web.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/domain_specific_language/",
	"title": "Langue spécifique au domaine",
	"tags": [],
	"description": "",
	"content": "Une langue spécifique au domaine (DSL) est un système qui fournit à l\u0026rsquo;utilisateur un moyen expressif de résoudre un problème. Il permet à un utilisateur de interagir avec le système à leurs conditions - pas seulement parler de programmeur.\nVos utilisateurs, en général, ne se soucient pas de l\u0026rsquo;apparence de votre site. Ils ne se soucient de la décoration, des animations ou des graphismes. Ils voulez utiliser votre système pour pousser leurs nouveaux employés à travers le processus avec une difficulté minimale; ils veulent réserver un voyage en Alaska; ils veulent configurer et acheter des licornes à prix réduit. Votre travail en tant que testeur doit se rapprocher le plus possible de la «capture» de cet état d\u0026rsquo;esprit. Dans cet esprit, nous avons entrepris de \u0026ldquo;modéliser\u0026rdquo; l\u0026rsquo;application que vous êtes travailler, de telle sorte que les scripts de test (la seule version préliminaire de l\u0026rsquo;utilisateur proxy) \u0026ldquo;parler\u0026rdquo; et représenter l\u0026rsquo;utilisateur.\nAvec Selenium, DSL est généralement représenté par des méthodes, écrites pour l\u0026rsquo;API simple et lisible - ils permettent un rapport entre le les développeurs et les parties prenantes (utilisateurs, propriétaires de produits, spécialistes du renseignement, etc.).\nBenefits  Lisible: Les parties prenantes commerciales peuvent le comprendre. Inscriptible: Facile à écrire, évite les doublons inutiles. Extensible: La fonctionnalité peut (raisonnablement) être ajoutée sans rompre les contrats et les fonctionnalités existantes. Maintenable: En laissant les détails de mise en œuvre hors de test cas, vous êtes bien isolé contre les modifications de l\u0026rsquo;AUT*.  Java Voici un exemple d\u0026rsquo;une méthode DSL raisonnable en Java. Par souci de concision, il suppose que l\u0026rsquo;objet driver est prédéfini et disponible pour la méthode.\n/** * Takes a username and password, fills out the fields, and clicks \u0026#34;login\u0026#34;. * @return An instance of the AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Fill out the password field. The locator we\u0026#39;re using is \u0026#34;By.id\u0026#34;, and we should  // have it defined elsewhere in the class.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Click the login button, which happens to have the id \u0026#34;submit\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Create and return a new instance of the AccountPage (via the built-in Selenium  // PageFactory).  return PageFactory.newInstance(AccountPage.class); } Cette méthode résume complètement les concepts de champs de saisie, des boutons, des clics et même des pages de votre code de test. Utiliser ceci approche, tout ce qu\u0026rsquo;un testeur doit faire est d\u0026rsquo;appeler cette méthode. Cela donne vous un avantage de maintenance: si les champs de connexion ont changé, vous n\u0026rsquo;aurait qu'à changer cette méthode - pas vos tests.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Now that we\u0026#39;re logged in, do some other stuff--since we used a DSL to support  // our testers, it\u0026#39;s as easy as choosing from available methods.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Something should have been done!\u0026#34;, something.wasDone()); // Note that we still haven\u0026#39;t referred to a button or web control anywhere in this  // script... } Il faut le répéter: l\u0026rsquo;un de vos principaux objectifs devrait être de rédiger un API qui permet à vos tests de répondre le problème à portée de main, et NON le problème de l\u0026rsquo;interface utilisateur. L\u0026rsquo;interface utilisateur est une préoccupation secondaire pour votre utilisateurs - ils ne se soucient pas de l\u0026rsquo;interface utilisateur, ils veulent juste obtenir leur emploi terminé. Vos scripts de test doivent se lire comme une liste de choses à laver l\u0026rsquo;utilisateur veut FAIRE et ce qu\u0026rsquo;il veut SAVOIR. Les tests ne devrait pas se préoccuper de la façon dont l\u0026rsquo;interface utilisateur vous oblige à aller à propos de ça.\n*AUT: Application under test\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/remote_webdriver/remote_webdriver_client/",
	"title": "Le client Remote WebDriver",
	"tags": [],
	"description": "",
	"content": "Pour exécuter un client WebDriver distant, nous devons d\u0026rsquo;abord nous connecter au RemoteWebDriver. Nous le faisons en pointant l\u0026rsquo;URL vers l\u0026rsquo;adresse du serveur exécutant nos tests. Afin de personnaliser notre configuration, nous avons défini les capacités souhaitées. Voici un exemple d\u0026rsquo;instanciation d\u0026rsquo;un objet WebDriver distant pointant vers notre serveur Web distant, www.example.com, exécuter nos tests sur Firefox.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver firefox_options = webdriver.FirefoxOptions() driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=firefox_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); var capabilities = Capabilities.firefox(); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     Pour personnaliser davantage notre configuration de test, nous pouvons ajouter d\u0026rsquo;autres fonctionnalités souhaitées.\nOptions du navigateur Par exemple, supposons que vous vouliez exécuter Chrome sur Windows XP, en utilisant la version 67 de Chrome:\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.set_capability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chrome_options.set_capability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=chrome_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var chromeOptions = new ChromeOptions(); chromeOptions.BrowserVersion = \u0026#34;67\u0026#34;; chromeOptions.PlatformName = \u0026#34;Windows XP\u0026#34;; IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); const chrome = require(\u0026#34;selenium-webdriver/chrome\u0026#34;) var capabilities = Capabilities.chrome(); //To avoid InsecureCertificateError for selenium4-aplha5 capabilities.setAcceptInsecureCerts(true); capabilities.set(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); capabilities.set(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit();     Détecteur de fichiers local Le détecteur de fichiers local permet le transfert de fichiers depuis le client machine au serveur distant. Par exemple, si un test doit télécharger un fichier vers une application Web, un WebDriver distant peut transférer automatiquement le fichier de la machine locale au serveur Web distant pendant Durée. Cela permet au fichier d'être téléchargé depuis la machine distante exécuter le test. Il n\u0026rsquo;est pas activé par défaut et peut être activé dans de la manière suivante:\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   from selenium.webdriver.remote.file_detector import LocalFileDetector driver.file_detector = LocalFileDetector()   var allowsDetection = this.driver as IAllowsFileDetection; if (allowsDetection != null) { allowsDetection.FileDetector = new LocalFileDetector(); }   @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   var remote = require(\u0026#39;selenium-webdriver/remote\u0026#39;); driver.setFileDetector(new remote.FileDetector);   driver.fileDetector = LocalFileDetector()     Une fois le code ci-dessus défini, vous pouvez télécharger un fichier dans votre test de la manière suivante:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) driver.find_element(By.ID, \u0026#34;myfile\u0026#34;).send_keys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)   driver.Navigate().GoToUrl(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); IWebElement upload = driver.FindElement(By.Id(\u0026#34;myfile\u0026#34;)); upload.SendKeys(@\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); var upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/driver_requirements/",
	"title": "Les pré-requis de WebDriver",
	"tags": [],
	"description": "",
	"content": "Grâce à WebDriver, Selenium prend en charge tous les principaux navigateurs du marché tels que Chrom(ium), Firefox, Internet Explorer, Opera et Safari. Dans la mesure du possible, WebDriver pilote le navigateur en utilisant la prise en charge intégrée du navigateur pour l\u0026rsquo;automatisation, bien que tous les navigateurs n\u0026rsquo;aient pas de support officiel pour la télécommande.\nL\u0026rsquo;objectif de WebDriver est d'émuler l\u0026rsquo;interaction d\u0026rsquo;un utilisateur réel avec le navigateur le plus près possible. Cela est possible à différents niveaux dans différents navigateurs. Pour plus de détails sur les différentes particularités des pilotes, veuillez consulter Idiosyncracies des pilotes.\nMême si tous les pilotes partagent une seule interface utilisateur pour contrôler le navigateur, ils ont des façons légèrement différentes de configurer des sessions de navigateur. Étant donné que de nombreuses implémentations de pilotes sont fournies par des tiers, ils ne sont pas inclus dans la distribution standard de sélénium.\nInstanciation du pilote, gestion des profils et divers paramètres spécifiques au navigateur sont des exemples de paramètres qui ont des exigences différentes selon le navigateur. Cette section explique les exigences de base pour vous familiariser avec les différents navigateurs.\nAjout d\u0026rsquo;exécutables à votre PATH La plupart des pilotes nécessitent un exécutable supplémentaire pour que Selenium puisse communiquer avec le navigateur. Vous pouvez spécifier manuellement l\u0026rsquo;emplacement de l\u0026rsquo;exécutable avant de démarrer WebDriver, mais cela peut rendre vos tests moins portables, car les exécutables devront être au même endroit sur chaque machine, ou inclus dans votre référentiel de code de test.\nEn ajoutant un dossier contenant les binaires de WebDriver à votre système chemin d\u0026rsquo;accès, Selenium pourra localiser les binaires supplémentaires sans nécessitant votre code de test pour localiser l\u0026rsquo;emplacement exact du pilote.\n  Créez un répertoire dans lequel placer les exécutables, comme C:\\WebDriver\\bin or /opt/WebDriver/bin\n  Ajoutez le répertoire à votre CHEMIN:\n  Sous Windows - Ouvrez une invite de commande en tant qu\u0026rsquo;administrateur et exécutez la commande suivante pour ajouter en permanence le répertoire à votre chemin pour tous les utilisateurs de votre machine:\nsetx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34;   Utilisateurs Bash sur macOS et Linux - Dans un terminal:\nexport PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile     Vous êtes maintenant prêt à tester vos modifications. Fermez toutes les invites de commande ouvertes et ouvrez-en une nouvelle. Tapez le nom de l\u0026rsquo;un des binaires dans le dossier que vous avez créé à l'étape précédente, par exemple:\nchromedriver   Si votre PATH est configuré correctement, vous verrez une sortie relative au démarrage du pilote:\nStarting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed.   Vous pouvez reprendre le contrôle de votre invite de commande en appuyant sur Ctrl + C Référence rapide    Browser Supported OS Maintained by Download Issue Tracker     Chromium/Chrome Windows/macOS/Linux Google Downloads Issues   Firefox Windows/macOS/Linux Mozilla Downloads Issues   Edge Windows 10 Microsoft Downloads Issues   Internet Explorer Windows Selenium Project Downloads Issues   Safari macOS El Capitan and newer Apple Built in Issues   Opera Windows/macOS/Linux Opera Downloads Issues    Chromium/Chrome Pour conduire Chrome ou Chromium, vous devez télécharger chromedriver et placez-le dans un dossier qui se trouve sur le chemin de votre système.\nSous Linux ou macOS, cela signifie modifier la variable d\u0026rsquo;environnement PATH. Vous pouvez voir quels répertoires, séparés par deux points, créez le chemin de votre système en exécutant la commande suivante:\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin Pour inclure chromedriver sur le chemin si ce n\u0026rsquo;est pas déjà fait, assurez-vous d\u0026rsquo;inclure le répertoire parent du binaire chromedriver. La ligne suivante définira la variable d\u0026rsquo;environnement PATH son contenu actuel, plus un chemin supplémentaire ajouté après les deux points:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; Lorsque chromedriver est disponible sur votre chemin, vous devriez pouvoir exécuter l\u0026rsquo;exécutable chromedriver à partir de n\u0026rsquo;importe quel répertoire.\nPour instancier une session Chrome / Chromium, vous pouvez procéder comme suit:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Simple assignment from selenium.webdriver import Chrome driver = Chrome() #Or use the context manager from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     N\u0026rsquo;oubliez pas que vous devez définir le chemin d\u0026rsquo;accès à l\u0026rsquo;exécutable chromedriver. Ceci est possible en utilisant la ligne suivante:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     Le chromedriver est implémenté en tant que serveur distant WebDriver qu\u0026rsquo;en exposant l\u0026rsquo;interface proxy d\u0026rsquo;automatisation interne de Chrome indique au navigateur quoi faire.\nFirefox Depuis Selenium 3, Mozilla a pris en charge la mise en œuvre de Pilote Firefox, avec geckodriver. Le nouveau pilote pour Firefox s\u0026rsquo;appelle geckodriver et fonctionne avec Firefox 48 et plus récent. Étant donné que Firefox WebDriver est en cours de développement, le plus la version Firefox est récente, meilleur est le support.\nComme geckodriver est la nouvelle façon par défaut de lancer Firefox, vous pouvez instancier Firefox de la même manière que Selenium 2:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Simple assignment from selenium.webdriver import Firefox driver = Firefox() #Or use the context manager from selenium.webdriver import Firefox with Firefox() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     Si vous préférez ne pas définir l\u0026rsquo;emplacement du geckodriver à l\u0026rsquo;aide de PATH, définissez l\u0026rsquo;emplacement binaire de geckodriver par programme:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.setBinary(\u0026#34;/path/to/geckodriver\u0026#34;);   System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     Il est également possible de définir la propriété au moment de l\u0026rsquo;exécution:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver Il est actuellement possible de revenir à l\u0026rsquo;ancienne, plus de fonctionnalités complètes Pilote Firefox, en installant Firefox 47.0.1 ou 45 ESR et en spécifiant une capacité souhaitée de marionnette comme false. Les versions ultérieures de Firefox ne sont plus compatibles.\nEdge Edge est le plus récent navigateur de Microsoft, inclus avec Windows 10 et Server 2016. Les mises à jour d\u0026rsquo;Edge sont regroupées avec les principales mises à jour Windows, vous devrez donc télécharger un fichier binaire qui correspond au numéro de version de votre version de Windows actuellement installée. Le site des développeurs Edge contient des liens vers tous les binaires disponibles. Bugs contre EdgeDriver la mise en œuvre peut être augmentée avec Microsoft. Si vous souhaitez exécuter des tests sur Edge, mais que vous n\u0026rsquo;exécutez pas Windows 10, Microsoft offrir des machines virtuelles gratuites aux testeurs sur le site des développeurs Edge.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Simple assignment from selenium.webdriver import Edge driver = Edge() #Or use the context manager from selenium.webdriver import Edge with Edge() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     Si le pilote Edge n\u0026rsquo;est pas présent dans votre chemin, vous pouvez définir le chemin à l\u0026rsquo;aide de la ligne suivante:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const edge = require(\u0026#39;selenium-webdriver/edge\u0026#39;); let service = new edge.ServiceBuilder(\u0026#34;/path/to/msedgedriver.exe\u0026#34;); (async function test() { let driver = await new Builder() .setEdgeService(service) .forBrowser(\u0026#39;MicrosoftEdge\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     Internet Explorer Internet Explorer était le navigateur par défaut de Microsoft jusqu'à Windows 10, bien qu\u0026rsquo;il est toujours inclus dans Windows 10. Le pilote Internet Explorer est le seul pilote Le projet Selenium vise à supporter les mêmes versions Microsoft considère actuel. Les versions plus anciennes peuvent fonctionner, mais ne seront pas prises en charge.\nAlors que le projet Selenium fournit des binaires pour les 32 bits et 64 bits versions d\u0026rsquo;Internet Explorer, il y en a limitations avec Internet Explorer 10 et 11 avec le pilote 64 bits, mais en utilisant le 32 bits le conducteur continue de bien fonctionner. Il convient de noter que, comme Internet Explorer les préférences sont enregistrées sur le compte de l\u0026rsquo;utilisateur connecté, certaines une configuration supplémentaire est requise.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Simple assignment from selenium.webdriver import Ie driver = Ie() #Or use the context manager from selenium.webdriver import Ie with Ie() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     Si le pilote Internet Explorer n\u0026rsquo;est pas présent dans votre chemin, vous pouvez définir le chemin en utilisant la ligne suivante:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let service = new ie.ServiceBuilder(\u0026#34;/path/to/IEDriverServer.exe\u0026#34;); (async function test() { let driver = await new Builder() .setIeService(service) .forBrowser(\u0026#39;internet explorer\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     Microsoft propose également un binaire WebDriver pour Internet Explorer 11 sur Windows 7 et 8.1. Il n\u0026rsquo;a pas été mis à jour depuis 2014 et est basé sur une version provisoire du Spécifications W3. Jim Evans a une excellente synthèse sur la mise en œuvre de Microsoft.\nOpera Les versions actuelles d\u0026rsquo;Opera sont construites sur le moteur Chromium, et WebDriver est désormais pris en charge via la source fermée Pilote Opera Chromium, qui peut être ajouté à votre CHEMIN ou en tant que propriété système.\nL\u0026rsquo;instanciation d\u0026rsquo;une session de pilote est similaire à Firefox et Chromium:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Simple assignment from selenium.webdriver import Opera driver = Opera() #Or use the context manager from selenium.webdriver import Opera with Opera() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const opera = require(\u0026#39;selenium-webdriver/opera\u0026#39;); (async function test() { let driver = await new Builder() .forBrowser(\u0026#39;opera\u0026#39;) .build(); })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari High Sierra et plus tard:\n Exécutez la commande suivante à partir du terminal pour la première l\u0026rsquo;heure et tapez votre mot de passe à l\u0026rsquo;invite pour autoriser WebDriver  safaridriver --enable El Capitan and Sierra:\n Activer le menu développeur à partir des préférences de Safari Cochez l\u0026rsquo;option Allow Remote Automation à partir de avec le menu Développer Exécutez la commande suivante à partir du terminal pour la première l\u0026rsquo;heure et tapez votre mot de passe à l\u0026rsquo;invite pour autoriser WebDriver  /usr/bin/safaridriver -p 1337\u0026lt;/ Vous pouvez ensuite démarrer une session de pilote en utilisant:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Simple assignment from selenium.webdriver import Safari driver = Safari() #Or use the context manager from selenium.webdriver import Safari with Safari() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     Ceux qui cherchent à automatiser Safari sur iOS devraient regarder Projet Appium. Alors que Safari était auparavant disponible pour Windows, Apple a depuis longtemps abandonné le support, ce qui en fait un mauvais choix de plateforme de test.\nNavigateur simulé HtmlUnit HtmlUnit est un \u0026ldquo;navigateur sans interface graphique pour les programmes Java\u0026rdquo;. Il modélise des documents HTML et fournit une API qui vous permet d\u0026rsquo;appeler des pages, de remplir des formulaires, de cliquer sur liens, etc. Il prend en charge JavaScript et est capable de travailler avec les bibliothèques AJAX, simulation de Chrome, Firefox ou Internet Explorer selon la configuration utilisé. Il a été déplacé vers un nouvel emplacement. La source est maintenue sur svn.\nPhantomJS PhantomJS est un navigateur sans tête basé sur Webkit, bien qu\u0026rsquo;une version beaucoup plus ancienne que celle utilisée par Google Chrome ou Safari. Bien qu\u0026rsquo;historiquement populaire choix, il serait désormais sage d'éviter PhantomJS. Le projet a été non entretenu depuis le 5 août, Ainsi, même si le Web continuera de changer, PhantomJS ne sera pas mis à jour. Ce fut après que Google a annoncé la possibilité d\u0026rsquo;exécuter Chrome sans tête, quelque chose aussi maintenant offert par Firefox de Mozilla.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/legacy_docs/migrating_from_rc_to_webdriver/",
	"title": "Migrating from RC to WebDriver",
	"tags": [],
	"description": "",
	"content": "Comment migrer vers Selenium WebDriver Une question fréquente lors de l\u0026rsquo;adoption de Selenium 2 est la bonne chose à faire lors de l\u0026rsquo;ajout de nouveaux tests à un ensemble de tests existant? Utilisateurs nouveaux dans le Le framework peut commencer par utiliser les nouvelles API WebDriver pour écrire leurs tests. Mais qu\u0026rsquo;en est-il des utilisateurs qui ont déjà des suites de tests existants? Ce guide est conçu pour montrer comment migrer vos tests existants vers les nouvelles API, permettant à tous les nouveaux tests d'être écrits en utilisant les nouvelles fonctionnalités offertes par WebDriver.\nLa méthode présentée ici décrit une migration fragmentaire vers le WebDriver API sans avoir à tout retravailler en une seule poussée massive. Ça signifie que vous pouvez accorder plus de temps pour la migration de vos tests existants, qui peut vous aider à décider où dépenser vos efforts.\nCe guide est écrit en utilisant Java, car il a le meilleur support pour faire la migration. Comme nous fournissons de meilleurs outils pour d\u0026rsquo;autres langues, ce guide sera élargi pour inclure ces langues.\nPourquoi migrer vers WebDriver Le déplacement d\u0026rsquo;une suite de tests d\u0026rsquo;une API à une autre API nécessite une énorme quantité d\u0026rsquo;effort. Pourquoi voudriez-vous, vous et votre équipe, envisager cette démarche? Voici quelques raisons pour lesquelles vous devriez envisager de migrer vos tests de Selenium pour utiliser WebDriver.\n API plus petite et compacte. L\u0026rsquo;API de WebDriver est plus orientée objet que le API d\u0026rsquo;origine Selenium RC. Cela peut faciliter le travail avec. Meilleure émulation des interactions utilisateur. Dans la mesure du possible, WebDriver fait utilisation d'événements natifs pour interagir avec une page Web. Cela de plus près imite la façon dont vos utilisateurs travaillent avec votre site et vos applications. En plus, WebDriver propose les API d\u0026rsquo;interaction utilisateur avancées qui vous permettent de modélisez des interactions complexes avec votre site. Prise en charge par les fournisseurs de navigateurs. Opera, Mozilla et Google sont tous actifs participants au développement de WebDriver, et chacun a des ingénieurs travaillant pour améliorer le cadre. Souvent, cela signifie que la prise en charge de WebDriver est intégré dans le navigateur lui-même: vos tests s\u0026rsquo;exécutent aussi rapidement et aussi stable que possible.  Avant de commencer Afin de rendre le processus de migration aussi indolore que possible, faites assurez-vous que tous vos tests fonctionnent correctement avec la dernière version de Selenium. Cela peut sembler évident, mais il vaut mieux le dire!\nCommencer La première étape lors du démarrage de la migration consiste à modifier la façon dont vous obtenez votre instance de Selenium. Lorsque vous utilisez Selenium RC, cela se fait comme suit:\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); Cela devrait être remplacé comme suit:\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); Prochaines étapes Une fois vos tests exécutés sans erreur, la prochaine étape consiste à migrer le code de test réel pour utiliser les API WebDriver. Selon la façon dont bien abstrait votre code est, cela peut être un processus court ou long. Dans les deux cas, l\u0026rsquo;approche est la même et peut se résumer simplement: modifier le code pour utiliser la nouvelle API lorsque vous venez de le modifier.\nSi vous devez extraire l\u0026rsquo;implémentation WebDriver sous-jacente de l\u0026rsquo;instance de Selenium, vous pouvez simplement la lancer sur WrapsDriver:\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); Cela vous permet de continuer à transmettre l\u0026rsquo;instance Selenium comme normal, mais pour déballer l\u0026rsquo;instance WebDriver comme requis.\nÀ un moment donné, votre base de code utilisera principalement les nouvelles API. À ce stade, vous pouvez inverser la relation en utilisant WebDriver et instancier une instance de Selenium à la demande:\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); Problèmes communs Heureusement, vous n'êtes pas la première personne à traverser cette migration, voici donc quelques problèmes communs que d\u0026rsquo;autres ont vus, et comment les résoudre.\nCliquer et taper est plus complet Un schéma courant dans un test Selenium RC est de voir quelque chose comme:\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); Cela repose sur le fait que \u0026ldquo;type\u0026rdquo; remplace simplement le contenu du élément identifié sans déclencher également tous les événements qui normalement être renvoyé si un utilisateur interagit avec la page. Les invocations directes finales de \u0026ldquo;clé*\u0026rdquo; provoque le déclenchement des gestionnaires JS comme prévu.\nLors de l\u0026rsquo;utilisation de WebDriverBackedSelenium, le résultat du remplissage du formulaire serait \u0026ldquo;texttt excitant\u0026rdquo;: pas ce que vous attendez! La raison de cela est que WebDriver émule plus précisément le comportement des utilisateurs, et aura donc a tiré des événements tout au long.\nCe même fait peut parfois déclencher un chargement de page plus tôt qu\u0026rsquo;il ne le ferait faire dans un test de sélénium 1. Vous pouvez dire que cela s\u0026rsquo;est produit si un \u0026ldquo;StaleElementException\u0026rdquo; est levé par WebDriver.\nWaitForPageToLoad revient trop tôt Découvrir quand un chargement de page est terminé est une entreprise délicate. Voulons-nous \u0026ldquo;lorsque l'événement de chargement se déclenche\u0026rdquo;, \u0026ldquo;lorsque toutes les requêtes AJAX sont terminées\u0026rdquo;, \u0026ldquo;lorsque il n\u0026rsquo;y a pas de trafic réseau \u0026ldquo;,\u0026rdquo; lorsque document.readyState a changé \u0026ldquo;ou quelque chose sinon entièrement?\nWebDriver tente de simuler le comportement d\u0026rsquo;origine de Selenium, mais cela ne fonctionnent toujours parfaitement pour diverses raisons. La raison la plus courante est que c\u0026rsquo;est difficile de faire la différence entre un chargement de page n\u0026rsquo;ayant pas encore commencé et un chargement de page terminé entre les appels de méthode. Cela signifie parfois que le contrôle revient à votre test avant que la page ne soit terminée (ou même commencée!) chargement.\nLa solution est d\u0026rsquo;attendre quelque chose de spécifique. Généralement, cela pourrait être pour l'élément avec lequel vous souhaitez interagir ensuite, ou pour une variable Javascript à définir sur une valeur spécifique. Un exemple serait:\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, Duration.ofSeconds(30)); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); Où \u0026ldquo;visibilityOfElementLocated\u0026rdquo; est implémenté comme:\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } Cela peut sembler complexe, mais c\u0026rsquo;est presque tout le code de la plaque de la chaudière. Le seul bit intéressant est que le \u0026ldquo;ExpectedCondition\u0026rdquo; sera évalué à plusieurs reprises jusqu'à ce que la méthode \u0026ldquo;apply\u0026rdquo; renvoie quelque chose qui n\u0026rsquo;est ni \u0026ldquo;null\u0026rdquo; ni Boolean.FALSE.\nBien sûr, l\u0026rsquo;ajout de tous ces appels \u0026ldquo;d\u0026rsquo;attente\u0026rdquo; peut encombrer votre code. Si c\u0026rsquo;est le cas, et vos besoins sont simples, pensez à utiliser les attentes implicites:\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); En faisant cela, chaque fois qu\u0026rsquo;un élément est localisé, si l'élément n\u0026rsquo;est pas présent, l\u0026rsquo;emplacement est réessayé jusqu'à ce qu\u0026rsquo;il soit présent ou jusqu'à 30 secondes passé.\nTrouver par XPath ou sélecteurs CSS ne fonctionne pas toujours, mais cela fonctionne avec Selenium 1 Dans Selenium 1, il était courant que xpath utilise une bibliothèque groupée plutôt que les capacités du navigateur lui-même. WebDriver utilisera toujours le natif méthodes de navigateur, sauf s\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;autre alternative. Cela signifie que xpath complexe les expressions peuvent se briser sur certains navigateurs.\nLes sélecteurs CSS dans Selenium 1 ont été implémentés à l\u0026rsquo;aide de la bibliothèque Sizzle. Cette implémente un surensemble de la spécification CSS Selector, et il n\u0026rsquo;est pas toujours clair où vous avez franchi la ligne. Si vous utilisez WebDriverBackedSelenium et utilisez un Sizzle locator au lieu d\u0026rsquo;un CSS Selector pour trouver des éléments, un avertissement être connecté à la console. Cela vaut la peine de prendre le temps de les chercher, en particulier si les tests échouent faute de pouvoir trouver des éléments.\nIl n\u0026rsquo;y a pas de Browserbot Selenium RC était basé sur Selenium Core, et donc lorsque vous avez exécuté JavaScript, vous pouvez accéder à des morceaux de Selenium Core pour faciliter les choses. Comme WebDriver n\u0026rsquo;est pas basé sur Selenium Core, cela n\u0026rsquo;est plus possible. Comment savoir si vous utilisez Selenium Core? Facile! Regardez juste pour voir si vos appels \u0026ldquo;getEval\u0026rdquo; ou similaires utilisent \u0026ldquo;Selenium\u0026rdquo; ou \u0026ldquo;browserbot\u0026rdquo; dans le Javascript évalué.\nVous utilisez peut-être le navigateur pour obtenir un descripteur de la fenêtre actuelle ou document du test. Heureusement, WebDriver évalue toujours JS dans le contexte de la fenêtre en cours, vous pouvez donc utiliser directement \u0026ldquo;fenêtre\u0026rdquo; ou \u0026ldquo;document\u0026rdquo;.\nVous pouvez également utiliser le navigateur pour localiser des éléments. Dans WebDriver, l\u0026rsquo;idiome pour ce faire est de localiser d\u0026rsquo;abord l'élément, puis passez cela comme argument au Javascript. Donc:\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); devient:\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); Remarquez comment la variable \u0026ldquo;element\u0026rdquo; passée apparaît comme premier élément dans le tableau \u0026ldquo;arguments\u0026rdquo; standard de JS.\nExecuting Javascript Doesn\u0026rsquo;t Return Anything JavascriptExecutor de WebDriver encapsulera tous les JS et l'évaluera comme une expression anonyme. Cela signifie que vous devez utiliser le mot-clé \u0026ldquo;retour\u0026rdquo;:\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); devient:\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;); "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/support_packages/working_with_colours/",
	"title": "Travailler avec les couleurs",
	"tags": [],
	"description": "",
	"content": "Vous voudrez parfois valider la couleur de quelque chose dans le cadre de vos tests; le problème est que les définitions de couleurs sur le Web ne sont pas constantes. Ne serait-ce pas bien s\u0026rsquo;il y avait un moyen facile de comparer une représentation HEX d\u0026rsquo;une couleur avec une représentation RGB d\u0026rsquo;une couleur, ou une représentation RGBA d\u0026rsquo;une couleur avec une représentation HSLA d\u0026rsquo;une couleur?\nNe t\u0026rsquo;inquiètes pas. Il y a une solution: la classe Color!\nTout d\u0026rsquo;abord, vous devrez importer la classe:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.Color    Vous pouvez maintenant commencer à créer des objets de couleur. Chaque objet de couleur devra être créé à partir d\u0026rsquo;une représentation sous forme de chaîne de votre couleur. Les représentations de couleurs prises en charge sont:\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     La classe Color prend également en charge toutes les définitions de couleurs de base spécifié dans http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     Parfois, les navigateurs renvoient une valeur de couleur \u0026ldquo;transparente\u0026rdquo; si aucune couleur n\u0026rsquo;a été définie sur un élément. La classe Color prend également en charge ceci:\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     Vous pouvez désormais interroger un élément en toute sécurité pour obtenir sa couleur / couleur de fond sachant que toute réponse sera correctement analysée et converti en un objet Color valide:\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)); Color loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;));   login_button_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;))   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    login_button_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;))   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)) val loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;))     Vous pouvez ensuite comparer directement les objets de couleur:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour == HOTPINK)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.equals(HOTPINK))     Ou vous pouvez convertir la couleur dans l\u0026rsquo;un des formats suivants et effectuer une validation statique:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     Les couleurs ne sont plus un problème.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/worst_practices/file_downloads/",
	"title": "Téléchargement de fichier",
	"tags": [],
	"description": "",
	"content": "Bien qu\u0026rsquo;il soit possible de démarrer un téléchargement en cliquant sur un lien avec un navigateur sous le contrôle de Selenium, l\u0026rsquo;API n\u0026rsquo;expose pas la progression du téléchargement, ce qui n\u0026rsquo;est pas idéal pour tester les fichiers téléchargés. En effet, le téléchargement de fichiers n\u0026rsquo;est pas considéré comme un aspect important d'émuler l\u0026rsquo;interaction des utilisateurs avec la plate-forme Web. À la place, recherchez le lien à l\u0026rsquo;aide de Selenium (et tous les cookies requis) et le passer à une bibliothèque de requêtes HTTP comme libcurl.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/worst_practices/http_response_codes/",
	"title": "Codes réponse HTTP",
	"tags": [],
	"description": "",
	"content": "Pour certaines configurations de navigateur dans Selenium RC, Selenium a agi comme un proxy entre le navigateur et le site étant automatisé. Cela signifiait que tout le trafic du navigateur passait par Selenium pourrait être capturé ou manipulé. La méthode captureNetworkTraffic() censé capturer tout le trafic réseau entre le navigateur et le site étant automatisé, y compris les codes de réponse HTTP.\nSelenium WebDriver est une approche complètement différente à l\u0026rsquo;automatisation du navigateur, préférant agir plus comme un utilisateur et cela est représenté dans la façon dont vous écrivez des tests avec WebDriver. Dans les tests fonctionnels automatisés, vérification du code d'état n\u0026rsquo;est pas un détail particulièrement important de l'échec d\u0026rsquo;un test; les étapes qui l\u0026rsquo;ont précédé sont plus importantes.\nLe navigateur représentera toujours le code d'état HTTP, imaginez par exemple une page d\u0026rsquo;erreur 404 ou 500. Un moyen simple de \u0026ldquo;échouer rapidement\u0026rdquo; lorsque vous rencontrez l\u0026rsquo;une de ces pages d\u0026rsquo;erreur est de vérifier le titre de la page ou le contenu d\u0026rsquo;un point fiable (par exemple, la balise \u0026lt;h1\u0026gt;) après chaque chargement de page. Si vous utilisez le modèle d\u0026rsquo;objet de page, vous pouvez inclure cette vérification dans votre constructeur de classe ou un point similaire où le chargement de la page est prévu. Parfois, le code HTTP peut même être représenté dans la page d\u0026rsquo;erreur du navigateur et vous pouvez utiliser WebDriver pour lire ceci et améliorez votre sortie de débogage.\nLa vérification de la page Web elle-même est en ligne avec la pratique idéale de WebDriver de représenter et d\u0026rsquo;affirmer la vision de l\u0026rsquo;utilisateur du site Web.\nSi vous insistez, une solution avancée pour capturer les codes d'état HTTP consiste à reproduire le comportement de Selenium RC à l\u0026rsquo;aide d\u0026rsquo;un proxy. L\u0026rsquo;API WebDriver permet de définir un proxy pour le navigateur, et il existe un certain nombre de procurations qui vous permet de manipuler par programme le contenu des demandes envoyées et reçues du serveur Web. L\u0026rsquo;utilisation d\u0026rsquo;un proxy vous permet de décider comment vous souhaitez répondre aux codes de réponse de redirection. De plus, tous les navigateurs ne sont pas met les codes de réponse à la disposition de WebDriver, donc choisir d\u0026rsquo;utiliser un proxy vous permet d\u0026rsquo;avoir une solution qui fonctionne pour chaque navigateur.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/generating_application_state/",
	"title": "Generer l&#39;état de l&#39;application",
	"tags": [],
	"description": "",
	"content": "Le sélénium ne doit pas être utilisé pour préparer un cas de test. Tous répétitifs les actions et les préparatifs pour un test élémentaire devraient être effectués par méthodes. Par exemple, la plupart des interfaces utilisateur Web ont une authentification (par exemple, une connexion forme). Éliminer la connexion via un navigateur Web avant chaque test améliorer à la fois la vitesse et la stabilité du test. Une méthode devrait être créé pour accéder à l\u0026rsquo;AUT * (par exemple, en utilisant une API pour vous connecter et définir un biscuit). En outre, la création de méthodes de préchargement des données pour les tests ne doivent pas être effectués avec du sélénium. Comme mentionné précédemment, les API existantes doivent être exploitées pour créer des données pour l\u0026rsquo;AUT *.\n*AUT: Application under test\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/selenium_installation/",
	"title": "Installation de Selenium",
	"tags": [],
	"description": "",
	"content": "Installation de Selenium La configuration de Selenium est très différente de la configuration d\u0026rsquo;autres outils commerciaux. Pour utiliser Selenium dans votre projet d\u0026rsquo;automatisation, vous devez installer les bibliothèques de liaisons linguistiques pour la langue de votre choix. De plus, vous aurez besoin des fichiers binaires WebDriver pour les navigateurs sur lesquels vous souhaitez automatiser et exécuter le test.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/selenium_installation/installing_standalone_server/",
	"title": "Installer le serveur Standalone",
	"tags": [],
	"description": "",
	"content": "Si vous prévoyez d\u0026rsquo;utiliser [Grid] (/grid/), vous devez télécharger le [selenium-server-standalone JAR] (https://selenium.dev/downloads/). Tous les composants sont disponibles via selenium-server. Le JAR autonome contient tout, y compris le serveur Selenium distant et les liaisons côté client. Cela signifie que si vous utilisez le la jar selenium-server-standalone dans votre projet, vous n\u0026rsquo;avez pas besoin d\u0026rsquo;ajouter de sélénium-java ou un le jar spécifique au navigateur.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/getting_started_with_webdriver/locating_elements/",
	"title": "Localiser des éléments",
	"tags": [],
	"description": "",
	"content": "Localiser des éléments Une des techniques fondamentales à maîtriser lorsque l\u0026rsquo;on utilise WebDriver consiste à chercher des éléments sur une page. WebDriver offre pour cela un ensemble pré-défini de type de selecteurs, parmi lesquels la recherche d\u0026rsquo;une élément par son attribut ID:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;fromage\u0026#34;));   driver.find_element(By.ID, \u0026#34;fromage\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;fromage\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;)   const fromage = driver.findElement(By.id(\u0026#39;fromage\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     Comme démontré dans cet exemple, la localisation des éléments à l\u0026rsquo;aide de WebDriver se fait via une instance de l\u0026rsquo;objet WebDriver. La méthode findElement(By) retourne un autre type d\u0026rsquo;objet fondamental, un WebElement.\n WebDriver represente la navigateur WebElement represente un noeud particulier du DOM (un lien, un champ texte, etc.)  Un fois que l\u0026rsquo;on a obtenu la référence de l'élément web qui a été \u0026ldquo;trouvé\u0026rdquo;, on peut encore réduire la portée de notre recherche en utilisant le même appel de méthode sur l\u0026rsquo;instance de cet objet:\nJava Python C# Ruby JavaScript Kotlin WebElement fromage = driver.findElement(By.id(\u0026#34;fromage\u0026#34;)); WebElement cheddar = fromage.findElement(By.id(\u0026#34;cheddar\u0026#34;));   fromage = driver.find_element(By.ID, \u0026#34;fromage\u0026#34;) cheddar = fromage.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement fromage = driver.FindElement(By.Id(\u0026#34;fromage\u0026#34;)); IWebElement cheddar = fromage.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   fromage = driver.find_element(id: \u0026#39;fromage\u0026#39;) cheddar = fromage.find_element(id: \u0026#39;cheddar\u0026#39;)   const fromage = driver.findElement(By.id(\u0026#39;fromage\u0026#39;)); const cheddar = fromage.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     Nous pouvons faire cela car les types WebDriver et WebElement implémentent tous deux l\u0026rsquo;interface SearchContext. Dans WebDriver, ce principe est connu sous le nom de role-based interface. Les interfaces basées sur le rôle nous permettent de déterminer si une implémentation particulière de driver supporte une fonctionnalité donnée. Ces interfaces sont clairement définies et tente d\u0026rsquo;adhérer au principe de responsabilité unique. Vous pouvez en lire plus sur le design de WebDriver et sur quels drivers supportent quels rôles dans le chapitre Un Autre Chapitre Qui Aura Un Nom.\nPar conséquent, l\u0026rsquo;interface By utilisée précédement fournit également d\u0026rsquo;autres stratégies de localisation. Une recherche imbriquée peut ne pas être la startégie la plus adaptée pour trouver notre cheddar puisqu\u0026rsquo;elle nécessite que deux instructions séparées soient envoyées au navigateur ; tout d\u0026rsquo;abord rechercher un élément ayant pour ID \u0026ldquo;fromage\u0026rdquo;, puis une recherche pour \u0026ldquo;cheddar\u0026rdquo; dans ce contexte plus restreint.\nPour améliorer légèrement les performances, nous pourrions essayer un sélecteur (une stratégie de localisation) plus spécifique : WebDriver supporte la localisation d'élément via sélecteur CSS, nous permettant de combiner les deux sélecteurs précédents en un seul:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#fromage #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#fromage #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#fromage #cheddar\u0026#34;));   driver.find_element(css: \u0026#39;#fromage #cheddar\u0026#39;)   const cheddar = driver.findElement(By.css(\u0026#39;#fromage #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     Localiser plusieurs éléments Il est possible que le document web sur lequel nous travaillons dispose d\u0026rsquo;une liste ordonnée de nos fromages préférés:\n\u0026lt;ol id=fromage\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; Puisque plus de fromage est sans conteste meilleur, et qu\u0026rsquo;il serait lourd de devoir récupérer chaque item un par un, une technique supérieure est d\u0026rsquo;utiliser la forme plurielle findElements(By). Cette méthode retourne une collection d'éléments web. Si un seul élement a été trouvé, la méthode renverra tout de même une collection (d\u0026rsquo;un seul élément). Si aucun élément ne correspond au sélécteur, la collection retournée sera alors vide.\nJava Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; pleinDeFromage = driver.findElements(By.cssSelector(\u0026#34;#fromage li\u0026#34;));   plein_de_fromage = driver.find_elements_by_css_selector(\u0026#34;#fromage li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; pleinDeFromage = driver.FindElements(By.CssSelector(“#fromage li”));   plein_de_fromage = driver.find_elements(css: \u0026#39;#fromage li\u0026#39;)   const pleinDeFromage = driver.findElements(By.css(\u0026#39;#fromage li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))     Stratégie de sélection des éléments WebDriver possède huit stratégies de localisation pré-définies différentes:\n   Sélecteur Description     class name Localise les éléments dont le nom de la classe contient la valeur recherchée (nom composés non permis)   css selector Localise les éléments correspondant à un sélecteur CSS   id Localise les éléments dont l\u0026rsquo;attribut ID correspond à la valeur recherchée   name Localise les éléments dont l\u0026rsquo;attribut NAME correspond à la valeur recherchée   link text Localise les éléments de type ancre (lien) dont le texte visible correspond à la valeur recherchée   partial link text Localise les éléments de type ancre (lien) dont le texte visible contient la valeur recherchée   tag name Localise les éléments dont le nom de tag correspond à la valeur recherchée   xpath Localise les éléments correspondant à un chemin XPath    Astuces d\u0026rsquo;utilisation des sélecteurs En règle général, si des ID HTML sont disponibles, uniques et prédictibles avec constance, alors il est préférable d\u0026rsquo;utiliser cette stratégie pour la localisation d'élément sur une page. Elle a tendance à être très rapide et évite les longs traitements liés à des traversées complexes du DOM.\nSi des IDs uniques ne sont pas disponibles, un sélecteur CSS bien écrit est la méthode de localisation la plus adaptée. Un sélecteur XPath marchera aussi bien qu\u0026rsquo;un sélecteur CSS, cependant sa syntaxe est plus complexe, et souvent, plus compliquée à débugguer. Même si les sélecteur XPath sont très flexibles, ils sont rarement testés d\u0026rsquo;un point de vue performance par les fournisseurs de navigateur et ont donc tendance à être assez lents.\nLes stratégies basés sur linkText et partialLinkText sont contraingnantes du fait qu\u0026rsquo;elles ne fonctionnent que sur des éléments de type lien hypertexte. De plus, elles sont implémentées au sein de WebDriver via des sélecteurs XPath.\nLe nom de tag est une façon dangereuse de localiser des éléments. Il y a fréquemment de multiples éléments ayant le même tag sur une page. Cette stratégie est principalement utile lorsque utilisée avec la méthode findElements(By), renvoyant une collection des élements.\nAu final, la recommendation est de garder ses sélecteurs aussi compacts et lisibles que possible. Demander à WebDriver de traverser la structure du DOM est une opération très coûteuse, de fait plus le scope de recherche sera restreint, meilleures seront les performances.\nRelative Locators Selenium 4 brings Relative Locators which are previously called as Friendly Locators. This functionality was added to help you locate elements that are nearby other elements. The Available Relative Locators are:\n above below toLeftOf toRightOf near  findElement method now accepts a new method withTagName() which returns a RelativeLocator.\nHow does it work Selenium uses the JavaScript function getBoundingClientRect() to find the relative elements. This function returns properties of an element such as right, left, bottom, and top.\nLet us consider the below example for understanding the relative locators.\nabove() Returns the WebElement, which appears above to the specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement passwordField= driver.findElement(By.id(\u0026#34;password\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .above(passwordField));   #from selenium.webdriver.support.relative_locator import with_tag_name passwordField = driver.find_element(By.ID, \u0026#34;password\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).above(passwordField))   //using static OpenQA.Selenium.RelativeBy; IWebElement passwordField = driver.FindElement(By.Id(\u0026#34;password\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Above(passwordField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      below() Returns the WebElement, which appears below to the specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressField= driver.findElement(By.id(\u0026#34;email\u0026#34;)); WebElement passwordField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .below(emailAddressField));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressField = driver.find_element(By.ID, \u0026#34;email\u0026#34;) passwordField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).below(emailAddressField))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressField = driver.FindElement(By.Id(\u0026#34;email\u0026#34;)); IWebElement passwordField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Below(emailAddressField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toLeftOf() Returns the WebElement, which appears to left of specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement submitButton= driver.findElement(By.id(\u0026#34;submit\u0026#34;)); WebElement cancelButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toLeftOf(submitButton));   #from selenium.webdriver.support.relative_locator import with_tag_name submitButton = driver.find_element(By.ID, \u0026#34;submit\u0026#34;) cancelButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_left_of(submitButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement submitButton = driver.FindElement(By.Id(\u0026#34;submit\u0026#34;)); IWebElement cancelButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .LeftOf(submitButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toRightOf() Returns the WebElement, which appears to right of the specified element\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement cancelButton= driver.findElement(By.id(\u0026#34;cancel\u0026#34;)); WebElement submitButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toRightOf(cancelButton));   #from selenium.webdriver.support.relative_locator import with_tag_name cancelButton = driver.find_element(By.ID, \u0026#34;cancel\u0026#34;) submitButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_right_of(cancelButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement cancelButton = driver.FindElement(By.Id(\u0026#34;cancel\u0026#34;)); IWebElement submitButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .RightOf(cancelButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      near() Returns the WebElement, which is at most 50px away from the specified element.\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressLabel= driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .near(emailAddressLabel));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressLabel = driver.find_element(By.ID, \u0026#34;lbl-email\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;). near(emailAddressLabel))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressLabel = driver.FindElement(By.Id(\u0026#34;lbl-email\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Near(emailAddressLabel));   # Please raise a PR   // Please raise a PR    // Please raise a PR      "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/browser_manipulation/",
	"title": "Manipulation du navigateur",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Ruby Ruby is not installed by default on Windows. Download the latest version and run the installer. You can leave all settings at default values, except at the Installation Destination and Optional Tasks screen check Add Ruby executables to your PATH checkbox. To drive any browser, you have to install selenium-webdriver Ruby gem. To install it, open command prompt and type this:\ngem install selenium-webdriver Or, if you use Bundler, add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#34;selenium-webdriver\u0026#34; And then execute the following command in prompt:\nbundle install Internet Explorer Internet Explorer is installed by default on Windows, so no installation is needed. To drive Internet Explorer on Windows, you have to download the latest Internet Explorer Driver and put the file into a folder that is in PATH. To find out which directories are in PATH, type echo %PATH% in command prompt.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin looks like a good place. Unzip IEDriverServer file and move IEDriverServer.exe there.\nThis should open a new Internet Explorer window:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Browser navigation Navigate to The first thing you will want to do after launching a browser is to open your website. This can be achieved in a single line:\nJava Python C# Ruby JavaScript Kotlin //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   # Convenient way driver.get \u0026#39;https://selenium.dev\u0026#39; # Longer Way driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;) //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     Get current URL You can read the current URL from the browser\u0026rsquo;s address bar using:\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.currentUrl    Back Pressing the browser\u0026rsquo;s back button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     Forward Pressing the browser\u0026rsquo;s forward button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward()    Refresh Refresh the current page:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    Get title You can read the current page title from the browser:\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.title    Windows and tabs WebDriver doesn\u0026rsquo;t make the distinction between windows and tabs. If your site opens a new tab or window, Selenium will let you work with it using a window handle. Each window has a unique identifier which remains persistent in a single session. You can get the window handle of the current window by using:\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.windowHandle    Switching windows or tabs Clicking a link which opens in a new windowwill focus the new window or tab on screen, but WebDriver will not know which window the Operating System considers active. To work with the new window you will need to switch to it. If you have only two tabs or windows open, and you know which window you start with, by the process of elimination you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nHowever, Selenium 4 provides a new api NewWindow which creates a new tab (or) new window and automatically switches to it.\nJava Python C# Ruby JavaScript Kotlin //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element(By.LINK_TEXT, \u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;SeleniumHQ Browser Automation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   //Store the ID of the original window val originalWindow = driver.getWindowHandle() //Check we don\u0026#39;t have other windows open already assert(driver.getWindowHandles().size() === 1) //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)) //Loop through until we find a new window handle for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     Create new window (or) new tab and switch Creates a new window (or) tab and will focus the new window or tab on screen. You don\u0026rsquo;t need to switch to work with the new window (or) tab. If you have more than two windows (or) tabs opened other than the new window, you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nNote: This feature works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB); // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW);   # Opens a new tab and switches to new tab driver.switch_to.new_window(\u0026#39;tab\u0026#39;) # Opens a new window and switches to new window driver.switch_to.new_window(\u0026#39;window\u0026#39;)   // Opens a new tab and switches to new tab driver.SwitchTo().NewWindow(WindowType.Tab) // Opens a new window and switches to new window driver.SwitchTo().NewWindow(WindowType.Window)   # Note: The new_window in ruby only opens a new tab (or) Window and will not switch automatically # The user has to switch to new tab (or) new window # Opens a new tab and switches to new tab driver.manage.new_window(:tab) # Opens a new window and switches to new window driver.manage.new_window(:window)   // Opens a new tab and switches to new tab await driver.switchTo().newWindow(\u0026#39;tab\u0026#39;); // Opens a new window and switches to new window await driver.switchTo().newWindow(\u0026#39;window\u0026#39;);   // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB) // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW)     Closing a window or tab When you are finished with a window or tab and it is not the last window or tab open in your browser, you should close it and switch back to the window you were using previously. Assuming you followed the code sample in the previous section you will have the previous window handle stored in a variable. Put this together and you will get:\nJava Python C# Ruby JavaScript Kotlin //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);   //Close the tab or window driver.close() //Switch back to the old tab or window driver.switchTo().window(originalWindow)     Forgetting to switch back to another window handle after closing a window will leave WebDriver executing on the now closed page, and will trigger a No Such Window Exception. You must switch back to a valid window handle in order to continue execution.\nQuitting the browser at the end of a session When you are finished with the browser session you should call quit, instead of close:\nJava Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()     Quit will:  Close all the windows and tabs associated with that WebDriver session The browser process The background driver process Notify Selenium Grid that the browser is no longer in use so it can be used by another session (if you are using Selenium Grid)    Failure to call quit will leave extra background processes and ports running on your machine which could cause you problems later.\nSome test frameworks offer methods and annotations which you can hook into to tear down at the end of a test.\nJava Python C# Ruby JavaScript Kotlin /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # unittest teardown # https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown def tearDown(self): self.driver.quit()   /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # UnitTest Teardown # https://www.rubydoc.info/github/test-unit/test-unit/Test/Unit/TestCase def teardown @driver.quit end   /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });   /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() { driver.quit() }     If not running WebDriver in a test context, you may consider using try / finally which is offered by most languages so that an exception will still clean up the WebDriver session.\nJava Python C# Ruby JavaScript Kotlin try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { //WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }   try { //WebDriver code here... } finally { driver.quit() }     Python\u0026rsquo;s WebDriver now supports the python context manager, which when using the with keyword can automatically quit the driver at the end of execution.\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation Frames and Iframes Frames are a now deprecated means of building a site layout from multiple documents on the same domain. You are unlikely to work with them unless you are working with an pre HTML5 webapp. Iframes allow the insertion of a document from an entirely different domain, and are still commonly used.\nIf you need to work with frames or iframes, WebDriver allows you to work with them in the same way. Consider a button within an iframe. If we inspect the element using the browser development tools, we might see the following:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; If it wasn\u0026rsquo;t for the iframe we would expect to click on the button using something like:\nJava Python C# Ruby JavaScript Kotlin //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # This Wont work driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # This won\u0026#39;t work driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     However, if there are no buttons outside of the iframe, you might instead get a no such element error. This happens because Selenium is only aware of the elements in the top level document. To interact with the button, we will need to first switch to the frame, in a similar way to how we switch windows. WebDriver offers three ways of switching to a frame.\nUsing a WebElement Switching using a WebElement is the most flexible option. You can find the frame using your preferred selector and switch to it.\nJava Python C# Ruby JavaScript Kotlin //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Store iframe web element iframe = driver.find_element(By.CSS_SELECTOR, \u0026#34;#modal \u0026gt; iframe\u0026#34;) # switch to selected iframe driver.switch_to.frame(iframe) # Now click on button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Store iframe web element iframe = driver.find_element(:css,\u0026#39;#modal \u0026gt; iframe\u0026#39;) # Switch to the frame driver.switch_to.frame iframe # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Store the web element const iframe = driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Store the web element val iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) //Switch to the frame driver.switchTo().frame(iframe) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using a name or ID If your frame or iframe has an id or name attribute, this can be used instead. If the name or ID is not unique on the page, then the first one found will be switched to.\nJava Python C# Ruby JavaScript Kotlin //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Switch frame by id driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # Now, Click on the button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Switch by ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using an index It is also possible to use the index of the frame, such as can be queried using window.frames in JavaScript.\nJava Python C# Ruby JavaScript Kotlin // Switches to the second frame driver.switchTo().frame(1);   # Switch to the second frame driver.switch_to.frame(1)   // Switches to the second frame driver.SwitchTo().Frame(1);   # switching to second iframe based on index iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # switch to selected iframe driver.switch_to.frame(iframe)   // Switches to the second frame await driver.switchTo().frame(1);   // Switches to the second frame driver.switchTo().frame(1)     Leaving a frame To leave an iframe or frameset, switch back to the default content like so:\nJava Python C# Ruby JavaScript Kotlin // Return to the top level driver.switchTo().defaultContent();   # switch back to default content driver.switch_to.default_content()   // Return to the top level driver.SwitchTo().DefaultContent();   # Return to the top level driver.switch_to.default_content   // Return to the top level await driver.switchTo().defaultContent();   // Return to the top level driver.switchTo().defaultContent()     Window management Screen resolution can impact how your web application renders, so WebDriver provides mechanisms for moving and resizing the browser window.\nGet window size Fetches the size of the browser window in pixels.\nJava Python C# Ruby JavaScript Kotlin //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # Access each dimension individually width = driver.manage.window.size.width height = driver.manage.window.size.height # Or store the dimensions and query them later size = driver.manage.window.size width1 = size.width height1 = size.height   // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   //Access each dimension individually val width = driver.manage().window().size.width val height = driver.manage().window().size.height //Or store the dimensions and query them later val size = driver.manage().window().size val width1 = size.width val height1 = size.height     Set window size Restores the window and sets the window size. Java Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });   driver.manage().window().size = Dimension(1024, 768)   \nGet window position Fetches the coordinates of the top left coordinate of the browser window.\nJava Python C# Ruby JavaScript Kotlin // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   #Access each dimension individually x = driver.manage.window.position.x y = driver.manage.window.position.y # Or store the dimensions and query them later rect = driver.manage.window.rect x1 = rect.x y1 = rect.y   // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // Access each dimension individually val x = driver.manage().window().position.x val y = driver.manage().window().position.y // Or store the dimensions and query them later val position = driver.manage().window().position val x1 = position.x val y1 = position.y     Set window position Moves the window to the chosen position.\nJava Python C# Ruby JavaScript Kotlin // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   # Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });   // Move the window to the top left of the primary monitor driver.manage().window().position = Point(0,0)     Maximise window Enlarges the window. For most operating systems, the window will fill the screen, without blocking the operating system\u0026rsquo;s own menus and toolbars.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    Minimize window Minimizes the window of current browsing context. The exact behavior of this command is specific to individual window managers.\nMinimize Window typically hides the window in the system tray.\nNote: This feature works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().minimize();  driver.minimize_window()  driver.Manage().Window.Minimize();   driver.manage.window.minimize  await driver.manage().window().minimize();   driver.manage().window().minimize()    Fullscreen window Fills the entire screen, similar to pressing F11 in most browsers.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/grid/setting_up_your_own_grid/",
	"title": "Mettre en place votre propre Grid",
	"tags": [],
	"description": "",
	"content": "Pour utiliser la grille de Selenium, vous devez maintenir votre propre infrastructure pour les nœuds. Comme cela peut être un effort lourd et intense en temps, de nombreuses organisations utilisent des fournisseurs IaaS comme Amazon EC2 et Google Compute pour fournir cette infrastructure.\nD\u0026rsquo;autres options incluent l\u0026rsquo;utilisation de fournisseurs tels que Sauce Labs ou Testing Bot qui fournissent un Selenium Grid en tant que service dans le cloud. Il est certainement possible d\u0026rsquo;exécuter également des nœuds sur votre propre matériel. Ce chapitre abordera en détail l\u0026rsquo;option de faire fonctionner votre propre grille, complet avec sa propre infrastructure de nœuds.\nQuick start Cet exemple vous montrera comment démarrer le Selenium 2 Grid Hub, et enregistrer à la fois un nœud WebDriver et un nœud hérité Selenium 1 RC. Nous vous montrerons également comment appeler la grille depuis Java. Le hub et les nœuds sont montrés ici fonctionnant sur la même machine, mais bien sûr, vous pouvez copier le serveur autonome de Selenium sur plusieurs machines.\nLe package selenium-server-standalone comprend le concentrateur, WebDriver et l\u0026rsquo;héritage RC nécessaires pour exécuter la grille, ant n\u0026rsquo;est plus requis. Vous pouvez télécharger le selenium-server-standalone.jar depuis https://selenium.dev/downloads/.\nÉtape 1: démarrez le hub Le Hub est le point central qui recevra les demandes de test et les distribuer aux bons nœuds. La distribution se fait sur la base des capacités, ce qui signifie un test nécessitant un ensemble de capacités ne sera distribué qu\u0026rsquo;aux nœuds offrant cet ensemble ou sous-ensemble de capacités.\nParce que les capacités souhaitées d\u0026rsquo;un test sont exactement ce que son nom l\u0026rsquo;indique, desired, le concentrateur ne peut pas garantir qu\u0026rsquo;il localisera un nœud correspondant parfaitement à l\u0026rsquo;ensemble de capacités souhaité.\nOuvrez une invite de commande et accédez au répertoire dans lequel vous avez copié le fichier selenium-server-standalone.jar. Vous démarrez le hub en passant le drapeau -role hub sur le serveur autonome:\njava -jar selenium-server-standalone.jar -role hub The Hub will listen to port 4444 by default. You can view the status of the hub by opening a browser window and navigating to http://localhost:4444/grid/console.\nLe concentrateur écoutera le port 4444 par défaut. Vous pouvez afficher l'état du concentrateur en ouvrant une fenêtre de navigateur et en accédant à http://localhost:4444/grid/console.\nPour modifier le port par défaut, vous pouvez ajouter le drapeau facultatif -port avec un entier représentant le port à écouter lorsque vous exécutez la commande. En outre, toutes les autres options que vous voyez dans le fichier de configuration JSON (voir ci-dessous) sont des drapeaux de ligne de commande possibles.\nVous pouvez certainement vous en tirer avec la simple commande ci-dessus, mais si vous avez besoin d\u0026rsquo;une configuration plus avancée, vous pouvez également spécifier un fichier de configuration au format JSON, pour plus de commodité, pour configurer le concentrateur au démarrage. Vous pouvez le faire comme ceci:\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug Ci-dessous, vous verrez un exemple de fichier hubConfig.json. Nous verrons plus en détail comment fournir les fichiers de configuration de noeud à l'étape 2.\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} Étape 2: démarrez les nœuds Que vous souhaitiez exécuter une grille avec de nouvelles fonctionnalités WebDriver, ou une grille avec la fonctionnalité Selenium 1 RC, Ou les deux à la fois, vous utilisez le même fichier selenium-server-standalone.jar pour démarrer les nœuds:\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 Si un port n\u0026rsquo;est pas spécifié via l\u0026rsquo;indicateur -port, un port libre sera choisi. Vous pouvez exécuter plusieurs nœuds sur une seule machine mais si vous le faites, vous devez être conscient des ressources mémoire de votre système et des problèmes avec les captures d'écran si vos tests les prennent.\nConfiguration du nœud avec options Comme mentionné, pour une compatibilité ascendante Les rôles \u0026ldquo;wd\u0026rdquo; et \u0026ldquo;rc\u0026rdquo; sont toujours un sous-ensemble valide du rôle \u0026ldquo;node\u0026rdquo;. Mais ces rôles limitent les types de connexions distantes à leur API correspondante, tandis que \u0026ldquo;node\u0026rdquo; permet à la fois les connexions à distance RC et WebDriver.\nPasser les propriétés JVM (en utilisant l\u0026rsquo;indicateur -D avant l\u0026rsquo;argument -jar) sur la ligne de commande, et ceux-ci seront ramassés et propagés aux nœuds:\n-Dwebdriver.chrome.driver=chromedriver.exe\nConfiguration de Node avec JSON Vous pouvez également démarrer des nœuds de grille configurés avec un fichier de configuration JSON\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json Et voici un exemple de fichier nodeConfig.json:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } Une note sur le drapeau -host\nPour le concentrateur et le nœud, si l\u0026rsquo;indicateur -host n\u0026rsquo;est pas spécifié, 0.0.0.0 sera utilisé par défaut. Cela se liera à tous les interfaces IPv4 publiques (sans boucle) de la machine. Si vous avez un spécial configuration réseau ou tout composant créant des interfaces réseau supplémentaires, il est conseillé de définir le drapeau -host avec une valeur qui concentrateur/node accessible depuis une autre machine.\nSpécification du port Le port TCP/IP par défaut utilisé par le concentrateur est 4444. Si vous devez changer le port veuillez utiliser les configurations mentionnées ci-dessus.\nDépannage Utilisation du fichier journal Pour un dépannage avancé, vous pouvez spécifier un fichier journal pour enregistrer les messages système. Démarrez le concentrateur ou le nœud Selenium GRID avec l\u0026rsquo;argument -log. Veuillez voir l\u0026rsquo;exemple ci-dessous:\njava -jar selenium-server-standalone.jar -role hub -log log.txt Utilisez votre éditeur de texte préféré pour ouvrir le fichier journal (log.txt dans l\u0026rsquo;exemple ci-dessus) pour trouver Journaux \u0026ldquo;ERREUR\u0026rdquo; si vous rencontrez des problèmes.\nUtilisation de l\u0026rsquo;argument -debug Vous pouvez également utiliser l\u0026rsquo;argument -debug pour imprimer les journaux de débogage sur la console. Démarrez Selenium Grid Hub ou Node avec l\u0026rsquo;argument -debug. S\u0026rsquo;il te plait regarde l\u0026rsquo;exemple ci-dessous:\njava -jar selenium-server-standalone.jar -role hub -debug Attention La grille de Selenium doit être protégée des accès externes à l\u0026rsquo;aide de autorisations de pare-feu.\nLe fait de ne pas protéger votre grille peut entraîner un ou plusieurs des événements suivants:\n Vous fournissez un accès ouvert à votre infrastructure Grid Vous autorisez des tiers à accéder aux applications et fichiers Web internes Vous autorisez des tiers à exécuter des binaires personnalisés  Voir cet article de blog sur Detectify, qui donne une bonne aperçu de l\u0026rsquo;utilisation abusive d\u0026rsquo;une grille exposée publiquement: Ne laissez pas votre grille grande ouverte.\nDocker Selenium Docker fournit un moyen pratique de fournir et dimensionner l\u0026rsquo;infrastructure Selenium Grid dans une unité appelée conteneur. Les conteneurs sont des unités logicielles standardisées qui contiennent tout le nécessaire pour exécuter l\u0026rsquo;application souhaitée, y compris toutes les dépendances, dans un environnement fiable et reproductible sur différentes machines.\nLe projet Selenium gère un ensemble d\u0026rsquo;images Docker que vous pouvez télécharger et exécutez pour obtenir une grille de travail rapidement opérationnelle. Les nœuds sont disponibles pour Firefox et Chrome. Vous trouverez tous les détails sur la configuration d\u0026rsquo;un réseau dans le Docker Selenium dépôt.\nPrérequis La seule exigence pour exécuter une grille est d\u0026rsquo;avoir Docker installé et fonctionnel. Installer Docker.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/legacy_docs/html-runner/",
	"title": "Runner HTML",
	"tags": [],
	"description": "",
	"content": "Selenium HTML-runner permet d\u0026rsquo;exécuter des Test Suites depuis la ligne de commande. Les Tests Suites sont des exports HTML depuis Selenium IDE ou autre outil compatible.\nInformations générales  Les combinaisons de version de geckodriver / firefox / selenium-html-runner sont importantes. Il doit y avoir une matrice de compatibilité quelque part. selenium-html-runner exécute seulement des Test Suites (et non pas des Test Case, comme un export de Monitis Transaction Monitor). Assurez-vous de vous y conformer. Pour les utilisateurs Linux sans affichage - vous devez exécuter html-runner avec un affichage virtuel (cherchez xvfb)  Exemple sur environnement Linux Installer / télécharger les packages suivants:\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Example de Test Suite:\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;YOUR-TEST-SCENARIO\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Comment exécuter selenium-html-runner en mode headless Pour la partie la plus importante, voici un exemple d\u0026rsquo;exécution de selenium-html-runner ! Votre expérience peut varier selon les combinaisons logicielles - versions de geckodriver/FF/html-runner.\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html [user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/support_packages/working_with_select_elements/",
	"title": "Travailler avec les éléments select",
	"tags": [],
	"description": "",
	"content": "Certains éléments peuvent nécessiter un peu de code de plaque de chaudière pour automatiser. Pour réduire cela et rendre vos tests plus propres, il existe un Classe Select dans le package de support Selenium. Pour l\u0026rsquo;utiliser, vous aurez besoin de l\u0026rsquo;instruction d\u0026rsquo;importation suivante:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.ui.Select     Vous pouvez ensuite créer un objet Select à l\u0026rsquo;aide d\u0026rsquo;un WebElement qui référence un élément \u0026lt;select\u0026gt;.\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element(By.ID,\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   IWebElement selectElement = driver.FindElement(By.Id(\u0026#34;selectElementID\u0026#34;)); var selectObject = new SelectElement(selectElement);   select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     L\u0026rsquo;objet Select va maintenant vous donner une série de commandes qui vous permettent d\u0026rsquo;interagir avec un élément \u0026lt;select\u0026gt;. Tout d\u0026rsquo;abord, il existe différentes façons de sélectionner une option de l'élément \u0026lt;select\u0026gt;.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; Il existe trois façons de sélectionner la première option dans l'élément ci-dessus:\nJava Python C# Ruby JavaScript Kotlin // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by_index(1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by_value(\u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.SelectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.SelectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text  selectObject.SelectByText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by(:index, 1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1) // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     Vous pouvez ensuite vérifier les options sélectionnées en utilisant:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Return a WebElement referencing the first selection option found by walking down the DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Return a list[WebElement] of options that have been selected all_selected_options = select_object.all_selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected var allSelectedOptions = selectObject.AllSelectedOptions; // Return a WebElement referencing the first selection option found by walking down the DOM var firstSelectedOption = selectObject.AllSelectedOptions.FirstOrDefault();   # Return an Array[Element] of options that have been selected all_selected_options = select_object.selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected val allSelectedOptions = selectObject.allSelectedOptions // Return a WebElement referencing the first selection option found by walking down the DOM val firstSelectedOption = selectObject.firstSelectedOption     Ou vous pouvez simplement être intéressé par les éléments l'élément \u0026lt;select\u0026gt; contient:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Return a list[WebElement] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // Return a IList\u0026lt;IWebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains IList\u0026lt;IWebElement\u0026gt; allAvailableOptions = selectObject.Options;   # Return an Array[Element] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains val allAvailableOptions = selectObject.options     Si vous souhaitez désélectionner des éléments, vous avez maintenant quatre options:\nJava Python C# Ruby JavaScript Kotlin // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by_index(1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all()   // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.DeselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.DeselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.DeselectByText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.DeselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by(:index, 1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1) // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll()     Enfin, certains éléments \u0026lt;select\u0026gt; vous permettent de sélectionner plusieurs options. Vous pouvez savoir si votre élément \u0026lt;select\u0026gt; en fait partie en utilisant:\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   bool doesThisAllowMultipleSelections = selectObject.IsMultiple;   does_this_allow_multiple_selections = select_object.multiple?   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val doesThisAllowMultipleSelections = selectObject.isMultiple     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/introduction/types_of_testing/",
	"title": "Types  de test",
	"tags": [],
	"description": "",
	"content": "Test d\u0026rsquo;acceptation Ce type de test est effectué pour déterminer si une fonctionnalité ou un système répond aux attentes et exigences du client. Ce type de test implique généralement le client la coopération ou la rétroaction, étant une activité de validation qui répond à la question:\n Construisons-nous le produit non?.\n Pour les applications web, l\u0026rsquo;automatisation de ces tests peut se faire directement avec Selenium en simulant le comportement attendu de l\u0026rsquo;utilisateur. Cette simulation peut être effectuée par enregistrement / lecture ou par différentes langues prises en charge comme expliqué dans cette documentation. Remarque: Les tests d\u0026rsquo;acceptation sont un sous-type de tests fonctionnels, auquel certaines personnes pourraient également se référer.\nTest fonctionel Ce type de test est effectué pour déterminer si un fonction ou le système fonctionne correctement sans problèmes. Il vérifie le système à différents niveaux pour garantir que tous les scénarios sont couverts et que le système fait censé faire. C\u0026rsquo;est une activité de vérification qui répond à la question:\n Construisons-nous le produit non?.\n Cela comprend généralement: les tests fonctionnent sans erreur (404, exceptions \u0026hellip;), de manière utilisable (redirections correctes), de manière accessible et correspondant à ses spécifications (voir test d\u0026rsquo;acceptation ci-dessus).\nPour les applications Web, l\u0026rsquo;automatisation de ces tests peut être fait directement avec Selenium en simulant les rendements attendus. Cette simulation peut être effectuée par enregistrement / lecture ou par les différentes langues prises en charge comme expliqué dans cette documentation.\nTest de performance Comme son nom l\u0026rsquo;indique, des tests de performances sont effectués pour mesurer la performance d\u0026rsquo;une application.\nIl existe deux sous-types principaux pour les tests de performances:\nLoad testing Des tests de charge sont effectués pour vérifier la l\u0026rsquo;application fonctionne sous différentes charges définies (généralement un nombre particulier d\u0026rsquo;utilisateurs connectés en même temps)\nTests de résistance Des tests de résistance sont effectués pour vérifier la l\u0026rsquo;application fonctionne sous contrainte (ou au-dessus de la charge maximale supportée).\nEn règle générale, les tests de performances sont effectués en exécutant certains Test écrit de sélénium simulant différents utilisateurs frapper une fonction particulière sur l\u0026rsquo;application Web et récupérer des mesures significatives.\nCela se fait généralement par d\u0026rsquo;autres outils qui récupèrent les métriques. Un tel outil est JMeter.\nPour une application Web, les détails à mesurer incluent débit, latence, perte de données, temps de chargement des composants individuels \u0026hellip;\nRemarque 1: tous les navigateurs ont un onglet de performances dans leur section des outils des développeurs (accessible en appuyant sur F12)\nRemarque 2: est un sous-type de tests non fonctionnels car cela est généralement mesuré par système et non par fonction / caractéristique.\nLes tests de régression Ce test est généralement effectué après un changement, un correctif ou un ajout de fonctionnalité.\nPour s\u0026rsquo;assurer que le changement n\u0026rsquo;a rompu aucun des fonctionnalité, certains tests déjà exécutés sont exécutés à nouveau.\nL\u0026rsquo;ensemble des tests réexécutés peut être complet ou partiel et peut inclure plusieurs types différents, selon sur l'équipe d\u0026rsquo;application et de développement.\nDéveloppement piloté par les tests (TDD) Plutôt qu\u0026rsquo;un type de test en soi, le TDD est un itératif méthodologie de développement dans laquelle les tests pilotent la conception d\u0026rsquo;une fonctionnalité.\nChaque cycle commence par la création d\u0026rsquo;un ensemble de tests unitaires qui la fonctionnalité doit réussir (ce qui devrait échouer lors de sa première exécution).\nAprès cela, le développement a lieu pour faire passer les tests. Les tests sont exécutés à nouveau en commençant un autre cycle et ce processus se poursuit jusqu'à ce que tous les tests soient réussis.\nCela vise à accélérer le développement d\u0026rsquo;une application basé sur le fait que les défauts sont moins coûteux plus tôt ils sont trouvés.\nDéveloppement axé sur le comportement (BDD) BDD est également une méthodologie de développement itérative basé sur ci-dessus (TDD) dans lequel le but est d\u0026rsquo;impliquer toutes les parties dans le développement d\u0026rsquo;une application.\nChaque cycle commence par la création de quelques spécifications (qui devrait échouer). Créez ensuite l\u0026rsquo;unité défaillante tests (qui devraient également échouer), puis créer le développement.\nCe cycle est répété jusqu'à ce que tous les types de tests réussissent.\nPour ce faire, un langage de spécification est utilisé. Il doit être compréhensible par toutes les parties et simple, standard et explicite. La plupart des outils utilisent Gherkin comme langue.\nL\u0026rsquo;objectif est de pouvoir détecter encore plus d\u0026rsquo;erreurs que TDD en ciblant les erreurs d\u0026rsquo;acceptation potentielles aussi et rendre la communication entre les parties plus fluide.\nUn ensemble d\u0026rsquo;outils est actuellement disponible écrire les spécifications et les associer aux fonctions de code, tels que Concombre ou SpecFlow.\nUn ensemble d\u0026rsquo;outils est construit sur Selenium pour rendre ce processus encore plus rapide en transformant directement les spécifications BDD en code exécutable. Certains d\u0026rsquo;entre eux sont JBehave, Capybara et Robot Framework.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/introduction/about_this_documentation/",
	"title": "A propos de cette documentation",
	"tags": [],
	"description": "",
	"content": "Cette documentation, tout comme le code lui-même, est maintenue à 100% par des volontaires de la communauté Selenium. Beaucoup font partie des utilisateurs de la première heure, mais encore plus sont des utilisateurs récents, et ont donné de leur temps pour améliorer l\u0026rsquo;accueil des nouveaux utilisateurs.\nSi vous rencontrez un problème avec la documentation, nous souhaitons le savoir ! La meilleure façon de communiquer un problème est de visiter https://github.com/seleniumhq/seleniumhq.github.io/issues et de vérifier si ce problème a déjà été remonté. Si ce n\u0026rsquo;est pas le cas, n\u0026rsquo;hésitez pas à ouvrir une nouvel issue !\nDe nombreux membre de la communauté fréquentent le canal IRC irc.freenode.net. N\u0026rsquo;hésitez pas à passer et poser vos questions. Si vous recevez de l\u0026rsquo;aide et pensez que cela devrait faire partie de la documentation, votre contribution sera plus que bienvenue ! Nous pouvons mettre à jour cette documentation, mais c\u0026rsquo;est beaucoup plus facile pour tout le monde lorsque nous recevons des contributions venant de nouvelles personnes.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/support_packages/mouse_and_keyboard_actions_in_detail/",
	"title": "Actions de la souris en détail",
	"tags": [],
	"description": "",
	"content": "La souris représente un événement de souris. Les actions de la souris sont effectuées en utilisant une interface de bas niveau qui nous permet de fournir une action de saisie de périphérique virtualisé au navigateur Web.\nclickAndHold Il se déplacera vers l'élément et cliquera (sans le relâcher) au milieu de l'élément donné.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform click-and-hold action on the element webdriver.ActionChains(driver).click_and_hold(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ClickAndHold { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.ClickAndHold(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform click-and-hold action on the element driver.action.click_and_hold(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function clickAndHold() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform mouseMove to element and mouseDown (press) action on the element  await actions.move({origin:searchBtn}).press().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform() } finally { driver.quit() } }     contextClick Cette méthode effectue tout d\u0026rsquo;abord un déplacement de la souris vers l\u0026rsquo;emplacement de l'élément et effectue le clic contextuel (clic droit) sur l'élément donné.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class contextClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform context-click action on the element webdriver.ActionChains(driver).context_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ContextClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.ContextClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform context-click action on the element driver.action.context_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function contextClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform context-click action on the element  await actions.contextClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform() } finally { driver.quit() } }     doubleClick Il se déplacera vers l'élément et effectuera un double-clic au milieu de l'élément donné.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class doubleClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform double-click action on the element webdriver.ActionChains(driver).double_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DoubleClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.DoubleClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform double-click action on the element driver.action.double_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function doubleClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform double-click action on the element  await actions.doubleClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform() } finally { driver.quit() } }     moveToElement Cette méthode déplace la souris au milieu de l'élément. L'élément défile également dans la vue lors de l\u0026rsquo;exécution de cette action.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveToElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) # Performs mouse move action onto the element webdriver.ActionChains(driver).move_to_element(gmailLink).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveToElement { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.MoveToElement(gmailLink).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Performs mouse move action onto the element driver.action.move_to(gmail_link).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveToElement() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({origin:gmailLink}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform() } finally { driver.quit() } }     moveByOffset Cette méthode déplace la souris de sa position actuelle (ou 0,0) par le décalage donné. Si les coordonnées sont en dehors de la fenêtre d\u0026rsquo;affichage, la souris se retrouvera en dehors de la fenêtre du navigateur.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveByOffset { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture x and y offset positions of element  int xOffset = gmailLink.getRect().getX(); int yOffset = gmailLink.getRect().getY(); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.moveByOffset(xOffset, yOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) #Set x and y offset positions of element xOffset = 100 yOffset = 100 # Performs mouse move action onto the element webdriver.ActionChains(driver).move_by_offset(xOffset,yOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveByOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); // Set x and y offset positions of element  int xOffset = 100; int yOffset = 100; Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.MoveByOffset(xOffset, yOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Capture x and y offset positions of element x_offset = gmail_link.rect.x y_offset = gmail_link.rect.y # Performs mouse move action onto the offset position driver.action.move_to_location(x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveByOffset() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture offset positions of element  let offset = await gmailLink.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({x:parseInt(x),y:parseInt(y)}).pause(3000).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) // Capture x and y offset positions of element  val xOffset = gmailLink.rect.getX() val yOffset = gmailLink.rect.getY() val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveByOffset(xOffset, yOffset).build().perform() } finally { driver.quit() } }     dragAndDrop Cette méthode effectue tout d\u0026rsquo;abord un clic et un maintien sur l'élément source, se déplace vers l\u0026rsquo;emplacement de l'élément cible, puis relâche la souris.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDrop { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs drag and drop action of sourceEle onto the targetEle webdriver.ActionChains(driver).drag_and_drop(sourceEle,targetEle).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDrop { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDrop(sourceEle, targetEle).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) # Store \u0026#39;box B\u0026#39; as source element target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Performs drag and drop action of sourceEle onto the targetEle driver.action.drag_and_drop(source_ele, target_ele).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDrop() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); // Performs drag and drop action of sourceEle onto the targetEle  await actions.dragAndDrop(sourceEle, targetEle).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform() } finally { driver.quit() } }     dragAndDropBy Cette méthode effectue d\u0026rsquo;abord un clic et un maintien sur l'élément source, se déplace vers le décalage donné puis relâche la souris.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDropBy { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.getLocation().getX(); int targetEleYOffset = targetEle.getLocation().getY(); Actions actionProvider = new Actions(driver); // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) targetEleXOffset = targetEle.location.get(\u0026#34;x\u0026#34;) targetEleYOffset = targetEle.location.get(\u0026#34;y\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).drag_and_drop_by_offset(sourceEle, targetEleXOffset, targetEleYOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDropToOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.Location.X; int targetEleYOffset = targetEle.Location.Y; Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDropToOffset(sourceEle, targetEleXOffset, targetEleYOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Capture x and y offset positions of element x_offset = target_ele.rect.x y_offset = target_ele.rect.y # Performs dragAndDropBy onto the target element offset position driver.action.drag_and_drop_by(source_ele, x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDropBy() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); let offset = await targetEle.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs dragAndDropBy onto the target element offset position  await actions.dragAndDrop(sourceEle, {x:parseInt(x), y:parseInt(y)}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val targetEleXOffset = targetEle.location.getX() val targetEleYOffset = targetEle.location.getY() val actionProvider = Actions(driver) // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform() } finally { driver.quit() } }     release Cette action relâche le bouton gauche de la souris enfoncé. Si WebElement est passé, il relâchera le bouton gauche de la souris enfoncé sur l'élément WebElement donné\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class release { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform(); // Performs release event  actionProvider.release().build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).click_and_hold(sourceEle).move_to_element(targetEle).perform() #Performs release event webdriver.ActionChains(driver).release().perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class Release { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.ClickAndHold(sourceEle).MoveToElement(targetEle).Build().Perform(); // Performs release event  actionProvider.Release().Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) driver.action.click_and_hold(source_ele).move_to(target_ele).perform # Performs release event driver.action.release.perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function release() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); await actions.move({origin:sourceEle}).press().perform(); // Performs release event on target element  await actions.move({origin:targetEle}).release().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform() // Performs release event  actionProvider.release().build().perform() } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/mock_external_services/",
	"title": "Bouchonner les appels externes",
	"tags": [],
	"description": "",
	"content": "L'élimination des dépendances sur les services externes s\u0026rsquo;améliorera considérablement la vitesse et la stabilité de vos tests.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/getting_started_with_webdriver/",
	"title": "Débuter avec WebDriver",
	"tags": [],
	"description": "",
	"content": "Débuter avec WebDriver Selenium permet l\u0026rsquo;automatisation des navigateurs les plus courants du marché à travers l\u0026rsquo;utilisation de WebDriver. WebDriver est une API et un protocole définissant une interface agnostique (non orientée vers un langage spécifique) permettant de controller le comportement des navigateurs web. Chaque navigateur est appuyé par une implémentation spécifique de WebDriver, appelée un driver. Ce driver est le composant responsable de la délégation vers le navigateur, et gère la communication entre Selenium et le navigateur.\nCette séparation fait partie d\u0026rsquo;un effor conscient afin de responsabiliser les fournisseurs de navigateurs quant à l\u0026rsquo;implémentation de ceux-ci. Selenium tire parti de drivers tierces lorsque c\u0026rsquo;est possible, mais fournit également ces propres drivers, maintenus par le projet, lorsque nécessaire.\nLe framework Selenium relie toutes ces pièces ensemnle via une interface user-friendly qui permet d\u0026rsquo;utiliser différents navigateurs de manière transparente, permettant ainsi l\u0026rsquo;automatisation cross-platform et cross-browser.\nPlus de détail à propos des driver peut être trouvé au chapitre Singularités du Driver.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/worst_practices/gmail_email_and_facebook_logins/",
	"title": "Gmail, email and logins Facebook",
	"tags": [],
	"description": "",
	"content": "Pour plusieurs raisons, vous connecter à des sites comme Gmail et Facebook l\u0026rsquo;utilisation de WebDriver n\u0026rsquo;est pas recommandée. En plus d'être contre les conditions d\u0026rsquo;utilisation de ces sites (où vous risquez de fermer le compte), c\u0026rsquo;est lent et peu fiable.\nLa pratique idéale consiste à utiliser les API proposées par les fournisseurs de messagerie, ou dans le cas de Facebook le service des outils de développement qui expose une API pour créer des comptes de test, des amis, etc. Bien que l\u0026rsquo;utilisation d\u0026rsquo;une API puisse sembler un peu plus difficile, vous serez récompensé en vitesse, fiabilité et stabilité. L\u0026rsquo;API est également peu susceptible de changer alors que les pages Web et les localisateurs HTML changent souvent et vous obliger à mettre à jour votre framework de test.\nSe connecter à des sites tiers à l\u0026rsquo;aide de WebDriver à tout moment de votre test augmente le risque de l'échec de votre test car cela rallonge votre test. Une règle générale est que des tests plus longs sont plus fragiles et peu fiables.\nLes implémentations WebDriver qui sont W3C conformant annoter également l\u0026rsquo;objet navigator avec une propriété WebDriver afin que les attaques par déni de service puissent être atténuées.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/legacy_docs/selenium_ide/",
	"title": "Legacy Selenium IDE",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Introduction The Selenium-IDE (Integrated Development Environment) is the tool you use to develop your Selenium test cases. It’s an easy-to-use Firefox plug-in and is generally the most efficient way to develop test cases. It also contains a context menu that allows you to first select a UI element from the browser’s currently displayed page and then select from a list of Selenium commands with parameters pre-defined according to the context of the selected UI element. This is not only a time-saver, but also an excellent way of learning Selenium script syntax.\nThis chapter is all about the Selenium IDE and how to use it effectively.\nInstalling the IDE Using Firefox, first, download the IDE from the SeleniumHQ downloads page\nFirefox will protect you from installing addons from unfamiliar locations, so you will need to click ‘Allow’ to proceed with the installation, as shown in the following screenshot.\nWhen downloading from Firefox, you’ll be presented with the following window.\nSelect Install Now. The Firefox Add-ons window pops up, first showing a progress bar, and when the download is complete, displays the following.\nRestart Firefox. After Firefox reboots you will find the Selenium-IDE listed under the Firefox Tools menu.\nOpening the IDE To run the Selenium-IDE, simply select it from the Firefox Tools menu. It opens as follows with an empty script-editing window and a menu for loading, or creating new test cases.\nIDE Features Menu Bar The File menu has options for Test Case and Test Suite (suite of Test Cases). Using these you can add a new Test Case, open a Test Case, save a Test Case, export Test Case in a language of your choice. You can also open the recent Test Case. All these options are also available for Test Suite.\nThe Edit menu allows copy, paste, delete, undo, and select all operations for editing the commands in your test case. The Options menu allows the changing of settings. You can set the timeout value for certain commands, add user-defined user extensions to the base set of Selenium commands, and specify the format (language) used when saving your test cases. The Help menu is the standard Firefox Help menu; only one item on this menu–UI-Element Documentation–pertains to Selenium-IDE.\nToolbar The toolbar contains buttons for controlling the execution of your test cases, including a step feature for debugging your test cases. The right-most button, the one with the red-dot, is the record button.\nSpeed Control: controls how fast your test case runs.\nRun All: Runs the entire test suite when a test suite with multiple test cases is loaded.\nRun: Runs the currently selected test. When only a single test is loaded this button and the Run All button have the same effect.\nPause/Resume: Allows stopping and re-starting of a running test case.\nStep: Allows you to “step” through a test case by running it one command at a time. Use for debugging test cases.\nTestRunner Mode: Allows you to run the test case in a browser loaded with the Selenium-Core TestRunner. The TestRunner is not commonly used now and is likely to be deprecated. This button is for evaluating test cases for backwards compatibility with the TestRunner. Most users will probably not need this button.\nApply Rollup Rules: This advanced feature allows repetitive sequences of Selenium commands to be grouped into a single action. Detailed documentation on rollup rules can be found in the UI-Element Documentation on the Help menu.\nTest Case Pane Your script is displayed in the test case pane. It has two tabs, one for displaying the command and their parameters in a readable “table” format.\nThe other tab - Source displays the test case in the native format in which the file will be stored. By default, this is HTML although it can be changed to a programming language such as Java or C#, or a scripting language like Python. See the Options menu for details. The Source view also allows one to edit the test case in its raw form, including copy, cut and paste operations.\nThe Command, Target, and Value entry fields display the currently selected command along with its parameters. These are entry fields where you can modify the currently selected command. The first parameter specified for a command in the Reference tab of the bottom pane always goes in the Target field. If a second parameter is specified by the Reference tab, it always goes in the Value field.\nIf you start typing in the Command field, a drop-down list will be populated based on the first characters you type; you can then select your desired command from the drop-down.\nLog/Reference/UI-Element/Rollup Pane The bottom pane is used for four different functions–Log, Reference, UI-Element, and Rollup–depending on which tab is selected.\nLog When you run your test case, error messages and information messages showing the progress are displayed in this pane automatically, even if you do not first select the Log tab. These messages are often useful for test case debugging. Notice the Clear button for clearing the Log. Also notice the Info button is a drop-down allowing selection of different levels of information to log.\nReference The Reference tab is the default selection whenever you are entering or modifying Selenese commands and parameters in Table mode. In Table mode, the Reference pane will display documentation on the current command. When entering or modifying commands, whether from Table or Source mode, it is critically important to ensure that the parameters specified in the Target and Value fields match those specified in the parameter list in the Reference pane. The number of parameters provided must match the number specified, the order of parameters provided must match the order specified, and the type of parameters provided must match the type specified. If there is a mismatch in any of these three areas, the command will not run correctly.\nWhile the Reference tab is invaluable as a quick reference, it is still often necessary to consult the Selenium Reference document.\nUI-Element and Rollup Detailed information on these two panes (which cover advanced features) can be found in the UI-Element Documentation on the Help menu of Selenium-IDE.\nBuilding Test Cases There are three primary methods for developing test cases. Frequently, a test developer will require all three techniques.\nRecording Many first-time users begin by recording a test case from their interactions with a website. When Selenium-IDE is first opened, the record button is ON by default. If you do not want Selenium-IDE to begin recording automatically you can turn this off by going under Options \u0026gt; Options… and deselecting “Start recording immediately on open.”\nDuring recording, Selenium-IDE will automatically insert commands into your test case based on your actions. Typically, this will include:\n clicking a link - click or clickAndWait commands entering values - type command selecting options from a drop-down listbox - select command clicking checkboxes or radio buttons - click command  Here are some “gotchas” to be aware of:\n The type command may require clicking on some other area of the web page for it to record. Following a link usually records a click command. You will often need to change this to clickAndWait to ensure your test case pauses until the new page is completely loaded. Otherwise, your test case will continue running commands before the page has loaded all its UI elements. This will cause unexpected test case failures.  Adding Verifications and Asserts With the Context Menu Your test cases will also need to check the properties of a web-page. This requires assert and verify commands. We won’t describe the specifics of these commands here; that is in the chapter on Selenium Commands – “Selenese”. Here we’ll simply describe how to add them to your test case.\nWith Selenium-IDE recording, go to the browser displaying your test application and right click anywhere on the page. You will see a context menu showing verify and/or assert commands.\nThe first time you use Selenium, there may only be one Selenium command listed. As you use the IDE however, you will find additional commands will quickly be added to this menu. Selenium-IDE will attempt to predict what command, along with the parameters, you will need for a selected UI element on the current web-page.\nLet’s see how this works. Open a web-page of your choosing and select a block of text on the page. A paragraph or a heading will work fine. Now, right-click the selected text. The context menu should give you a verifyTextPresent command and the suggested parameter should be the text itself.\nAlso, notice the Show All Available Commands menu option. This shows many, many more commands, again, along with suggested parameters, for testing your currently selected UI element.\nTry a few more UI elements. Try right-clicking an image, or a user control like a button or a checkbox. You may need to use Show All Available Commands to see options other than verifyTextPresent. Once you select these other options, the more commonly used ones will show up on the primary context menu. For example, selecting verifyElementPresent for an image should later cause that command to be available on the primary context menu the next time you select an image and right-click.\nAgain, these commands will be explained in detail in the chapter on Selenium commands. For now though, feel free to use the IDE to record and select commands into a test case and then run it. You can learn a lot about the Selenium commands simply by experimenting with the IDE.\nEditing Insert Command Table View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click on the line where you want to insert a new command. Right-click and select Insert Command; the IDE will add a blank line just ahead of the line you selected. Now use the command editing text fields to enter your new command and its parameters.\nSource View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click between the commands where you want to insert a new command, and enter the HTML tags needed to create a 3-column row containing the Command, first parameter (if one is required by the Command), and second parameter (again, if one is required to locate an element) and third parameter(again, if one is required to have a value). Example:\n\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Command\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;target (locator)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Insert Comment Comments may be added to make your test case more readable. These comments are ignored when the test case is run.\nComments may also be used to add vertical white space (one or more blank lines) in your tests; just create empty comments. An empty command will cause an error during execution; an empty comment won’t.\nTable View Select the line in your test case where you want to insert the comment. Right-click and select Insert Comment. Now use the Command field to enter the comment. Your comment will appear in purple text.\nSource View Select the point in your test case where you want to insert the comment. Add an HTML-style comment, i.e., \u0026lt;!-- your comment here --\u0026gt;.\nEdit a Command or Comment Table View Simply select the line to be changed and edit it using the Command, Target, and Value fields.\nSource View Since Source view provides the equivalent of a WYSIWYG (What You See is What You Get) editor, simply modify which line you wish–command, parameter, or comment.\nOpening and Saving a Test Case Like most programs, there are Save and Open commands under the File menu. However, Selenium distinguishes between test cases and test suites. To save your Selenium-IDE tests for later use you can either save the individual test cases, or save the test suite. If the test cases of your test suite have not been saved, you’ll be prompted to save them before saving the test suite.\nWhen you open an existing test case or suite, Selenium-IDE displays its Selenium commands in the Test Case Pane.\nRunning Test Cases The IDE allows many options for running your test case. You can run a test case all at once, stop and start it, run it one line at a time, run a single command you are currently developing, and you can do a batch run of an entire test suite. Execution of test cases is very flexible in the IDE.\nRun a Test Case\nClick the Run button to run the currently displayed test case.\nRun a Test Suite\nClick the Run All button to run all the test cases in the currently loaded test suite.\nStop and Start\nThe Pause button can be used to stop the test case while it is running. The icon of this button then changes to indicate the Resume button. To continue click Resume.\nStop in the Middle\nYou can set a breakpoint in the test case to cause it to stop on a particular command. This is useful for debugging your test case. To set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint.\nStart from the Middle\nYou can tell the IDE to begin running from a specific command in the middle of the test case. This also is used for debugging. To set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point.\nRun Any Single Command\nDouble-click any single command to run it by itself. This is useful when writing a single command. It lets you immediately test a command you are constructing, when you are not sure if it is correct. You can double-click it to see if it runs correctly. This is also available from the context menu.\nUsing Base URL to Run Test Cases in Different Domains The Base URL field at the top of the Selenium-IDE window is very useful for allowing test cases to be run across different domains. Suppose that a site named http://news.portal.com had an in-house beta site named http://beta.news.portal.com. Any test cases for these sites that begin with an open statement should specify a relative URL as the argument to open rather than an absolute URL (one starting with a protocol such as http: or https:). Selenium-IDE will then create an absolute URL by appending the open command’s argument onto the end of the value of Base URL. For example, the test case below would be run against http://news.portal.com/about.html:\nThis same test case with a modified Base URL setting would be run against http://beta.news.portal.com/about.html:\nSelenium Commands – “Selenese” Selenium commands, often called selenese, are the set of commands that run your tests. A sequence of these commands is a test script. Here we explain those commands in detail, and we present the many choices you have in testing your web application when using Selenium.\nSelenium provides a rich set of commands for fully testing your web-app in virtually any way you can imagine. The command set is often called selenese. These commands essentially create a testing language.\nIn selenese, one can test the existence of UI elements based on their HTML tags, test for specific content, test for broken links, input fields, selection list options, submitting forms, and table data among other things. In addition Selenium commands support testing of window size, mouse position, alerts, Ajax functionality, pop up windows, event handling, and many other web-application features. The Command Reference lists all the available commands.\nA command tells Selenium what to do. Selenium commands come in three “flavors”: Actions, Accessors, and Assertions.\n  Actions are commands that generally manipulate the state of the application. They do things like “click this link” and “select that option”. If an Action fails, or has an error, the execution of the current test is stopped.\nMany Actions can be called with the “AndWait” suffix, e.g. “clickAndWait”. This suffix tells Selenium that the action will cause the browser to make a call to the server, and that Selenium should wait for a new page to load.\n  Accessors examine the state of the application and store the results in variables, e.g. “storeTitle”. They are also used to automatically generate Assertions.\n  Assertions are like Accessors, but they verify that the state of the application conforms to what is expected. Examples include “make sure the page title is X” and “verify that this checkbox is checked”.\n  All Selenium Assertions can be used in 3 modes: “assert”, “verify”, and ” waitFor”. For example, you can “assertText”, “verifyText” and “waitForText”. When an “assert” fails, the test is aborted. When a “verify” fails, the test will continue execution, logging the failure. This allows a single “assert” to ensure that the application is on the correct page, followed by a bunch of “verify” assertions to test form field values, labels, etc.\n“waitFor” commands wait for some condition to become true (which can be useful for testing Ajax applications). They will succeed immediately if the condition is already true. However, they will fail and halt the test if the condition does not become true within the current timeout setting (see the setTimeout action below).\nScript Syntax Selenium commands are simple, they consist of the command and two parameters. For example:\n          verifyText //div//a[2] Login    The parameters are not always required; it depends on the command. In some cases both are required, in others one parameter is required, and in still others the command may take no parameters at all. Here are a couple more examples:\n          goBackAndWait     verifyTextPresent  Welcome to My Home Page   type id=phone (555) 666-7066   type id=address1 ${myVariableAddress}    The command reference describes the parameter requirements for each command.\nParameters vary, however they are typically:\n a locator for identifying a UI element within a page. a text pattern for verifying or asserting expected page content a text pattern or a Selenium variable for entering text in an input field or for selecting an option from an option list.  Locators, text patterns, Selenium variables, and the commands themselves are described in considerable detail in the section on Selenium Commands.\nSelenium scripts that will be run from Selenium-IDE will be stored in an HTML text file format. This consists of an HTML table with three columns. The first column identifies the Selenium command, the second is a target, and the final column contains a value. The second and third columns may not require values depending on the chosen Selenium command, but they should be present. Each table row represents a new Selenium command. Here is an example of a test that opens a page, asserts the page title and then verifies some content on the page:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;/download/\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;assertTitle\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;verifyText\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;//h2\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Rendered as a table in a browser this would look like the following:\n          open /download/    assertTitle  Downloads   verifyText //h2 Downloads    The Selenese HTML syntax can be used to write and run tests without requiring knowledge of a programming language. With a basic knowledge of selenese and Selenium-IDE you can quickly produce and run testcases.\nTest Suites A test suite is a collection of tests. Often one will run all the tests in a test suite as one continuous batch-job.\nWhen using Selenium-IDE, test suites also can be defined using a simple HTML file. The syntax again is simple. An HTML table defines a list of tests where each row defines the filesystem path to each test. An example tells it all.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Suite Function Tests - Priority 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Suite Of Tests\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./Login.html\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SearchValues.html\u0026#34;\u0026gt;Test Searching for Values\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SaveValues.html\u0026#34;\u0026gt;Test Save\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; A file similar to this would allow running the tests all at once, one after another, from the Selenium-IDE.\nTest suites can also be maintained when using Selenium-RC. This is done via programming and can be done a number of ways. Commonly Junit is used to maintain a test suite if one is using Selenium-RC with Java. Additionally, if C# is the chosen language, Nunit could be employed. If using an interpreted language like Python with Selenium-RC then some simple programming would be involved in setting up a test suite. Since the whole reason for using Selenium-RC is to make use of programming logic for your testing this usually isn’t a problem.\nCommonly Used Selenium Commands To conclude our introduction of Selenium, we’ll show you a few typical Selenium commands. These are probably the most commonly used commands for building tests.\nopen\nopens a page using a URL.\nclick/clickAndWait\nperforms a click operation, and optionally waits for a new page to load.\nverifyTitle/assertTitle\nverifies an expected page title.\nverifyTextPresent\nverifies expected text is somewhere on the page.\nverifyElementPresent\nverifies an expected UI element, as defined by its HTML tag, is present on the page.\nverifyText\nverifies expected text and its corresponding HTML tag are present on the page.\nverifyTable\nverifies a table’s expected contents.\nwaitForPageToLoad\npauses execution until an expected new page loads. Called automatically when clickAndWait is used.\nwaitForElementPresent\npauses execution until an expected UI element, as defined by its HTML tag, is present on the page.\nVerifying Page Elements Verifying UI elements on a web page is probably the most common feature of your automated tests. Selenese allows multiple ways of checking for UI elements. It is important that you understand these different methods because these methods define what you are actually testing.\nFor example, will you test that…\n an element is present somewhere on the page? specific text is somewhere on the page? specific text is at a specific location on the page?  For example, if you are testing a text heading, the text and its position at the top of the page are probably relevant for your test. If, however, you are testing for the existence of an image on the home page, and the web designers frequently change the specific image file along with its position on the page, then you only want to test that an image (as opposed to the specific image file) exists somewhere on the page.\nAssertion or Verification? Choosing between “assert” and “verify” comes down to convenience and management of failures. There’s very little point checking that the first paragraph on the page is the correct one if your test has already failed when checking that the browser is displaying the expected page. If you’re not on the correct page, you’ll probably want to abort your test case so that you can investigate the cause and fix the issue(s) promptly. On the other hand, you may want to check many attributes of a page without aborting the test case on the first failure as this will allow you to review all failures on the page and take the appropriate action. Effectively an “assert” will fail the test and abort the current test case, whereas a “verify” will fail the test and continue to run the test case.\nThe best use of this feature is to logically group your test commands, and start each group with an “assert” followed by one or more “verify” test commands. An example follows:\n   Command Target Value     open /download/    assertTitle  Downloads   verifyText //h2 Downloads   assertTable 1.2.1 Selenium IDE   verifyTable 1.2.2 June 3, 2008   verifyTable 1.2.3 1.0 beta 2    The above example first opens a page and then “asserts” that the correct page is loaded by comparing the title with the expected value. Only if this passes will the following command run and “verify” that the text is present in the expected location. The test case then “asserts” the first column in the second row of the first table contains the expected value, and only if this passed will the remaining cells in that row be “verified”.\nverifyTextPresent The command verifyTextPresent is used to verify specific text exists somewhere on the page. It takes a single argument–the text pattern to be verified. For example:\n   Command Target Value     verifyTextPresent Marketing Analysis     This would cause Selenium to search for, and verify, that the text string “Marketing Analysis” appears somewhere on the page currently being tested. Use verifyTextPresent when you are interested in only the text itself being present on the page. Do not use this when you also need to test where the text occurs on the page.\nverifyElementPresent Use this command when you must test for the presence of a specific UI element, rather than its content. This verification does not check the text, only the HTML tag. One common use is to check for the presence of an image.\n   Command Target Value     verifyElementPresent //div/p/img     This command verifies that an image, specified by the existence of an HTML tag, is present on the page, and that it follows a tag and a tag. The first (and only) parameter is a locator for telling the Selenese command how to find the element. Locators are explained in the next section.\nverifyElementPresent can be used to check the existence of any HTML tag within the page. You can check the existence of links, paragraphs, divisions , etc. Here are a few more examples.\n   Command Target Value     verifyElementPresent //div/p    verifyElementPresent //div/a    verifyElementPresent id=Login    verifyElementPresent link=Go to Marketing Research    verifyElementPresent //a[2]    verifyElementPresent //head/title     These examples illustrate the variety of ways a UI element may be tested. Again, locators are explained in the next section.\nverifyText Use verifyText when both the text and its UI element must be tested. verifyText must use a locator. If you choose an XPath or DOM locator, you can verify that specific text appears at a specific location on the page relative to other UI components on the page.\n   Command Target Value     verifyText //table/tr/td/div/p This is my text and it occurs right after the div inside the table.    Locating Elements For many Selenium commands, a target is required. This target identifies an element in the content of the web application, and consists of the location strategy followed by the location in the format locatorType=location. The locator type can be omitted in many cases. The various locator types are explained below with examples for each.\nLocating by Identifier This is probably the most common method of locating elements and is the catch-all default when no recognized locator type is used. With this strategy, the first element with the id attribute value matching the location will be used. If no element has a matching id attribute, then the first element with a name attribute matching the location will be used.\nFor instance, your page source could have id and name attributes as follows:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; The following locator strategies would return the elements from the HTML snippet above indicated by line number:\n identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)  Since the identifier type of locator is the default, the identifier= in the first three examples above is not necessary.\nLocating by Id This type of locator is more limited than the identifier locator type, but also more explicit. Use this when you know an element\u0026rsquo;s id attribute.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  id=loginForm (3)  Locating by Name The name locator type will locate the first element with a matching name attribute. If multiple elements have the same value for a name attribute, then you can use filters to further refine your location strategy. The default filter type is value (matching the value attribute).\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7)  Note: Unlike some types of XPath and DOM locators, the three types of locators above allow Selenium to test a UI element independent of its location on the page. So if the page structure and organization is altered, the test will still pass. You may or may not want to also test whether the page structure changes. In the case where web designers frequently alter the page, but its functionality must be regression tested, testing via id and name attributes, or really via any HTML property, becomes very important.\nLocating by XPath XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.\nOne of the main reasons for using XPath is when you don\u0026rsquo;t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.\nAbsolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.\nSince only xpath locators start with \u0026ldquo;//\u0026quot;, it is not necessary to include the xpath= label when specifying an XPath locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  xpath=/html/body/form[1] (3) - Absolute path (would break if the HTML was changed only slightly) //form[1] (3) - First form element in the HTML xpath=//form[@id='loginForm'] (3) - The form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; xpath=//form[input/@name='username'] (3) - First form element with an input child element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //input[@name='username'] (4) - First input element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //form[@id='loginForm']/input[1] (4) - First input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; //input[@name='continue'][@type='button'] (7) - Input with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;continue\u0026rsquo; and attribute named \u0026lsquo;type\u0026rsquo; and the value \u0026lsquo;button\u0026rsquo; //form[@id='loginForm']/input[4] (7) - Fourth input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and value \u0026lsquo;loginForm\u0026rsquo;  These examples cover some basics, but in order to learn more, the following references are recommended:\n W3Schools XPath Tutorial W3C XPath Recommendation  There are also a couple of very useful Firefox Add-ons that can assist in discovering the XPath of an element:\n XPath Checker XPath and can be used to test XPath results. [Firebug](https://addons.mozilla.org/en-US/firefox/addon/1843 - XPath suggestions are just one of the many powerful features of this very useful add-on.  Locating Hyperlinks by Link Text This is a simple method of locating a hyperlink in your web page by using the text of the link. If two links with the same text are present, then the first match will be used.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Are you sure you want to do this?\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;continue.html\u0026#34;\u0026gt;Continue\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;cancel.html\u0026#34;\u0026gt;Cancel\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  link=Continue (4) link=Cancel (5)  Locating by DOM The Document Object Model represents an HTML document and can be accessed using JavaScript. This location strategy takes JavaScript that evaluates to an element on the page, which can be simply the element\u0026rsquo;s location using the hierarchical dotted notation.\nSince only dom locators start with \u0026ldquo;document\u0026rdquo;, it is not necessary to include the dom= label when specifying a DOM locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  dom=document.getElementById('loginForm') (3) dom=document.forms['loginForm'] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements['username'] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7)  You can use Selenium itself as well as other sites and extensions to explore the DOM of your web application. A good reference exists on W3Schools.\nLocating by CSS CSS (Cascading Style Sheets) is a language for describing the rendering of HTML and XML documents. CSS uses Selectors for binding style properties to elements in the document. These Selectors can be used by Selenium as another locating strategy.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;required\u0026#34; name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;required passfield\u0026#34; name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  css=form#loginForm (3) css=input[name=\u0026quot;username\u0026quot;] (4) css=input.required[type=\u0026quot;text\u0026quot;] (4) css=input.passfield (5) css=#loginForm input[type=\u0026quot;button\u0026quot;] (7) css=#loginForm input:nth-child(2) (5)  For more information about CSS Selectors, the best place to go is the W3C publication. You\u0026rsquo;ll find additional references there.\nImplicit Locators You can choose to omit the locator type in the following situations:\n  Locators without an explicitly defined locator strategy will default to using the identifier locator strategy. See Locating by Identifier_.\n  Locators starting with \u0026ldquo;//\u0026rdquo; will use the XPath locator strategy. See Locating by XPath_.\n  Locators starting with \u0026ldquo;document\u0026rdquo; will use the DOM locator strategy. See Locating by DOM_\n  Matching Text Patterns Like locators, patterns are a type of parameter frequently required by Selenese commands. Examples of commands which require patterns are verifyTextPresent, verifyTitle, verifyAlert, assertConfirmation, verifyText, and verifyPrompt. And as has been mentioned above, link locators can utilize a pattern. Patterns allow you to describe, via the use of special characters, what text is expected rather than having to specify that text exactly.\nThere are three types of patterns: globbing, regular expressions, and exact.\nGlobbing Patterns Most people are familiar with globbing as it is utilized in filename expansion at a DOS or Unix/Linux command line such as ls *.c. In this case, globbing is used to display all the files ending with a .c extension that exist in the current directory. Globbing is fairly limited.\nOnly two special characters are supported in the Selenium implementation:\n* which translates to \u0026ldquo;match anything,\u0026rdquo; i.e., nothing, a single character, or many characters.\n[ ] (character class) which translates to \u0026ldquo;match any single character found inside the square brackets.\u0026rdquo; A dash (hyphen) can be used as a shorthand to specify a range of characters (which are contiguous in the ASCII character set). A few examples will make the functionality of a character class clear:\n[aeiou] matches any lowercase vowel\n[0-9] matches any digit\n[a-zA-Z0-9] matches any alphanumeric character\nIn most other contexts, globbing includes a third special character, the ?. However, Selenium globbing patterns only support the asterisk and character class.\nTo specify a globbing pattern parameter for a Selenese command, you can prefix the pattern with a glob: label. However, because globbing patterns are the default, you can also omit the label and specify just the pattern itself.\nBelow is an example of two commands that use globbing patterns. The actual link text on the page being tested was \u0026ldquo;Film/Television Department\u0026rdquo;; by using a pattern rather than the exact text, the click command will work even if the link text is changed to \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo; or \u0026ldquo;Film and Television Department\u0026rdquo;. The glob pattern\u0026rsquo;s asterisk will match \u0026ldquo;anything or nothing\u0026rdquo; between the word \u0026ldquo;Film\u0026rdquo; and the word \u0026ldquo;Television\u0026rdquo;.\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle glob:*Film*Television*     The actual title of the page reached by clicking on the link was \u0026ldquo;De Anza Film And Television Department - Menu\u0026rdquo;. By using a pattern rather than the exact text, the verifyTitle will pass as long as the two words \u0026ldquo;Film\u0026rdquo; and \u0026ldquo;Television\u0026rdquo; appear (in that order) anywhere in the page\u0026rsquo;s title. For example, if the page\u0026rsquo;s owner should shorten the title to just \u0026ldquo;Film \u0026amp; Television Department,\u0026rdquo; the test would still pass. Using a pattern for both a link and a simple test that the link worked (such as the verifyTitle above does) can greatly reduce the maintenance for such test cases.\nRegular Expression Patterns Regular expression patterns are the most powerful of the three types of patterns that Selenese supports. Regular expressions are also supported by most high-level programming languages, many text editors, and a host of tools, including the Linux/Unix command-line utilities grep, sed, and awk. In Selenese, regular expression patterns allow a user to perform many tasks that would be very difficult otherwise. For example, suppose your test needed to ensure that a particular table cell contained nothing but a number. regexp: [0-9]+ is a simple pattern that will match a decimal number of any length.\nWhereas Selenese globbing patterns support only the * and [ ] (character class) features, Selenese regular expression patterns offer the same wide array of special characters that exist in JavaScript. Below are a subset of those special characters:\n   PATTERN MATCH     . any single character   [ ] character class: any single character that appears inside the brackets   * quantifier: 0 or more of the preceding character (or group)   + quantifier: 1 or more of the preceding character (or group)   ? quantifier: 0 or 1 of the preceding character (or group)   {1,5} quantifier: 1 through 5 of the preceding character (or group)   | alternation: the character/group on the left or the character/group on the right   ( ) grouping: often used with alternation and/or quantifier    Regular expression patterns in Selenese need to be prefixed with either regexp: or regexpi:. The former is case-sensitive; the latter is case-insensitive.\nA few examples will help clarify how regular expression patterns can be used with Selenese commands. The first one uses what is probably the most commonly used regular expression pattern\u0026ndash;.* (\u0026ldquo;dot star\u0026rdquo;). This two-character sequence can be translated as \u0026ldquo;0 or more occurrences of any character\u0026rdquo; or more simply, \u0026ldquo;anything or nothing.\u0026rdquo; It is the equivalent of the one-character globbing pattern * (a single asterisk).\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle regexp:.*Film.*Television.*     The example above is functionally equivalent to the earlier example that used globbing patterns for this same test. The only differences are the prefix (regexp: instead of glob:) and the \u0026ldquo;anything or nothing\u0026rdquo; pattern (.* instead of just *).\nThe more complex example below tests that the Yahoo! Weather page for Anchorage, Alaska contains info on the sunrise time:\n   Command Target Value     open http://weather.yahoo.com/forecast/USAK0012.html    verifyTextPresent regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m     Let\u0026rsquo;s examine the regular expression above one part at a time:\n         Sunrise: * The string Sunrise: followed by 0 or more spaces   [0-9]{1,2} 1 or 2 digits (for the hour of the day)   : The character : (no special characters involved)   [0-9]{2} 2 digits (for the minutes) followed by a space   [ap]m \u0026ldquo;a\u0026rdquo; or \u0026ldquo;p\u0026rdquo; followed by \u0026ldquo;m\u0026rdquo; (am or pm)    Exact Patterns The exact type of Selenium pattern is of marginal usefulness. It uses no special characters at all. So, if you needed to look for an actual asterisk character (which is special for both globbing and regular expression patterns), the exact pattern would be one way to do that. For example, if you wanted to select an item labeled \u0026ldquo;Real *\u0026rdquo; from a dropdown, the following code might work or it might not. The asterisk in the glob:Real * pattern will match anything or nothing. So, if there was an earlier select option labeled \u0026ldquo;Real Numbers,\u0026rdquo; it would be the option selected rather than the \u0026ldquo;Real *\u0026rdquo; option.\n   Command Target Value     select //select glob:Real *    In order to ensure that the \u0026ldquo;Real *\u0026rdquo; item would be selected, the exact: prefix could be used to create an exact pattern as shown below:\n   Command Target Value     select //select exact:Real *    But the same effect could be achieved via escaping the asterisk in a regular expression pattern:\n   Command Target Value     select //select regexp:Real \\*    It\u0026rsquo;s rather unlikely that most testers will ever need to look for an asterisk or a set of square brackets with characters inside them (the character class for globbing patterns). Thus, globbing patterns and regular expression patterns are sufficient for the vast majority of us.\nThe \u0026ldquo;AndWait\u0026rdquo; Commands The difference between a command and its AndWait alternative is that the regular command (e.g. click) will do the action and continue with the following command as fast as it can, while the AndWait alternative (e.g. clickAndWait) tells Selenium to wait for the page to load after the action has been done.\nThe AndWait alternative is always used when the action causes the browser to navigate to another page or reload the present one.\nBe aware, if you use an AndWait command for an action that does not trigger a navigation/refresh, your test will fail. This happens because Selenium will reach the AndWait\u0026lsquo;s timeout without seeing any navigation or refresh being made, causing Selenium to raise a timeout exception.\nThe waitFor Commands in AJAX applications In AJAX driven web applications, data is retrieved from server without refreshing the page. Using andWait commands will not work as the page is not actually refreshed. Pausing the test execution for a certain period of time is also not a good approach as web element might appear later or earlier than the stipulated period depending on the system\u0026rsquo;s responsiveness, load or other uncontrolled factors of the moment, leading to test failures. The best approach would be to wait for the needed element in a dynamic period and then continue the execution as soon as the element is found.\nThis is done using waitFor commands, as waitForElementPresent or waitForVisible, which wait dynamically, checking for the desired condition every second and continuing to the next command in the script as soon as the condition is met.\nSequence of Evaluation and Flow Control When a script runs, it simply runs in sequence, one command after another.\nSelenese, by itself, does not support condition statements (if-else, etc.) or iteration (for, while, etc.). Many useful tests can be conducted without flow control. However, for a functional test of dynamic content, possibly involving multiple pages, programming logic is often needed.\nWhen flow control is needed, there are three options:\na) Run the script using Selenium-RC and a client library such as Java or PHP to utilize the programming language\u0026rsquo;s flow control features. b) Run a small JavaScript snippet from within the script using the storeEval command. c) Install the goto_sel_ide.js extension.\nMost testers will export the test script into a programming language file that uses the Selenium-RC API (see the Selenium-IDE chapter). However, some organizations prefer to run their scripts from Selenium-IDE whenever possible (for instance, when they have many junior-level people running tests for them, or when programming skills are lacking). If this is your case, consider a JavaScript snippet or the goto_sel_ide.js extension.\nStore Commands and Selenium Variables You can use Selenium variables to store constants at the beginning of a script. Also, when combined with a data-driven test design (discussed in a later section), Selenium variables can be used to store values passed to your test program from the command-line, from another program, or from a file.\nThe plain store command is the most basic of the many store commands and can be used to simply store a constant value in a Selenium variable. It takes two parameters, the text value to be stored and a Selenium variable. Use the standard variable naming conventions of only alphanumeric characters when choosing a name for your variable.\n   Command Target Value     store paul@mysite.org     Later in your script, you\u0026rsquo;ll want to use the stored value of your variable. To access the value of a variable, enclose the variable in curly brackets ({}) and precede it with a dollar sign like this.\n   Command Target Value     verifyText //div/p \\${userName}    A common use of variables is for storing input for an input field.\n   Command Target Value     type id=login \\${userName}    Selenium variables can be used in either the first or second parameter and are interpreted by Selenium prior to any other operations performed by the command. A Selenium variable may also be used within a locator expression.\nAn equivalent store command exists for each verify and assert command. Here are a couple more commonly used store commands.\nstoreElementPresent This corresponds to verifyElementPresent. It simply stores a boolean value\u0026ndash;\u0026ldquo;true\u0026rdquo; or \u0026ldquo;false\u0026rdquo;\u0026ndash;depending on whether the UI element is found.\nstoreText StoreText corresponds to verifyText. It uses a locator to identify specific page text. The text, if found, is stored in the variable. StoreText can be used to extract text from the page being tested.\nstoreEval This command takes a script as its first parameter. Embedding JavaScript within Selenese is covered in the next section. StoreEval allows the test to store the result of running the script in a variable.\nJavaScript and Selenese Parameters JavaScript can be used with two types of Selenese parameters: script and non-script (usually expressions). In most cases, you\u0026rsquo;ll want to access and/or manipulate a test case variable inside the JavaScript snippet used as a Selenese parameter. All variables created in your test case are stored in a JavaScript associative array. An associative array has string indexes rather than sequential numeric indexes. The associative array containing your test case\u0026rsquo;s variables is named storedVars. Whenever you wish to access or manipulate a variable within a JavaScript snippet, you must refer to it as storedVars[\u0026lsquo;yourVariableName\u0026rsquo;].\nJavaScript Usage with Script Parameters Several Selenese commands specify a script parameter including assertEval, verifyEval, storeEval, and waitForEval. These parameters require no special syntax. A Selenium-IDE user would simply place a snippet of JavaScript code into the appropriate field, normally the Target field (because a script parameter is normally the first or only parameter).\nThe example below illustrates how a JavaScript snippet can be used to perform a simple numerical calculation:\n   Command Target Value     store 10 hits   storeXpathCount //blockquote blockquotes   storeEval storedVars[\u0026lsquo;hits\u0026rsquo;].storedVars[\u0026lsquo;blockquotes\u0026rsquo;] paragraphs    This next example illustrates how a JavaScript snippet can include calls to methods, in this case the JavaScript String object\u0026rsquo;s toUpperCase method and toLowerCase method.\n   Command Target Value     store Edith Wharton name   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() uc   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() lc    JavaScript Usage with Non-Script Parameters JavaScript can also be used to help generate values for parameters, even when the parameter is not specified to be of type script.\nHowever, in this case, special syntax is required\u0026ndash;the entire parameter value must be prefixed by javascript{ with a trailing }, which encloses the JavaScript snippet, as in javascript{*yourCodeHere*}. Below is an example in which the type command\u0026rsquo;s second parameter value is generated via JavaScript code using this special syntax:\n   Command Target Value     store league of nations searchString   type q javascript{storedVars[\u0026lsquo;searchString\u0026rsquo;].toUpperCase()}    echo - The Selenese Print Command Selenese has a simple command that allows you to print text to your test\u0026rsquo;s output. This is useful for providing informational progress notes in your test which display on the console as your test is running. These notes also can be used to provide context within your test result reports, which can be useful for finding where a defect exists on a page in the event your test finds a problem. Finally, echo statements can be used to print the contents of Selenium variables.\n   Command Target Value     echo Testing page footer now.    echo Username is \\${userName}     Alerts, Popups, and Multiple Windows Suppose that you are testing a page that looks like this.\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function output(resultText){ document.getElementById(\u0026#39;output\u0026#39;).childNodes[0].nodeValue=resultText; } function show_confirm(){ var confirmation=confirm(\u0026#34;Chose an option.\u0026#34;); if (confirmation==true){ output(\u0026#34;Confirmed.\u0026#34;); } else{ output(\u0026#34;Rejected!\u0026#34;); } } function show_alert(){ alert(\u0026#34;I\u0026#39;m blocking!\u0026#34;); output(\u0026#34;Alert is gone.\u0026#34;); } function show_prompt(){ var response = prompt(\u0026#34;What\u0026#39;s the best web QA tool?\u0026#34;,\u0026#34;Selenium\u0026#34;); output(response); } function open_window(windowName){ window.open(\u0026#34;newWindow.html\u0026#34;,windowName); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnConfirm\u0026#34; onclick=\u0026#34;show_confirm()\u0026#34; value=\u0026#34;Show confirm box\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnAlert\u0026#34; onclick=\u0026#34;show_alert()\u0026#34; value=\u0026#34;Show alert\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPrompt\u0026#34; onclick=\u0026#34;show_prompt()\u0026#34; value=\u0026#34;Show prompt\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;newWindow.html\u0026#34; id=\u0026#34;lnkNewWindow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;New Window Link\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamelessWindow\u0026#34; onclick=\u0026#34;open_window()\u0026#34; value=\u0026#34;Open Nameless Window\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamedWindow\u0026#34; onclick=\u0026#34;open_window(\u0026#39;Mike\u0026#39;)\u0026#34; value=\u0026#34;Open Named Window\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span id=\u0026#34;output\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The user must respond to alert/confirm boxes, as well as moving focus to newly opened popup windows. Fortunately, Selenium can cover JavaScript pop-ups.\nBut before we begin covering alerts/confirms/prompts in individual detail, it is helpful to understand the commonality between them. Alerts, confirmation boxes and prompts all have variations of the following\n   Command Description     assertFoo(pattern) throws error if pattern doesn’t match the text of the pop-up   assertFooPresent throws error if pop-up is not available   assertFooNotPresent throws error if any pop-up is present   storeFoo(variable) stores the text of the pop-up in a variable   storeFooPresent(variable) stores the text of the pop-up in a variable and returns true or false    When running under Selenium, JavaScript pop-ups will not appear. This is because the function calls are actually being overridden at runtime by Selenium\u0026rsquo;s own JavaScript. However, just because you cannot see the pop-up doesn\u0026rsquo;t mean you don\u0026rsquo;t have to deal with it. To handle a pop-up, you must call its assertFoo(pattern) function. If you fail to assert the presence of a pop-up your next command will be blocked and you will get an error similar to the following [error] Error: There was an unexpected Confirmation! [Chose an option.]\nAlerts Let\u0026rsquo;s start with alerts because they are the simplest pop-up to handle. To begin, open the HTML sample above in a browser and click on the \u0026ldquo;Show alert\u0026rdquo; button. You\u0026rsquo;ll notice that after you close the alert the text \u0026ldquo;Alert is gone.\u0026rdquo; is displayed on the page. Now run through the same steps with Selenium IDE recording, and verify the text is added after you close the alert. Your test will look something like this:\n   Command Target Value     open /    click btnAlert    assertAlert I’m blocking!    verifyTextPresent Alert is gone.     You may be thinking \u0026ldquo;That\u0026rsquo;s odd, I never tried to assert that alert.\u0026rdquo; But this is Selenium-IDE handling and closing the alert for you. If you remove that step and replay the test you will get the following error [error] Error: There was an unexpected Alert! [I'm blocking!]. You must include an assertion of the alert to acknowledge its presence.\nIf you just want to assert that an alert is present but either don\u0026rsquo;t know or don\u0026rsquo;t care what text it contains, you can use assertAlertPresent. This will return true or false, with false halting the test.\nConfirmations Confirmations behave in much the same way as alerts, with assertConfirmation and assertConfirmationPresent offering the same characteristics as their alert counterparts. However, by default Selenium will select OK when a confirmation pops up. Try recording clicking on the \u0026ldquo;Show confirm box\u0026rdquo; button in the sample page, but click on the \u0026ldquo;Cancel\u0026rdquo; button in the popup, then assert the output text. Your test may look something like this:\n   Command Target Value     open /    click btnConfirm    chooseCancelOnNextConfirmation     assertConfirmation Choose an option.    verifyTextPresent Rejected     The chooseCancelOnNextConfirmation function tells Selenium that all following confirmation should return false. It can be reset by calling chooseOkOnNextConfirmation.\nYou may notice that you cannot replay this test, because Selenium complains that there is an unhandled confirmation. This is because the order of events Selenium-IDE records causes the click and chooseCancelOnNextConfirmation to be put in the wrong order (it makes sense if you think about it, Selenium can\u0026rsquo;t know that you\u0026rsquo;re cancelling before you open a confirmation) Simply switch these two commands and your test will run fine.\nPrompts Prompts behave in much the same way as alerts, with assertPrompt and assertPromptPresent offering the same characteristics as their alert counterparts. By default, Selenium will wait for you to input data when the prompt pops up. Try recording clicking on the \u0026ldquo;Show prompt\u0026rdquo; button in the sample page and enter \u0026ldquo;Selenium\u0026rdquo; into the prompt. Your test may look something like this:\n   Command Target Value     open /    answerOnNextPrompt Selenium!    click id=btnPrompt    assertPrompt What’s the best web QA tool?    verifyTextPresent Selenium!     If you choose cancel on the prompt, you may notice that answerOnNextPrompt will simply show a target of blank. Selenium treats cancel and a blank entry on the prompt basically as the same thing.\nDebugging Debugging means finding and fixing errors in your test case. This is a normal part of test case development.\nWe won\u0026rsquo;t teach debugging here as most new users to Selenium will already have some basic experience with debugging. If this is new to you, we recommend you ask one of the developers in your organization.\nBreakpoints and Startpoints The Sel-IDE supports the setting of breakpoints and the ability to start and stop the running of a test case, from any point within the test case. That is, one can run up to a specific command in the middle of the test case and inspect how the test case behaves at that point. To do this, set a breakpoint on the command just before the one to be examined.\nTo set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint. Then click the Run button to run your test case from the beginning up to the breakpoint.\nIt is also sometimes useful to run a test case from somewhere in the middle to the end of the test case or up to a breakpoint that follows the starting point.\nFor example, suppose your test case first logs into the website and then performs a series of tests and you are trying to debug one of those tests.\nHowever, you only need to login once, but you need to keep rerunning your tests as you are developing them. You can login once, then run your test case from a startpoint placed after the login portion of your test case. That will prevent you from having to manually logout each time you rerun your test case.\nTo set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point. Then click the Run button to execute the test case beginning at that startpoint.\nStepping Through a Testcase To execute a test case one command at a time (\u0026ldquo;step through\u0026rdquo; it), follow these steps:\n  Start the test case running with the Run button from the toolbar.\n  Immediately pause the executing test case with the Pause button.\n  Repeatedly select the Step button.\n  Find Button The Find button is used to see which UI element on the currently displayed webpage (in the browser) is used in the currently selected Selenium command.\nThis is useful when building a locator for a command\u0026rsquo;s first parameter (see the section on :ref:locators \u0026lt;locators-section\u0026gt; in the Selenium Commands chapter). It can be used with any command that identifies a UI element on a webpage, i.e. click, clickAndWait, type, and certain assert and verify commands, among others.\nFrom Table view, select any command that has a locator parameter. Click the Find button.\nNow look on the webpage: There should be a bright green rectangle enclosing the element specified by the locator parameter.\nPage Source for Debugging Often, when debugging a test case, you simply must look at the page source (the HTML for the webpage you\u0026rsquo;re trying to test) to determine a problem. Firefox makes this easy. Simply right-click the webpage and select \u0026lsquo;View-\u0026gt;Page Source.\nThe HTML opens in a separate window. Use its Search feature (Edit=\u0026gt;Find) to search for a keyword to find the HTML for the UI element you\u0026rsquo;re trying to test.\nAlternatively, select just that portion of the webpage for which you want to see the source. Then right-click the webpage and select View Selection Source. In this case, the separate HTML window will contain just a small amount of source, with highlighting on the portion representing your selection.\nLocator Assistance Whenever Selenium-IDE records a locator-type argument, it stores additional information which allows the user to view other possible locator-type arguments that could be used instead. This feature can be very useful for learning more about locators, and is often needed to help one build a different type of locator than the type that was recorded.\nThis locator assistance is presented on the Selenium-IDE window as a drop-down list accessible at the right end of the Target field (only when the Target field contains a recorded locator-type argument).\nBelow is a snapshot showing the contents of this drop-down for one command. Note that the first column of the drop-down provides alternative locators, whereas the second column indicates the type of each alternative.\nWriting a Test Suite A test suite is a collection of test cases which is displayed in the leftmost pane in the IDE.\nThe test suite pane can be manually opened or closed via selecting a small dot halfway down the right edge of the pane (which is the left edge of the entire Selenium-IDE window if the pane is closed).\nThe test suite pane will be automatically opened when an existing test suite is opened or when the user selects the New Test Case item from the File menu. In the latter case, the new test case will appear immediately below the previous test case.\nSelenium-IDE also supports loading pre-existing test cases by using the File -\u0026gt; Add Test Case menu option. This allows you to add existing test cases to a new test suite.\nA test suite file is an HTML file containing a one-column table. Each cell of each row in the section contains a link to a test case. The example below is of a test suite containing four test cases:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Sample Selenium Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Test Cases for De Anza A-Z Directory Links\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./a.html\u0026#34;\u0026gt;A Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./b.html\u0026#34;\u0026gt;B Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./c.html\u0026#34;\u0026gt;C Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./d.html\u0026#34;\u0026gt;D Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Note: Test case files should not have to be co-located with the test suite file that invokes them. And on Mac OS and Linux systems, that is indeed the case. However, at the time of this writing, a bug prevents Windows users from being able to place the test cases elsewhere than with the test suite that invokes them.\nUser Extensions User extensions are JavaScript files that allow one to create his or her own customizations and features to add additional functionality. Often this is in the form of customized commands although this extensibility is not limited to additional commands.\nThere are a number of useful extensions_ created by users.\nIMPORTANT: THIS SECTION IS OUT OF DATE\u0026ndash;WE WILL BE REVISING THIS SOON.\n _extensions: http://wiki.openqa.org/display/SEL/Contributed+User-Extensions  .. _goto_sel_ide.js extension:\nPerhaps the most popular of all Selenium-IDE extensions is one which provides flow control in the form of while loops and primitive conditionals. This extension is the goto_sel_ide.js_. For an example of how to use the functionality provided by this extension, look at the page_ created by its author.\nTo install this extension, put the pathname to its location on your computer in the Selenium Core extensions field of Selenium-IDE\u0026rsquo;s Options=\u0026gt;Options=\u0026gt;General tab.\nAfter selecting the OK button, you must close and reopen Selenium-IDE in order for the extensions file to be read. Any change you make to an extension will also require you to close and reopen Selenium-IDE.\nInformation on writing your own extensions can be found near the bottom of the Selenium Reference_ document.\nSometimes it can prove very useful to debug step by step Selenium IDE and your User Extension. The only debugger that appears able to debug XUL/Chrome based extensions is Venkman which is supported in Firefox until version 32 included. The step by step debug has been verified to work with Firefox 32 and Selenium IDE 2.9.0.\nFormat Format, under the Options menu, allows you to select a language for saving and displaying the test case. The default is HTML.\nIf you will be using Selenium-RC to run your test cases, this feature is used to translate your test case into a programming language. Select the language, e.g. Java, PHP, you will be using with Selenium-RC for developing your test programs. Then simply save the test case using File=\u0026gt;Export Test Case As. Your test case will be translated into a series of functions in the language you choose. Essentially, program code supporting your test is generated for you by Selenium-IDE.\nAlso, note that if the generated code does not suit your needs, you can alter it by editing a configuration file which defines the generation process.\nEach supported language has configuration settings which are editable. This is under the Options=\u0026gt;Options=\u0026gt;Formats tab.\nExecuting Selenium-IDE Tests on Different Browsers While Selenium-IDE can only run tests against Firefox, tests developed with Selenium-IDE can be run against other browsers, using a simple command-line interface that invokes the Selenium-RC server. This topic is covered in the :ref:Run Selenese tests \u0026lt;html-suite\u0026gt; section on Selenium-RC chapter. The -htmlSuite command-line option is the particular feature of interest.\nTroubleshooting Below is a list of image/explanation pairs which describe frequent sources of problems with Selenium-IDE:\nTable view is not available with this format.\nThis message can be occasionally displayed in the Table tab when Selenium IDE is launched. The workaround is to close and reopen Selenium IDE. See issue 1008. for more information. If you are able to reproduce this reliably then please provide details so that we can work on a fix.\n error loading test case: no command found\nYou\u0026rsquo;ve used File=\u0026gt;Open to try to open a test suite file. Use File=\u0026gt;Open Test Suite instead.\nAn enhancement request has been raised to improve this error message. See issue 1010.\n This type of error may indicate a timing problem, i.e., the element specified by a locator in your command wasn\u0026rsquo;t fully loaded when the command was executed. Try putting a pause 5000 before the command to determine whether the problem is indeed related to timing. If so, investigate using an appropriate waitFor* or *AndWait command before the failing command.\n Whenever your attempt to use variable substitution fails as is the case for the open command above, it indicates that you haven\u0026rsquo;t actually created the variable whose value you\u0026rsquo;re trying to access. This is sometimes due to putting the variable in the Value field when it should be in the Target field or vice versa. In the example above, the two parameters for the store command have been erroneously placed in the reverse order of what is required. For any Selenese command, the first required parameter must go in the Target field, and the second required parameter (if one exists) must go in the Value field.\n error loading test case: [Exception\u0026hellip; \u0026ldquo;Component returned failure code: 0x80520012 (NS_ERROR_FILE_NOT_FOUND) [nsIFileInputStream.init]\u0026rdquo; nresult: \u0026ldquo;0x80520012 (NS_ERROR_FILE_NOT_FOUND)\u0026rdquo; location: \u0026ldquo;JS frame :: chrome://selenium-ide/content/file-utils.js :: anonymous :: line 48\u0026rdquo; data: no]\nOne of the test cases in your test suite cannot be found. Make sure that the test case is indeed located where the test suite indicates it is located. Also, make sure that your actual test case files have the .html extension both in their filenames, and in the test suite file where they are referenced.\nAn enhancement request has been raised to improve this error message. See issue 1011.\n Your extension file\u0026rsquo;s contents have not been read by Selenium-IDE. Be sure you have specified the proper pathname to the extensions file via Options=\u0026gt;Options=\u0026gt;General in the Selenium Core extensions field. Also, Selenium-IDE must be restarted after any change to either an extensions file or to the contents of the Selenium Core extensions field.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/grid/when_to_use_grid/",
	"title": "Quand utiliser Grid",
	"tags": [],
	"description": "",
	"content": "De manière générale, il existe deux raisons pour lesquelles vous souhaiterez peut-être utiliser Grid.\n Pour exécuter vos tests sur plusieurs navigateurs, plusieurs versions de navigateur, et les navigateurs fonctionnant sur différents systèmes d\u0026rsquo;exploitation. Pour réduire le temps nécessaire à la suite de tests pour terminer une passe de test.  La grille est utilisée pour accélérer l\u0026rsquo;exécution d\u0026rsquo;un test réussi en utilisant plusieurs machines pour exécuter des tests en parallèle. Par exemple, si vous avez une suite de 100 tests, mais vous avez configuré Grid pour prendre en charge 4 machines différentes (VM ou machines physiques distinctes) pour exécuter ces tests, votre suite de tests se terminera en (environ) un quart du temps comme si vous exécutiez vos tests de manière séquentielle sur une seule machine. Pour les grandes suites de tests et les suites de tests de longue durée telles que ceux qui effectuent de grandes quantités de validation des données, cela peut être un gagne-temps. Certaines suites de tests peuvent prendre des heures à s\u0026rsquo;exécuter. Une autre raison de booster la le temps passé à exécuter la suite est de raccourcir le délai d\u0026rsquo;exécution des résultats des tests après le code d\u0026rsquo;enregistrement des développeurs pour l\u0026rsquo;AUT. De plus en plus d'équipes logicielles pratiquant le développement logiciel Agile veulent des commentaires sur les tests aussi possible par opposition à attendre la nuit pour un passage de test de nuit.\nLa grille est également utilisée pour prendre en charge l\u0026rsquo;exécution de tests sur plusieurs environnements d\u0026rsquo;exécution environnements, en particulier, contre différents navigateurs en même temps. Pour Par exemple, une \u0026ldquo;grille\u0026rdquo; de machines virtuelles peut être configurée, chacune prenant en charge un navigateur différent que l\u0026rsquo;application à tester doit prendre en charge. Donc, la machine 1 a Internet Explorer 8, machine 2, Internet Explorer 9, machine 3 la dernière Chrome et la machine 4 la dernière version de Firefox. Lorsque la suite de tests est exécutée, Selenium-Grid reçoit chaque combinaison de navigateur de test et attribue chaque test à exécuter sur son navigateur requis.\nDe plus, on peut avoir une grille de tous les mêmes navigateur, type et version. Pour par exemple, on pourrait avoir une grille de 4 machines exécutant chacune 3 instances de Firefox 70, permettant une \u0026ldquo;batterie de serveurs\u0026rdquo; (dans un sens) de Firefox disponible instances. Lorsque la suite s\u0026rsquo;exécute, chaque test est passé à Grid qui attribue le test à la prochaine instance de Firefox disponible. De cette manière, on obtient la réussite du test où, en théorie, 12 tests sont tous en cours d\u0026rsquo;exécution en même temps dans parallèle, ce qui réduit considérablement le temps nécessaire pour réussir un test.\nLa grille est très flexible. Ces deux exemples peuvent être combinés pour permettre plusieurs instances de chaque type et version de navigateur. Une configuration telle que cela fournirait à la fois une exécution parallèle pour un achèvement rapide des tests et prise en charge simultanée de plusieurs types et versions de navigateur.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "Réaliser des action sur l&#39;AUT*",
	"tags": [],
	"description": "",
	"content": "Il est possible de renseigner le texte d\u0026rsquo;un élément web grâce à la méthode sendKeys, comme suit:\nJava Python C# Ruby JavaScript Kotlin String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(By.NAME, \u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);   val name = \u0026#34;Charles\u0026#34; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name)     Certaines applications web utilisent des librairies Javascript pour ajouter des fonctionnalités de drag-and-drop. Suit un exemple basique permettant de dragger un élément sur un autre :\nJava Python C# Ruby JavaScript Kotlin WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element(By.ID, \u0026#34;source\u0026#34;) target = driver.find_element(By.ID, \u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();   val source = driver.findElement(By.id(\u0026#34;source\u0026#34;)) val target = driver.findElement(By.id(\u0026#34;target\u0026#34;)) Actions(driver).dragAndDrop(source, target).build().perform()     Cliquer sur un élément Il est possible de cliquer sur un élément en utilisant la méhode click:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element(By.CSS_SELECTOR, \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click()     AUT: Application testée (Application under test en anglais)\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/waits/",
	"title": "Waits",
	"tags": [],
	"description": "",
	"content": "WebDriver peut généralement être considéré comme ayant une API de blocage. Parce que c\u0026rsquo;est une bibliothèque hors processus qui instruit le navigateur à faire, et parce que la plate-forme Web a une nature intrinsèquement asynchrone, WebDriver ne suit pas l'état actif en temps réel du DOM. Cela s\u0026rsquo;accompagne de quelques défis que nous aborderons ici.\nDe l\u0026rsquo;expérience, la plupart des intermittents résultant de l\u0026rsquo;utilisation de Selenium et de WebDriver sont liés aux conditions de concurrence qui se produisent entre le navigateur et les instructions de l\u0026rsquo;utilisateur. Un exemple pourrait être que l\u0026rsquo;utilisateur demande au navigateur de naviguer vers une page, obtient alors une erreur no such element lorsque vous essayez de trouver un élément.\nConsidérez le document suivant:\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; Les instructions WebDriver peuvent sembler assez innocentes:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Get and store Paragraph Text search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     Le problème ici est que la valeur par défaut stratégie de chargement de page utilisé dans WebDriver écoute le document.readyState pour passer à \u0026quot;complete\u0026quot; avant de revenir de l\u0026rsquo;appel à navigate. Parce que l'élément p est ajouté après le chargement du document, ce script WebDriver peut être intermittent. Elle \u0026ldquo;pourrait\u0026rdquo; être intermittente car aucune garantie ne peut être apportée sur les éléments ou événements qui se déclenchent de manière asynchrone sans attendre ou bloquer explicitement ces événements.\nHeureusement, en utilisant le jeu d\u0026rsquo;instructions normal disponible sur l\u0026rsquo;interface [WebElement] (/webdriver/web_element/) - telle comme WebElement.click et WebElement.sendKeys — sont garantie d'être synchrone, en ce que les appels de fonction ne reviendront pas (ou le rappel ne se déclenchera pas dans les langues de style rappel) jusqu'à ce que la commande soit terminée dans le navigateur. Les API d\u0026rsquo;interaction utilisateur avancées, Keyboard et Mouse, sont des exceptions car ils sont explicitement destinés à \u0026ldquo;Faire ce que je dis\u0026rdquo;, commandes asynchrones.\nL\u0026rsquo;attente, c\u0026rsquo;est l\u0026rsquo;exécution automatisée des tâches s\u0026rsquo;est écoulé un certain temps avant de passer à l'étape suivante.\nPour surmonter le problème des conditions de course entre le navigateur et votre script WebDriver, la plupart des clients Selenium sont livrés avec un package wait. Lorsque vous utilisez une attente, vous utilisez ce qui est communément appelé en tant que explicit wait.\nExplicit wait Explicit Wait sont disponibles pour les clients Selenium pour les langages procéduraux impératifs. Ils permettent à votre code d\u0026rsquo;arrêter l\u0026rsquo;exécution du programme, ou geler le fil, jusqu'à ce que le condition que vous passez, il résout. La condition est appelée avec une certaine fréquence jusqu'à ce que le délai d\u0026rsquo;attente soit écoulé. Cela signifie que tant que la condition renvoie une valeur fausse, il continuera d\u0026rsquo;essayer et d\u0026rsquo;attendre.\nÉtant donné que les attentes explicites vous permettent d\u0026rsquo;attendre qu\u0026rsquo;une condition se produise, ils font un bon ajustement pour synchroniser l'état entre le navigateur et son DOM, et votre script WebDriver.\nPour remédier à notre jeu d\u0026rsquo;instructions de buggy antérieur, nous pourrions utiliser une attente pour avoir l\u0026rsquo;appel findElement attendre que l'élément ajouté dynamiquement du script a été ajouté au DOM:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Initialize and wait till element(link) became clickable - timeout in 10 seconds WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Print the first result System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Initialize and wait till element(link) became clickable - timeout in 10 seconds val firstResult = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Print the first result println(firstResult.text)     On passe la condition comme référence de fonction que le wait s\u0026rsquo;exécutera à plusieurs reprises jusqu'à ce que sa valeur de retour soit véridique. Une valeur de retour \u0026ldquo;véridique\u0026rdquo; est tout ce qui est évalué comme booléen true dans la langue utilisée, comme une chaîne, un nombre, un booléen, un objet (dont un WebElement), ou une séquence ou une liste remplie (non vide). Cela signifie qu\u0026rsquo;une liste vide est évaluée comme fausse. Lorsque la condition est vraie et que l\u0026rsquo;attente de blocage est abandonnée, la valeur de retour de la condition devient la valeur de retour de l\u0026rsquo;attente.\nAvec cette connaissance, et parce que l\u0026rsquo;utilitaire d\u0026rsquo;attente n\u0026rsquo;ignore pas une telle erreur d'élément par défaut, nous pouvons refactoriser nos instructions pour être plus concis:\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3)) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); }   driver.get \u0026#39;file:///race_condition.html\u0026#39; wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) ele = wait.until { driver.find_element(css: \u0026#39;p\u0026#39;)} foo = ele.text assert_match foo, \u0026#39;Hello from JavaScript\u0026#39;   let ele = await driver.wait(until.elementLocated(By.css(\u0026#39;p\u0026#39;)),10000); let foo = await ele.getText(); assert(foo == \u0026#34;Hello from JavaScript\u0026#34;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val ele = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026#34;p\u0026#34;))) assert(ele.text == \u0026#34;Hello from JavaScript!\u0026#34;)     Dans cet exemple, nous passons une fonction anonyme (mais nous pourrions également le définir explicitement comme nous l\u0026rsquo;avons fait précédemment afin qu\u0026rsquo;il puisse être réutilisé). Le premier et le seul argument qui est passé à notre condition est toujours une référence à notre objet pilote, WebDriver (appelé d dans l\u0026rsquo;exemple). Dans un environnement multi-thread, vous devez être prudent pour opérer sur la référence du conducteur transmise à la condition plutôt que la référence au pilote dans la portée externe.\nParce que l\u0026rsquo;attente n\u0026rsquo;avalera pas de telles erreurs d'élément qui sont levées lorsque l'élément n\u0026rsquo;est pas trouvé, la condition réessayera jusqu'à ce que l'élément soit trouvé. Ensuite, il prendra la valeur de retour, en tant qu'élément Web, et le transmettre à notre script.\nSi la condition échoue, par exemple. une valeur de retour véridique de la condition n\u0026rsquo;est jamais atteinte, l\u0026rsquo;attente générera / déclenchera une erreur / exception appelée erreur de temporisation.\nOptions La condition d\u0026rsquo;attente peut être personnalisée pour répondre à vos besoins. Parfois, il n\u0026rsquo;est pas nécessaire d\u0026rsquo;attendre toute l'étendue du délai d\u0026rsquo;expiration par défaut, car la pénalité pour ne pas avoir réussi peut être chère.\nL\u0026rsquo;attente vous permet de passer un argument pour remplacer le délai:\nJava Python C# Ruby JavaScript Kotlin new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) wait.until { driver.find_element(:id, \u0026#39;message\u0026#39;).displayed? }   await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000);   WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     Expected conditions Parce que c\u0026rsquo;est assez courant d\u0026rsquo;avoir à synchroniser le DOM et vos instructions, la plupart des clients sont également livrés avec un ensemble de expected conditions prédéfinies. Comme son nom l\u0026rsquo;indique, ce sont des conditions prédéfinies pour les opérations d\u0026rsquo;attente fréquentes.\nLes conditions disponibles dans les différentes liaisons linguistiques varient, mais ceci est une liste non exhaustive de quelques-uns:\n alert is present element exists element is visible title contains title is element staleness visible text  Vous pouvez vous référer à la documentation de l\u0026rsquo;API pour chaque liaison client pour trouver une liste exhaustive des conditions attendues:\n Java\u0026rsquo;s org.openqa.selenium.support.ui.ExpectedConditions class Python\u0026rsquo;s selenium.webdriver.support.expected_conditions class .NET\u0026rsquo;s OpenQA.Selenium.Support.UI.ExpectedConditions type  Implicit wait Il existe un deuxième type d\u0026rsquo;attente distinct de attente explicite appelée implicit wait. En attendant implicitement, WebDriver interroge le DOM pendant une certaine durée lors de la recherche de l'élément any. Cela peut être utile lorsque certains éléments de la page Web ne sont pas disponibles immédiatement et nécessitent un certain temps de chargement.\nAttendre implicitement que les éléments apparaissent est désactivé par défaut et devra être activé manuellement sur une base par session. Mélange attentes explicites et attentes implicites entraînera des conséquences inattendues, à savoir les attentes de sommeil pour le maximum même si l'élément est disponible ou si la condition est vraie.\navertissement: Ne mélangez pas les attentes implicites et explicites. Cela peut entraîner des temps d\u0026rsquo;attente imprévisibles. Par exemple, définir une attente implicite de 10 secondes et une attente explicite de 15 secondes pourrait entraîner un délai d\u0026rsquo;attente après 20 secondes.\nUne attente implicite consiste à dire à WebDriver d\u0026rsquo;interroger le DOM pendant un certain temps lorsque vous essayez de trouver un élément ou des éléments s\u0026rsquo;ils ne sont pas immédiatement disponibles. Le paramètre par défaut est 0, ce qui signifie désactivé. Une fois définie, l\u0026rsquo;attente implicite est définie pour la durée de vie de la session.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element(By.ID, \u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Apply timeout for 10 seconds await driver.manage().setTimeouts( { implicit: 10000 } ); // Navigate to url await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     FluentWait L\u0026rsquo;instance FluentWait définit la durée maximale d\u0026rsquo;attente d\u0026rsquo;une condition, ainsi que la fréquence à laquelle vérifier l'état.\nLes utilisateurs peuvent configurer l\u0026rsquo;attente pour ignorer des types spécifiques d\u0026rsquo;exceptions en attendant, comme NoSuchElementException lors de la recherche d\u0026rsquo;un élément sur la page.\nJava Python C# Ruby JavaScript Kotlin // Waiting 30 seconds for an element to be present on the page, checking // for its presence once every 5 seconds. Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox exception = Selenium::WebDriver::Error::NoSuchElementError begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; wait = Selenium::WebDriver::Wait.new(timeout: 30, interval: 5, message: \u0026#39;Timed out after 30 sec\u0026#39;, ignore: exception) foo = wait.until { driver.find_element(id: \u0026#39;foo\u0026#39;)} ensure driver.quit end   const {Builder, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); // Waiting 30 seconds for an element to be present on the page, checking  // for its presence once every 5 seconds.  let foo = await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000, \u0026#39;Timed out after 30 seconds\u0026#39;, 5000); })();   val wait = FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/support_classes/",
	"title": "Classes de support",
	"tags": [],
	"description": "",
	"content": "Les classes de support WebDriver sont fournies pour simplifier la maintenance de votre code.Elles fournissent une belle abstraction pour faciliter la modélisation des éléments HTML en tant qu\u0026rsquo;objets de domaine, ainsi que des méthodes d\u0026rsquo;aide pour rendre l\u0026rsquo;utilisation de ces objets facile à raisonner.\n Stratégies de localisation Événements LoadableComponent ThreadGuard etc.  Commençons:\nThreadGuard  Cette classe est uniquement disponible dans la liaison Java\n ThreadGuard vérifie qu\u0026rsquo;un pilote est appelé uniquement à partir du même thread qui l\u0026rsquo;a créé. Les problèmes de thread, en particulier lors de l\u0026rsquo;exécution de tests en parallèle, peuvent être mystérieux et difficile à diagnostiquer les erreurs. L\u0026rsquo;utilisation de ce wrapper empêche cette catégorie d\u0026rsquo;erreurs et lèvera une exception lorsque cela se produira.\nL\u0026rsquo;exemple suivant simule un choc de threads:\npublic class DriverClash { //thread main (id 1) created this driver  private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;\u0026lt;Set path to your Chromedriver\u0026gt;\u0026#34;); } //Thread-1 (id 24) is calling the same driver causing the clash to happen  Runnable r1 = () -\u0026gt; {protectedDriver.get(\u0026#34;https://selenium.dev\u0026#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } Le résultat ci-dessous:\nException in thread \u0026#34;Thread-1\u0026#34; org.openqa.selenium.WebDriverException: Thread safety error; this instance of WebDriver was constructed on thread main (id 1)and is being accessed by thread Thread-1 (id 24) This is not permitted and *will* cause undefined behaviour Comme le montre l\u0026rsquo;exemple:\n protectedDriver sera créé dans le thread principal Nous utilisons Java Runnable pour lancer un nouveau processus et un nouveau Thread pour exécuter le processus Les deux Thread s\u0026rsquo;affrontent car le Thread principal n\u0026rsquo;a pas protectedDriver dans sa mémoire. ThreadGuard.protect lèvera une exception.  Remarque: Cela ne remplace pas la nécessité d\u0026rsquo;utiliser ThreadLocal pour gérer les pilotes lors de l\u0026rsquo;exécution en parallèle.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/worst_practices/test_dependency/",
	"title": "Dépéndence des tests",
	"tags": [],
	"description": "",
	"content": "Une idée courante et une idée fausse concernant les tests automatisés concernent ordre de test spécifique. Vos tests devraient pouvoir s\u0026rsquo;exécuter dans n\u0026rsquo;importe quel ordre, et ne pas compter sur d\u0026rsquo;autres tests pour réussir pour réussir.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/improved_reporting/",
	"title": "Reporting amélioré",
	"tags": [],
	"description": "",
	"content": "Le sélénium n\u0026rsquo;est pas conçu pour rendre compte de l'état des cas de test courir. Profitant des capacités de rapport intégrées de l\u0026rsquo;unité les cadres de test sont un bon début. La plupart des cadres de tests unitaires ont rapports pouvant générer des rapports au format xUnit ou HTML. xUnit les rapports sont populaires pour importer des résultats dans une intégration continue (CI) comme Jenkins, Travis, Bamboo, etc. Voici quelques liens pour plus d\u0026rsquo;informations sur les sorties de rapports pour plusieurs langues.\nNUnit 3 Console Runner\nNUnit 3 Console Command Line\nxUnit getting test results in TeamCity\nxUnit getting test results in CruiseControl.NET\nxUnit getting test results in Azure DevOps\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": "WebDriver WebDriver pilote un navigateur nativement, comme le ferait un utilisateur, soit localement ou sur une machine distante utilisant le serveur Selenium, marque un bond en avant en termes d\u0026rsquo;automatisation du navigateur.\nSelenium WebDriver fait référence aux deux liaisons de langue et les implémentations du code de contrôle de navigateur individuel. Ceci est communément appelé simplement WebDriver.\nSelenium WebDriver est une recommandation du W3C\n  WebDriver est conçu comme un simple et une interface de programmation plus concise.\n  WebDriver est une API orientée objet compacte.\n  Il pilote efficacement le navigateur.\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/js_alerts_prompts_and_confirmations/",
	"title": "Alerts, prompts et confirmations Javascript",
	"tags": [],
	"description": "",
	"content": "WebDriver fournit une API pour travailler avec les trois types de messages contextuels natifs proposés par JavaScript. Ces popups sont stylisés par le navigateur et offrent une personnalisation limitée.\nAlerts Le plus simple d\u0026rsquo;entre eux est appelé une alerte, qui montre une message personnalisé, et un seul bouton qui rejette l\u0026rsquo;alerte, étiqueté dans la plupart des navigateurs comme OK. Il peut également être ignoré dans la plupart des navigateurs par en appuyant sur le bouton de fermeture, mais cela fera toujours la même chose que le bouton OK. Voir un exemple d\u0026rsquo;alerte.\nWebDriver peut obtenir le texte de la fenêtre contextuelle et les accepter ou les rejeter alertes.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See an example alert\u0026#34;).click() # Wait for the alert to be displayed and store it in a variable alert = wait.until(expected_conditions.alert_is_present()) # Store the alert text in a variable text = alert.text # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert text in a variable string text = alert.Text; //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on OK button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the OK button await alert.accept(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Store the alert text in a variable val text = alert.getText() //Press the OK button alert.accept()     Confirm Une boîte de confirmation est similaire à une alerte, sauf que l\u0026rsquo;utilisateur peut également choisir pour annuler le message. Voir un échantillon confirme .\nCet exemple montre également une approche différente du stockage d\u0026rsquo;une alerte:\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()); //Store the alert in a variable Alert alert = driver.switchTo().alert(); //Store the alert in a variable for reuse String text = alert.getText(); //Press the Cancel button alert.dismiss();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample confirm\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = driver.switch_to.alert # Store the alert text in a variable text = alert.text # Press the Cancel button alert.dismiss()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Wait for the alert to be displayed wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert in a variable IAlert alert = driver.SwitchTo().Alert(); //Store the alert in a variable for reuse string text = alert.Text; //Press the Cancel button alert.Dismiss();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on Cancel button alert.dismiss   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the Cancel button await alert.dismiss(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()) //Store the alert in a variable val alert = driver.switchTo().alert() //Store the alert in a variable for reuse val text = alert.text //Press the Cancel button alert.dismiss()     Prompt Les invites sont similaires aux cases de confirmation, sauf qu\u0026rsquo;elles incluent également un texte contribution. Comme pour travailler avec des éléments de formulaire, vous pouvez utiliser WebDriver envoyer des clés pour remplir une réponse. Cela remplacera complètement l\u0026rsquo;espace réservé texte. En appuyant sur le bouton Annuler, aucun texte ne sera envoyé. Voir un exemple d\u0026rsquo;invite .\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample prompt\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = Alert(driver) # Type your message alert.send_keys(\u0026#34;Selenium\u0026#34;) # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Type your message alert.SendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Type a message alert.send_keys(\u0026#34;selenium\u0026#34;) # Press on Ok button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Type your message await alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button await alert.accept(); //Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;) //Press the OK button alert.accept()     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/avoid_sharing_state/",
	"title": "Eviter de partager l&#39;état",
	"tags": [],
	"description": "",
	"content": "Bien que mentionné à plusieurs endroits, il convient de le mentionner à nouveau. Assurer les tests sont isolés les uns des autres.\n  Ne partagez pas les données de test. Imaginez plusieurs tests qui interrogent chacun la base de données pour les commandes valides avant d\u0026rsquo;en choisir une pour effectuer une action. Devrait deux tests prenez la même commande que vous risquez d\u0026rsquo;obtenir un comportement inattendu.\n  Nettoyez les données périmées dans l\u0026rsquo;application qui pourraient être récupérées par un autre test par ex. enregistrements de commande invalides.\n  Créez une nouvelle instance WebDriver par test. Cela permet d\u0026rsquo;assurer l\u0026rsquo;isolement des tests et rend la parallélisation plus simple.\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/remote_webdriver/",
	"title": "Remote WebDriver",
	"tags": [],
	"description": "",
	"content": "Remote WebDriver Vous pouvez utiliser WebDriver à distance de la même manière que vous l\u0026rsquo;utiliseriez localement. La principale différence est qu’un WebDriver distant doit être configuré pour qu\u0026rsquo;il puisse exécuter vos tests sur une machine distincte.\nUn WebDriver distant est composé de deux éléments: un client et un serveur. Le client est votre test WebDriver et le serveur est simplement un Servlet Java, qui peut être hébergé sur n\u0026rsquo;importe quel serveur d\u0026rsquo;application JEE moderne.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/worst_practices/performance_testing/",
	"title": "Test de performance",
	"tags": [],
	"description": "",
	"content": "Test de performances avec Selenium et WebDriver n\u0026rsquo;est généralement pas conseillé. Pas parce qu\u0026rsquo;il est incapable mais parce qu\u0026rsquo;il n\u0026rsquo;est pas optimisé pour le travail et il est peu probable que vous obteniez de bons résultats.\nCela peut sembler idéal pour tester les performances dans le contexte de l\u0026rsquo;utilisateur mais une suite de tests WebDriver sont soumis à de nombreux points de fragilité externe et interne qui échappent à votre contrôle; par exemple la vitesse de démarrage du navigateur, vitesse des serveurs HTTP, réponse des serveurs tiers qui hébergent JavaScript ou CSS, et la pénalité d\u0026rsquo;instrumentation de l\u0026rsquo;implémentation WebDriver elle-même. Une variation à ces points entraînera une variation de vos résultats. Il est difficile de séparer la différence entre les performances de votre site web et la performance des ressources externes, et il est également difficile de dire quelle est la pénalité de performance pour utiliser WebDriver dans le navigateur, surtout si vous injectez des scripts.\nL\u0026rsquo;autre attraction potentielle est \u0026ldquo;gagner du temps\u0026rdquo; - effectuer des tests fonctionnels et de performance en même temps. Cependant, les tests fonctionnels et de performance ont des objectifs opposés. Pour tester la fonctionnalité, un testeur peut devoir être patient et attendre le chargement, mais cela obscurcira les résultats des tests de performances et vice versa.\nPour améliorer les performances de votre site Web, vous devrez être en mesure d\u0026rsquo;analyser les performances globales indépendamment des différences d\u0026rsquo;environnement, identifier les mauvaises pratiques de code, ventilation des performances des ressources individuelles (i.e. CSS ou JavaScript) afin de savoir quoi améliorer. Il existe des outils de test de performance disponibles qui peut déjà faire ce travail, et qui fournissent des rapports et des analyses qui peut même faire des suggestions d\u0026rsquo;amélioration.\nExemples de packages (open source) à utiliser: JMeter\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/support_packages/working_with_cookies/",
	"title": "Travailler avec des cookies",
	"tags": [],
	"description": "",
	"content": "Un cookie est un petit morceau de données qui est envoyé à partir d\u0026rsquo;un site Web et stocké dans votre ordinateur. Les cookies sont principalement utilisés pour reconnaître l\u0026rsquo;utilisateur et charger les informations stockées.\nL\u0026rsquo;API WebDriver fournit un moyen d\u0026rsquo;interagir avec les cookies avec des méthodes intégrées:\nAdd Cookie Il est utilisé pour ajouter un cookie au contexte de navigation actuel. Ajouter un cookie accepte uniquement un ensemble d\u0026rsquo;objets JSON sérialisables définis. Ici est le lien vers la liste des valeurs de clé JSON acceptées\nTout d\u0026rsquo;abord, vous devez être sur le domaine où le cookie sera valable. Si vous essayez de prédéfinir des cookies avant vous commencez à interagir avec un site et votre page d\u0026rsquo;accueil est grande / prend un certain temps à charger une alternative consiste à trouver une page plus petite sur le site (généralement la page 404 est petite, par exemple. http://example.com/some404page)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Adds the cookie into current browser context  driver.manage().addCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;})   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace AddCookie { class AddCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Adds the cookie into current browser context  driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context driver.manage.add_cookie(name: \u0026#34;key\u0026#34;, value: \u0026#34;value\u0026#34;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;}); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Adds the cookie into current browser context  driver.manage().addCookie(Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit() } }     Get Named Cookie Il renvoie les données de cookie sérialisées correspondant au nom du cookie parmi tous les cookies associés.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class getCookieNamed { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  Cookie cookie1 = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); System.out.println(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bar\u0026#34;}) # Get cookie details with named cookie \u0026#39;foo\u0026#39; print(driver.get_cookie(\u0026#34;foo\u0026#34;))   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetCookieNamed { class GetCookieNamed { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  var cookie = driver.Manage().Cookies.GetCookieNamed(\u0026#34;foo\u0026#34;); System.Console.WriteLine(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;) # Get cookie details with named cookie \u0026#39;foo\u0026#39; puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;foo\u0026#39;, value: \u0026#39;bar\u0026#39;}); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  driver.manage().getCookie(\u0026#39;foo\u0026#39;).then(function (cookie) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookie); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  val cookie = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); println(cookie); } finally { driver.quit() } }     Get All Cookies Il renvoie des \u0026lsquo;données de cookie sérialisées réussies\u0026rsquo; pour le contexte de navigation actuel. Si le navigateur n\u0026rsquo;est plus disponible, il renvoie une erreur.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Set; public class getAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Add few cookies  driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  Set\u0026lt;Cookie\u0026gt; cookies = driver.manage().getCookies(); System.out.println(cookies); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Get all available cookies print(driver.get_cookies())   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetAllCookies { class GetAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  var cookies = driver.Manage().Cookies.AllCookies; } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Get all available cookies puts driver.manage.all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  val cookies = driver.manage().cookies; println(cookies); } finally { driver.quit() } }     Delete Cookie Il supprime les données de cookie correspondant au nom de cookie fourni.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); Cookie cookie1 = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); /* Selenium Java bindings also provides a way to delete cookie by passing cookie object of current browsing context */ driver.manage().deleteCookie(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Delete a cookie with name \u0026#39;test1\u0026#39; driver.delete_cookie(\u0026#34;test1\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteCookie { class DeleteCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); var cookie = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.Manage().Cookies.AddCookie(cookie); // delete a cookie with name \u0026#39;test1\u0026#39;\t driver.Manage().Cookies.DeleteCookieNamed(\u0026#34;test1\u0026#34;); // Selenium .net bindings also provides a way to delete  // cookie by passing cookie object of current browsing context  driver.Manage().Cookies.DeleteCookie(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # delete a cookie with name \u0026#39;test1\u0026#39; driver.manage.delete_cookie(\u0026#39;test1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete a cookie with name \u0026#39;test1\u0026#39;  await driver.manage().deleteCookie(\u0026#39;test1\u0026#39;); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); val cookie1 = Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;) driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); // delete cookie by passing cookie object of current browsing context.  driver.manage().deleteCookie(cookie1); } finally { driver.quit() } }     Delete All Cookies Il supprime tous les cookies du contexte de navigation actuel.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Deletes all cookies driver.delete_all_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteAllCookies { class DeleteAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.Manage().Cookies.DeleteAllCookies(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # deletes all cookies driver.manage.delete_all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete all cookies  await driver.manage().deleteAllCookies(); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit() } }     Same-Site Cookie Attribute Il permet à un utilisateur de demander aux navigateurs de contrôler si les cookies sont envoyés avec la demande initiée par des sites tiers. Il est introduit pour empêcher les attaques CSRF (Cross-Site Request Forgery).\nL\u0026rsquo;attribut de cookie du même site accepte deux paramètres comme instructions\nStrict: Lorsque l\u0026rsquo;attribut sameSite est défini sur Strict, le cookie ne sera pas envoyé avec demandes initiées par des sites Web tiers.\nLax: Lorsque vous définissez un attribut sameSite de cookie sur Lax, le cookie sera envoyé avec le GET demande initiée par un site Web tiers.\nRemarque: À partir de maintenant, cette fonctionnalité est livrée en chrome (version 80 +) et fonctionne avec Selenium 4 et versions ultérieures.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class cookieTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); Cookie cookie = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build(); Cookie cookie1 = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build(); driver.manage().addCookie(cookie); driver.manage().addCookie(cookie1); System.out.println(cookie.getSameSite()); System.out.println(cookie1.getSameSite()); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Strict\u0026#39;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Lax\u0026#39;}) cookie1 = driver.get_cookie(\u0026#39;foo\u0026#39;) cookie2 = driver.get_cookie(\u0026#39;foo1\u0026#39;) print(cookie1) print(cookie2)   // Please raise a PR    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Strict\u0026#34;) driver.manage.add_cookie(name: \u0026#34;foo1\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Lax\u0026#34;) puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) puts driver.manage.cookie_named(\u0026#39;foo1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39;  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Strict\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Lax\u0026#39;}); console.log(await driver.manage().getCookie(\u0026#39;key\u0026#39;)); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;http://www.example.com\u0026#34;) val cookie = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build() val cookie1 = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build() driver.manage().addCookie(cookie) driver.manage().addCookie(cookie1) println(cookie.getSameSite()) println(cookie1.getSameSite()) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/test_independency/",
	"title": "Indépendence des tests",
	"tags": [],
	"description": "",
	"content": "Écrivez chaque test comme sa propre unité. Écrivez les tests d\u0026rsquo;une manière qui ne sera pas dépendant d\u0026rsquo;autres tests pour effectuer:\nDisons qu\u0026rsquo;il existe un système de gestion de contenu avec lequel vous pouvez créer du contenu personnalisé qui apparaît ensuite sur votre site Web sous forme de module après la publication et la synchronisation entre le CMS et le serveur peut prendre un certain temps. application.\nUne mauvaise façon de tester votre module est que le contenu est créé et publié dans un test, puis vérifier le module dans un autre test. Cette n\u0026rsquo;est pas réalisable car le contenu peut ne pas être disponible immédiatement pour le autre test après publication.\nAu lieu de cela, vous pouvez créer un contenu de stub qui peut être activé et désactivé dans le test affecté, et utilisez-le pour valider le module. cependant, pour la création de contenu, vous pouvez toujours avoir un test séparé.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/",
	"title": "Lignes directrices et recommendations",
	"tags": [],
	"description": "",
	"content": "Lignes directrices et recommandations Une note sur les \u0026ldquo;meilleures pratiques\u0026rdquo;: nous avons intentionnellement évité l\u0026rsquo;expression \u0026ldquo;meilleures Pratiques \u0026ldquo;dans cette documentation. Aucune approche ne fonctionne pour toutes les situations. Nous préférons l\u0026rsquo;idée de \u0026ldquo;Lignes directrices et recommandations\u0026rdquo;. Nous encourageons vous devez les lire et décider de manière réfléchie quelles approches travaillera pour vous dans votre environnement particulier.\nLes tests fonctionnels sont difficiles à obtenir correctement pour de nombreuses raisons. Comme si l'état, la complexité et les dépendances des applications ne rendent pas les tests assez difficiles, gérer les navigateurs (en particulier les incompatibilités entre navigateurs) fait de la rédaction de bons tests un défi.\nSelenium fournit des outils pour faciliter l\u0026rsquo;interaction fonctionnelle des utilisateurs, mais ne vous aide pas à écrire des suites de tests bien conçues. Dans ce chapitre, nous proposons des conseils, des directives et des recommandations sur la façon d\u0026rsquo;aborder l\u0026rsquo;automatisation fonctionnelle des pages Web.\nCe chapitre enregistre les modèles de conception de logiciels populaires parmi de nombreux utilisateurs de sélénium qui ont fait leurs preuves au fil des ans.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/worst_practices/link_spidering/",
	"title": "Link spidering",
	"tags": [],
	"description": "",
	"content": "Utilisation de WebDriver pour parcourir des liens n\u0026rsquo;est pas une pratique recommandée non pas parce que cela ne peut pas être fait, mais parce que ce n\u0026rsquo;est certainement pas l\u0026rsquo;outil le plus idéal. WebDriver a besoin de temps pour démarrer, et peut prendre plusieurs secondes jusqu'à une minute en fonction de la façon dont votre test est écrit, juste pour accéder à la page et parcourir le DOM.\nAu lieu d\u0026rsquo;utiliser WebDriver pour cela, vous pourriez économiser une tonne de temps en exécutant une commande curl, ou en utilisant une bibliothèque telle que BeautifulSoup puisque ces méthodes ne reposent pas sur la création d\u0026rsquo;un navigateur et la navigation vers une page. Vous économisez des tonnes de temps en n\u0026rsquo;utilisant pas WebDriver pour cette tâche.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/http_proxies/",
	"title": "Proxys HTTP",
	"tags": [],
	"description": "",
	"content": "Un serveur proxy sert d\u0026rsquo;intermédiaire pour les demandes entre un client et un serveur. En toute simplicité, le trafic circule via le serveur proxy en route vers l\u0026rsquo;adresse vous avez demandé et retour.\nUn serveur proxy pour les scripts d\u0026rsquo;automatisation avec Le Selenium pourrait être utile pour:\n Capturez le trafic réseau Mock backend calls made by the website Accéder au site Web demandé sous un réseau complexe topologies ou restrictions / politiques d\u0026rsquo;entreprise strictes.  Si vous êtes dans un environnement d\u0026rsquo;entreprise et le navigateur ne parvient pas à se connecter à une URL, c\u0026rsquo;est très probablement parce que l\u0026rsquo;environnement a besoin d\u0026rsquo;un proxy à accéder.\nSelenium WebDriver permet d\u0026rsquo;accéder aux paramètres du proxy\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Proxy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.chrome.ChromeOptions; public class proxyTest { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;); ChromeOptions options = new ChromeOptions(); options.setCapability(\u0026#34;proxy\u0026#34;, proxy); WebDriver driver = new ChromeDriver(options); driver.get(\u0026#34;https://www.google.com/\u0026#34;); driver.manage().window().maximize(); driver.quit(); } }   from selenium import webdriver PROXY = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34; webdriver.DesiredCapabilities.FIREFOX[\u0026#39;proxy\u0026#39;] = { \u0026#34;httpProxy\u0026#34;: PROXY, \u0026#34;ftpProxy\u0026#34;: PROXY, \u0026#34;sslProxy\u0026#34;: PROXY, \u0026#34;proxyType\u0026#34;: \u0026#34;MANUAL\u0026#34;, } with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://selenium.dev\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; public class ProxyTest{ public static void Main() { ChromeOptions options = new ChromeOptions(); Proxy proxy = new Proxy(); proxy.Kind = ProxyKind.Manual; proxy.IsAutoDetect = false; proxy.SslProxy = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;; options.Proxy = proxy; options.AddArgument(\u0026#34;ignore-certificate-errors\u0026#34;); IWebDriver driver = new ChromeDriver(options); driver.Navigate().GoToUrl(\u0026#34;https://www.selenium.dev/\u0026#34;); } }   # Need PR   // need PR    import org.openqa.selenium.Proxy import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions class proxyTest { fun main() { val proxy = Proxy() proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;) val options = ChromeOptions() options.setCapability(\u0026#34;proxy\u0026#34;, proxy) val driver: WebDriver = ChromeDriver(options) driver[\u0026#34;https://www.google.com/\u0026#34;] driver.manage().window().maximize() driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/consider_using_a_fluent_api/",
	"title": "Considerer l&#39;utilisation d&#39;une API fluent",
	"tags": [],
	"description": "",
	"content": "Martin Fowler a inventé le terme [\u0026ldquo;Fluent API\u0026rdquo;](// www.martinfowler.com/bliki/FluentInterface.html). Sélénium déjà implémente quelque chose comme ça dans leur classe FluentWait, qui est conçu comme une alternative à la classe standard Wait. Vous pouvez activer le modèle de conception de l\u0026rsquo;API Fluent dans votre objet de page puis interrogez la page de recherche Google avec un extrait de code comme celui-ci:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); La classe d\u0026rsquo;objets de page Google avec ce comportement fluide pourrait ressembler à ceci:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // If load() fails, calls isLoaded() until page is finished loading  PageFactory.initElements(driver, this); // Initialize WebElements on page  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, Duration.ofSeconds(3) ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } } "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/worst_practices/",
	"title": "Mauvaises pratiques",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Worst practices "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/page_loading_strategy/",
	"title": "Stratégie de chargement de la page",
	"tags": [],
	"description": "",
	"content": "Définit la stratégie de chargement des pages de la session en cours. Par défaut, lorsque Selenium WebDriver charge une page, il suit le normal pageLoadStrategy. Il est toujours recommandé d\u0026rsquo;arrêter le téléchargement de ressources (comme les images, css, js) lorsque le chargement de la page prend beaucoup de temps.\nLa propriété document.readyState d\u0026rsquo;un document décrit l'état de chargement du document actuel. Par défaut, WebDriver ne répondra pas à un driver.get() (ou) driver.navigate().to() appeler jusqu'à ce que l'état prêt du document soit complete\nDans les applications SPA (comme Angular, react, Ember) une fois le contenu dynamique est déjà chargé (c\u0026rsquo;est-à-dire une fois que le statut de pageLoadStrategy est COMPLETE), cliquer sur un lien ou effectuer une action dans la page ne fera pas de nouvelle demande sur le serveur car le contenu est chargé dynamiquement côté client sans actualisation de la page d\u0026rsquo;extraction.\nLes applications SPA peuvent charger de nombreuses vues dynamiquement sans aucune demande de serveur, donc pageLoadStrategy affichera toujours l'état COMPLETE jusqu'à nous faisons un nouveau driver.get() et driver.navigate().to()\nWebDriver pageLoadStrategy prend en charge les valeurs suivantes:\nnormal Cela obligera Selenium WebDriver à attendre que la page entière soit chargée. Lorsqu\u0026rsquo;il est réglé sur normal, Selenium WebDriver attend que le load le feu d'événement est renvoyé.\nPar défaut, normal est défini sur le navigateur si aucun n\u0026rsquo;est fourni.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;normal\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Normal; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;normal\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;normal\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     eager Cela fera attendre Selenium WebDriver jusqu'à ce que le document HTML initial a été complètement chargé et analysé, et supprime le chargement des feuilles de style, des images et des sous-trames.\nLorsqu\u0026rsquo;il est réglé sur eager, Selenium WebDriver attend jusqu'à Le feu d'événement DOMContentLoaded est renvoyé.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;eager\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Eager; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;eager\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;eager\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     none Lorsqu\u0026rsquo;il est défini sur none Selenium WebDriver n\u0026rsquo;attend que le téléchargement de la page initiale.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;none\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.None; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;none\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;none\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/grid/",
	"title": "Grid",
	"tags": [],
	"description": "",
	"content": "Grid Selenium Grid est un serveur proxy intelligent qui permet aux tests Selenium d\u0026rsquo;acheminer des commandes vers des instances de navigateur Web distantes. Son objectif est de fournir un moyen simple d\u0026rsquo;exécuter des tests en parallèle sur plusieurs machines.\nAvec Selenium Grid, un serveur fait office de concentrateur qui achemine les commandes de test au format JSON à un ou plusieurs nœuds de grille enregistrés. Les tests contactent le concentrateur pour obtenir l\u0026rsquo;accès aux instances de navigateur distantes. Le concentrateur dispose d\u0026rsquo;une liste de serveurs enregistrés auxquels il donne accès, et permet le contrôle de ces instances.\nSelenium Grid nous permet d\u0026rsquo;effectuer des tests en parallèle sur plusieurs machines, et pour gérer les différentes versions et configurations de navigateur de manière centralisée (au lieu de dans chaque test individuel).\nLa grille de sélénium n\u0026rsquo;est pas une solution miracle. Il résout un sous-ensemble de problèmes de délégation et de distribution communs, mais ne gèrera par exemple pas votre infrastructure, et pourrait ne pas répondre à vos besoins spécifiques.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/guidelines_and_recommendations/fresh_browser_per_test/",
	"title": "Nouveau navigateur par test",
	"tags": [],
	"description": "",
	"content": "Commencez chaque test à partir d\u0026rsquo;un état connu propre. Idéalement, faites tourner une nouvelle machine virtuelle pour chaque test. Si la rotation d\u0026rsquo;une nouvelle machine virtuelle n\u0026rsquo;est pas pratique, démarrez au moins un nouveau WebDriver pour chaque test. Pour Firefox, démarrez un WebDriver avec votre profil connu.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile); "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/web_element/",
	"title": "Web element",
	"tags": [],
	"description": "",
	"content": "WebElement représente un élément DOM. Les WebElements peuvent être trouvés en recherchant racine du document à l\u0026rsquo;aide d\u0026rsquo;une instance WebDriver ou en recherchant sous une autre WebElement\nL\u0026rsquo;API WebDriver fournit des méthodes intégrées pour trouver les WebElements qui sont basé sur différentes propriétés comme ID, nom, classe, XPath, sélecteurs CSS, texte de lien, etc.\nFind Element Il est utilisé pour rechercher un élément et renvoie une première référence WebElement unique correspondante, qui peut être utilisé pour de futures actions d'élément\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element WebElement searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_box = driver.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_bar = driver.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element let searchBar = driver.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element val searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements Similaire à \u0026ldquo;Rechercher un élément\u0026rdquo;, mais renvoie une liste de WebElements correspondants. Pour utiliser un WebElement particulier de la liste, vous devez parcourir la liste des éléments pour effectuer une action sur l'élément sélectionné.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import java.util.List; public class findElementsExample { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement element : elements) { System.out.println(\u0026#34;Paragraph text:\u0026#34; + element.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() # Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using System.Collections.Generic; namespace FindElementsExample { class FindElementsExample { public static void Main(string[] args) { IWebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = driver.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await driver.findElements(By.tagName(\u0026#39;p\u0026#39;)); for(let e of elements) { console.log(await e.getText()); } } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (element in elements) { println(\u0026#34;Paragraph text:\u0026#34; + element.text) } } finally { driver.quit() } }     Find Element From Element Il est utilisé pour rechercher un élément enfant dans le contexte de l'élément parent. Pour ce faire, le WebElement parent est chaîné avec \u0026lsquo;findElement\u0026rsquo; pour accéder aux éléments enfants\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element(By.TAG_NAME, \u0026#34;form\u0026#34;) search_box = search_form.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = searchForm.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Get search box element from webElement \u0026#39;form\u0026#39; search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; let searchForm = driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Get search box element from webElement \u0026#39;form\u0026#39; let searchBar = searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements From Element Il est utilisé pour rechercher la liste des WebElements enfants correspondants dans le contexte de l'élément parent. Pour ce faire, le WebElement parent est chaîné avec \u0026ldquo;findElements\u0026rdquo; pour accéder aux éléments enfants\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import java.util.List; public class findElementsFromElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  WebElement element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement e : elements) { System.out.println(e.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(By.TAG_NAME, \u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System.Collections.Generic; namespace FindElementsFromElement { class FindElementsFromElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  IWebElement element = driver.FindElement(By.TagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = element.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(:tag_name,\u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get element with tag name \u0026#39;div\u0026#39;  let element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for(let e of elements) { console.log(await e.getText()); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get element with tag name \u0026#39;div\u0026#39;  val element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (e in elements) { println(e.text) } } finally { driver.quit() } }     Get Active Element Il est utilisé pour suivre (ou) trouver l'élément DOM qui a le focus dans le contexte de navigation actuel.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class activeElementTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  String attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); System.out.println(attr); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.find_element(By.CSS_SELECTOR, \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#34;webElement\u0026#34;) # Get attribute of current active element attr = driver.switch_to.active_element.get_attribute(\u0026#34;title\u0026#34;) print(attr)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace ActiveElement { class ActiveElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://www.google.com\u0026#34;); driver.FindElement(By.CssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).SendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  string attr = driver.SwitchTo().ActiveElement().GetAttribute(\u0026#34;title\u0026#34;); System.Console.WriteLine(attr); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.google.com\u0026#39; driver.find_element(css: \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#39;webElement\u0026#39;) # Get attribute of current active element attr = driver.switch_to.active_element.attribute(\u0026#39;title\u0026#39;) puts attr ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); await driver.get(\u0026#39;https://www.google.com\u0026#39;); await driver.findElement(By.css(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  let attr = await driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); console.log(`${attr}`) })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;) // Get attribute of current active element  val attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); print(attr); } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/support_packages/chrome_devtools/",
	"title": "Chrome Devtools",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Selenium 4 alpha versions have much awaited native support for Chrome Dev Protocol through \u0026ldquo;DevTools\u0026rdquo; interface. This helps us getting Chrome Development properties such as Application Cache, Fetch, Network, Performance, Profiler, Resource Timing, Security and Target CDP domains etc.\nChrome DevTools is a set of web developer tools built directly into the Google Chrome browser. DevTools can help you edit pages on-the-fly and diagnose problems quickly, which ultimately helps you build better websites, faster.\nEmulate Geo Location: Some applications have different features and functionalities across different locations. Automating such applications is difficult because it is hard to emulate the geo locations in the browser using Selenium. But with the help of Devtools, we can easily emulate them. Below code snippet demonstrates that.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.devtools.DevTools; public void geoLocationTest(){ ChromeDriver driver = new ChromeDriver(); Map coordinates = new HashMap() {{ put(\u0026#34;latitude\u0026#34;, 50.2334); put(\u0026#34;longitude\u0026#34;, 0.2334); put(\u0026#34;accuracy\u0026#34;, 1); }}; driver.executeCdpCommand(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, coordinates); driver.get(\u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;); }   # Please raise a PR to add code sample   // Please raise a PR to add code sample    # Please raise a PR to add code sample   // Please raise a PR to add code sample    // Please raise a PR to add code sample      "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/webdriver/keyboard/",
	"title": "Clavier",
	"tags": [],
	"description": "",
	"content": "Le clavier représente un événement KeyBoard. Les actions du clavier sont effectuées à l\u0026rsquo;aide de bas niveau interface qui nous permet de fournir une entrée d\u0026rsquo;appareil virtualisé au navigateur Web.\nsendKeys SendKeys tape une séquence de touches dans l'élément DOM même si une séquence de touches de modification est rencontrée. Here are the list of possible keystrokes that WebDriver Supports.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER);\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Firefox()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r \rusing (var driver = new FirefoxDriver())\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :firefox\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.firefox.FirefoxDriver\rfun main() {\rval driver = FirefoxDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER)\r} finally {\rdriver.quit()\r}\r}\r \r  keyDown Le keyDown est utilisé pour simuler l\u0026rsquo;action d\u0026rsquo;appuyer sur une touche de modification (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER);\rActions actionProvider = new Actions(driver);\rAction keydown = actionProvider.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build();\rkeydown.perform();\r} finally {\rdriver.quit();\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r webdriver.ActionChains(driver).key_down(Keys.CONTROL).send_keys(\u0026#34;a\u0026#34;).perform()\r \rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r Actions actionProvider = new Actions(driver);\rIAction keydown = actionProvider.KeyDown(Keys.Control).SendKeys(\u0026#34;a\u0026#34;).Build();\rkeydown.Perform();\r}\rfinally\r{\rdriver.Quit();\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r driver.action.key_down(:control).send_keys(\u0026#39;a\u0026#39;).perform\rensure\rdriver.quit\rend\r \r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r await driver.actions().keyDown(Key.CONTROL).sendKeys(\u0026#39;a\u0026#39;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\rval action = Actions(driver)\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r action.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  keyUp Le keyUp est utilisé pour simuler l\u0026rsquo;action de relâchement (ou) de relâchement de touche d\u0026rsquo;une touche de modification (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rimport org.openqa.selenium.interactions.Actions;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r WebElement search = driver.findElement(By.name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search,\u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store google search box WebElement\r search = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\raction = webdriver.ActionChains(driver)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.key_down(Keys.SHIFT).send_keys_to_element(search, \u0026#34;qwerty\u0026#34;).key_up(Keys.SHIFT).send_keys(\u0026#34;qwerty\u0026#34;).perform()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing OpenQA.Selenium.Interactions;\rnamespace HelloSelenium\r{\rclass HelloSelenium\r{\rpublic static void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r IWebElement search = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.KeyDown(Keys.Shift).SendKeys(search, \u0026#34;qwerty\u0026#34;).KeyUp(Keys.Shift).SendKeys(\u0026#34;qwerty\u0026#34;).Perform();\r}\rfinally {\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Store google search box WebElement\r search = driver.find_element(name: \u0026#39;q\u0026#39;)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r driver.action.key_down(:shift).send_keys(search,\u0026#39;qwerty\u0026#39;).key_up(:shift).send_keys(\u0026#34;qwerty\u0026#34;).perform\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store google search box WebElement\r let search = driver.findElement(By.name(\u0026#39;q\u0026#39;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r await driver.actions().click(search).keyDown(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).keyUp(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Store google search box WebElement\r val search = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rval action = Actions(driver)\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search, \u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  clear Efface le contenu d\u0026rsquo;un élément modifiable. Ceci n\u0026rsquo;est appliqué qu\u0026rsquo;aux éléments modifiables et interactifs, sinon le sélénium renvoie l\u0026rsquo;erreur (état d'élément invalide (ou) élément non interactif)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.chrome.ChromeDriver;\rpublic class clear {\rpublic static void main(String[] args) {\rWebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r WebElement searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;));\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.clear();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store \u0026#39;SearchInput\u0026#39; element\r SearchInput = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\rSearchInput.send_keys(\u0026#34;selenium\u0026#34;)\r# Clears the entered text\r SearchInput.clear()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing System;\rnamespace SnipetProjectDelete\r{\rclass Program\r{\rstatic void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(@\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r IWebElement searchInput = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\rsearchInput.SendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.Clear();\r}\rfinally\r{\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# store \u0026#39;search_input\u0026#39; element\r search_input = driver.find_element(name: \u0026#39;q\u0026#39;)\rsearch_input.send_keys(\u0026#39;selenium\u0026#39;)\r# Clears the entered text\r search_input.clear\rensure\rdriver.quit\rend\r \rconst {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store \u0026#39;SearchInput\u0026#39; element\r let searchInput = driver.findElement(By.name(\u0026#39;q\u0026#39;));\rawait searchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r await searchInput.clear();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.chrome.ChromeDriver\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;)\r// Store \u0026#39;searchInput\u0026#39; element\r val searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;)\r// Clears the entered text\r searchInput.clear()\r} finally {\rdriver.quit()\r}\r}\r \r  "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/driver_idiosyncrasies/",
	"title": "Singularités du Driver",
	"tags": [],
	"description": "",
	"content": "Singularités du Driver "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/support_packages/",
	"title": "Packages de support",
	"tags": [],
	"description": "",
	"content": "Packages de support "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/legacy_docs/",
	"title": "Legacy",
	"tags": [],
	"description": "",
	"content": "Legacy Sous cette section, vous trouverez toute la documentation relative aux composants hérités de Selenium. Ceci est destiné à être conservé uniquement pour des raisons historiques et non comme une incitation à utiliser Composants.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/front_matter/",
	"title": "Front matter",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Front matter "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.selenium.dev/documentation/fr/contributing/",
	"title": "Contributing to the Selenium Site &amp; Documentation",
	"tags": [],
	"description": "",
	"content": "Selenium est un gros projet logiciel, son site et sa documentation sont essentiels comprendre comment les choses fonctionnent et apprendre des moyens efficaces d\u0026rsquo;exploiter son potentiel.\nCe projet contient à la fois le site et la documentation de Selenium. C\u0026rsquo;est un effort continu (qui ne vise aucune version spécifique) pour fournir des informations mises à jour sur la façon d\u0026rsquo;utiliser efficacement le sélénium, impliqués et comment contribuer au sélénium.\nLes contributions vers le site et les documents suivent le processus décrit dans la section ci-dessous sur les contributions. Tu devrais passer du temps vous familiariser avec la documentation en lisant en savoir plus.\nLe projet Selenium accueille les contributions de tous. Il y a un plusieurs façons d\u0026rsquo;aider:\nSignaler un problème Lorsque vous signalez un nouveau problème ou commentez un problème existant, veuillez assurez-vous que les discussions sont liées à des problèmes techniques concrets avec le Logiciel Selenium, son site et / ou sa documentation.\nTous les composants Selenium changent assez rapidement au fil du temps, donc cela peut rendre la documentation obsolète. Si vous trouvez cela être le cas, comme mentionné, ne doutez pas de créer un problème pour cela. Il est également possible que vous sachiez comment mettre à jour documentation, merci de nous envoyer une pull request avec les informations changements.\nSi vous n'êtes pas sûr que ce que vous avez trouvé soit un problème ou non, Si vous n'êtes pas sûr que ce que vous avez trouvé soit un problème ou non, veuillez demander par les canaux de communication décrits à https://selenium.dev/support.\nContributions Le projet Selenium accueille de nouveaux contributeurs. Les individus qui font des contributions importantes et précieuses au fil du temps sont faites Committers et donné un accès de validation au projet.\nCe guide vous guidera tout au long du processus de contribution.\nStep 1: Fork Fork le projet sur Github et vérifiez votre copie localement.\n% git clone git@github.com:seleniumhq/seleniumhq.github.io.git % cd seleniumhq.github.io Dépendances: Hugo Nous utilisons Hugo pour construire et rendre le site et les documents. Pour tout vérifier localement avant même de commettre des modifications, veuillez installez Hugo, familiarisez-vous avec elle et exécutez le serveur local pour rendre le site localement (des instructions détaillées peuvent être trouvées dans le prochaines étapes).\nStep 2: Branch Créez une branche de fonctionnalité et lancez le piratage:\n% git checkout -b my-feature-branch Nous pratiquons le développement basé sur HEAD, ce qui signifie que tous les changements sont appliqués directement sur le dessus du maître.\nStep 3: Faire des changements Le référentiel contient le site et les documents, qui sont deux Hugo séparés projets. Si vous souhaitez apporter des modifications au site, travaillez sur le répertoire site_source_files. Pour voir un aperçu en direct de vos modifications, exécutez hugo server sur le répertoire racine du site.\n% cd site_source_files % hugo server Pour apporter des modifications aux documents, basculez vers le répertoire docs_source_files.\n% cd docs_source_files % hugo server Les documents sont traduits en plusieurs langues et les traductions sont basées sur le contenu anglais. Lorsque vous modifiez un fichier, assurez-vous de changements dans tous les autres fichiers traduits également. Cela peut différer selon sur le changement, par exemple:\n Si vous ajoutez un exemple de code au fichier browser_manipulation.en.md, ajoutez-le également à browser_manipulation.es.md, browser_manipulation.ef.md, browser_manipulation.ja.md, et tous les autres fichiers traduits. Si vous trouvez une traduction qui peut être améliorée, ne modifiez que la traduction fichier. Si vous ajoutez une nouvelle traduction linguistique, ajoutez les nouveaux fichiers avec le suffixe approprié. Il n\u0026rsquo;est pas nécessaire de tout traduire pour soumettre un PR, cela peut être fait de manière itérative. N\u0026rsquo;oubliez pas de vérifier certaines configurations nécessaires dans le fichier config.toml. Si vous apportez des modifications au texte dans la version anglaise, remplacez la même section dans les fichiers traduits avec votre modification (oui, en anglais), et ajoutez ce qui suit remarquez en haut du fichier.  {{% notice info %}} \u0026lt;i class=\u0026#34;fas fa-language\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Page being translated from English to {LANGUAGE}. Do you speak {LANGUAGE}? Help us to translate it by sending us pull requests! {{% /notice %}} Step 4: Commit Assurez-vous d\u0026rsquo;abord que git connaît votre nom et votre adresse e-mail:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; Il est important d'écrire de bons messages de validation. Un message de validation devrait décrire ce qui a changé, pourquoi et les problèmes de référence résolus (si tout). Suivez ces directives lorsque vous en rédigez une:\n La première ligne doit contenir environ 50 caractères ou moins et contenir un brève description du changement. Laissez la deuxième ligne vierge. Enveloppez toutes les autres lignes sur 72 colonnes. Incluez Fixes #N, où N est le numéro de problème du commit corrections, le cas échéant.  Un bon message de validation peut ressembler à ceci:\nexplain commit normatively in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way `git log` will show things nicely even when it is indented. Fixes #141 La première ligne doit être significative car c\u0026rsquo;est ce que les gens voient lorsqu\u0026rsquo;ils exécutez git shortlog ou git log --oneline.\nStep 5: Rebase Utilisez git rebase (et non git merge) pour synchroniser votre travail de temps en temps.\n% git fetch upstream % git rebase upstream/master Step 6: Test N\u0026rsquo;oubliez pas de exécuter le serveur local, avec cela, vous pouvez être sûr que vos modifications n\u0026rsquo;ont rien cassé.\nStep 7: Push % git push origin my-feature-branch Accédez à _https://github.com/yourusername/seleniumhq.github.io.git_ et appuyez sur la Pull Request et remplissez le formulaire. Indiquez s\u0026rsquo;il vous plait que vous avez signé le CLA (voir l'étape 7).\nLes demandes d\u0026rsquo;extraction sont généralement examinées en quelques jours. S\u0026rsquo;il y a commentaires à adresser, appliquez vos modifications dans les nouveaux commits (de préférence fixups) et pousser à la même chose branche.\nStep 8: Integration Lorsque la révision du code est terminée, un committer prendra votre PR et l\u0026rsquo;intégrer dans la branche principale du référentiel. Parce que nous aimons garder un histoire linéaire sur la branche principale, nous allons normalement écraser et rebaser l\u0026rsquo;historique de votre succursale.\nCommunication Tous les détails sur la façon de communiquer avec les contributeurs du projet et la communauté dans son ensemble se trouve sur https://selenium.dev/support\n"
},
{
	"uri": "https://www.selenium.dev/documentation/fr/",
	"title": "Le Projet d&#39;Automatisation de Navigateur Selenium",
	"tags": [],
	"description": "",
	"content": "Le Projet d\u0026rsquo;Automatisation de Navigateur Selenium Selenium est projet englobant un éventail d\u0026rsquo;outils et de librairies permettant l\u0026rsquo;automtisation des navigateurs internet.\nIl fournit des extensions afin d'émuler des interactions utilisateur avec les navigateurs, un serveur de distribution permettant la mise à l'échelle de l\u0026rsquo;allocation de navigateur ainsi que l\u0026rsquo;infrastructure pour l\u0026rsquo;implémentation de la spécification W3C WebDriver permettant l'écriture de code interchangeable pour tous les principaux navigateurs.\nCe projet est rendu possible grâce au contributeurs volontaires ayant investi des milliers d\u0026rsquo;heures de leur temps et rendu le code source disponible librement à quiconque souhaitant l\u0026rsquo;utiliser et l\u0026rsquo;améliorer ou simplement s\u0026rsquo;amuser.\nSelenium rassemble distributeurs de navigateur, ingénieurs et entousiastes pour favoriser une discussion ouverte autour de l\u0026rsquo;automatisation de la platerforme web. Le projet organise une conférence annuelle afin d\u0026rsquo;entretenir cette communauté.\nAu coeur de Selenium se trouve WebDriver, une interface permettant d'écrire des instructions pouvant être exécutées indifférement par de nombreux navigateurs. Voici par exemple une des plus simples instructions disponibles:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; import java.time.Duration; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #This example requires Selenium WebDriver 3.13 or newer with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located(By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;)) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;div\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;cheese\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;div\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated import org.openqa.selenium.support.ui.WebDriverWait import java.time.Duration fun main() { val driver = FirefoxDriver() val wait = WebDriverWait(driver, Duration.ofSeconds(10)) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))) println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } }     Suivez le Quick Tour pour une explication complète de ce qu\u0026rsquo;il se passe derrière ces exemples de code. Il est conseillé de poursuivre cette documentation narrative afin de voir comment installer et utiliser Selenium en tant qu\u0026rsquo;outil d\u0026rsquo;automatisation de test, ainsi que pour mettre à l\u0026rsquo;echelle l\u0026rsquo;exécution de tels tests sur de larges environnements distribués, avec de multiples navigateurs et des systèmes d\u0026rsquo;exploitation différents.\nGetting started Si Selenium est nouveau pour vous, nous vous proposons quelques ressources qui pourront vous aider à vous mettre à niveau très rapidement.\n Tour rapide  WebDriver IDE Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/fr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]