[
{
	"uri": "https://www.selenium.dev/documentation/ja/worst_practices/captchas/",
	"title": "CAPTCHA（キャプチャ）",
	"tags": [],
	"description": "",
	"content": "CAPTCHA（キャプチャ）は、 Completely Automated Public Turing test to tell Computers and Humans Apart （コンピューターと人間を区別するための完全に自動化された公開チューリングテスト）の略で、自動化を防ぐように明示的に設計されているため、試さないでください！ CAPTCHAチェックを回避するための2つの主要な戦略があります。\n テスト環境でCAPTCHAを無効にします テストがCAPTCHAをバイパスできるようにするフックを追加します  "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/legacy_docs/selenium_rc/",
	"title": "Selenium 1 (Selenium RC)",
	"tags": [],
	"description": "",
	"content": "紹介 Selenium RCは長い間メインのSeleniumプロジェクトでしたが、WebDriver/Seleniumを併合したより強力なツールであるSelenium 2が登場しました。 Selenium 1はもうサポートされていないことを強調する価値があります。\nSelenium RCの仕組み はじめに、Selenium RCのコンポーネントがどのように動作するか、およびテストスクリプトの実行でそれぞれが果たす役割について説明します。\nRCコンポーネント SeleniumRCコンポーネントは、以下のとおりです。\n ブラウザを起動および終了し、テストプログラムから渡されたSeleneseコマンドを解釈および実行し、ブラウザとAUTの間で渡されるHTTPメッセージをインターセプトおよび検証するSeleniumサーバー 各プログラミング言語とSelenium RC Server間のインターフェイスを提供するクライアントライブラリ  これは簡略化されたアーキテクチャ図です。\nこの図は、クライアントライブラリが実行される各Seleniumコマンドを渡すサーバーと通信することを示しています。 次に、サーバーはSelenium-Core JavaScriptコマンドを使用してSeleniumコマンドをブラウザーに渡します。 ブラウザは、JavaScriptインタープリターを使用して、Seleniumコマンドを実行します。 これにより、テストスクリプトで指定したSeleneseアクションまたは検証が実行されます。\nSeleniumサーバー Seleniumサーバーは、テストプログラムからSeleniumコマンドを受信して解釈し、それらのテストの実行結果をプログラムに報告します。\nRCサーバーはSelenium Coreをバンドルし、ブラウザーに自動的に挿入します。 これは、テストプログラムがブラウザを開いたときに発生します（クライアントライブラリのAPI関数を使用）。 Selenium-CoreはJavaScriptプログラムです。 実際には、ブラウザの組み込みJavaScriptインタープリターを使用してSeleneseコマンドを解釈および実行するJavaScript関数のセットです。\nサーバーは、単純なHTTP GET/POSTリクエストを使用して、テストプログラムからSeleneseコマンドを受け取ります。 これは、HTTPリクエストを送信できるプログラミング言語を使用して、ブラウザーでのSeleniumテストを自動化できることを意味します。\nクライアントライブラリ クライアントライブラリは、独自の設計のプログラムからSeleniumコマンドを実行できるプログラミングサポートを提供します。 サポートされる言語ごとに異なるクライアントライブラリがあります。 Seleniumクライアントライブラリは、プログラミングインターフェイス（API）、つまり、独自のプログラムからSeleniumコマンドを実行する一連の関数を提供します。 各インターフェイス内には、各Seleneseコマンドをサポートするプログラミング関数があります。\nクライアントライブラリは、Seleneseコマンドを受け取り、それをSeleniumサーバーに渡して、特定のアクションまたはテスト対象アプリケーション（AUT）に対するテストを処理します。 クライアントライブラリは、そのコマンドの結果も受け取り、プログラムに返します。 プログラムは結果を受け取ってプログラム変数に保存し、成功または失敗として報告するか、予期しないエラーの場合は修正アクションを実行できます。\nしたがって、テストプログラムを作成するには、クライアントライブラリAPIを使用して一連のSeleniumコマンドを実行するプログラムを作成するだけです。 また、オプションで、Selenium-IDEでSeleneseテストスクリプトを既に作成している場合は、Selenium RCコードを生成できます。 Selenium-IDEは、（エクスポートメニュー項目を使用して）SeleniumコマンドをクライアントドライバーのAPI関数呼び出しに変換できます。 Selenium-IDEからRCコードをエクスポートする詳細については、Selenium-IDEの章を参照してください。\nインストール インストールというのは、Seleniumの誤った呼び名です。 Seleniumには、選択したプログラミング言語で利用可能な一連のライブラリがあります。 ダウンロードページからダウンロードできます。\n使用する言語を選択したら、次のことを行う必要があります。\n Selenium RCサーバーをインストールします。 言語固有のクライアントドライバーを使用してプログラミングプロジェクトをセットアップします。  Seleniumサーバーのインストール Selenium RCサーバーは単なるJava jarファイル（selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar）であり、特別なインストールは不要です。 zipファイルをダウンロードして、目的のディレクトリにサーバーを展開するだけで十分です。\nSeleniumサーバーを実行する テストを開始する前に、サーバーを起動する必要があります。 Selenium RCのサーバーがあるディレクトリに移動し、コマンドラインコンソールから次を実行します。\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar これは、上記のコマンドを含むバッチまたはシェル実行可能ファイル（Windowsでは.bat、Linuxでは.sh）を作成することで簡素化できます。 次に、デスクトップ上でその実行可能ファイルへのショートカットを作成し、アイコンをダブルクリックしてサーバーを起動します。\nサーバーを実行するには、Javaをインストールし、PATH環境変数をコンソールから実行するように正しく構成する必要があります。 コンソールで次を実行すると、Javaが正しくインストールされていることを確認できます。\njava -version バージョン番号（1.5以降である必要があります）を取得したら、Selenium RCの使用を開始できます。\nJavaクライアントドライバーの使用  SeleniumHQダウンロードページからSelenium Javaクライアントドライバーのzipファイルをダウンロードします。 selenium-java-\u0026lt;version-number\u0026gt; .jarファイルを解凍します。 Open your desired Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.) 希望するJava IDE（Eclipse、NetBeans、IntelliJ、Netweaverなど）を開きます。 Javaプロジェクトを作成します。 selenium-java-\u0026lt;version-number\u0026gt;.jarファイルをプロジェクトの参照先に追加します。 selenium-java-\u0026lt;version-number\u0026gt;.jarファイルをプロジェクトのクラスパスに追加します。 Selenium-IDEから、スクリプトをJavaファイルにエクスポートしてJavaプロジェクトに含めるか、selenium-java-client APIを使用してJavaでSeleniumテストを記述します。 APIについては、この章の後半で説明します。 JUnitまたはTestNgを使用してテストを実行するか、独自の単純なmain()プログラムを作成できます。 これらの概念については、このセクションの後半で説明します。 コンソールからSeleniumサーバーを実行します。 Java IDEまたはコマンドラインからテストを実行します。  Javaテストプロジェクトの設定詳細については、付録セクションの「EclipseでのSelenium RCの設定」および「IntellijでのSelenium RCの設定」を参照してください。\nPythonクライアントドライバーの使用  SeleniumをPIP経由でインストールします。手順はSeleniumHQダウンロードページにリンクされています。 SeleniumテストをPythonで作成するか、Selenium-IDEからPythonファイルにスクリプトをエクスポートします。 コンソールからSeleniumサーバーを実行します。 コンソールまたはPython IDEからテストを実行します。  Pythonクライアントドライバーの設定詳細については、付録「Pythonクライアントドライバーの設定」を参照してください。\n.NETクライアントドライバーの使用  SeleniumHQダウンロードページからSelenium RCをダウンロードします。 フォルダーを解凍します。 NUnitをダウンロードしてインストールします。 （注：テストエンジンとしてNUnitを使用できます。 NUnitにまだ慣れていない場合は、簡単なmain()関数を作成してテストを実行することもできますが、NUnitはテストエンジンとして非常に便利です。） 希望した.Net IDE（Visual Studio、SharpDevelop、MonoDevelop）を開きます。 クラスライブラリ(.dll)を作成します。 次のDLLへの参照を追加します。 nmock.dll、nunit.core.dll、nunit、framework.dll、ThoughtWorks.Selenium.Core.dll、ThoughtWorks.Selenium.IntegrationTests.dll、ThoughtWorks.Selenium.UnitTests.dll Seleniumテストを.Net言語(C#、VB.Net)で記述するか、Selenium-IDEからC#ファイルにスクリプトをエクスポートし、このコードを作成したクラスファイルにコピーします。 独自の単純なmain()プログラムを作成するか、テストを実行するためにプロジェクトにNUnitを含めることができます。 これらの概念については、この章の後半で説明します。 コンソールからSeleniumサーバーを実行します。 IDE、NUnit GUI、またはコマンドラインからテストを実行します。  Visual Studioを使用した.NETクライアントドライバーの設定詳細については、付録の.NETクライアントドライバー設定を参照してください。\nRubyクライアントドライバーの使用  RubyGemsがまだない場合は、RubyForgeからインストールします。 次のコマンドを実行します。 gem install selenium-client テストスクリプトの上部に次の行を追加します。 require \u0026quot;selenium/client\u0026quot; Rubyテストハーネス(Test :: Unit、Mini :: Test、RSpecなど)を使用してテストスクリプトを記述します。 コンソールからSeleniumサーバーを実行します。 他のRubyスクリプトを実行するのと同じ方法でテストを実行します。  Rubyクライアントドライバーの構成の詳細については、Selenium-Clientのドキュメント を参照してください。\nSeleneseからプログラムへ Selenium RCを使用する主なタスクは、Seleneseをプログラミング言語に変換することです。 このセクションでは、言語固有の例をいくつか示します。\nサンプルテストスクリプト Seleneseテストスクリプトの例から始めましょう。 Selenium-IDEで次のテストを記録することを想像してください。\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     注：この例は、Google検索ページ http://www.google.com で機能します。\nプログラミングコードとしてのSelenese サポートされている各プログラミング言語に(Selenium-IDE経由で)エクスポートされたテストスクリプトを次に示します。 オブジェクト指向プログラミング言語の少なくとも基本的な知識がある場合は、これらの例のいずれかを読むことで、SeleniumがSeleneseコマンドを実行する方法を理解できます。 特定の言語の例を表示するには、これらのボタンのいずれかを選択します。\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } } Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt; Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end 次のセクションでは、生成されたコードを使用してテストプログラムを構築する方法を説明します。\nテストをプログラミングする 次に、サポートされている各プログラミング言語の例を使用して、独自のテストをプログラミングする方法を説明します。 基本的に2つのタスクがあります。\n Selenium-IDEからスクリプトをプログラミング言語に生成し、必要に応じて結果を変更します。 生成されたコードを実行する非常に単純なmainプログラムを記述します。  必要に応じて、JUnitまたはJava用のTestNG、またはこれらの言語のいずれかを使用している場合は.NET用のNUnitなどのテストエンジンプラットフォームを採用できます。\nここでは、言語固有の例を示します。 言語固有のAPIはそれぞれ異なっている傾向があるため、それぞれに個別の説明があります。\n Java C# Python Ruby Perl, PHP  Java Javaの場合、テストエンジンとしてJUnitまたはTestNGを使用します。 Eclipseは、プラグインを介してこれらを直接サポートしています。 これにより、さらに簡単になります。 JUnitまたはTestNGの指導はこのドキュメントの範囲外ですが、資料はオンラインで入手でき、利用可能な出版物があります。 すでに\u0026quot;java-shop\u0026quot;であれば、開発者がこれらのテストフレームワークのいずれかで既にある程度の経験を持っている可能性があります。\nおそらく、テストクラスの名前を\u0026quot;NewTest\u0026quot;から独自の名前に変更する必要があります。 また、ステートメント内のブラウザを開くパラメーターを変更する必要があります。\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); Selenium-IDEで生成されたコードは次のようになります。 この例では、わかりやすくするためにコメントを手動で追加しています。\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# .NETクライアントドライバーはMicrosoft.NETで動作します。 NUnitやVisual Studio 2005 Team Systemなどの.NETテストフレームワークで利用できます。\nSelenium-IDEは、テストフレームワークとしてNUnitを使用することを想定しています。 以下の生成コードでこれを確認できます。 NUnitの using ステートメントと、テストクラスの各メンバー関数の役割を識別する対応するNUnit属性が含まれています。\nおそらく、テストクラスの名前を\u0026quot;NewTest\u0026quot;から独自の選択に変更する必要があります。 また、ステートメントのブラウザで開くパラメーターを変更する必要があります。\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); 生成されたコードは次のようになります。\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } } NUnitにテストの実行を管理させることができます。 または、テストオブジェクトをインスタンス化し、SetupTest()、TheNewTest()、TeardownTest() の各メソッドを順番に実行する単純な main() プログラムを作成することもできます。\nPython Pyunitは、Pythonで使用するテストフレームワークです。\n基本的なテスト構造は次のとおりです。\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Selenium-IDEの古い（2.0より前の）バージョンは、古いSelenium gemを必要とするRubyコードを生成します。 したがって、IDEによって生成されたRubyスクリプトを次のように更新することをお勧めします。\n  １行目を require \u0026quot;selenium\u0026quot; から require \u0026quot;selenium/client\u0026quot; に変更\n  11行目を Selenium::SeleniumDriver.new から Selenium::Client::Driver.new に変更\n  クラス名を\u0026quot;Untitled\u0026quot;よりもわかりやすい名前に変更し、テストメソッドの名前を\u0026quot;test_untitled\u0026quot;以外の名前に変更することもできます。\n上記のように、Selenium IDEによって生成されたRubyコードを変更して作成された簡単な例を次に示します。\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP ドキュメントチームのメンバーは、PerlまたはPHPでSelenium RCを使用していません。 これらの2つの言語のいずれかでSelenium RCを使用している場合は、ドキュメントチームに連絡してください（貢献に関する章を参照）。 PerlおよびPHPユーザーをサポートするために、あなたとあなたの経験からいくつかの例を含めたいと思います。\nAPIを学ぶ Selenium RC APIは、Seleneseを理解していると仮定すると、インターフェイスのほとんどが自明である命名規則を使用します。 ただし、ここでは、最も重要で、おそらくそれほど明白ではない側面について説明します。\nブラウザーを起動する CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start これらの各例はブラウザを開き、\u0026ldquo;ブラウザーインスタンス\u0026quot;をプログラム変数に割り当てることでそのブラウザを表します。 このプログラム変数は、ブラウザからメソッドを呼び出すために使用されます。 これらのメソッドは、Seleniumコマンドを実行します。 つまり、 open コマンドや type コマンド、 verify コマンドなどです。\nブラウザーインスタンスの作成時に必要なパラメーターは次のとおりです。\n  host サーバーが配置されているコンピューターのIPアドレスを指定します。 通常、これはクライアントが実行されているマシンと同じマシンであるため、この場合は localhost が渡されます。 一部のクライアントでは、これは任意のパラメーターです。\n  port サーバーがクライアントが接続を確立するのを待機しているTCP/IPソケットを指定します。 これは、一部のクライアントドライバーでは任意です。\n  browser テストを実行するブラウザー。 これは必須パラメーターです。\n  url テスト対象のアプリケーションのベースURL。 これは、すべてのクライアントライブラリに必要であり、ブラウザプロキシAUT通信を開始するための不可欠な情報です。\n  一部のクライアントライブラリでは、 start() メソッドを呼び出してブラウザーを明示的に起動する必要があります。\nコマンドを実行する ブラウザを初期化して変数（一般的に\u0026quot;selenium\u0026quot;という名前）に割り当てたら、ブラウザ変数からそれぞれのメソッドを呼び出してSeleneseコマンドを実行させることができます。 たとえば、Seleniumオブジェクトの type メソッドを呼び出すには、以下のように記述します。\nselenium.type(\u0026#34;field-id\u0026#34;,\u0026#34;string to type\u0026#34;) バックグラウンドで、ブラウザは、メソッド呼び出し中に指定したロケーターと文字列を使用して、ユーザーがブラウザーに入力を入力するのと本質的に同じタイプ操作を実際に実行します。\n結果を報告する Selenium RCには、結果を報告するための独自のメカニズムがありません。 むしろ、選択したプログラミング言語の機能を使用して、ニーズに合わせてカスタマイズしたレポートを作成できます。 それは素晴らしいことですが、すでにあなたのために行われている何かを簡単にしたい場合はどうでしょうか？ 多くの場合、既存のライブラリまたはテストフレームワークは、独自のテストレポートコードを開発するよりも早くニーズを満たすことができます。\nテストフレームワークのレポートツール テストフレームワークは、多くのプログラミング言語で使用できます。 これらは、テストを実行するための柔軟なテストエンジンを提供する主な機能とともに、結果を報告するためのライブラリコードを含んでいます。 たとえば、Javaには一般的に使用される2つのテストフレームワーク、JUnitとTestNGがあります。 .NETには独自のNUnitもあります。\nここではフレームワーク自体を教えません。 これはこのユーザーガイドの範囲外です。 Seleniumに関連するフレームワーク機能と、適用可能ないくつかのテクニックを簡単に紹介します。 ただし、これらのテストフレームワークに関する優れた書籍は、インターネット上の情報とともに入手できます。\nテストレポートライブラリ 選択したプログラミング言語でテスト結果を報告するために特別に作成されたサードパーティライブラリも利用できます。 これらは多くの場合、HTMLやPDFなどのさまざまな形式をサポートします。\n最良のアプローチは何ですか？ テストフレームワークを初めて使用するほとんどの人は、フレームワークに組み込まれているレポート機能から始めます。 独自のライブラリを開発するよりも時間がかかりません。 Seleniumを使用し始めたら、進捗を報告するための独自の\u0026quot;印刷したステートメント\u0026quot;を入力し始めることは間違いありません。 それにより、ライブラリまたはテストフレームワークの使用と並行して、独自のレポートの開発に徐々につながる可能性があります。 とにかく、最初の、しかし短い学習曲線の後、あなたは自分の状況に最適なものを自然に開発します。\nテストレポートの例 説明のために、Seleniumでサポートされている他の言語のいくつかの特定のツールを紹介します。 ここにリストされているものは一般的に使用されており、このガイドの著者によって広く使用されています（したがって、推奨されています）。\nJavaのテストレポート   SeleniumテストケースがJUnitを使用して開発されている場合、JUnitレポートを使用してテストレポートを生成できます。\n  TestNGを使用してSeleniumテストケースを開発する場合、テストレポートを生成するために外部タスクは必要ありません。 TestNGフレームワークは、テストの詳細をリストするHTMLレポートを生成します。\n  ReportNGは、TestNGフレームワーク用のHTMLレポートプラグインです。 これは、デフォルトのTestNG HTMLレポートの代替として意図されています。 ReportNGは、テスト結果の色分けされたシンプルなビューを提供します。\n  Seleneseコマンドのロギング  Seleniumのロギングを使用して、テスト内のすべてのSeleneseコマンドのレポートを、それぞれの成功または失敗とともに生成できます。 ロギングSeleniumはJavaクライアントドライバーを拡張して、このSeleneseロギング機能を追加します。  Pythonのテストレポート  Pythonクライアントドライバーを使用する場合、HTMLTestRunnerを使用してテストレポートを生成できます。  Rubyのテストレポート  RSpecフレームワークをRubyでのSeleniumテストケースの作成に使用する場合、そのHTMLレポートを使用してテストレポートを生成できます。  テストにスパイスを追加する 次に、テストにプログラミングロジックを追加して、Selenium RCを使用するすべての理由を説明します。 他のプログラムと同じです。 プログラムフローは、条件ステートメントと反復を使用して制御されます。 さらに、I/Oを使用して進捗情報を報告できます。 このセクションでは、プログラミング言語の構成要素をSeleniumと組み合わせて、一般的なテストの問題を解決する方法の例をいくつか示します。\nページ要素の存在の単純なテストから、予想される結果を検証するためにプログラミングロジックを必要とする複数のWebページとさまざまなデータを含む動的機能のテストに移行するときにわかります。 基本的に、Selenium-IDEは反復および標準条件ステートメントをサポートしていません。 Seleneseパラメーターにjavascriptを埋め込むことでいくつかの条件を実行できますが、反復は不可能であり、プログラミング言語ではほとんどの条件がはるかに簡単になります。 さらに、エラー回復のために例外処理が必要になる場合があります。 これらの理由およびその他の理由により、自動テストでの\u0026quot;検証力\u0026quot;を高めるための一般的なプログラミング手法の使用を説明するために、このセクションを作成しました。\nこのセクションの例はC#とJavaで記述されていますが、コードはシンプルであり、サポートされている他の言語に簡単に適合させることができます。 オブジェクト指向プログラミング言語の基本的な知識があれば、このセクションを理解するのに困難はないはずです。\n反復 反復は、テストで行う必要がある最も一般的なことの1つです。 たとえば、検索を複数回実行したい場合があります。 または、おそらくテスト結果を検証するために、データベースから返された\u0026quot;結果セット\u0026quot;を処理する必要があります。\n前に使用したのと同じGoogle検索の例を使用して、Seleniumの検索結果を確認しましょう。 このテストではSeleneseを使用できます。\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     同じ手順を3回実行するためにコードが繰り返されています。 ただし、同じコードのコピーを複数作成することは、維持する作業が増えるため、プログラムとしては適切ではありません。 プログラミング言語を使用することで、検索結果を反復処理して、より柔軟で保守可能なソリューションを実現できます。\nC# の場合 // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); } 条件ステートメント テストでの条件の使用を説明するために、例から始めます。 Seleniumテストの実行中に発生する一般的な問題は、ページで予期される要素が利用できない場合に発生します。 たとえば、次の行を実行する場合です。\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); 要素 \u0026lsquo;q'がページにない場合、例外がスローされます。\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found これにより、テストが中断する可能性があります。 いくつかのテストでは、それがあなたの望むものです。 しかし、多くの場合、テストスクリプトには実行する他の多くのテストがあるため、これは望ましくありません。\nより良いアプローチは、まず要素が実際に存在するかどうかを検証し、次に存在しない場合に代替手段を取ることです。 Javaを使用してこれを見てみましょう。\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } このアプローチの利点は、ページで一部のUI要素が利用できない場合でも、テストの実行を続行できることです。\nテストからJavaScriptを実行する JavaScriptは、セレンによって直接サポートされていないアプリケーションを実行する際に非常に便利です。 Selenium APIの getEval メソッドを使用して、Selenium RCからJavaScriptを実行できます。\n静的な識別子のないチェックボックスを持つアプリケーションを考えてください。 この場合、Selenium RCからJavaScriptを評価して、すべてのチェックボックスのIDを取得し、それらを実行できます。\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } ページ上の画像の数を数えるには、以下のとおりです。\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); デフォルトでは、テストウィンドウではなくSeleniumウィンドウが参照されるため、DOM式の場合は必ずウィンドウオブジェクトを使用してください。\nサーバーオプション サーバーの起動時に、コマンドラインオプションを使用してデフォルトのサーバーの動作を変更できます。\nサーバーを起動するには、次を実行してください。\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar オプションのリストを表示するには、 -h オプションを指定してサーバーを実行します。\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h サーバーで使用できるすべてのオプションのリストとそれぞれの簡単な説明が表示されます。 提供された説明では必ずしも十分ではないため、いくつかのより重要なオプションについて説明しました。\nプロキシ設定 AUTが認証を必要とするHTTPプロキシの後ろにある場合、次のコマンドを使用してhttp.proxyHost、http.proxyPort、http.proxyUserおよびhttp.proxyPasswordを設定する必要があります。\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password マルチウィンドウモード Selenium 1.0を使用している場合は、マルチウィンドウモードがデフォルトの動作であるため、おそらくこのセクションをスキップできます。 ただし、バージョン1.0より前は、Seleniumはデフォルトで、ここに示すようにサブフレームでテスト対象のアプリケーションを実行していました。\n一部のアプリケーションはサブフレームで正しく実行されず、ウィンドウの上部フレームにロードする必要がありました。 マルチウィンドウモードオプションにより、AUTはデフォルトフレームではなく別のウィンドウで実行でき、そこで必要なトップフレームを取得できました。\nSeleniumの古いバージョンでは、次のオプションで明示的にマルチウィンドウモードを指定する必要があります。\n-multiwindow Selenium RC 1.0の時点で、単一のフレーム内でテストを実行する場合（つまり、以前のSeleniumバージョンの標準を使用する場合）、オプションを使用してこれをSelenium Serverに指定できます。\n-singlewindow Firefoxプロファイルの指定 Firefoxは、インスタンスごとに個別のプロファイルを指定しない限り、2つのインスタンスを同時に実行しません。 Selenium RC 1.0以降は個別のプロファイルで自動的に実行されるため、Selenium 1.0を使用している場合は、このセクションをスキップできます。 ただし、Seleniumの古いバージョンを使用している場合、またはテストに特定のプロファイルを使用する必要がある場合（https証明書の追加やアドオンのインストールなど）、プロファイルを明示的に指定する必要があります。\n最初に、別のFirefoxプロファイルを作成するには、次の手順に従います。 Windowsのスタートメニューを開き、\u0026ldquo;実行\u0026quot;を選択して、次のいずれかを入力します。\nfirefox.exe -profilemanager firefox.exe -P ダイアログを使用して新しいプロファイルを作成します。 次に、Seleniumサーバーを実行するときに、サーバーのコマンドラインオプション -firefoxProfileTemplate でこの新しいFirefoxプロファイルを使用し、ファイル名とディレクトリパスを使用してプロファイルへのパスを指定するように指示します。\n-firefoxProfileTemplate \u0026#34;path to the profile\u0026#34; 警告: 必ずデフォルトとは別の新しいフォルダーにプロファイルを入れてください!!! Firefoxプロファイルマネージャーツールは、プロファイルを削除すると、プロファイルファイルであるかどうかに関係なく、フォルダー内のすべてのファイルを削除します。\nFirefoxプロファイルの詳細については、Mozillaのナレッジベースをご覧ください。\n-htmlSuiteを使用してサーバー内でSeleneseを直接実行する HTMLファイルをサーバーのコマンドラインに渡すことで、Selenese HTMLファイルをSelenium Server内で直接実行できます。 例えば、\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; これにより、HTMLスイートが自動的に起動され、すべてのテストが実行され、結果とともにHTMLレポートが保存されます。\n注意: このオプションを使用すると、サーバーはテストを開始し、テストが完了するまで指定された秒数待機します。 その時間内にテストが完了しない場合、コマンドはゼロ以外の終了コードで終了し、結果ファイルは生成されません。\nこのコマンドラインは非常に長いため、入力するときは注意してください。 これには、単一のテストではなく、HTML Seleneseスイートを渡す必要があることに注意してください。 また、 -htmlSuite オプションは-interactiveと互換性がないことに注意してください。 両方を同時に実行することはできません。\nSeleniumサーバーのログ サーバー側のログ Seleniumサーバーを起動するときに、 -log オプションを使用して、Seleniumサーバーによってレポートされた貴重なデバッグ情報をテキストファイルに記録できます。\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log このログファイルは、標準のコンソールログよりも詳細です（DEBUGレベルのログメッセージが含まれます）。 ログファイルには、ロガー名、およびメッセージを記録したスレッドのID番号も含まれます。 例えば、\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW メッセージの形式は、以下のとおりです。\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE このメッセージは複数行の場合があります。\nブラウザ側のログ ブラウザ側のJavaScript（Selenium Core）も重要なメッセージを記録します。 多くの場合、これらは通常のSeleniumサーバーログよりもエンドユーザーにとって有用です。 ブラウザ側のログにアクセスするには、 -browserSideLog 引数をSeleniumサーバーに渡します。\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog を -log 引数と組み合わせて、browserSideLogs（および他のすべてのDEBUGレベルのログメッセージ）をファイルに記録する必要があります。\n特定のブラウザへのパスを指定する 特定のブラウザーへのパスをSelenium RCに指定できます。 これは、同じブラウザーの異なるバージョンがあり、特定のブラウザーを使用する場合に便利です。 また、これは、Selenium RCで直接サポートされていないブラウザーに対してテストを実行できるようにするために使用されます。 実行モードを指定するときは、ブラウザの実行可能ファイルへのフルパスが後に続く *custom 指定子を使用します。\n*custom \u0026lt;path to browser\u0026gt; Selenium RCアーキテクチャ 注意: このトピックでは、Selenium RCの背後にある技術的な実装について説明します。 Seleniumユーザーがこれを知ることは基本的なことではありませんが、将来発生する可能性のある問題の一部を理解するのに役立ちます。\nSelenium RC Serverがどのように機能し、プロキシインジェクションと高度な特権モードを使用する理由を詳細に理解するには、最初に 同一オリジンポリシー を理解する必要があります。\n同一オリジンポリシー Seleniumが直面する主な制限は、同一オリジンポリシーです。 このセキュリティ制限は、市場のすべてのブラウザーによって適用され、その目的は、サイトのコンテンツが別のサイトのスクリプトによってアクセスされないようにすることです。 同一オリジンポリシーでは、ブラウザ内にロードされたコードはすべて、そのウェブサイトのドメイン内でのみ動作することが規定されています。 別のWebサイトで関数を実行することはできません。 たとえば、ブラウザが www.mysite.com を読み込むときにJavaScriptコードを読み込むと、それが別のサイトであっても、読み込まれたコードを www.mysite2.com に対して実行できません。 これが可能な場合、他のタブで口座ページを開いていれば、開いているウェブサイトに配置されたスクリプトは銀行口座の情報を読み取ることができます。 これはXSS（クロスサイトスクリプティング）と呼ばれます。\nこのポリシー内で機能するには、Selenium-Core（およびすべての魔法を発生させるJavaScriptコマンド）をテスト対象アプリケーション（同じURL）と同一オリジンに配置する必要があります。\n歴史的に、Selenium-CoreはJavaScriptで実装されていたため、この問題によって制限されていました。 ただし、Selenium RCは同一オリジンポリシーによって制限されていません。 Seleniumサーバーをプロキシとして使用すると、この問題を回避できます。 基本的に、ブラウザがサーバーが提供する単一の\u0026quot;なりすまし\u0026quot;ウェブサイトで動作していることをブラウザに伝えます。\n注意: このトピックに関する追加情報は、同一オリジンポリシーおよびXSSに関するWikipediaページで見つけることができます。\nプロキシインジェクション 同一オリジンポリシーを回避するためにSeleniumが使用した最初の方法は、プロキシインジェクションでした。 プロキシインジェクションモードでは、Selenium Serverはブラウザと テスト対象アプリケーション1 の間にあるクライアント設定の HTTPプロキシ2として機能します。 次に、架空のURLでテスト対象アプリケーションをマスクします（Selenium-Coreと一連のテストを埋め込み、同一オリジンから来ているかのように配信します）。\nこれがアーキテクチャ図です。\nお気に入りの言語でテストスイートが開始されると、次のようになります。\n クライアント/ドライバーは、selenium-RCサーバーとの接続を確立します。 Selenium RCサーバーは、Selenium-CoreのJavaScriptをブラウザーがロードしたWebページに挿入するURLを使用してブラウザーを起動します（または古いブラウザーを再利用します）。 クライアントドライバーはSeleneseコマンドをサーバーに渡します。 サーバーはコマンドを解釈し、対応するJavaScript実行をトリガーして、ブラウザー内でそのコマンドを実行します。 Selenium-Coreは、ブラウザーに最初の命令に基づいて動作するよう指示し、通常はテスト対象アプリケーションのページを開きます。 ブラウザーはオープンリクエストを受信し、Selenium RCサーバー（使用するブラウザーのHTTPプロキシとして設定）からWebサイトのコンテンツを要求します。 Selenium RCサーバーはWebサーバーと通信してページを要求し、ページを受信すると、ブラウザーにページを送信し、オリジンをマスクしてページがSelenium-Coreと同じサーバーからのものであるように見えます（これにより、Selenium-Coreは 同一オリジンポリシーを使用）。 ブラウザーはWebページを受信し、そのページ用に予約されているフレーム/ウィンドウにレンダリングします。  Heightened Privileges でブラウザーを起動する この方法のこのワークフローは、プロキシインジェクションに非常に似ていますが、主な違いは、ブラウザが Heightened Privileges と呼ばれる特別なモードで起動されることです。 これにより、Webサイトは一般に許可されていないこと（SeleniumにXSSを実行したり、ファイルのアップロード入力を入力したり）を許可します。 これらのブラウザーモードを使用することで、Selenium CoreはAUT全体をSelenium RCサーバーに渡すことなく、テスト対象アプリケーションを直接開き、コンテンツを読み取り/操作できます。\nこれがアーキテクチャ図です。\nお気に入りの言語でテストスイートが開始されると、次のようになります。\n クライアント/ドライバーは、selenium-RCサーバーとの接続を確立します。 Selenium RCサーバーは、WebページにSelenium-CoreをロードするURLを使用してブラウザーを起動します（または古いブラウザーを再利用します）。 Selenium-Coreは、クライアント/ドライバーから最初の命令を取得します（Selenium RCサーバーへの別のHTTP要求を介して）。 Selenium-Coreはその最初の命令に基づいて動作し、通常はテスト対象アプリケーションのページを開きます。 ブラウザはオープン要求を受信し、Webサーバーにページを要求します。 ブラウザがWebページを受信すると、そのページ用に予約されたフレーム/ウィンドウにレンダリングします。  HTTPSおよびセキュリティポップアップの処理 多くのアプリケーションは、パスワードやクレジットカード情報などの暗号化された情報を送信する必要がある場合、HTTPからHTTPSに切り替えます。 これは、今日の多くのWebアプリケーションに共通しています。 Selenium RCはこれをサポートしています。\nHTTPSサイトが本物であることを確認するには、ブラウザにセキュリティ証明書が必要です。 そうでない場合、ブラウザがHTTPSを使用してテスト対象アプリケーションにアクセスすると、アプリケーションが'信頼されていない'と見なされます。 これが発生すると、ブラウザにセキュリティポップアップが表示され、Selenium RCを使用してこれらのポップアップを閉じることはできません。\nSelenium RCテストでHTTPSを扱う場合、これをサポートし、セキュリティ証明書を処理する実行モードを使用する必要があります。 テストプログラムでSeleniumを初期化するときに、実行モードを指定します。\nSelenium RC 1.0ベータ2以降では、実行モードに* firefoxまたは* iexploreを使用します。 Selenium RC 1.0 beta 1を含む以前のバージョンでは、実行モードに*chromeまたは *iehtaを使用します。 これらの実行モードを使用すると、特別なセキュリティ証明書をインストールする必要はありません。 Selenium RCがそれを処理します。\nバージョン1.0では、実行モード*firefoxまたは*iexploreが推奨されます。 ただし、*iexploreproxyおよび*firefoxproxyの追加の実行モードがあります。 これらは後方互換性のためにのみ提供されており、レガシーテストプログラムで必要でない限り使用しないでください。 アプリケーションが追加のブラウザウィンドウを開く場合、セキュリティ証明書の処理と複数のウィンドウの実行に制限があります。\nSelenium RCの以前のバージョンでは、 *chromeまたは*iehtaは、HTTPSおよびセキュリティポップアップの処理をサポートする実行モードでした。 これらは'実験モード'と見なされましたが、非常に安定し、多くの人が使用していました。 Selenium 1.0を使用している場合、これらの古い実行モードは不要であり、使用すべきではありません。\nセキュリティ証明書の説明 通常、ブラウザは、既に所有しているセキュリティ証明書をインストールすることで、テストしているアプリケーションを信頼します。 ブラウザのオプションまたはインターネットのプロパティでこれを確認できます（テスト対象アプリケーションのセキュリティ証明書がわからない場合は、システム管理者に問い合わせてください）。 Seleniumがブラウザーをロードすると、ブラウザーとサーバー間のメッセージをインターセプトするコードを挿入します。 ブラウザーは、信頼されていないソフトウェアがアプリケーションのように見えると解釈するようになりました。 ポップアップメッセージで警告することで応答します。\nこれを回避するために、Selenium RC（これをサポートする実行モードを使用する場合）は、ブラウザーがアクセスできる場所でクライアントコンピューターに独自のセキュリティ証明書を一時的にインストールします。 これにより、ブラウザはテスト対象アプリケーションとは異なるサイトにアクセスしていると思わせ、ポップアップを効果的に抑制します。\nSeleniumの以前のバージョンで使用された別の方法は、Seleniumのインストールで提供されるCybervilliansセキュリティ証明書をインストールすることでした。 ただし、ほとんどのユーザーはこれを行う必要がなくなります。 Selenium RCをプロキシインジェクションモードで実行している場合、このセキュリティ証明書を明示的にインストールする必要があるかもしれません。\n追加のブラウザーとブラウザー構成のサポート Selenium APIは、Internet ExplorerとMozilla Firefoxに加えて、複数のブラウザーに対する実行をサポートしています。 サポートされるブラウザーについては、 https://selenium.dev Webサイトを参照してください。 さらに、ブラウザーが直接サポートされていない場合でも、テストアプリケーションがブラウザーを起動する時に\u0026rdquo;*custom\u0026quot;実行モード（すなわち、*firefoxまたは*iexploreの代わり）を使用して、選択したブラウザーに対してSeleniumテストを実行できます。 これにより、API呼び出し内で実行可能なブラウザーへのパスを渡します。 これは、対話モードのサーバーからも実行できます。\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com 異なるブラウザー設定でテストを実行する 通常、Selenium RCはブラウザーを自動的に設定しますが、\u0026quot;*custom\u0026rdquo; 実行モードを使用してブラウザーを起動する場合、自動設定を使用せずにSelenium RCにブラウザーをそのまま強制的に起動させることができます。\nたとえば、次のようなカスタム設定でFirefoxを起動できます。\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com この方法でブラウザーを起動する場合、Selenium Serverをプロキシとして使用するようにブラウザーを手動で設定する必要があることに注意してください。 通常、これはブラウザーの設定を開き、\u0026ldquo;localhost:4444\u0026quot;をHTTPプロキシとして指定することを意味しますが、この手順はブラウザーごとに根本的に異なる場合があります。 詳細については、ブラウザーのドキュメントを参照してください。\nMozillaブラウザは、起動と停止の方法が異なる場合があることに注意してください。 Mozillaブラウザの動作をもう少し予測可能にするために、MOZ_NO_REMOTE環境変数を設定する必要があるかもしれません。 Unixユーザーは、シェルスクリプトを使用してブラウザを起動しないでください。 一般に、バイナリ実行可能ファイル（firefox-binなど）を直接使用することをお勧めします。\n一般的な問題のトラブルシューティング Selenium RCの使用を開始すると、一般的に発生する可能性のある問題がいくつかあります。 ここでそれらとその解決策を紹介します。\nサーバーに接続できません テストプログラムがSeleniumサーバーに接続できない場合、Seleniumはテストプログラムで例外をスローします。 このメッセージまたは同様のメッセージが表示されるはずです。\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2) このようなメッセージが表示された場合は、必ずSeleniumサーバーを起動してください。 その場合、SeleniumクライアントライブラリとSeleniumサーバー間の接続に問題があります。\nSelenium RCを使用する場合、ほとんどの人は、同じマシンでテストプログラム（Seleniumクライアントライブラリを使用）とSeleniumサーバーを実行することから始めます。 これを行うには、接続パラメーターとして\u0026quot;localhost\u0026quot;を使用します。 開始する潜在的なネットワークの問題の影響を軽減するため、この方法で開始することをお勧めします。 オペレーティングシステムに一般的なネットワーク設定とTCP/IP設定があると仮定すると、ほとんど問題はありません。 実際、多くの人がこの方法でテストを実行することを選択します。\nただし、リモートマシンでSeleniumサーバーを実行する場合は、2台のマシン間に有効なTCP/IP接続があると仮定すると、接続は良好です。\n接続に問題がある場合は、 ping 、telnet 、 ifconfig(Unix)/ipconfig(Windows) などの一般的なネットワークツールを使用して、有効なネットワーク接続を確保できます。 これらに不慣れな場合は、システム管理者が支援できます。\nブラウザをロードできません わかりやすいエラーメッセージではありません。 申し訳ありませんが、Seleniumサーバーがブラウザをロードできない場合、このエラーが表示される可能性があります。\n(500) Internal Server Error これは、下記が原因の可能性があります。\n Firefox（Selenium 1.0より前）は、ブラウザーが既に開いており、別のプロファイルを指定していないため、起動できません。 サーバーオプションのFirefoxプロファイルのセクションを参照してください。 使用している実行モードは、マシン上のどのブラウザとも一致しません。 プログラムでブラウザーを開いたときに、Seleniumに渡したパラメーターを確認してください。 ブラウザーへのパスを明示的に指定しました（ \u0026ldquo;*custom\u0026rdquo; を使用 - 上記を参照）が、パスが正しくありません。 パスが正しいことを確認してください。 また、ユーザーグループをチェックして、ブラウザーと \u0026ldquo;*custom\u0026rdquo; パラメーターに既知の問題がないことを確認します。  SeleniumはAUTを見つけることができません テストプログラムがブラウザを正常に起動したが、テストしているWebサイトがブラウザに表示されない場合、最も可能性の高い原因は、テストプログラムが正しいURLを使用していないことです。\nこれは簡単に起きます。 Selenium-IDEを使用してスクリプトをエクスポートすると、ダミーのURLが挿入されます。 アプリケーションをテストするには、URLを手動で正しいものに変更する必要があります。\nFirefoxはプロファイルの準備中にシャットダウンを拒否しました これはほとんどの場合、Selenium RCテストプログラムをFirefoxに対して実行しますが、Firefoxブラウザーセッションが既に実行されており、Selenium Serverの起動時に別のプロファイルを指定しなかった場合に発生します。 テストプログラムからのエラーは次のようになります。\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile サーバーからの完全なエラーメッセージを次に示します。\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock これを解決するには、個別のFirefoxプロファイルの指定に関するセクションを参照してください。\nバージョン管理の問題 Seleniumのバージョンがブラウザのバージョンをサポートしていることを確認してください。 たとえば、Selenium RC 0.92はFirefox 3をサポートしていません。 時には幸運かもしれません（私はそうでした）。 ただし、使用しているSeleniumのバージョンでサポートされているブラウザのバージョンを確認することを忘れないでください。 疑わしい場合は、ブラウザの最も広く使用されているバージョンでSeleniumの最新リリースバージョンを使用してください。\nサーバーの起動中のエラーメッセージ： \u0026ldquo;(Unsupported major.minor version 49.0)\u0026rdquo; このエラーは、正しいバージョンのJavaを使用していないことを示しています。 Selenium ServerにはJava 1.5以降が必要です。\nJavaバージョンを再確認するには、コマンドラインからこれを実行します。\njava -version Javaバージョンを示すメッセージが表示されます。\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) 低いバージョン番号が表示される場合は、JREを更新するか、単に更新したJREをPATH環境変数に追加する必要があります。\ngetNewBrowserSessionコマンドの実行時の404エラー \u0026ldquo;http://www.google.com/selenium-server/\u0026quot; でページを開こうとしているときに404エラーが表示される場合は、Seleniumサーバーがプロキシとして正しく構成されていないことが原因である必要があります。 \u0026ldquo;selenium-server\u0026rdquo; ディレクトリはgoogle.comには存在しません。 プロキシが適切に設定されている場合にのみ存在します。 プロキシ設定は、Firefox、iexplore、opera、またはカスタムでブラウザを起動する方法に大きく依存します。\n  iexplore: *iexplore を使用してブラウザを起動した場合、Internet Explorerのプロキシ設定に問題がある可能性があります。 Seleniumサーバーは、インターネットオプションコントロールパネルでグローバルプロキシ設定を構成しようとします。 Seleniumサーバーがブラウザーを起動するときに、これらが正しく構成されていることを確認する必要があります。 インターネットオプションコントロールパネルを見てみてください。 \u0026ldquo;接続\u0026quot;タブをクリックし、\u0026ldquo;LAN設定\u0026quot;をクリックします。\n プロキシを使用してテストするアプリケーションにアクセスする必要がある場合は、\u0026quot;-Dhttp.proxyHost\u0026quot;でSeleniumサーバーを起動する必要があります。 詳細については、Proxy Configuration_ を参照してください。 プロキシを手動で設定してから、 *custom または *iehta ブラウザーランチャーでブラウザーを起動することもできます。    custom: *customを使用する場合、プロキシを正しく（手動で）設定する必要があります。 そうしないと、404エラーが発生します。 プロキシ設定が正しく構成されていることを再確認してください。 プロキシを正しく設定したかどうかを確認するには、意図的にブラウザを誤って設定しようとします。 間違ったプロキシサーバーのホスト名または間違ったポートを使用するようにブラウザーを構成してください。 ブラウザのプロキシ設定を正しく構成しなかった場合、ブラウザーはインターネットに接続できなくなります。 これは、関連する設定を調整していることを確認する1つの方法です。\n  他のブラウザ（*firefox、*opera）では、プロキシが自動的にハードコード化されるため、この機能に関する既知の問題はありません。 404エラーが発生し、このユーザーガイドに従っている場合は、ユーザーコミュニティからの助けを得るために、ユーザーグループに結果を慎重に投稿してください。\n  パーミッション拒否エラー このエラーの最も一般的な理由は、セッションがドメインの境界を越える（たとえば、 http://domain1 から、http://domain2 のページにアクセスします）かプロトコルを切り替える（http://domainX から https://domainX に移動する）ことで同一オリジンポリシーに違反しようとしていることです。\nこのエラーは、JavaScriptがまだ使用可能でないUIページ（ページが完全にロードされる前）または使用できなくなった（ページのアンロードが開始された後）UIオブジェクトを見つけようとした場合にも発生します。 これは、AJAXページで最も一般的に発生します。 AJAXページは、大きなページとは独立してロードおよび/またはリロードするページまたはサブフレームのセクションで動作します。\nこのエラーは断続的に発生する場合があります。 問題はデバッガーのオーバーヘッドがシステムに追加されたときに再現できない競合状態に起因するため、デバッガーで問題を再現することはできません。 パーミッションの問題については、チュートリアルで詳しく説明します。 The Same Origin Policy、Proxy Injectionに関する章を注意深くお読みください。\nブラウザーポップアップウィンドウの処理 Seleniumテスト中に取得できる\u0026quot;ポップアップ\u0026quot;にはいくつかの種類があります。 テスト対象アプリケーションではなくブラウザによって開始されたSeleniumコマンドを実行しても、これらのポップアップを閉じることができない場合があります。 これらの管理方法を知る必要があるかもしれません。 ポップアップの種類ごとに異なる方法で対処する必要があります。\n  HTTP基本認証ダイアログ：これらのダイアログは、サイトにログインするためのユーザー名/パスワードの入力を求めます。 HTTP基本認証を必要とするサイトにログインするには、次のように、RFC 1738で説明されているように、URLでユーザー名とパスワードを使用します。 open(\u0026ldquo;http://myusername:myuserpassword@myexample.com/blah/blah/blah\u0026quot;).\n  SSL証明書の警告：Selenium RCは、SSL証明書がプロキシとして有効になっている場合、自動的になりすまそうとします。 詳細については、HTTPSの章を参照してください。 ブラウザーが正しく設定されている場合、SSL証明書の警告は表示されませんが、危険な\u0026quot;CyberVillains\u0026quot;SSL認証局を信頼するようにブラウザーを設定する必要があります。 繰り返しますが、これを行う方法についてはHTTPSセクションを参照してください。\n  モーダルJavaScriptアラート/確認/プロンプトダイアログ：Seleniumはそれらのダイアログを（window.alert、window.confirm、window.promptを置き換えることで）隠そうとするため、ページの実行が停止されません。 アラートポップアップが表示されている場合は、ページの読み込みプロセス中に発生した可能性があります。 通常、ページを保護するには早すぎます。 Seleneseには、アラートと確認のポップアップをアサートまたは検証するためのコマンドが含まれています。 第4章のこれらのトピックに関する章を参照してください。\n  Linuxで、Firefoxブラウザーセッションが閉じないのはなぜですか？ Unix/Linuxでは、\u0026ldquo;firefox-bin\u0026quot;を直接呼び出す必要があるため、実行可能ファイルがパス上にあることを確認してください。 シェルスクリプトを介してFirefoxを実行している場合、ブラウザーを終了するときが来ると、Selenium RCはシェルスクリプトを終了し、ブラウザーを実行したままにします。 このように、firefox-binへのパスを直接指定できます。\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome はカスタムプロファイルでは機能しません Firefoxプロファイルのフォルダー -\u0026gt; prefs.js -\u0026gt; user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0); を確認してください。 次の行を \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; のようにコメントアウトして、再度試してください。\n親ページの読み込み中にカスタムポップアップを読み込むことはできますか（つまり、親ページのjavascript window.onload()関数が実行される前）？ いいえ。Seleniumはインターセプターに依存しており、ロード中のウィンドウ名を決定します。 これらのインターセプターは、ウィンドウがonload()関数の後にロードされた場合、新しいウィンドウをキャッチするのに最適に機能します。 Seleniumは、onload関数の前にロードされたウィンドウを認識しない場合があります。\nLinux上のFirefox Unix/Linuxでは、1.0より前のSeleniumのバージョンは \u0026ldquo;firefox-bin\u0026rdquo; を直接呼び出す必要があったため、以前のバージョンを使用している場合は、実際の実行可能ファイルがパス上にあることを確認してください。\nほとんどのLinuxディストリビューションでは、実際の firefox-bin は次の場所にあります。\n/usr/lib/firefox-x.x.x/ x.x.xは現在使用しているバージョン番号です。 そのため、そのパスをユーザーのパスに追加します。 以下を.bashrcファイルに追加する必要があります。\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; 必要に応じて、次のようにテストで直接firefox-binへのパスを指定できます。\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IEおよびスタイル属性 Internet Explorerでテストを実行していて、style属性を使用して要素を見つけられない場合、例えば、次のような場合があります。\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] これはFirefox、Opera、またはSafariで完全に機能しますが、IEでは機能しません。 IEは @style のキーを大文字として解釈します。 したがって、ソースコードが小文字であっても、下記のように使用したほうがよいです。\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] テストが複数のブラウザーで動作することを意図している場合、これは問題ですが、簡単にテストをコーディングして状況を検出し、IEでのみ動作する代替ロケーターを試すことができます。\nエラーが発生しました-*googlechromeブラウザーのシャットダウン時に\u0026quot;Cannot convert object to primitive value\u0026rdquo; このエラーを回避するには、同一オリジンポリシーチェックを無効にするオプションでブラウザを起動する必要があります。\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); IEでエラーが発生しました - \u0026ldquo;Couldn\u0026rsquo;t open app window; is the pop-up blocker enabled?\u0026rdquo; このエラーを回避するには、ブラウザを設定する必要があります。 ポップアップブロッカーを無効にし、ツール \u0026raquo; オプション \u0026raquo;セキュリティで'保護モードを有効にする'オプションをオフにします。\n  ブラウザーは、 localhost:4444 をHTTPプロキシーとして設定した構成プロファイルで起動されます。 これが、ブラウザーが行うHTTP要求がSeleniumサーバーを通過し、レスポンスが実サーバーからではなく通過する理由です。 \u0026#x21a9;\u0026#xfe0e;\n プロキシは、2つの部分の間でボールを渡す中間の第三者です。 AUTをブラウザに配信する\u0026quot;Webサーバー\u0026quot;として機能します。 プロキシであるため、Seleniumサーバーはテスト対象アプリケーションの実際のURLについて\u0026quot;嘘をつく\u0026quot;機能を提供します。 \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/introduction/the_selenium_project_and_tools/",
	"title": "Seleniumプロジェクトとツール",
	"tags": [],
	"description": "",
	"content": "SeleniumはWebブラウザーを制御します Selenium はいろいろなものがありますが中核となるのは、ブラウザインスタンスをリモートで制御し、ブラウザとのユーザーの対話をエミュレートするために利用可能な最良の技術を使用するWebブラウザ自動化用のツールセットです。\nユーザーは、エンドユーザーが実行する一般的なアクティビティをシミュレートできます。 フィールドにテキストを入力し、ドロップダウン値とチェックボックスを選択し、ドキュメント内のリンクをクリックします。 また、マウスの移動、任意のJavaScriptの実行など、他の多くのコントロールも提供します。\n主にWebサイトのフロントエンドテストに使用されますが、Seleniumはブラウザーユーザーエージェント ライブラリ の中核です。 インターフェイスはアプリケーションに遍在しているため、目的に合わせて他のライブラリとの組み合わせて使うことを奨励します。\nすべてを支配する1つのインターフェース プロジェクトの指針の1つは、すべての（主要な）ブラウザーテクノロジーに共通インターフェイスをサポートすることです。 Webブラウザーは非常に複雑で高度に設計されたアプリケーションであり、まったく異なる方法で操作を実行しますが、実行中に同じように見えることがよくあります。 テキストは同じフォントで表示されますが、画像は同じ場所に表示され、リンクは同じリンク先に移動します。 下で起こっていることは、昼と夜と同じくらい異なっています。 Seleniumはこれらの違いを \u0026ldquo;抽象化\u0026rdquo; し、コードを書いている人から詳細や複雑さを隠します。 これにより、数行のコードを記述して複雑なワークフローを実行できますが、これらの同じ行はFirefox、Internet Explorer、Chrome、およびサポートされている他のすべてのブラウザーで実行されます。\nツールとサポート Seleniumのミニマリストデザインアプローチは、より大きなアプリケーションのコンポーネントとして含まれる汎用性を提供します。 Selenium傘下で提供される周囲のインフラストラクチャは、 ブラウザのグリッド をまとめるツールを提供するため、さまざまなマシンで異なるブラウザーおよび複数のオペレーティングシステムでテストを実行できます。\nサーバールームまたはデータセンターにある積み重なったのコンピューターがすべてブラウザーを同時に起動してサイトのリンク、フォーム、およびテーブルにアクセスし、アプリケーションを24時間テストすることを想像してください。 最も一般的な言語用に提供されたシンプルなプログラミングインターフェイスを介して、これらのテストは休むことなく並行して実行され、エラーが発生したときにレポートを返します。\nブラウザを制御するだけでなく、そのようなグリッドを簡単に拡張および展開できるツールとドキュメントをユーザーに提供することで、これを実現することを目指しています。\n誰がSeleniumを使うか 世界で最も重要な企業の多くは、ブラウザベースのテストにSeleniumを採用しており、多くの場合、他の独自のツールを使用した長年の努力に取って代わりました。 人気が高まるにつれて、その要件と課題が倍増しています。\nウェブがより複雑になり、新しいテクノロジーがウェブサイトに追加されるにつれて、可能な限りそれらに遅れずについていくことがこのプロジェクトの使命です。 オープンソースプロジェクトであるこのサポートは、\u0026ldquo;本業\u0026quot;をもっている多くのボランティアからの寛大な時間の寄付によって提供されます。\nプロジェクトのもう1つの使命は、より多くのボランティアがこの取り組みに参加することを奨励し、プロジェクトが引き続き新しいテクノロジーに追いつき、機能テスト自動化の主要なプラットフォームであり続けることができるよう、強力なコミュニティを構築することです。\n歴史 2004年にSelenium 1がリリースされたとき、Webアプリケーションのフロントエンドで一貫した動作を手動で検証するために費やす時間を削減する必要はありませんでした。 当時利用可能なツールを利用し、テスト中のWebページへのJavaScriptの注入に大きく依存して、ユーザーのインタラクションをエミュレートしました。\nJavaScriptは、DOMのプロパティを内観し、他の方法では実行できない特定のクライアント側の観察を行うことができる優れたツールですが、キーボードが使っているようなマウスとマウスの操作を自然に複製する機能には不十分です。\nそれ以来、Seleniumは多くの成長と成熟を遂げ、世界中のほとんどの大規模な組織ではなく、多くの人々が広く使用するツールになりました。 Seleniumは、ニッチな聴衆と特定のユースケースのためにThoughtworksで開発された自作のテスト自動化ツールキットから、世界の デファクト ブラウザ自動化ライブラリになりました。\nSelenium RCが当時利用可能な業界のツールを利用したように、Selenium WebDriverは、ブラウザインタラクションの部分をブラウザベンダーの本拠地に持ち込み、バックエンドのブラウザー対応実装の責任を取るよう依頼することにより、その伝統を推進しています。 最近、この作業は、SeleniumのWebDriverコンポーネントをユーザーエージェント用の 最新の リモートコントロールライブラリにすることを目標とするW3C標準化プロセスに進化しました。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/selenium_installation/installing_selenium_libraries/",
	"title": "Seleniumライブラリのインストール",
	"tags": [],
	"description": "",
	"content": "最初にあなたの自動化プロジェクトにSeleniumのバインディングをインストールする必要があります。 インストールの方法は選択した言語によって異なります。\nJava JavaへのSeleniumライブラリのインストールはMavenを使います。 プロジェクトのpom.xmlに selenium-java の依存関係を追加してください。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; selenium-java 依存関係は、Seleniumがサポートする全てのブラウザを自動化プロジェクトで実行できるようにします。 もし特定のブラウザだけでテストを実行したい場合は、そのブラウザの依存関係を pom.xml ファイルに追加することができます。 例えば、Firefoxのみでテストを実行するためには下記の依存関係を pom.xml ファイルに追加します。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 同じように、Chromeのみでテストを実行するためには下記の依存関係を追加します。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python PythonへのSeleniumライブラリのインストールはpipを使います。\npip install selenium また、PyPI source archive (selenium-x.x.x.tar.gz)をダウンロードして、 setup.py でインストールすることもできます。\npython setup.py install C# C#へのSeleniumライブラリのインストールはNuGetを使います。\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby RubyへのSeleniumライブラリのインストールはgemを使います。\ngem install selenium-webdriver JavaScript JavaScriptへのSeleniumライブラリのインストールはnpmを使います。\nnpm install selenium-webdriver "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/getting_started/",
	"title": "はじめる",
	"tags": [],
	"description": "",
	"content": "Getting started もしSeleniumが初めてでしたら、素早く知識を得るためのリソースを用意しました。\n クイックツアー  WebDriver IDE Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/getting_started/quick/",
	"title": "クイックツアー",
	"tags": [],
	"description": "",
	"content": "Seleniumは一つのツールやAPIではありません。たくさんのツールから構成されています。\nWebDriver デスクトップのウェブサイトのテスト自動化をはじめるのなら、WebDriver APIを使いましょう。 WebDriver はブラウザ自動化のAPIを使用します。このAPIは、ブラウザをコントロールしてテストを実行するためにブラウザベンダーによって提供されています。これは現実のユーザーがブラウザを操作するかのように動きます。 WebDriverのAPIはアプリケーションのコードと一緒にコンパイルする必要がありませんから、全く邪魔になりません。 これによって、あなたは本番環境と同じアプリケーションをテストすることができます。\nIDE IDE (Integrated Development Environment: 統合開発環境)はSeleniumのテストケースを開発するためのツールです。 これは利用しやすいChromeとFirefoxの拡張機能であり、テストケースを開発するための一般に最も効率的なツールです。 IDEはあなたのブラウザ上で、その要素で定義されたパラメーターと共にSeleniumのコマンドを使いユーザーの動作を記録します。 これは時間の節約だけでなく、Seleniumスクリプトのシンタックスを学ぶための優れた方法です。\nGrid Selenium Grid を使用すると、さまざまなプラットフォームのさまざまなマシンでテストケースを実行できます。 テストケースの起動の制御はローカル端末で行われ、テストケースが起動されると、 リモート端末によって自動的に実行されます。\nWebDriverテストの開発後、複数のブラウザーとオペレーティングシステムの組み合わせでテストを実行する必要が出てくる場合があります。 ここで Grid が登場します。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/understanding_the_components/",
	"title": "コンポーネントを理解する",
	"tags": [],
	"description": "",
	"content": "WebDriverを使ってテストスイートを構築するには、多くの異なるコンポーネントを理解し、効率的に使用する必要があります。 ソフトウェアのすべてがそうであるように、人によっては同じ概念に異なる用語を使用します。 以下は、本説明での用語の使用方法の内訳です。\n用語  API: アプリケーション プログラミング インターフェイス。これはWebDriverを操作するために使用する\u0026quot;コマンド\u0026quot;をまとめたものです。 ライブラリ: APIとそれらを実装する必要なコードを含むコードモジュール。 ライブラリは各言語バインディング向けのものです。例 .jar files for Java, .dll files for .NET, など. ドライバー: 実際のブラウザを制御します。 ほとんどのドライバーはブラウザベンダー自身が作成します。ドライバーは一般的にブラウザ自体を備えたシステムで実行される実行可能モジュールであり、テストスイートを実行するシステムにはありません。（ただし、それらは同じシステムであっても構いません。）注: 一部の人々はドライバーをプロキシと呼んでいます。 フレームワーク: WebDriverスイートのサポートとして使用する追加ライブラリ。これらのフレームワークは、JUnitやNUnitなどのテストフレームワークです。また、CucumberまたはRobotiumといった自然言語機能をサポートするフレームワークでもあります。フレームワークは、テスト対象のシステムの操作や構成、データ作成、テストオラクルなどに記述、利用されます。  部品構成 最低限、WebDriverはドライバーを経由してブラウザーと通信します。 コミュニケーションは双方向です：WebDriverは、ドライバーを経由してブラウザーにコマンドを渡し、同じルートを経由して情報を受け取ります。\nドライバーは、ChromeDriver for GoogleのChrome/Chromium、MozillaのFirefox用GeckoDriverなどブラウザー固有のものです。 ドライバーはブラウザと同じシステムで動きます。これは、テスト自体を実行するところが同じシステムである場合とそうでない場合があります。\n上記の簡単な例は 直接 通信です。ブラウザへのコミュニケーションは、Selenium ServerまたはRemoteWebDriverを経由した リモート 通信もできます。RemoteWebDriverは、ドライバーおよびブラウザと同じシステムで実行されます。\nリモート通信は、ホストシステム上のドライバーと順に通信するSelenium ServerまたはSelenium Gridを使用して行うこともできます。\nどのフレームワークに適しているか WebDriverには1つのジョブしかありません:　上記の任意のメソッドを経由してブラウザと通信します。WebDriverはテストに関することを知りません:　WebDriverは物事を比較する方法、成功または失敗を確認する方法を知りません、そして、レポートや Given/When/Then 文法に関しても確実に知りません。\nここで、さまざまなフレームワークが登場します。 最低限必要なのは言語バインディングに一致するテストフレームワーク、例えば NUnit for .NET, JUnitfor Java, RSpec for Ruby などです。\nテストフレームワークは、WebDriverおよびテストの関連手順の実行を担当します。 それは下記図に似ていると考えることができます。\n上図でCucumberなどの自然言語のフレームワーク/ツールがテストフレームワークボックスの一部として存在する場合があります、またはテストフレームワークを独自の実装で完全に密閉する場合があります。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/getting_started_with_webdriver/browsers/",
	"title": "ブラウザ",
	"tags": [],
	"description": "",
	"content": "一般のブラウザ Seleniumフレームワークは公式に以下のブラウザをサポートしています。\n   ブラウザ メンテナ サポートバージョン     Chrome Chromium 全てのバージョン   Firefox Mozilla 54 以上   Internet Explorer Selenium 6 以上   Opera Opera Chromium / Presto 10.5 以上   Safari Apple 10 以上    専用のブラウザ それ以外に専用のブラウザがあります。これらは通常は開発環境で使用されます。 これらのブラウザを自動化の目的で使用することができます。 Seleniumは次の専用のブラウザをサポートしています。\n   ドライバー名 用途 メンテナ     HtmlUnitDriver Rhinoバックエンドのヘッドレスブラウザエミュレーター Seleniumプロジェクト    "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/page_object_models/",
	"title": "ページオブジェクトモデル",
	"tags": [],
	"description": "",
	"content": "ページオブジェクトは、テストメンテナンスを強化し、コードの重複を減らすためのテスト自動化で一般的になったデザインパターンです。 ページオブジェクトは、AUT（テスト対象アプリケーション）のページへのインターフェイスとして機能するオブジェクト指向クラスです。 テストは、そのページのUIと対話する必要があるときは常に、このページオブジェクトクラスのメソッドを使用します。 利点は、ページのUIが変更された場合、テスト自体を変更する必要はなく、ページオブジェクト内のコードのみを変更する必要があることです。 その後、その新しいUIをサポートするためのすべての変更は1か所に配置されます。\nページオブジェクトデザインパターンには、次の利点があります。\n テストコードと、ロケーター（またはUIマップを使用している場合はロケーター）、レイアウトなどのページ固有のコードを明確に分離します。 これらのサービスをテスト全体に分散させるのではなく、ページによって提供されるサービスまたは操作用の単一のリポジトリがあります。  どちらの場合でも、これにより、UIの変更により必要な変更をすべて1か所で行うことができます。 この'テストデザインパターン'が広く使用されるようになったため、この手法に関する有用な情報は多数のブログで見つけることができます。 詳細を知りたい読者には、このテーマに関するブログをインターネットで検索することをお勧めします。 多くの人がこの設計パターンについて書いており、このユーザーガイドの範囲を超えた有用なヒントを提供できます。 ただし、簡単に始めるために、ページオブジェクトを簡単な例で説明します。\n最初に、ページオブジェクトを使用しないテスト自動化の典型的な例を考えてみましょう。\n/*** * Tests login feature */ public class Login { public void testLogin() { // fill login data on sign-in page  driver.findElement(By.name(\u0026#34;user_name\u0026#34;)).sendKeys(\u0026#34;testUser\u0026#34;); driver.findElement(By.name(\u0026#34;password\u0026#34;)).sendKeys(\u0026#34;my supersecret password\u0026#34;); driver.findElement(By.name(\u0026#34;sign_in\u0026#34;)).click(); // verify h1 tag is \u0026#34;Hello userName\u0026#34; after login  driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).isDisplayed(); assertThat(driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).getText(), is(\u0026#34;Hello userName\u0026#34;)); } } このアプローチには2つの問題があります。\n テスト方法とAUTのロケーター（この例ではID）の間に区別はありません。 どちらも単一のメソッドで絡み合っています。 AUTのUIが識別子、レイアウト、またはログインの入力および処理方法を変更する場合、テスト自体を変更する必要があります。 IDロケーターは、このログインページを使用する必要があったすべてのテストで、複数のテストに分散されます。  ページオブジェクトの手法を適用すると、この例は、サインインページのページオブジェクトの次の例のように書き換えることができます。\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Sign-in page. */ public class SignInPage { protected static WebDriver driver; // \u0026lt;input name=\u0026#34;user_name\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By usernameBy = By.name(\u0026#34;user_name\u0026#34;); // \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By passwordBy = By.name(\u0026#34;password\u0026#34;); // \u0026lt;input name=\u0026#34;sign_in\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;SignIn\u0026#34;\u0026gt;  private By signinBy = By.name(\u0026#34;sign_in\u0026#34;); public SignInPage(WebDriver driver){ this.driver = driver; } /** * Login as valid user * * @param userName * @param password * @return HomePage object */ public HomePage loginValidUser(String userName, String password) { driver.findElement(usernameBy).sendKeys(userName); driver.findElement(passwordBy).sendKeys(password); driver.findElement(signinBy).click(); return new HomePage(driver); } } そして、ホームページのページオブジェクトは次のようになります。\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Home Page */ public class HomePage { protected static WebDriver driver; // \u0026lt;h1\u0026gt;Hello userName\u0026lt;/h1\u0026gt;  private By messageBy = By.tagName(\u0026#34;h1\u0026#34;); public HomePage(WebDriver driver){ this.driver = driver; if (!driver.getTitle().equals(\u0026#34;Home Page of logged in user\u0026#34;)) { throw new IllegalStateException(\u0026#34;This is not Home Page of logged in user,\u0026#34; + \u0026#34; current page is: \u0026#34; + driver.getCurrentUrl()); } } /** * Get message (h1 tag) * * @return String message text */ public String getMessageText() { return driver.findElement(messageBy).getText(); } public HomePage manageProfile() { // Page encapsulation to manage profile functionality  return new HomePage(driver); } /* More methods offering the services represented by Home Page of Logged User. These methods in turn might return more Page Objects for example click on Compose mail button could return ComposeMail class object */ } したがって、ログインテストでは、これら2つのページオブジェクトを次のように使用します。\n/*** * Tests login feature */ public class TestLogin { @Test public void testLogin() { SignInPage signInPage = new SignInPage(driver); HomePage homePage = signInPage.loginValidUser(\u0026#34;userName\u0026#34;, \u0026#34;password\u0026#34;); assertThat(homePage.getMessageText(), is(\u0026#34;Hello userName\u0026#34;)); } } ページオブジェクトの設計方法には多くの柔軟性がありますが、テストコードの望ましい保守性を得るための基本的なルールがいくつかあります。\nページオブジェクト自体は、検証やアサーションを行うべきではありません。 これはテストの一部であり、常にページオブジェクトではなく、テストのコード内にある必要があります。 ページオブジェクトには、ページの表現と、ページがメソッドを介して提供するサービスが含まれますが、テスト対象に関連するコードはページオブジェクト内に存在しないようにします。\nページオブジェクト内に存在する可能性のある単一の検証があります。 これは、ページおよびページ上の重要な要素が正しく読み込まれたことを検証するためのものです。 この検証は、ページオブジェクトをインスタンス化する間に実行する必要があります。 上記の例では、SignInPageコンストラクターとHomePageコンストラクターの両方が期待するページを取得し、テストからの要求に対応できることを確認します。\nページオブジェクトは、必ずしもページ全体を表す必要はありません。 ページオブジェクトデザインパターンは、ページ上のコンポーネントを表すために使用できます。 AUTのページに複数のコンポーネントがある場合、コンポーネントごとに個別のページオブジェクトがあると、保守性が向上する場合があります。\nまた、テストで使用できる他のデザインパターンがあります。 ページファクトリを使用してページオブジェクトをインスタンス化するものもあります。 これらすべてについて議論することは、このユーザーガイドの範囲を超えています。 ここでは、読者にできることのいくつかを認識させるための概念を紹介したいだけです。 前述のように、多くの人がこのトピックについてブログを書いていますし、読者がこれらのトピックに関するブログを検索することをお勧めします。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/remote_webdriver/remote_webdriver_server/",
	"title": "リモートWebDriverサーバー",
	"tags": [],
	"description": "",
	"content": "サーバーは、テストするブラウザーがインストールされたマシンで常に実行されます。 サーバーは、コマンドラインから、またはコード設定を通じて使用できます。\nコマンドラインからサーバーを起動する 一旦、selenium-server-standalone-{VERSION}.jarをダウンロードしたら、テストしたいブラウザーのあるコンピューターに配置します。 次に、jarを含むディレクトリから、次のコマンドを実行します。\njava -jar selenium-server-standalone-{VERSION}.jar サーバーを実行するにあたって考慮すること 呼び出し元は、Selenium#stop()またはWebDriver#quitを呼び出して、各セッションを適切に終了すべきです。\nselenium-serverは、進行中の各セッションのメモリ内ログを保持します。 これらのログは、Selenium#stop()またはWebDriver#quitが呼び出されるとクリアされます。 これらのセッションの終了を忘れると、サーバーでメモリリークが発生する可能性があります。 非常に長時間実行されるセッションを維持する場合は、時々停止または終了する必要があります（または-Xmx jvmオプションでメモリを増やします）。\nタイムアウト (version 2.21以降) サーバーには2つの異なるタイムアウトがあり、次のように設定できます。\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  ブラウザーのハングを許可する時間を制御します（値は秒単位）。   timeout  セッションが回収されるまでにクライアントがいなくなる時間を制御します（値は秒単位）。    システムプロパティselenium.server.session.timeoutは、2.21からサポートされなくなりました。\nbrowserTimeoutは、通常のタイムアウトメカニズムが失敗した場合の予備のタイムアウトメカニズムであることに注意してください。これは主にグリッド/サーバー環境で使用され、クラッシュ/失われたプロセスが長く滞留、ランタイム環境を汚染しないようにします。\nプログラムでサーバーを構成する 理論的には、プロセスはDriverServletをURLにマッピングするのと同じくらい簡単ですが、ページを全体的にコードで構成されたJettyなどの軽量コンテナでホストすることもできます。これを行う手順は次のとおりです。\nselenium-server.zipをダウンロードして解凍します。 JARをCLASSPATHに配置します。 AppServerという新しいクラスを作成します。 ここでは、Jettyを使用しているので、それもダウンロードする必要があります。\nimport org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } } "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/driver_idiosyncrasies/shared_capabilities/",
	"title": "共有Capabilities",
	"tags": [],
	"description": "",
	"content": "Selenium WebDriverで新しいセッションを作成するには、ローカルエンドがリモートエンドに基本的なCapabilities（ブラウザの設定情報）を提供する必要があります。 リモートエンドは、一連の同じCapabilitiesを使用してセッションを作成し、現在のセッション機能を描きます。\nWebDriverは、各リモートエンドがCapabilitiesをサポートする/すべきCapabilitiesを提供します。 WebDriverがサポートするCapabilitiesは次のとおりです。\nbrowserName: このCapabilityは、特定のセッションの browserName を設定するために使います。 指定されたブラウザがリモートエンドにインストールされていない場合、セッションの作成は失敗します。\nbrowserVersion: このCapabilityはオプションです。 これは、リモートエンドで使用可能なブラウザーバージョンを設定するために使います。 たとえば、Chromeバージョン80のみがインストールされているシステムでバージョン75を要求すると、セッションの作成は失敗します。\nページロード戦略 URLを介して新しいページに移動する場合、デフォルトでは、Seleniumは応答する前にページが完全にロードされるまで待機します。 これは初心者には効果的ですが、多数のサードパーティリソースをロードするページで長い待ち時間を引き起こす可能性があります。 デフォルト以外の戦略を使用すると、このような場合にテストの実行を高速化できますが、ページの要素がロードされてサイズが変更されると、ページ上の要素の位置が変化する不安定さを引き起こします。\n次の表で説明するように、ページロード戦略は document.readyState を問い合わせます。\n   戦略 Ready State 注釈     normal complete デフォルトで使用され、すべてのリソースがダウンロードされるまで待機します   eager interactive DOMアクセスの準備はできていますが、画像などの他のリソースがまだ読み込まれている可能性があります   none Any WebDriverをまったくブロックしません    platformName これにより、リモートエンドのオペレーティングシステムが識別され、 platformName を取得するとOS名が返されます。\nクラウドベースのプロバイダーでは、 platformName を設定すると、リモートエンドのOSが設定されます。\nacceptInsecureCerts この機能は、セッション中のナビゲーション中に、期限切れ（または）無効な TLS証明書 が使用されているかどうかを確認します。\n機能が false に設定されている場合、ナビゲーションでドメイン証明書の問題が発生すると、 insecure certificate error が返されます。 true に設定すると、無効な証明書はブラウザーによって信頼されます。\nすべての自己署名証明書は、デフォルトでこの機能によって信頼されます。 一度設定すると、 acceptInsecureCerts Capabilityはセッション全体に影響します。\nSession timeouts WebDriverの セッション には特定の セッションタイムアウト 間隔が設定されており、 その間、ユーザーはスクリプトの実行またはブラウザーからの情報の取得の動作を制御できます。\n各セッションタイムアウトは、以下で説明するように、異なる タイムアウト の組み合わせで構成されます。\nScript Timeout: 現在のブラウジングコンテキストで実行中のスクリプトをいつ中断するかを指定します。 新しいセッションがWebDriverによって作成されると、デフォルトのタイムアウト 30,000 が課されます。\nPage Load Timeout: 現在のブラウジングコンテキストでWebページをロードする必要がある時間間隔を指定します。 新しいセッションがWebDriverによって作成されると、デフォルトのタイムアウト 300,000 が課されます。 ページの読み込みが指定/デフォルトの時間枠を制限する場合、スクリプトは　TimeoutException　によって停止されます。\nImplicit Wait Timeout これは、要素を検索するときに暗黙的な要素の検索戦略を待つ時間を指定します。 新しいセッションがWebDriverによって作成されると、デフォルトのタイムアウト 0 が課されます。\nunhandledPromptBehavior 現在のセッションの ユーザープロンプトハンドラー の状態を指定します。 デフォルトでは、 dismiss and notify (却下して通知する) 状態 となります。\nUser Prompt Handler これは、リモートエンドでユーザープロンプトが表示されたときに実行する必要があるアクションを定義します。 これは、 unhandledPromptBehavior Capabilityによって定義され、次の状態があります。\n dismiss (却下) accept (受入) dismiss and notify (却下して通知) accept and notify (受け入れて通知) ignore (無視)  setWindowRect このコマンドは、現在のブラウジングコンテキストウィンドウのサイズと位置を変更します。 このコマンドは、幅 、高さ、x、yを 任意 の引数として受け取る getWindowRect コマンドのセッターとして機能します。\n自動化中、現在のブラウジングコンテキストは、 ブラウザーウィンドウの可視状態を表すウィンドウ状態に関連付けられます。 ウィンドウ状態は、以下です。\n maximized minimized normal fullscreen  幅 または 高さ を設定しても、結果のウィンドウサイズが要求されたものと 正確に一致することを保証しません。 これは、一部のドライバはシングルピクセル単位でサイズ変更できない場合があるからです。 このため、 getWindowRect でウィンドウの状態/詳細を取得しても、 ブラウザーに設定された値と等しく一致しない場合があります。\nstrictFileInteractability The new capabilitiy indicates if strict interactability checks should be applied to input type=file elements. As strict interactability checks are off by default, there is a change in behaviour when using Element Send Keys with hidden file upload controls.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/grid/purposes_and_main_functionalities/",
	"title": "目的と主な機能",
	"tags": [],
	"description": "",
	"content": " すべてのテストの中央エントリポイント ブラウザーが実行されるノード・環境の管理と制御 スケーリング テストを並列実行 クロスプラットフォームでのテスト 負荷分散  "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/front_matter/copyright_and_attributions/",
	"title": "著作権と帰属",
	"tags": [],
	"description": "",
	"content": "Seleniumのドキュメント 著作権 \u0026copy; 2013-2020 Software Freedom Conservancy\nこのドキュメントをできるだけ完全かつ正確にするためにあらゆる努力が払われましたが、 保証または適合性は暗示されていません。 提供される情報は「現状のまま」です。 著者および出版社は、本書に含まれる情報から生じる損失または損害に関して、 いかなる個人または団体に対しても責任も責任も負わないものとします。 ここに含まれる情報の使用に関して、特許責任は一切負いません。\n帰属 Thanks to: Selenium メイン Repository Selenium IDE Docker Selenium Selenium Website \u0026amp; Docs Previous Selenium Website Previous Documentation Rewrite Project Seleniumドキュメントプロジェクトで使用されるサードパーティソフトウェア    Software Version License     Hugo v0.59.0 Apache 2.0   Hugo Learn Theme v2.4.0 MIT   Code Tabs Style \u0026mdash; MIT    ライセンス Seleniumプロジェクトから作成されたすべてのコードとドキュメントは、 Apache 2.0ライセンスに基づいてライセンスされており、 Software Freedom Conservancy に著作権があります。\nライセンスは便宜上ここに含まれていますが、 Apache FoundationのWebサイトでも見つけることができます。\nApache License Version 2.0, 2004年1月 http://www.apache.org/licenses/ 使用、複製、および頒布に関する条項 1. 定義 「ライセンス」とは、このドキュメントの第1項から第9項までで定義している、 使用、複製、および頒布に関する条項を指します。 「ライセンサー」とは、著作権所有者、あるいは著作権所有者が ライセンス付与対象として認めた者を指します。 「法人」とは、行為者と、行為者を管理するか行為者により管理されるか 行為者共通の管理下にある他のすべての者とから成る連合体を指します。 この定義における「管理」とは、 (i) 契約またはその他により、直接または間接的にこの法人の指揮・経営を行う権限、または (ii) この法人の50%以上の株式の所有権 または (iii) 受益所有権を有することを指します。 「あなた」とは、本ライセンスにより付与される権利を行使する個人または法人を指します。 「ソース」形式とは、ソフトウェアのソースコード、ドキュメントソース、 設定ファイルといった、変更を加えるのに好都合な形式を指します。 「オブジェクト」形式とは、コンパイルされたオブジェクトコード、生成されたドキュメント、 他のメディアへの変換物といった、ソース形式の機械的な変換により生じる形式を指します。 「成果物」とは、ソース形式であるとオブジェクト形式であるとを問わず、 製作物に挿入または添付される（後出の付録に例がある）著作権表示で示された著作物で、 本ライセンスに基づいて利用が許されるものを指します。 「派生成果物」とは、編集上の改訂、注解、推敲など、 成果物を基にしていて全体としてオリジナル著作物と呼べるような製作物全般を指します。 本ライセンスでは、成果物や派生成果物から分離できる製作物や、 成果物や派生成果物のインタフェースへの単なるリンク（または名前によるバインド）を、 派生成果物に含めません。 「コントリビューション」とは、成果物のオリジナルバージョンならびに成果物 または派生成果物への変更や追加も含めて、著作権所有者あるいは著作権所有者が認めた 個人または法人による成果物への組み込みを意図してライセンサーに提出される 著作物全般を指します。 この定義における「提出」とは、成果物を論じたり改良するためにライセンサー またはその代理者により管理される電子的メーリングリスト、ソースコード管理システム、 問題追跡システムといった、電子的方法、口頭、または書面で、 ライセンサーまたはその代理者に情報を送ることを指します。 ただし、著作権所有者が書面で「コントリビューションでない」と明示したものは除きます。 「コントリビューター」とは、ライセンサーおよびその代理を務める個人または法人で、 自分のコントリビューションがライセンサーに受領されて成果物に組み込まれた者を指します。 2. 著作権ライセンスの付与 本ライセンスの条項に従って、各コントリビューターはあなたに対し、 ソース形式であれオブジェクト形式であれ、成果物および派生成果物を複製したり、 派生成果物を作成したり、公に表示したり、公に実行したり、サブライセンスしたり、 頒布したりする、無期限で世界規模で非独占的で使用料無料で取り消し不能な 著作権ライセンスを付与します。 3. 特許ライセンスの付与 本ライセンスの条項に従って、各コントリビューターはあなたに対し、 成果物を作成したり、使用したり、販売したり、販売用に提供したり、 インポートしたり、その他の方法で移転したりする、 無期限で世界規模で非独占的で使用料無料で取り消し不能な （この項で明記したものは除く）特許ライセンスを付与します。 ただし、このようなライセンスは、コントリビューターによって ライセンス可能な特許申請のうち、当該コントリビューターのコントリビューションを 単独または該当する成果物と組み合わせて用いることで必然的に侵害されるものにのみ 適用されます。 あなたが誰かに対し、交差請求や反訴を含めて、 成果物あるいは成果物に組み込まれたコントリビューションが 直接または間接的な特許侵害に当たるとして特許訴訟を起こした場合、 本ライセンスに基づいてあなたに付与された特許ライセンスは、 そうした訴訟が正式に起こされた時点で終了するものとします。 4. 再頒布 あなたは、ソース形式であれオブジェクト形式であれ、変更の有無に関わらず、 以下の条件をすべて満たす限りにおいて、成果物またはその派生成果物のコピーを 複製したり頒布したりすることができます。 (a) 成果物または派生成果物の他の受領者に本ライセンスのコピーも渡すこと。 (b) 変更を加えたファイルについては、あなたが変更したということが よくわかるような告知を入れること。 (c) ソース形式の派生成果物を頒布する場合は、ソース形式の成果物に含まれている著作権、 特許、商標、および帰属についての告知を、派生成果物のどこにも関係しないものは除いて、 すべて派生成果物に入れること。 (d) 成果物の一部として「NOTICE」に相当するテキストファイルが含まれている場合は、 そうしたNOTICEファイルに含まれている帰属告知のコピーを、 派生成果物のどこにも関係しないものは除いて、頒布する派生成果物に入れること。 その際、次のうちの少なくとも1箇所に挿入すること。 (i) 派生成果物の一部として頒布するNOTICEテキストファイル、 (ii) ソース形式またはドキュメント（派生成果物と共にドキュメントを頒布する場合）、 (iii) 派生成果物によって生成される表示 （こうした第三者告知を盛り込むことが標準的なやり方になっている場合）。 NOTICEファイルの内容はあくまで情報伝達用であって、 本ライセンスを修正するものであってはなりません。 あなたは頒布する派生成果物に自分の帰属告知を （成果物からのNOTICEテキストに並べて、またはその付録として）追加できますが、 これはそうした追加の帰属告知が本ライセンスの修正と 解釈されるおそれがない場合に限られます。 あなたは自分の修正物に自らの著作権表示を追加することができ、 自分の修正物の使用、複製、または頒布について、あるいはそうした派生成果物の全体について、 付加的なライセンス条項または異なるライセンス条項を設けることができます。 ただし、これは成果物についてのあなたの使用、複製、および頒布が、 それ以外の点で本ライセンスの条項に従っている場合に限られます。 5. コントリビューションの提出 特に断りがない限り、あなたが成果物への組み込みを意図してライセンサーに 提出したコントリビューションは、付加的な条項がなければ、 本ライセンスの条項に従うものとします。 上述の規定にかかわらず、そうしたコントリビューションに関してあなたがライセンサーと 結んだかもしれない別のライセンス契約の条項を、ここで無効にしたり 修正したりすることはありません。 6. 商標 本ライセンスでは、成果物の出所を記述したりNOTICEファイルの内容を複製するときに 必要になる妥当で慣習的な使い方は別として、ライセンサーの商号、商標、サービスマーク、 または製品名の使用権を付与しません。 7. 保証の否認 適用される法律または書面での同意によって命じられない限り、 ライセンサーは成果物を（そしてコントリビューターは各自のコントリビューションを） 「現状のまま」提供するものとし、明示黙示を問わず、タイトル、非侵害性、 商業的な使用可能性、および特定の目的に対する適合性を含め、 いかなる保証も条件も提供しません。 あなたは成果物の使用や再頒布の適切性を自分で判断する責任を持つと共に、 本ライセンスにより付与される権利を行使することに伴うすべてのリスクを負うことになります。 8. 責任の制限 いかなる条件および法理論においても、不法行為（過失を含む）、契約、 またはその他いかなる場合でも、適用される法律または書面での同意によって命じられない限り、 コントリビューターは本ライセンスまたは成果物の使い方に関連して生じる直接損害、 間接損害、偶発的な損害、特別損害、懲罰的損害、または結果損害を含め、 営業権の損失、業務の停止、コンピューター障害または誤作動、 その他の商業上の損害や損失など、いかなる損害に対しても、 たとえそうした損害の可能性をたとえ知らされていたとしても、 あなたに責任を負わないものとします。 9. 保証または追加的責任の引き受け 成果物またはその派生成果物を再頒布する際、あなたはサポート、保証、損害補償、 またはその他の責任や、本ライセンスに矛盾しない権利を提示し、 これを有料にすることができます。 ただし、そうした責任を引き受ける場合、あなたはそれを自分自身のためにだけ 自己責任として行えるのであって、他のコントリビューターのために行うことはできません。 また、あなたはそうした保証や追加的責任のせいで他のコントリビューターに 責任が降りかかったり賠償要求が出されたとしても、それらのコントリビューターに 損害が及ぶのを防ぐと共に各コントリビューターの損害を補償することに同意しなければなりません。 使用、複製、および頒布に関する条項の終わり 付録： Apache Licenseの適用の仕方 あなたの製作物にApache Licenseを適用するときは、次の定型文を添付してください。 ただし、\u0026#34;[]\u0026#34;で囲まれている部分は、あなた自身の識別情報に置き換えてください （その際、角括弧は取り除きます）。 また、この文言を該当するファイル形式に合ったコメント構文で囲んでください。 さらに、第三者アーカイブ内での識別を容易にするため、 ファイル名またはクラス名ならびに趣旨説明が著作権表示と同じ「印刷ページ」に 現れるようにすることをお勧めします。 Copyright [yyyy] [著作権所有者の名前] Apache License Version 2.0（「本ライセンス」）に基づいてライセンスされます。 あなたがこのファイルを使用するためには、本ライセンスに従わなければなりません。 本ライセンスのコピーは下記の場所から入手できます。 http://www.apache.org/licenses/LICENSE-2.0 適用される法律または書面での同意によって命じられない限り、 本ライセンスに基づいて頒布されるソフトウェアは、明示黙示を問わず、 いかなる保証も条件もなしに「現状のまま」頒布されます。 本ライセンスでの権利と制限を規定した文言については、本ライセンスを参照してください。 "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/legacy_docs/migrating_from_rc_to_webdriver/",
	"title": "RCからWebDriverへの移行",
	"tags": [],
	"description": "",
	"content": "Selenium WebDriverに移行する方法 Selenium 2を採用する際によくある質問は、「既存のテストセットに新しいテストを追加するときに正しいことは何ですか？」ということです。 フレームワークを初めて使用するユーザーは、新しいWebDriver APIを使用してテストを作成することから始めることができます。 しかし、既存のテストスイートを既に持っているユーザーはどうでしょうか？ このガイドは、既存のテストを新しいAPIに移行し、WebDriverが提供する新機能を使用してすべての新しいテストを作成する方法を示すことを目的としています。\nここで紹介する方法は、1回の大規模なプッシュですべてをやり直す必要のない、WebDriver APIへの断片的な移行について説明しています。 これは、既存のテストの移行により多くの時間を割り当てることができることを意味します。 これにより、どこに労力を費やすかを決定しやすくなります。\nこのガイドは、移行を行うための最良のサポートがあるため、Javaを使用して書かれています。 他の言語用のより優れたツールを提供するため、このガイドはそれらの言語を含むように拡張されます。\nWebDriverに移行する理由 一連のテストをあるAPIから別のAPIに移動するには、多大な労力が必要です。 なぜあなたとあなたのチームはこの動きを検討するのですか？ WebDriverを使用するためにSeleniumテストを移行することを検討する必要があるいくつかの理由を以下に示します。\n 小さくコンパクトなAPI。 WebDriverのAPIは、元のSelenium RC APIよりもオブジェクト指向です。 これにより、作業が容易になります。 ユーザー操作のより良いエミュレーション。 可能な場合、WebDriverはWebページと対話するためにネイティブイベントを使用します。 これは、ユーザーがサイトやアプリを操作する方法をより厳密に模倣しています。 さらに、WebDriverは、サイトとの複雑な相互作用をモデル化できる高度なユーザーインタラクションAPIを提供します。 ブラウザーベンダーによるサポート。 Opera、Mozilla、GoogleはすべてWebDriverの開発に積極的に参加しており、それぞれにフレームワークの改善に取り組んでいるエンジニアがいます。 多くの場合、これはWebDriverのサポートがブラウザー自体に組み込まれていることを意味します。 テストは可能な限り高速で安定して実行されます。  はじめる前に 移行プロセスを可能な限り簡単にするために、すべてのテストが最新のSeleniumリリースで正しく実行されることを確認してください。 これは当たり前のように聞こえるかもしれませんが、言ってもらうのが最善です！\nはじめに 移行を開始する最初の手順は、Seleniumのインスタンスの取得方法を変更することです。 Selenium RCを使用する場合、これは次のように行われます。\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); これは次のように置き換える必要があります。\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); 次のステップ テストがエラーなしで実行されたら、次の段階は実際のテストコードを移行してWebDriver APIを使用することです。 コードがどれだけ適切に抽象化されているかによって、これは短いプロセスまたは長いプロセスになります。 どちらの場合でも、アプローチは同じであり、簡単に要約できます。 編集するときに新しいAPIを使用するようにコードを変更します。\n基になるWebDriver実装をSeleniumインスタンスから抽出する必要がある場合は、WrapsDriverにキャストするだけです。\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); これにより、通常どおりSeleniumインスタンスの受け渡しを続けることができますが、必要に応じてWebDriverインスタンスのラップを解除できます。\nある時点で、コードベースは主に新しいAPIを使用します。 この時点で、WebDriverを使用して関係を反転し、オンデマンドでSeleniumインスタンスをインスタンス化できます。\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); 一般的な問題 幸いなことに、この移行を最初に行ったのはあなたではないので、他の人が経験した一般的な問題とその解決方法を以下に示します。\nクリックと入力がより完全に Selenium RCテストの一般的なパターンは、以下のとおりです。\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); これは、ユーザーがページと対話した場合に通常発生するすべてのイベントも発生せずに、\u0026ldquo;type\u0026quot;が識別された要素のコンテンツを単に置き換えるという事実に依存しています。 \u0026ldquo;key*\u0026rdquo; の最後の直接呼び出しにより、JSハンドラーが期待どおりに起動します。\nWebDriverBackedSeleniumを使用する場合、フォームフィールドに入力した結果は \u0026ldquo;exciting texttt\u0026rdquo; になります。 期待したものではありません！ これは、WebDriverがユーザーの動作をより正確にエミュレートするため、ずっとイベントを発火させていたためです。\nこの同じ事実により、Selenium 1テストよりも早くページの読み込みが発生する場合があります。 \u0026ldquo;StaleElementException\u0026quot;がWebDriverによってスローされた場合、これが発生したことを確認できます。\nWaitForPageToLoadがすぐに戻る ページの読み込みが完了したことを発見するのは難しい仕事です。 \u0026ldquo;ロードイベントが発生したとき\u0026rdquo;、\u0026ldquo;すべてのAJAXリクエストが完了したとき\u0026rdquo;、\u0026ldquo;ネットワークトラフィックがないとき\u0026rdquo;、\u0026ldquo;document.readyStateが変更されたとき\u0026rdquo;、または他の全体的な何かを意味しますか？\nWebDriverは元のSeleniumの動作をシミュレートしようとしますが、これはさまざまな理由で常に完全に機能するとは限りません。 最も一般的な理由は、ページの読み込みがまだ開始されていないことと、ページ呼び出しがメソッド呼び出し間で完了したことの違いを見分けることが難しいことです。 これは、ページの読み込みが完了する前（または開始される前）に制御がテストに返されることを意味する場合があります。\nこれに対する解決策は、特定の何かを待つことです。 一般的に、これは次にやり取りしたい要素、または特定の値に設定されるJavascript変数のためのものです。 例えば、\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, Duration.ofSeconds(30)); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); \u0026ldquo;visibilityOfElementLocated\u0026rdquo; は次のように実装されます。\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } これは複雑に見えるかもしれませんが、ほとんどすべての定型コードです。 唯一の興味深い点は、 \u0026ldquo;apply\u0026rdquo; メソッドが \u0026ldquo;null\u0026rdquo; でもBoolean.FALSEでもないものを返すまで、 \u0026ldquo;ExpectedCondition\u0026rdquo; が繰り返し評価されることです。\nもちろん、これらの \u0026ldquo;wait\u0026rdquo; 呼び出しをすべて追加すると、コードが混乱する可能性があります。 その場合で、ニーズが単純な場合は、暗黙的な待機の使用を検討してください。\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); これにより、要素が見つかるたびに、要素が存在しない場合は、存在するか、30秒が経過するまで位置が再試行されます。\nXPathまたはCSSセレクターによる検索は常に機能するとは限りませんが、Selenium1では機能します Selenium 1では、xpathがブラウザ自体の機能ではなく、バンドルされたライブラリを使用するのが一般的でした。 代替手段がない限り、WebDriverは常にネイティブブラウザーメソッドを使用します。 つまり、一部のブラウザでは複雑なxpath式が壊れる場合があります。\nSelenium 1のCSSセレクターは、Sizzleライブラリを使用して実装されました。 これにより、CSS Selector仕様のスーパーセットが実装され、どこで境界を越えたかが常に明確になるとは限りません。 WebDriverBackedSeleniumを使用していて、要素の検索にCSSセレクターの代わりにSizzleロケーターを使用している場合、コンソールに警告が記録されます。 特に要素を見つけることができないためにテストが失敗する場合、これらを探すのに時間をかける価値があります。\nBrowserbotはありません Selenium RCはSelenium Coreに基づいていたため、Javascriptを実行すると、Selenium Coreの一部にアクセスして作業を簡単にすることができました。 WebDriverはSelenium Coreに基づいていないため、これは不可能です。 Selenium Coreを使用しているかどうかをどのように確認できますか？ シンプル！ \u0026ldquo;getEval\u0026rdquo; または同様の呼び出しが、評価されたJavascriptで \u0026ldquo;selenium\u0026rdquo; または \u0026ldquo;browserbot\u0026rdquo; を使用しているかどうかを確認してください。\nbrowserbotを使用して、テストの現在のウィンドウまたはドキュメントへのハンドルを取得している可能性があります。 幸いなことに、WebDriverは常に現在のウィンドウのコンテキストでJSを評価するため、\u0026ldquo;ウィンドウ\u0026quot;または\u0026quot;ドキュメント\u0026quot;を直接使用できます。\nまたは、Browserbotを使用して要素を見つけることもできます。 WebDriverでは、これを行うためのイディオムは、最初に要素を見つけ、それを引数としてJavascriptに渡すことです。 従って、\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); このようになります。\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); 渡された \u0026ldquo;element\u0026rdquo; 変数が、JS標準の \u0026ldquo;arguments\u0026rdquo; 配列の最初の項目としてどのように表示されるかに注目してください。\nExecuting Javascript Doesn\u0026rsquo;t Return Anything WebDriverのJavascriptExecutorは、すべてのJSをラップし、匿名式として評価します。 これは、 \u0026ldquo;return\u0026rdquo; キーワードを使用する必要があることを意味します。\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); このようになります。\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;); "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/selenium_installation/installing_webdriver_binaries/",
	"title": "WebDriverバイナリのインストール",
	"tags": [],
	"description": "",
	"content": "プロジェクトを実行し、ブラウザをコントロールするためにはブラウザ固有のWebDriverバイナリをインストールする必要があります。\n使用するブラウザがサポートするWebDriverバイナリをダウンロードして、 System PATHの通った場所に配置してください。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/grid/components_of_a_grid/",
	"title": "グリッドのコンポーネント",
	"tags": [],
	"description": "",
	"content": "ハブ  仲介者およびマネージャー テストを実行する要求を受け入れます クライアントから命令を受け取り、ノード上でリモートで実行します スレッドを管理します  ハブ は、すべてのテストが送信される中心点です。 各Selenium Gridは、ちょうど1つのハブで構成されます。 ハブは、それぞれのクライアント（CIサーバー、開発者マシンなど）から到達可能である必要があります。 ハブは、テストが委任される1つ以上のノードを接続します。\nノード  ブラウザが存在する場所 ハブに自分自身を登録し、その機能を伝えます ハブからリクエストを受信して実行します  ノード は、個々のコンピューターシステムでテストを実行するさまざまなSeleniumインスタンスです。 グリッドには多くのノードが存在する場合があります。 ノードであるマシンは、ハブまたは他のノードと同じプラットフォームであったり、同じブラウザーを選定する必要はありません。 Windows上のノードは、Internet Explorerをブラウザーオプションとして提供する機能を備えている場合がありますが、これはLinuxまたはMacでは不可能です。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "サードパーティのドライバとプラグイン",
	"tags": [],
	"description": "",
	"content": "Seleniumはプラグインを通して拡張することができます。ここにはサードパーティによって作られたいくつかのプラグインがあります。 独自のプラグインを作成する、またはリストする方法についてはドキュメントを参照してください。\nこれらのプラグインはSeleniumプロジェクトによってサポート、メンテナンス、主催、承認されているものではないことに注意してください。加えて、以下にリストされているプラグインは必ずしもApache License v.2.0によってライセンスされているわけではありません。 いくつかは他のフリーかつオープンソースのライセンス下で使用可能であり、他のいくつかはプロプライエタリなライセンスの下でのみ使用可能です。プラグインとその配布ライセンスに関するどんな質問も、それぞれの開発者に対して上げる必要があります。\n   ブラウザ 最新版 変更履歴 イシュートラッカー     Mozilla GeckoDriver 最新版 変更履歴 イシュートラッカー   Google Chrome Driver 最新版 変更履歴 イシュートラッカー   Opera 最新版 - イシュートラッカー   Microsoft Edge Driver 最新版 - イシュートラッカー   SafariDriver ビルトイン - イシュートラッカー    "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/introduction/on_test_automation/",
	"title": "テスト自動化について",
	"tags": [],
	"description": "",
	"content": "まず、本当にブラウザを使用する必要があるかどうかを自問することから始めます。 ある時点で複雑なWebアプリケーションで作業している場合、おそらくブラウザを開いて実際にテストする必要があるでしょう。\nただし、Seleniumテストなどの機能的なエンドユーザーテストの実行には費用がかかります。 さらに、それらは通常、効果的に実行するために適切なインフラストラクチャを配置する必要があります。 単体テストなどのより軽量なテストアプローチを使用して、または下位レベルのアプローチを使用して、テストすることを実行できるかどうかを常に自問するのは良いルールです。\nWebブラウザーのテストビジネスに参加していることを確認し、Selenium環境でテストの記述を開始できるようになったら、通常は3つのステップを組み合わせて実行します。\n データを設定する 個別の一連のアクションを実行する 結果を評価する  これらの手順はできるだけ短くしてください。 ほとんどの場合、1つまたは2つの操作で十分です。 ブラウザの自動化は\u0026quot;不安定\u0026quot;であるという評判がありますが、実際には、ユーザーが頻繁に多くを求めることが多いためです。 後の章では、特にブラウザーとWebDriver間の競合状態を克服する方法に関する、テストでの断続的な問題を軽減するために使用できる手法に戻ります。\nテストを短くして、代替手段がまったくない場合にのみWebブラウザーを使用することで、不安定さを最小限にして多くのテストを実行できます。\nSeleniumテストの明確な利点は、ユーザーの観点から、バックエンドからフロントエンドまで、アプリケーションのすべてのコンポーネントをテストする固有の機能です。 つまり、機能テストは実行に費用がかかる可能性がありますが、同時にビジネスに不可欠な大規模な部分も含まれます。\nテスト要件 前述のように、Seleniumテストの実行には費用がかかる場合があります。 どの程度までテストを実行しているブラウザーに依存しますが、歴史的にブラウザーの動作は非常に多様であるため、多くの場合、複数のブラウザーに対するクロステストの目標として述べられてきました。\nSeleniumを使用すると、複数のオペレーティングシステム上の複数のブラウザーに対して同じ命令を実行できますが、すべての可能なブラウザー、それらの異なるバージョン、およびそれらが実行される多くのオペレーティングシステムの列挙はすぐに重要な作業になります。\n例から始めましょう ラリーは、ユーザーがカスタムユニコーンを注文できるWebサイトを作成しました。\n一般的なワークフロー（\u0026ldquo;ハッピーパス\u0026quot;と呼ぶ）は次のようなものです。\n アカウントを作成する ユニコーンを設定する ショッピングカートにユニコーンを追加します チェックアウトしてお支払い ユニコーンについてフィードバックを送る  これらのすべての操作を実行するために1つの壮大なSeleniumスクリプトを作成するのは魅力的です。 その誘惑に抵抗しましょう！ そうすると、\na）時間がかかる\nb）ページレンダリングのタイミングの問題に関する一般的な問題が発生する\nc）失敗した場合、簡潔で\u0026quot;一目瞭然\u0026quot;にならない、何がうまくいかなかったかを診断する方法がない\nというテストになります。\nこのシナリオをテストするための好ましい戦略は、一連の独立した迅速なテストに分割することです。 各テストには、1つの\u0026quot;理由\u0026quot;が存在します。\n2番目のステップであるユニコーンの構成をテストしたいと思います。 次のアクションを実行します。\n アカウントを作成する ユニコーンを設定する  これらの手順の残りをスキップしていることに注意してください。 この手順を完了した後、他の小さな個別のテストケースで残りのワークフローをテストします。\n開始するには、アカウントを作成する必要があります。 ここには、いくつかの選択があります。\n 既存のアカウントを使用しますか？ 新しいアカウントを作成しますか？ 設定を開始する前に考慮する必要があるそのようなユーザーの特別なプロパティはありますか？  この質問への回答方法に関係なく、テストの\u0026quot;データのセットアップ\u0026quot;部分の一部にすると解決します。 ラリーが、ユーザー（またはだれでも）がユーザーアカウントを作成および更新できるAPIを公開している場合は、それを使用してこの質問に回答してください。 可能であれば、資格情報を使用してログインできるユーザーが\u0026quot;手元に\u0026quot;いる場合にのみブラウザを起動します。\n各ワークフローの各テストがユーザーアカウントの作成から始まる場合、各テストの実行に何秒も追加されます。 APIの呼び出しとデータベースとの対話は、ブラウザを開いたり、適切なページに移動したり、フォームをクリックして送信されるのを待つなどの高価なプロセスを必要としない、迅速な\u0026quot;ヘッドレス\u0026quot;操作です。\n理想的には、1行のコードでこのセットアップフェーズに対処できます。 これは、ブラウザーが起動する前に実行されます。\nJava Python C# Ruby JavaScript Kotlin // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = user_factory.create_common_user() #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.get_email(), user.get_password())   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.CreateCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = LoginAs(user.Email, user.Password);   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = UserFactory.create_common_user #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.email, user.password)   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. var user = userFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. var accountPage = loginAs(user.email, user.password);   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. val user = UserFactory.createCommonUser() //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     ご想像のとおり、 UserFactory を拡張して createAdminUser() や createUserWithPayment() などのメソッドを提供できます。 重要なのは、これらの2行のコードは、このテストの最終目的であるユニコーンの構成からあなたをそらすものではないということです。\nページオブジェクトモデルの込み入った事柄については、後の章で説明しますが、ここで概念を紹介します。\nテストは、サイトのページのコンテキスト内で、ユーザーの観点から実行されるアクションで構成される必要があります。 これらのページはオブジェクトとして保存され、Webページがどのように構成され、アクションがどのように実行されるかに関する特定の情報が含まれます。\nどんなユニコーンが欲しいですか？ ピンクが必要かもしれませんが、必ずしもそうではありません。 紫は最近非常に人気があります。 彼女はサングラスが必要ですか？ スタータトゥー？ これらの選択は困難ですが、テスターとしての最大の関心事です。 発送センターが適切なユニコーンを適切な人に送信することを確認する必要があります。\nこの段落では、ボタン、フィールド、ドロップダウン、ラジオボタン、またはWebフォームについては説明していません。 また、テストするべきではありません！ ユーザーが問題を解決しようとしているようにコードを書きたいと思います。 これを実行する1つの方法を次に示します（前の例から継続）\nJava Python C# Ruby JavaScript Kotlin // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn() # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.Purple, UnicornAccessories.Sunglasses, UnicornAdornments.StarTattoos); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.AddUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.CreateUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn.new(\u0026#39;Sparkles\u0026#39;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. var sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there.  var addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. var unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. val addUnicornPage = accountPage.addUnicorn() // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     ユニコーンの設定が完了したら、ステップ3に進んで、ユニコーンが実際に機能することを確認する必要があります。\nJava Python C# Ruby JavaScript Kotlin // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles));   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.True(unicornConfirmationPage.Exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. expect(unicorn_confirmation_page.exists?(sparkles)).to be, \u0026#39;Sparkles should have been created, with all attributes intact\u0026#39;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assert(unicornConfirmationPage.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles))     テスターはまだこのコードでユニコーンについて話しているだけです。 ボタンもロケーターもブラウザーコントロールもありません。 ラリーが来週、Ruby-on-Railsが好きではなくなったと判断し、Fortranフロントエンドを使用して最新のHaskellバインディングでサイト全体を再実装することを決めた場合でも、アプリケーションを モデル化する この方法により、これらのテストレベルのコマンドを所定の位置に変えずに維持できます。\nページオブジェクトは、サイトの再設計に準拠するために若干のメンテナンスが必要になりますが、これらのテストは同じままです。 この基本的な設計を採用することで、可能な限りブラウザに面した最小限の手順でワークフローを進めていきたいと思うでしょう。 次のワークフローでは、ユニコーンをショッピングカートに追加します。 カートの状態が適切に維持されていることを確認するために、おそらくこのテストを何度も繰り返す必要があります。 開始する前に、カートに複数のユニコーンがありますか？ ショッピングカートには何個収容できますか？ 同じ名前や機能で複数作成すると、壊れますか？ 既存のものを保持するだけですか、それとも別のものを追加しますか？\nワークフローを移動するたびに、アカウントを作成し、ユーザーとしてログインし、ユニコーンを設定する必要を避けたいと考えています。 理想的には、APIまたはデータベースを介してアカウントを作成し、ユニコーンを事前設定できるようになります。 その後、ユーザーとしてログインし、きらめきを見つけてカートに追加するだけです。\n自動化するかしないか 自動化は常に有利ですか？ テストケースの自動化をいつ決定する必要がありますか？\nテストケースを自動化することは必ずしも有利ではありません。 手動テストがより適切な場合があります。 たとえば、近い将来にアプリケーションのユーザーインターフェースが大幅に変更される場合は、自動化を書き換える必要があるかもしれません。 また、テストの自動化を構築する時間が足りない場合もあります。 短期的には、手動テストの方が効果的です。 アプリケーションの期限が非常に厳しい場合、現在利用できるテストの自動化はなく、その期間内にテストを実施することが不可欠です。 手動テストが最適なソリューションです。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/domain_specific_language/",
	"title": "ドメイン固有言語（DSL）",
	"tags": [],
	"description": "",
	"content": "ドメイン固有言語（DSL）は、問題を解決するための表現手段をユーザーに提供するシステムです。 それによって、ユーザーは、プログラマーの言葉でなく、自分の言葉でシステムとやりとりすることができます。\n通常、ユーザーはサイトの外観を気にしません。 装飾、アニメーション、グラフィックスは気にしません。 彼らはあなたのシステムを使用して、新しい従業員を最小限の難しさでプロセスに押し込みたいと考えています。 彼らはアラスカへの旅行を予約したい。 ユニコーンを設定して割引価格で購入したいのです。 テスターとしてのあなたの仕事は、この考え方を\u0026quot;とらえる\u0026quot;ことにできるだけ近づくことです。 それを念頭に置いて、テストスクリプト（ユーザーの唯一のプレリリースの代理人）がユーザーを\u0026quot;代弁し\u0026rdquo;、表現するように、作業中のアプリケーションの\u0026quot;モデリング\u0026quot;に取り掛かります。\nSeleniumでは、DSLは通常、APIをシンプルで読みやすいように記述したメソッドで表されます。 開発者と利害関係者（ユーザー、製品所有者、ビジネスインテリジェンススペシャリストなど）との伝達が可能になります。\n利点  Readable: ビジネス関係者はそれを理解できます。 Writable: 書きやすく、不要な重複を避けます。 Extensible: 機能は（合理的に）契約と既存の機能を壊すことなく追加できます。 Maintainable: 実装の詳細をテストケースから除外することにより、AUT* の変更に対して十分に隔離されます。  Java Javaの妥当なDSLメソッドの例を次に示します。 簡潔にするために、driverオブジェクトが事前に定義されており、メソッドで使用可能であることを前提としています。\n/** * Takes a username and password, fills out the fields, and clicks \u0026#34;login\u0026#34;. * @return An instance of the AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Fill out the password field. The locator we\u0026#39;re using is \u0026#34;By.id\u0026#34;, and we should  // have it defined elsewhere in the class.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Click the login button, which happens to have the id \u0026#34;submit\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Create and return a new instance of the AccountPage (via the built-in Selenium  // PageFactory).  return PageFactory.newInstance(AccountPage.class); } このメソッドは、テストコードから入力フィールド、ボタン、クリック、さらにはページの概念を完全に抽象化します。 このアプローチを使用すると、テスターはこのメソッドを呼び出すだけで済みます。 これにより、メンテナンスの利点が得られます。 ログインフィールドが変更された場合、テストではなく、このメソッドを変更するだけで済みます。\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Now that we\u0026#39;re logged in, do some other stuff--since we used a DSL to support  // our testers, it\u0026#39;s as easy as choosing from available methods.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Something should have been done!\u0026#34;, something.wasDone()); // Note that we still haven\u0026#39;t referred to a button or web control anywhere in this  // script... } 繰り返しになります。 主な目標の1つは、 テストが UIの問題ではなく、手元の問題 に対処できるAPIを作成することです。 UIはユーザーにとって二次的な関心事です。ユーザーはUIを気にせず、ただ仕事をやりたいだけです。 テストスクリプトは、ユーザーがやりたいことと知りたいことの長々としたリストのように読む必要があります。 テストでは、UIがどのようにそれを実行するように要求するかについて、気にするべきではありません。\n*AUT: Application under test（テスト対象アプリケーション）\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/driver_idiosyncrasies/driver_specific_capabilities/",
	"title": "ドライバー固有の機能",
	"tags": [],
	"description": "",
	"content": "Firefox FirefoxOptions を使用してCapabilitiesを定義する FirefoxOptions は、Firefoxブラウザの機能を定義する新しい方法であり、通常はDesiredCapabilitiesよりも優先して使用する必要があります。\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   require \u0026#39;selenium-webdriver\u0026#39; opts = Selenium::WebDriver::Firefox::Options.new(args: [\u0026#39;-headless\u0026#39;]) driver = Selenium::WebDriver.for(:firefox, options: opts)   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.headless(); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     カスタムプロファイルを設定する 以下に示すように、Firefoxのカスタムプロファイルを作成することができます。\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   profile = Selenium::WebDriver::Firefox::Profile.new profile[\u0026#39;browser.download.dir\u0026#39;] = \u0026#34;/tmp/webdriver-downloads\u0026#34; options = Selenium::WebDriver::Firefox::Options.new(profile: profile) driver = Selenium::WebDriver.for :firefox, options: options   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); let profile = \u0026#39;/path to custom profile\u0026#39;; options.setProfile(profile); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer fileUploadDialogTimeout 環境によっては、ファイルアップロードダイアログを開くときにInternet Explorerがタイムアウトする場合があります。 IEDriverのデフォルトのタイムアウトは1000ミリ秒ですが、fileUploadDialogTimeout capabilityを使用してタイムアウトを増やすことができます。\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.waitForUploadDialogUpTo(Duration.ofSeconds(2)); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.file_upload_dialog_timeout = 2000 driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.file_upload_dialog_timeout = 2000 driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().fileUploadDialogTimeout(2000); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.waitForUploadDialogUpTo(Duration.ofSeconds(2)) val driver = RemoteWebDriver(options)     ensureCleanSession この機能を true に設定すると、手動またはドライバーによって開始されたものを含め、 InternetExplorerの実行中のすべてのインスタンスのキャッシュ、ブラウザー履歴、およびCookieがクリアされます。 デフォルトでは、false に設定されています。\nこの機能を使用すると、ドライバーがIEブラウザーを起動する前にキャッシュがクリアされるまで待機するため、 ブラウザーの起動中にパフォーマンスが低下します。\nこのケイパビリティは、ブール値をパラメーターとして受け入れます。\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.destructivelyEnsureCleanSession(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ensure_clean_session = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.EnsureCleanSession = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ensure_clean_session = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ensureCleanSession(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.destructivelyEnsureCleanSession() val driver = RemoteWebDriver(options)     ignoreZoomSetting InternetExplorerドライバーは、ブラウザーのズームレベルが100％であることを想定しています。 それ以外の場合、ドライバーは例外をスローします。 このデフォルトの動作は、 ignoreZoomSetting を true に設定することで無効にできます。\nこのケイパビリティは、ブール値をパラメーターとして受け入れます。\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.ignoreZoomSettings(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_zoom_level = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IgnoreZoomLevel = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_zoom_level = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ignoreZoomSetting(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.ignoreZoomSettings() val driver = RemoteWebDriver(options)     ignoreProtectedModeSettings 新しいIEセッションの起動中に 保護モード チェックをスキップするかどうか。\n設定されておらず、 保護モード 設定がすべてのゾーンで同じでない場合、 ドライバーによって例外がスローされます。\nケイパビリティを true に設定すると、テストが不安定になったり、応答しなくなったり、 ブラウザがハングしたりする場合があります。 ただし、これはまだ2番目に良い選択であり、最初の選択は 常に 各ゾーンの保護モード設定を手動で実際に設定することです。 ユーザーがこのプロパティを使用している場合、「ベストエフォート」のみがサポートされます。\nこのケイパビリティは、ブール値をパラメーターとして受け入れます。\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.introduceFlakinessByIgnoringSecurityDomains(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_protected_mode_settings = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IntroduceInstabilityByIgnoringProtectedModeSettings = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_protected_mode_settings = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().introduceFlakinessByIgnoringProtectedModeSettings(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.introduceFlakinessByIgnoringSecurityDomains() val driver = RemoteWebDriver(options)     silent true に設定すると、このケイパビリティはIEDriverServerの診断出力を抑制します。\nこのケイパビリティは、ブール値をパラメーターとして受け入れます。\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.setCapability(\u0026#34;silent\u0026#34;, true); WebDriver driver = new InternetExplorerDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.set_capability(\u0026#34;silent\u0026#34;, True) driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   InternetExplorerOptions options = new InternetExplorerOptions(); options.AddAdditionalInternetExplorerOption(\u0026#34;silent\u0026#34;, true); IWebDriver driver = new InternetExplorerDriver(options);   # Please raise a PR to add code sample   const {Builder,By, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); let caps = Capabilities.ie(); caps.set(\u0026#39;silent\u0026#39;, true); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;internet explorer\u0026#39;) .withCapabilities(caps) .build(); try { await driver.get(\u0026#39;http://www.google.com/ncr\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.setCapability(\u0026#34;silent\u0026#34;, true) val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     IE Command-Line Options Internet Explorerには、ブラウザーのトラブルシューティングと構成を可能にするいくつかのコマンドラインオプションが含まれています。\n次に、サポートされているいくつかのコマンドラインオプションについて説明します。\n  -private : IEをプライベートブラウジングモードで起動するために使用されます。 これはIE 8以降のバージョンで機能します。\n  -k : Internet Explorerをキオスクモードで起動します。 ブラウザは、アドレスバー、ナビゲーションボタン、またはステータスバーを表示しない最大化されたウィンドウで開きます。\n  -extoff : アドオンなしモードでIEを起動します。 このオプションは、ブラウザーのアドオンに関する問題のトラブルシューティングに特に使用されます。 IE 7以降のバージョンで動作します。\n  注：コマンドライン引数が機能するためには、 forceCreateProcessApi を順番に有効にする必要があります。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.add_argument(\u0026#39;-private\u0026#39;) options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; options.BrowserCommandLineArguments = \u0026#34;-k\u0026#34;; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true options.add_argument(\u0026#39;-k\u0026#39;) driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.addBrowserCommandSwitches(\u0026#39;-k\u0026#39;); options.addBrowserCommandSwitches(\u0026#39;-private\u0026#39;); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps); } finally { driver.quit(); } }     forceCreateProcessApi CreateProcess APIを使用してInternet Explorerを強制的に起動します。 デフォルト値はfalseです。\nIE 8以降の場合、このオプションでは \u0026ldquo;TabProcGrowth\u0026rdquo; レジストリの値を0に設定する必要があります。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps) } finally { driver.quit(); } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/driver_requirements/",
	"title": "ドライバー要件",
	"tags": [],
	"description": "",
	"content": "SeleniumはWebDriverを経由して、Chrom(ium)、Firefox、Internet Explorer、Opera、Safariなど、市場のすべての主要なブラウザーをサポートします。 すべてのブラウザーがリモートコントロールを公式にサポートしているわけではありませんが、可能であれば、ブラウザーの自動化のビルトインサポートを使用して、WebDriverはブラウザーを動かします。\nWebDriverの目的は、できるだけブラウザーに近づけて実際のユーザーのインタラクションを模倣することです。 これは、ブラウザーによって異なる水準となる可能性があります。 さまざまなドライバーの特異性の詳細については、 ドライバーの特異性 をご覧ください。\nブラウザーを制御するためすべてのドライバーが単一のユーザー向けインターフェイスを共有している場合でも、 ブラウザーのセッションを設定する方法が少し異なります。 ドライバーの実装の多くはサードパーティによって提供されているため、 標準のSeleniumディストリビューションには含まれていません。\nドライバーのインスタンス化、プロファイル管理、およびブラウザー固有のさまざまな設定は、ブラウザーに応じて異なる要件を持つパラメーターの例です。 このセクションでは、さまざまなブラウザーを使い始めるための基本的な要件について説明します。\n実行可能ファイルをパスに追加する ほとんどのドライバーでは、ブラウザーと通信するためにSeleniumの追加の実行可能ファイルが必要です。 WebDriverを起動する前に実行可能ファイルの場所を手動で指定できますが、これによりテストの移植性が低下します。 実行可能ファイルはすべてのマシンの同じ場所にあるか、テストコードリポジトリに含まれている必要があるためです。\nWebDriverのバイナリを含むフォルダーをシステムのパスに追加することで、Seleniumはドライバーの正確な場所を見つけるためにテストコードを要求することなく、追加のバイナリを見つけることができます。\n 実行可能ファイルを配置するディレクトリをこのように作成します。 C:\\WebDriver\\bin or /opt/WebDriver/bin PATHにディレクトリを追加します。  Windows - 管理者権限でコマンドプロンプトを開いて 次のコマンドを実行して、マシン上のすべてのユーザー向けにディレクトリをPATHに永続的に追加します。    setx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34;  macOS、Linux で bashを使う場合は、terminalを開いて次のコマンドを実行します。  export PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile   これで、変更をテストする準備ができました。 開いているすべてのコマンドプロンプトを閉じて、新しいプロンプトを開きます。 前の手順で作成したフォルダー内のバイナリのいずれかの名前を入力します。例：\nchromedriver   PATHが正しく設定されている場合、ドライバーの起動に関連する出力が表示されます。\n  Starting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed. Ctrl + Cを押すと、コマンドプロンプトの制御を取り戻すことができます。\nクイックリファレンス    ブラウザー サポートOS メンテナ ダウンロード イシュートラッカー     Chromium/Chrome Windows/macOS/Linux Google ダウンロード イシュートラッカー   Firefox Windows/macOS/Linux Mozilla ダウンロード イシュートラッカー   Edge Windows 10 Microsoft ダウンロード イシュートラッカー   Internet Explorer Windows Selenium Project ダウンロード イシュートラッカー   Safari macOS El Capitan and newer Apple ビルトイン イシュートラッカー   Opera Windows/macOS/Linux Opera ダウンロード イシュートラッカー    Chromium/Chrome Chrome または Chromium を動かす場合、chromedriver をダウンロードして、システムパスのフォルダに置いてください。\nLinuxまたはmacOSでは、これは PATH 環境変数を変更することを意味します。 次のコマンドを実行すると、コロンで区切られたディレクトリがシステムのパスを構成していることがわかります。\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin まだパスを追加していない場合にchromedriverをパスに含めるには、chromedriverバイナリの親ディレクトリを必ず含めてください。 次の行は、 PATH 環境変数の現在のコンテンツに加えて、コロンの後に追加のパスを設定します。\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; パス上でchromedriverが使用可能な場合、任意のディレクトリから_chromedriver_実行可能ファイルを実行できるはずです。\nChrome / Chromiumセッションをインスタンス化するには、次のとおり。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Simple assignment from selenium.webdriver import Chrome driver = Chrome() #Or use the context manager from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     chromedriver実行可能ファイルへのパスを設定する必要があることに注意してください。 これは、次の行を使えば可能です。\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     chromedriverは、Chromeの内部自動化プロキシインターフェイスを公開することにより、ブラウザーに処理を指示するWebDriverリモートサーバーとして実装されています。\nFirefox Selenium 3以降、MozillaはFirefoxドライバーの実装である geckodriver を引き継ぎました。 Firefox用の新しいドライバーはgeckodriverと呼ばれ、Firefox 48以降で動作します。 Firefox WebDriverは開発中であるため、Firefoxバージョンが新しいほどサポートが向上します。\ngeckodriverはFirefoxを起動する新しいデフォルトの方法であるため、 Selenium 2と同じ方法でFirefoxをインスタンス化できます。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Simple assignment from selenium.webdriver import Firefox driver = Firefox() #Or use the context manager from selenium.webdriver import Firefox with Firefox() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     PATHを使用してgeckodriverの場所を設定しない場合は、 geckodriverバイナリの場所をプログラムで設定します。\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.setBinary(\u0026#34;/path/to/geckodriver\u0026#34;);   System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     実行時にプロパティを設定することも可能です。\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver Firefox 47.0.1 または 45 ESR をインストール、および marionette の必要な機能を false として指定することにより、多くの機能が完了した古いFirefoxドライバーに戻すことが可能です。 以降のFirefoxのリリースには互換性がありません。\nEdge Edgeは、Microsoftの最新のブラウザーで、Windows 10およびServer 2016に含まれています。 Edgeの更新は、主要なWindowsUpdateプログラムにバンドルされているため、現在インストールされているWindowsビルドのビルド番号に一致するバイナリをダウンロードする必要があります。 Edge Developer サイトには、利用可能なすべてのバイナリへのリンクが含まれています。 EdgeDriverの実装に対するバグは、Microsoftに起票する可能性があります。 Edgeに対してテストを実行したいがWindows 10を実行していない場合、MicrosoftはEdge Edge Developer サイトでテスター向けに無料のVMを提供しています。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Simple assignment from selenium.webdriver import Edge driver = Edge() #Or use the context manager from selenium.webdriver import Edge with Edge() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     Edgeドライバーがパスに存在しない場合、次の行を使用してパスを設定できます。\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const edge = require(\u0026#39;selenium-webdriver/edge\u0026#39;); let service = new edge.ServiceBuilder(\u0026#34;/path/to/msedgedriver.exe\u0026#34;); (async function test() { let driver = await new Builder() .setEdgeService(service) .forBrowser(\u0026#39;MicrosoftEdge\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     Internet Explorer Internet Explorerは、Windows 10まではMicrosoftのデフォルトのブラウザーでしたが、Windows 10にはまだ含まれています。 Internet ExplorerドライバーはSeleniumプロジェクトは、同じリリースのMicrosoftの現在の考慮をサポートすることを目指す唯一のドライバーです。 古いリリースは動作する可能性がありますが、サポートされません。\nSeleniumプロジェクトはInternet Explorerの32ビット版と64ビット版の両方のバイナリを提供しますが、64ビットドライバーを使用するInternet Explorer 10および11にはいくつかの制限がありますが、32ビットドライバーの使うことでうまく機能します。 ログインしたユーザーのアカウントに対してInternet Explorerの設定が保存されるため、追加の設定が必要になることに注意してください。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Simple assignment from selenium.webdriver import Ie driver = Ie() #Or use the context manager from selenium.webdriver import Ie with Ie() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     Internet Explorerドライバーがパスに存在しない場合、次の行を使用してパスを設定できます。\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let service = new ie.ServiceBuilder(\u0026#34;/path/to/IEDriverServer.exe\u0026#34;); (async function test() { let driver = await new Builder() .setIeService(service) .forBrowser(\u0026#39;internet explorer\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     Microsoftは、Internet Explorer 11 on Windows 7 \u0026amp; 8.1上のInternet Explorer 11用のWebDriverバイナリも提供しています。 2014年以降更新されておらず、W3仕様のドラフトバージョンに基づいています。 ジム エバンスは、Microsoftの実装に関する優れた記事を持っています。\nOpera Operaの現在のリリースはChromiumエンジンの上に構築されており、WebDriverはPATHに追加したりシステムプロパティとして追加したりできるクローズドソースのOpera Chromium Driverを介してサポートされるようになりました。\nドライバーセッションのインスタンス化は、FirefoxとChromiumに似ています。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Simple assignment from selenium.webdriver import Opera driver = Opera() #Or use the context manager from selenium.webdriver import Opera with Opera() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const opera = require(\u0026#39;selenium-webdriver/opera\u0026#39;); (async function test() { let driver = await new Builder() .forBrowser(\u0026#39;opera\u0026#39;) .build(); })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari High Sierra 以降 :\n まず端末から次のコマンドを実行し、プロンプトでパスワードを入力してWebDriverを認証します  safaridriver --enable El Capitan と Sierra :\n Safariの設定から開発メニューを有効にします 開発メニューから リモート オートメーションを許可 オプションをオンにします まずターミナルから次のコマンドを実行し、プロンプトでパスワードを入力してWebDriverを認証します  /usr/bin/safaridriver -p 1337\u0026lt;/ その後、次を使用してドライバーセッションを開始できます。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Simple assignment from selenium.webdriver import Safari driver = Safari() #Or use the context manager from selenium.webdriver import Safari with Safari() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     iOSでSafariを自動化する場合は、Appium projectをご覧ください。 Safariは以前はWindowsで利用可能でしたが、Appleは長い間サポートを終了しており、テストプラットフォームの選択肢としては不適切です。\nモック ブラウザー HtmlUnit HtmlUnitは \u0026ldquo;Javaプログラム用のGUIレスブラウザー\u0026rdquo; です。 HTMLドキュメントをモデル化し、ページの呼び出し、フォームへの入力、リンクのクリックなどを可能にするAPIを提供します。 JavaScriptをサポートしており、AJAXライブラリを使用して、使用する設定に応じてChrome、Firefox、またはInternet Explorerをシミュレートできます。 新しい場所に移動しました。 ソースはsvnで管理されています。\nPhantomJS PhantomJSは、Google ChromeまたはSafariで使用されているバージョンよりもはるかに古いバージョンですが、Webkitベースのヘッドレスブラウザーです。 歴史的に人気のある選択肢でしたが、今ではPhantomJSを避ける​​のが賢明です。 プロジェクトは8月5日以降メンテナンスされていないため、Webの変更は継続されますが、PhantomJSは更新されません。これは、GoogleがChromeをヘッドレスで実行する機能を発表した後のことで、MozillaのFirefoxでも提供されています。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/worst_practices/file_downloads/",
	"title": "ファイルダウンロード",
	"tags": [],
	"description": "",
	"content": "Seleniumの管理下にあるブラウザーでリンクをクリックしてダウンロードを開始することは可能ですが、APIはダウンロードの進行状況を公開しないため、ダウンロードしたファイルのテストには理想的ではありません。 これは、ファイルのダウンロードは、Webプラットフォームとのユーザーインタラクションをエミュレートする重要な側面とは見なされないためです。 代わりに、Selenium（および必要なCookie）を使用してリンクを見つけ、 libcurl などのHTTPリクエストライブラリに渡します。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/remote_webdriver/remote_webdriver_client/",
	"title": "リモートWebDriverクライアント",
	"tags": [],
	"description": "",
	"content": "リモートWebDriverクライアントを実行するには、まずRemoteWebDriverに接続する必要があります。 これを行うには、テストを実行しているサーバーのアドレスをURLに指定します。 設定をカスタマイズするために、desired capabilitiesを設定します。 以下は、Firefoxでテストを実行しているリモートWebサーバー www.example.com を指定してリモートWebDriverオブジェクトをインスタンス化する例です。\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver firefox_options = webdriver.FirefoxOptions() driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=firefox_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); var capabilities = Capabilities.firefox(); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     テスト設定をさらにカスタマイズするために、他のdesired capabilitiesを追加できます。\nブラウザーオプション 例えば、Chromeバージョン67を使用して、Windows XPでChromeを実行する場合は、このようになるかと思います。\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.set_capability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chrome_options.set_capability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=chrome_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var chromeOptions = new ChromeOptions(); chromeOptions.BrowserVersion = \u0026#34;67\u0026#34;; chromeOptions.PlatformName = \u0026#34;Windows XP\u0026#34;; IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); const chrome = require(\u0026#34;selenium-webdriver/chrome\u0026#34;) var capabilities = Capabilities.chrome(); //To avoid InsecureCertificateError for selenium4-aplha5 capabilities.setAcceptInsecureCerts(true); capabilities.set(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); capabilities.set(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit();     ローカルファイルDetector ローカルファイルDetectorを使用すると、クライアントマシンからリモートサーバーにファイルを転送できます。 例えば、テストでファイルをWebアプリケーションにアップロードする必要がある場合、リモートWebDriverは実行時にローカルマシンからリモートWebサーバーにファイルを自動的に転送できます。 これにより、テストを実行しているリモートマシンからファイルをアップロードできます。 デフォルトでは有効になっておらず、次の方法で有効にできます。\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   from selenium.webdriver.remote.file_detector import LocalFileDetector driver.file_detector = LocalFileDetector()   var allowsDetection = this.driver as IAllowsFileDetection; if (allowsDetection != null) { allowsDetection.FileDetector = new LocalFileDetector(); }   @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   var remote = require(\u0026#39;selenium-webdriver/remote\u0026#39;); driver.setFileDetector(new remote.FileDetector);   driver.fileDetector = LocalFileDetector()     上記のコードを定義したら、次の方法でテストにファイルをアップロードできます。\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) driver.find_element(By.ID, \u0026#34;myfile\u0026#34;).send_keys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)   driver.Navigate().GoToUrl(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); IWebElement upload = driver.FindElement(By.Id(\u0026#34;myfile\u0026#34;)); upload.SendKeys(@\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); var upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/introduction/",
	"title": "紹介",
	"tags": [],
	"description": "",
	"content": "紹介 Seleniumはブラウザー自動化を可能にし、それを支えるツール群とライブラリー群のプロジェクトです。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/support_packages/working_with_colours/",
	"title": "色を扱う",
	"tags": [],
	"description": "",
	"content": "テストの一部として何かの色を検証したい場合があります。 問題は、ウェブ上の色の定義が一定ではないことです。 色のHEX表現を色のRGB表現と比較する簡単な方法、または色のRGBA表現を色のHSLA表現と比較する簡単な方法があったらいいのではないでしょうか？\n心配しないでください。解決策があります。: Color クラスです！\nまず、クラスをインポートする必要があります。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.Color    これで、カラーオブジェクトの作成を開始できます。 すべての色オブジェクトは、色の文字列表現から作成する必要があります。 サポートされている色表現は、以下のとおりです。\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     Colorクラスは、 http://www.w3.org/TR/css3-color/#html4 で指定されているすべての基本色定義もサポートしています。\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     要素に色が設定されていない場合、ブラウザは \u0026ldquo;透明\u0026rdquo; の色の値を返すことがあります。 Colorクラスもこれをサポートしています。\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     レスポンスが正しく解析され、有効なColorオブジェクトに変換されることを認識して、要素を安全にクエリしてその色/背景色を取得できるようになりました。\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)); Color loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;));   login_button_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;))   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    login_button_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;))   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)) val loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;))     そして、色オブジェクトを直接比較できます。\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour == HOTPINK)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.equals(HOTPINK))     または、色を次の形式のいずれかに変換し、静的に検証することができます。\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     色はもはや問題ではありません。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/front_matter/typographical_conventions/",
	"title": "表記規則",
	"tags": [],
	"description": "",
	"content": "タイトルの大文字化 A Very Fine Heading などのタイトルの大文字化は避け、代わりに A very fine heading を選択してください。 大げさな大文字表記、またはタイトルケースは、多くの場合、正書法の慣習に対する誤解または無視を示します。 ヘッダーを開始するための最初の大文字を1つ持つセンテンスケースとして知られているものを好みます。\n行の長さ プレーンHTMLで記述されたドキュメントのソースを編集するときは、行の長さを約72文字に制限してください。\nこれをさらに一歩進めて、いわゆるセマンティックラインフィード と呼ばれるものを使用します。 これは、一般の人には読まれないHTMLソース行を散文の「自然な区切り」で分割する手法です。 つまり、文は句間の自然な区切りで分割されます。 すべての段落が右マージンの近くで終了するように各段落の行を混乱させるのではなく、 アイデアが途切れる場所であればどこでも改行を追加できます。\nこれにより、gitを使用して共同作業するときにdiffを非常に読みやすくすることができますが、 使用するコントリビューターに強制するものではありません。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/legacy_docs/html-runner/",
	"title": "HTMLランナー",
	"tags": [],
	"description": "",
	"content": "Selenium HTMLランナー を使用すると、コマンドラインからテストスイートを実行できます。 テストスイートは、Selenium IDEまたは互換性ツールからのHTMLエクスポートです。\n共通情報  geckodriver / firefox / selenium-html-runnerのリリースの組み合わせが重要です。 どこかにソフトウェア互換性マトリックスがあるかもしれません。 selenium-html-runnerはテストスイートのみを実行します（テストケースではなく、Monitis Transaction Monitorからのエクスポートなど）。 必ずこれを順守してください。 DISPLAYのないLinuxユーザーの場合-仮想ディスプレイでhtml-runnerを起動する必要があります（xvfbを検索）。  Linux環境の例 次のソフトウェアパッケージをインストール/ダウンロードします。\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 テストスイートの例\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;YOUR-TEST-SCENARIO\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; selenium-html-runnerをヘッドレスで実行する方法 さて、最も重要な部分、selenium-html-runnerの実行方法の例！ 経験によってソフトウェアの組み合わせ、- geckodriver / FF / html-runnerリリースによって異なる場合があります。\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html [user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/worst_practices/http_response_codes/",
	"title": "HTTPレスポンスコード",
	"tags": [],
	"description": "",
	"content": "Selenium RCの一部のブラウザー構成では、Seleniumはブラウザーと自動化されているサイトの間のプロキシとして機能しました。 これは、Seleniumを通過したすべてのブラウザートラフィックをキャプチャまたは操作できることを意味していました。 captureNetworkTraffic() メソッドは、HTTPレスポンスコードを含むブラウザーと自動化されているサイト間のすべてのネットワークトラフィックをキャプチャすることを目的としています。\nSelenium WebDriverは、ブラウザーの自動化に対するまったく異なるアプローチであり、ユーザーのように振る舞うことを好むため、WebDriverを使用してテストを記述する方法で表現します。 自動化された機能テストでは、ステータスコードの確認はテストの失敗の特に重要な詳細ではありません。 それに先行する手順がより重要です。\nブラウザーは常にHTTPステータスコードを表します。たとえば、404または500エラーページを想像してください。 これらのエラーページの1つに遭遇したときに\u0026quot;早く失敗\u0026quot;する簡単な方法は、ページが読み込まれるたびにページタイトルまたは信頼できるポイント（たとえば \u0026lt;h1\u0026gt; タグ）のコンテンツをチェックすることです。 ページオブジェクトモデルを使用している場合、このチェックをクラスコンストラクターまたはページの読み込みが予想される同様のポイントに含めることができます。 場合によっては、HTTPコードがブラウザーのエラーページに表示されることもあります。 WebDriverを使用してこれを読み取り、デバッグ出力を改善できます。\nWebページ自体を確認することは、WebDriverの理想的なプラクティスに沿っており、WebDriverのユーザーのWebサイトの見え方を表現し、主張します。\nHTTPステータスコードをキャプチャするための高度なソリューションは、プロキシを使用してSelenium RCの動作を複製することです。 WebDriver APIは、ブラウザーのプロキシを設定する機能を提供します。 Webサーバーとの間で送受信されるリクエストのコンテンツをプログラムで操作できるプロキシがいくつかあります。 プロキシを使用すると、リダイレクトレスポンスコードへの応答方法を決めることができます。 さらに、すべてのブラウザーがWebDriverでレスポンスコードを利用できるようにするわけではないため、プロキシを使用することを選択すると、すべてのブラウザーで機能するソリューションが得られます。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/selenium_installation/",
	"title": "Seleniumのインストール",
	"tags": [],
	"description": "",
	"content": "Seleniumのインストール Seleniumのセットアップは他の商用ツールと少し違います。自動化プロジェクトでSeleniumを使うためには、選択した言語の言語バインディングライブラリをインストールする必要があります。加えて、自動化でテストを実行したいブラウザのWebDriverバイナリも必要となります。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/generating_application_state/",
	"title": "アプリケーション状態の生成",
	"tags": [],
	"description": "",
	"content": "Seleniumはテストケースの準備に使用しないでください。 テストケースのすべての反復アクションと準備は、他の方法で行う必要があります。 たとえば、ほとんどのWeb UIには認証があります（ログインフォームなど）。 すべてのテストの前にWebブラウザーからのログインをなくすことで、テストの速度と安定性の両方が向上します。 AUT* にアクセスするためのメソッドを作成する必要があります（APIを使用してログインし、Cookieを設定するなど）。 また、テスト用にデータをプリロードするメソッドの作成は、Seleniumを使用して実行しないほうがいいです。 前述のように、AUT* のデータを作成するには、既存のAPIを活用する必要があります。\n*AUT: Application under test（テスト対象アプリケーション）\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/selenium_installation/installing_standalone_server/",
	"title": "スタンドアロンサーバのインストール",
	"tags": [],
	"description": "",
	"content": "Gridを使う予定なら、selenium-server-standalone JARファイルをダウンロードする必要があります。selenium-server-standalone jarは決してアップロードされることはありませんが、selenium-serverを通して全てのコンポーネントが利用可能です。 このスタンドアロンJARはリモートSeleniumサーバとクライアントサイドバインディングを含む全てが入っています。 これはプロジェクトでselenium-server-standalone jarを使えば、selenium-javaやブラウザ固有のjarを追加しなくても良いということです。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/introduction/types_of_testing/",
	"title": "テストの種類",
	"tags": [],
	"description": "",
	"content": "受け入れテスト このタイプのテストは、機能またはシステムが顧客の期待と要件を満たしているかどうかを判断するために行われます。 このタイプのテストには通常、顧客の協力またはフィードバックが関与します。 下記質問に答えることで確認することができます。\n 正しい 製品を作っていますか？\n Webアプリケーションの場合、ユーザーの予想される動作をシミュレートすることで、 このテストの自動化をSeleniumで直接実行できます。 このシミュレーションは、このドキュメントで説明されているように、記録/再生によって、 またはサポートされているさまざまな言語によって実行できます。 注：受け入れテストは 機能テスト のサブタイプであり、一部の人はこれにも言及する場合があります。\n機能テスト このタイプのテストは、機能またはシステムが問題なく正常に機能するかどうかを判断するために行われます。 システムをさまざまなレベルでチェックして、すべてのシナリオがカバーされていること、 およびシステムが実行すべきことを実行していることを確認します。 下記質問に答えることで確認することができます。\n 製品を 正しく 作っていますか？\n これは通常以下を含みます。 テストがエラーなし（404、例外\u0026hellip;）、使用可能な方法（正しいリダイレクト）で機能する、 利用しやすく、仕様に一致します（上記の 受け入れテスト を参照）。\nWebアプリケーションの場合、期待されるリターンをシミュレートすることにより、このテストの自動化をSeleniumで直接実行できます。 このシミュレーションは、このドキュメントで説明されているように、記録/再生またはサポートされているさまざまな言語で実行できます。\nパフォーマンステスト その名前が示すように、パフォーマンステストは、アプリケーションのパフォーマンスを測定するために行われます。\nパフォーマンステストには2つの主なサブタイプがあります。\nロードテスト ロードテストは、定義されたさまざまな負荷（通常、特定の数のユーザーが同時に接続されている場合）でアプリケーションがどの程度機能するかを確認するために行われます。\nストレステスト ストレステストは、ストレス下（またはサポートされている最大負荷以上）でアプリケーションがどの程度機能するかを確認するために行われます。\n一般に、パフォーマンステストは、Seleniumで書かれたテストを実行して、さまざまなユーザーがWebアプリの特定の機能を押して、意味のある測定値を取得することをシミュレートして実行されます。\nこれは通常、メトリックを取得する他のツールによって行われます。 そのようなツールの1つが JMeter です。\nWebアプリケーションの場合、測定する詳細には、スループット、待ち時間、データ損失、個々のコンポーネントの読み込み時間などが含まれます…\n注1：すべてのブラウザには、開発者のツールセクションにパフォーマンスタブがあります（F12キーを押すとアクセス可能）\n注2：これは一般に機能/機能ごとではなくシステムごとに測定されるため、 非機能テスト のサブタイプです。\n回帰テスト このテストは通常、変更、修正、または機能の追加後に行われます。\n変更によって既存の機能が破壊されないようにするために、すでに実行されたいくつかのテストが再度実行されます。\n再実行されるテストのセットは、完全または部分的なものにすることができ、アプリケーションおよび開発チームに応じて、いくつかの異なるタイプを含めることができます。\nテスト駆動開発 (TDD) テストタイプそのものではなく、TDDはテストが機能の設計を推進する反復的な開発方法論です。\n各サイクルは、機能がパスする単体テストのセットを作成することから始まります（最初に実行すると失敗します）。\nこの後、テストに合格するための開発が行われます。 別のサイクルを開始してテストが再度実行され、すべてのテストに合格するまでこのプロセスが続行されます。\nこれは、欠陥が発見されるほどコストが安くなるという事実に基づいて、アプリケーションの開発をスピードアップすることを目的としています。\nビヘイビア駆動開発 (BDD) BDDは、上記に基づいた反復開発方法論（TDD）でもあり、その目的は、アプリケーションの開発にすべての関係者を関与させることです。\n各サイクルは、いくつかの仕様を作成することから始まります（これは失敗するはずです）。 次に、失敗する単体テスト（これも失敗するはずです）を作成し、開発を作成します。\nこのサイクルは、すべてのタイプのテストに合格するまで繰り返されます。\nそのためには、仕様言語が使用されます。 すべての関係者が理解でき、単純で、標準的かつ明示的でなければなりません。 ほとんどのツールは、この言語として Gherkin を使用します。\n目標は、潜在的な受入エラーも対象とすることでTDDよりも多くのエラーを検出し、当事者間のコミュニケーションを円滑にすることです。\n現在、仕様を記述し、 Cucumber や SpecFlow などのコード関数と一致させるための一連のツールが利用可能です。\nSelenium上に一連のツールが構築されており、BDD仕様を実行可能コードに直接変換することにより、このプロセスをさらに高速化しています。 これらのいくつかは、 JBehave、Capybara、およびRobot Framework です。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/browser_manipulation/",
	"title": "ブラウザー操作",
	"tags": [],
	"description": "",
	"content": "Ruby RubyはWindowsにデフォルトではインストールされません。最新バージョンをダウンロードし、インストーラーを実行します。 Installation Destination and Optional Tasks 画面で Add Ruby executables to your PATH チェックボックス以外のすべての設定をデフォルト値のままにすることができます。ブラウザーを操作するには、selenium-webdriver Ruby gemをインストールする必要があります。それをインストールするには、コマンドプロンプトを開き、次のように入力します。\ngem install selenium-webdriver または、Bundlerを使用する場合、次の行をアプリケーションのGemfileに追加します。\ngem \u0026#34;selenium-webdriver\u0026#34; そして、プロンプトで次のコマンドを実行します。\nbundle install Internet Explorer Internet ExplorerはデフォルトでWindowsにインストールされるため、インストールは不要です。 WindowsでInternet Explorerを動かすには、最新のInternet Explorer Driverをダウンロードし、ファイルを PATHにあるフォルダーに入れる必要があります。どのディレクトリが PATHにあるかを調べるには、コマンドプロンプトでecho％PATH％と入力します。\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin は良い場所のようです。 IEDriverServerファイルを解凍し、IEDriverServer.exeをそこに移動します。\nこれにより、新しいInternet Explorerウィンドウが開きます。\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Browser操作 ナビゲート ブラウザーを起動した後に最初に行うことは、Webサイトを開くことです。これは1行で実現できます。\nJava Python C# Ruby JavaScript Kotlin //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   # Convenient way driver.get \u0026#39;https://selenium.dev\u0026#39; # Longer Way driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;) //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     現在のURLを取得 ブラウザーのアドレスバーから現在のURLを読むには、次を使用します。\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.currentUrl    戻る ブラウザーの戻るボタンを押す。\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     次へ ブラウザーの次へボタンを押す。\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward()    更新 現在のページを更新する。\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    タイトルの取得 ブラウザーから現在のページタイトルを読むことができます。\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.title    ウィンドウとタブ ウィンドウハンドルの取得 WebDriverは、ウィンドウとタブを区別しません。 サイトが新しいタブまたはウィンドウを開く場合、Seleniumはウィンドウハンドルを使って連動します。 各ウィンドウには一意の識別子があり、これは単一のセッションで持続します。 次のコードを使用して、現在のウィンドウのウィンドウハンドルを取得できます。\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.windowHandle    ウィンドウまたはタブの切り替え 新しいウィンドウで開くリンクをクリックすると、新しいウィンドウまたはタブが画面にフォーカスされますが、WebDriverはオペレーティングシステムがアクティブと見なすウィンドウを認識しません。 新しいウィンドウで作業するには、それに切り替える必要があります。 開いているタブまたはウィンドウが2つしかなく、どちらのウィンドウから開始するかがわかっている場合、削除のプロセスによって、WebDriverが表示できる両方のウィンドウまたはタブをループし、元のウィンドウまたはタブに切り替えることができます。\nただし、Selenium 4には、新しいタブ（または）新しいウィンドウを作成して自動的に切り替える新しいAPI NewWindowが用意されています。\nJava Python C# Ruby JavaScript Kotlin //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element(By.LINK_TEXT, \u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;SeleniumHQ Browser Automation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   //Store the ID of the original window val originalWindow = driver.getWindowHandle() //Check we don\u0026#39;t have other windows open already assert(driver.getWindowHandles().size() === 1) //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)) //Loop through until we find a new window handle for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     新しいウィンドウ（または）新しいタブを作成して切り替える 新しいウィンドウ（または）タブを作成し、画面上の新しいウィンドウまたはタブにフォーカスします。 新しいウィンドウ（または）タブを使用するように切り替える必要はありません。 新しいウィンドウ以外に3つ以上のウィンドウ（または）タブを開いている場合、WebDriverが表示できる両方のウィンドウまたはタブをループして、元のものではないものに切り替えることができます。\n注意: この機能は、Selenium 4以降のバージョンで機能します。\nJava Python C# Ruby JavaScript Kotlin // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB); // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW);   # Opens a new tab and switches to new tab driver.switch_to.new_window(\u0026#39;tab\u0026#39;) # Opens a new window and switches to new window driver.switch_to.new_window(\u0026#39;window\u0026#39;)   // Opens a new tab and switches to new tab driver.SwitchTo().NewWindow(WindowType.Tab) // Opens a new window and switches to new window driver.SwitchTo().NewWindow(WindowType.Window)   # Note: The new_window in ruby only opens a new tab (or) Window and will not switch automatically # The user has to switch to new tab (or) new window # Opens a new tab and switches to new tab driver.manage.new_window(:tab) # Opens a new window and switches to new window driver.manage.new_window(:window)   // Opens a new tab and switches to new tab await driver.switchTo().newWindow(\u0026#39;tab\u0026#39;); // Opens a new window and switches to new window await driver.switchTo().newWindow(\u0026#39;window\u0026#39;);   // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB) // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW)     ウィンドウまたはタブを閉じる ウィンドウまたはタブでの作業が終了し、 かつ ブラウザーで最後に開いたウィンドウまたはタブではない場合、それを閉じて、以前使用していたウィンドウに切り替える必要があります。 前のセクションのコードサンプルに従ったと仮定すると、変数に前のウィンドウハンドルが格納されます。 これをまとめると以下のようになります。\nJava Python C# Ruby JavaScript Kotlin //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);   //Close the tab or window driver.close() //Switch back to the old tab or window driver.switchTo().window(originalWindow)     ウィンドウを閉じた後に別のウィンドウハンドルに切り替えるのを忘れると、現在閉じられているページでWebDriverが実行されたままになり、 No Such Window Exception が発行されます。実行を継続するには、有効なウィンドウハンドルに切り替える必要があります。\nセッションの終了時にブラウザーを終了する ブラウザーセッションを終了したら、closeではなく、quitを呼び出す必要があります。\nJava Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()     Quitは、  そのWebDriverセッションに関連付けられているすべてのウィンドウとタブを閉じます ブラウザーのプロセス バックグラウンドのドライバーのプロセス ブラウザーが使用されなくなったことをSelenium Gridに通知して、別のセッションで使用できるようにします（Selenium Gridを使用している場合）    quitの呼び出しに失敗すると、余分なバックグラウンドプロセスとポートがマシン上で実行されたままになり、後で問題が発生する可能性があります。\n一部のテストフレームワークでは、テストの終了時にフックできるメソッドとアノテーションを提供しています。\nJava Python C# Ruby JavaScript Kotlin /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # unittest teardown # https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown def tearDown(self): self.driver.quit()   /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # UnitTest Teardown # https://www.rubydoc.info/github/test-unit/test-unit/Test/Unit/TestCase def teardown @driver.quit end   /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });   /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() { driver.quit() }     テストコンテキストでWebDriverを実行していない場合は、ほとんどの言語で提供されている try / finally の使用を検討して、例外がWebDriverセッションをクリーンアップするようにします。\nJava Python C# Ruby JavaScript Kotlin try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { //WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }   try { //WebDriver code here... } finally { driver.quit() }     PythonのWebDriverは、pythonコンテキストマネージャーをサポートするようになりました。 withキーワードを使用すると、実行終了時にドライバーを自動的に終了できます。\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation FrameとIframe frameは、同じドメイン上の複数のドキュメントからサイトレイアウトを構築する非推奨の手段となりました。 HTML5以前のWebアプリを使用している場合を除き、frameを使用することはほとんどありません。 iframeは、まったく異なるドメインからのドキュメントの挿入を許可し、今でも一般的に使用されています。\nフレームまたはiframeを使用する必要がある場合、Webdriverを使用して同じ方法で作業できます。 iframe内のボタンがある場合を考えてみましょう。ブラウザー開発ツールを使用して要素を検査すると、次のように表示される場合があります。\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; iframeがなければ、次のようなボタンを使用してボタンをクリックします。\nJava Python C# Ruby JavaScript Kotlin //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # This Wont work driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # This won\u0026#39;t work driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     ただし、iframeの外側にボタンがない場合は、代わりにno such elementエラーが発生する可能性があります。 これは、Seleniumがトップレベルのドキュメントの要素のみを認識するために発生します。 ボタンを操作するには、ウィンドウを切り替える方法と同様に、最初にフレームに切り替える必要があります。 WebDriverは、フレームに切り替える3つの方法を提供します。\nWebElementを使う WebElementを使用した切り替えは、最も柔軟なオプションです。好みのセレクタを使用してフレームを見つけ、それに切り替えることができます。\nJava Python C# Ruby JavaScript Kotlin //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Store iframe web element iframe = driver.find_element(By.CSS_SELECTOR, \u0026#34;#modal \u0026gt; iframe\u0026#34;) # switch to selected iframe driver.switch_to.frame(iframe) # Now click on button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Store iframe web element iframe = driver.find_element(:css,\u0026#39;#modal \u0026gt; iframe\u0026#39;) # Switch to the frame driver.switch_to.frame iframe # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Store the web element const iframe = driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Store the web element val iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) //Switch to the frame driver.switchTo().frame(iframe) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     nameまたはIDを使う フレームまたはiframeにidまたはname属性がある場合、代わりにこれを使うことができます。 名前またはIDがページ上で一意でない場合、最初に見つかったものに切り替えます。\nJava Python C# Ruby JavaScript Kotlin //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Switch frame by id driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # Now, Click on the button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Switch by ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     インデックスを使う JavaScriptの window.frames を使用して照会できるように、frameのインデックスを使用することもできます。\nJava Python C# Ruby JavaScript Kotlin // Switches to the second frame driver.switchTo().frame(1);   # Switch to the second frame driver.switch_to.frame(1)   // Switches to the second frame driver.SwitchTo().Frame(1);   # switching to second iframe based on index iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # switch to selected iframe driver.switch_to.frame(iframe)   // Switches to the second frame await driver.switchTo().frame(1);   // Switches to the second frame driver.switchTo().frame(1)     frameを終了する iframeまたはフレームセットを終了するには、次のようにデフォルトのコンテンツに切り替えます。\nJava Python C# Ruby JavaScript Kotlin // Return to the top level driver.switchTo().defaultContent();   # switch back to default content driver.switch_to.default_content()   // Return to the top level driver.SwitchTo().DefaultContent();   # Return to the top level driver.switch_to.default_content   // Return to the top level await driver.switchTo().defaultContent();   // Return to the top level driver.switchTo().defaultContent()     ウィンドウマネジメント 画面解像度はWebアプリケーションのレンダリング方法に影響を与える可能性があるため、WebDriverはブラウザーウィンドウを移動およびサイズ変更するメカニズムを提供します。\nウィンドウサイズの取得 ブラウザーウィンドウのサイズをピクセル単位で取得します。\nJava Python C# Ruby JavaScript Kotlin //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # Access each dimension individually width = driver.manage.window.size.width height = driver.manage.window.size.height # Or store the dimensions and query them later size = driver.manage.window.size width1 = size.width height1 = size.height   // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   //Access each dimension individually val width = driver.manage().window().size.width val height = driver.manage().window().size.height //Or store the dimensions and query them later val size = driver.manage().window().size val width1 = size.width val height1 = size.height     ウィンドウサイズの設定 ウィンドウを復元し、ウィンドウサイズを設定します。\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });   driver.manage().window().size = Dimension(1024, 768)    ウィンドウの位置を取得 ブラウザーウィンドウの左上の座標を取得します。\nJava Python C# Ruby JavaScript Kotlin // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   #Access each dimension individually x = driver.manage.window.position.x y = driver.manage.window.position.y # Or store the dimensions and query them later rect = driver.manage.window.rect x1 = rect.x y1 = rect.y   // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // Access each dimension individually val x = driver.manage().window().position.x val y = driver.manage().window().position.y // Or store the dimensions and query them later val position = driver.manage().window().position val x1 = position.x val y1 = position.y     ウィンドウの位置設定 選択した位置にウィンドウを移動します。\nJava Python C# Ruby JavaScript Kotlin // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   # Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });   // Move the window to the top left of the primary monitor driver.manage().window().position = Point(0,0)     ウィンドウの最大化 ウィンドウを拡大します。ほとんどのオペレーティングシステムでは、オペレーティングシステムのメニューとツールバーをブロックすることなく、ウィンドウが画面いっぱいに表示されます。\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    ウィンドウを最小化 現在のブラウジングコンテキストのウィンドウを最小化します。 このコマンドの正確な動作は、個々のウィンドウマネージャーに固有のものです。\nウィンドウを最小化すると、通常、システムトレイのウィンドウが非表示になります。\n注：この機能は、Selenium 4以降のバージョンで機能します。\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().minimize();  driver.minimize_window()  driver.Manage().Window.Minimize();   driver.manage.window.minimize  await driver.manage().window().minimize();   driver.manage().window().minimize()    全画面ウィンドウ ほとんどのブラウザーでF11を押すのと同じように、画面全体に表示されます。\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/grid/setting_up_your_own_grid/",
	"title": "独自のグリッドを設定する",
	"tags": [],
	"description": "",
	"content": "Selenium Gridを使用するには、ノード用の独自のインフラストラクチャを維持する必要があります。 これは面倒で時間のかかる作業になる可能性があるため、多くの組織はこのインフラストラクチャを提供するためにAmazon EC2やGoogle ComputeなどのIaaSプロバイダーを使用しています。\n他の選択肢として、クラウドのサービスとしてSelenium Gridを提供するSauce LabsやTesting Botなどのプロバイダーの使うこともできます。 独自のハードウェアでノードを実行することも確かに可能です。 この章では、独自のノードインフラストラクチャを備えた独自のグリッドを実行するオプションについて詳しく説明します。\nクイックスタート この例では、Selenium 2グリッドハブを起動し、WebDriverノードとSelenium 1 RCレガシーノードの両方を登録する方法を示します。 また、Javaからグリッドを呼び出す方法も示します。 ここでは、ハブとノードが同じマシンで実行されていますが、もちろん、selenium-server-standaloneを複数のマシンにコピーできます。\nselenium-server-standaloneパッケージには、グリッドの実行に必要なハブ、WebDriver、およびレガシーRCが含まれています。 ant はもう必要ありません。 selenium-server-standalone.jarは https://selenium.dev/downloads/ からダウンロードできます。\nステップ1：ハブを開始する ハブは、テストリクエストを受信し、それらを適切なノードに配布する中心点です。 配布は機能ベースで行われます。 つまり、一連の機能を必要とするテストは、その機能セットまたは機能のサブセットを提供するノードにのみ配布されます。\nテストのDesiredCapabilitiesは、 任意の を意味するため、ハブはDesiredCapabilitiesの設定に完全に一致するノードを見つけることを保証できません。\nコマンドプロンプトを開き、selenium-server-standalone.jarファイルをコピーしたディレクトリに移動します。 ハブを起動するには、-role hubフラグをスタンドアロンサーバーに渡します。\njava -jar selenium-server-standalone.jar -role hub ハブはデフォルトでポート4444をリッスンします。 ブラウザーウィンドウを開いて http://localhost:4444/grid/console に移動すると、ハブのステータスを表示できます。\nデフォルトのポートを変更するには、コマンドを実行するときにリッスンするポートを表す整数を持つオプションの -port フラグを追加できます。 また、JSON構成ファイル（以下を参照）に表示される他のすべてのオプションは、可能なコマンドラインフラグです。\n確かに上記の簡単なコマンドだけでうまくいくことができますが、より高度な構成が必要な場合は、JSON形式の構成ファイルを指定して、開始時にハブを構成することもできます。 JSON形式の構成ファイルを指定して開始時にハブを構成する方法は以下のとおりです。\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug 以下に、 hubConfig.json ファイルの例を示します。 ステップ2でノード構成ファイルを提供する方法について詳しく説明します。\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} ステップ2：ノードを起動する 新しいWebDriver機能を備えたグリッドを実行するか、Selenium 1 RC機能を備えたグリッドを実行するか、または両方を同時に実行するかに関係なく、同じ selenium-server-standalone.jar ファイルを使用してノードを起動します。\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 -port フラグでポートが指定されていない場合、空いているポートが選択されます。 1台のマシンで複数のノードを実行できますが、実行する場合は、システムメモリリソースとスクリーンショットの問題をテストで確認する必要があることに注意する必要があります。\nオプションを使用したノード構成 前述のように、下位互換性のために、\u0026ldquo;wd\u0026quot;および\u0026quot;rc\u0026quot;ロールは\u0026quot;node\u0026quot;ロールの有効なサブセットのままです。 ただし、これらのロールは、対応するAPIへのリモート接続の種類を制限し、\u0026ldquo;node\u0026quot;はRCとWebDriverの両方のリモート接続を許可します。\nコマンドラインでもJVMプロパティを（ -jar引数の前に -Dフラグを使用して）渡すと、これらが取得され、ノードに伝播されます。\n-Dwebdriver.chrome.driver=chromedriver.exe\nJSONを使用したノード構成 JSON設定ファイルで構成されたグリッドノードを起動することもできます。\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json そして、これは nodeConfig.json ファイルの例です。\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } -host フラグに関する注意\nハブとノードの両方で、-hostフラグが指定されていない場合、デフォルトで0.0.0.0を使用します。 これにより、マシンのすべてのパブリック（非ループバック）IPv4インターフェイスにバインドされます。 特別なネットワーク構成または追加のネットワークインターフェイスを作成するコンポーネントがある場合は、-hostフラグにハブ/ノードが別のマシンから到達できる値を設定することをお勧めします。\nポートを指定する ハブで使用されるデフォルトのTCP / IPポートは4444です。 ポートを変更する必要がある場合は、上記の構成を使用してください。\nトラブルシューティング ログファイルを使用する 高度なトラブルシューティングのために、システムメッセージを記録するログファイルを指定できます。 -log引数を使用してSelenium GRIDハブまたはノードを起動します。 以下の例をご覧ください。\njava -jar selenium-server-standalone.jar -role hub -log log.txt お気に入りのテキストエディターを使用してログファイル（上記の例ではlog.txt）を開き、問題が発生した場合に\u0026quot;エラー\u0026quot;ログを見つけます。\n-debug 引数を使用する -debug引数を使用して、デバッグログをコンソールに出力することもできます。 -debug 引数を使用してSeleniumグリッドハブまたはノードを起動します。 以下の例をご覧ください。\njava -jar selenium-server-standalone.jar -role hub -debug 警告 Selenium Gridは、適切なファイアウォールアクセス許可を使用して外部アクセスから保護する必要があります。\nグリッドを保護しないと、次の1つ以上が発生する可能性があります。\n グリッドインフラストラクチャへのオープンアクセスを提供します。 サードパーティが内部Webアプリケーションおよびファイルにアクセスすることを許可します。 サードパーティにカスタムバイナリの実行を許可します。  Detectify に関するこのブログ投稿をご覧ください。 これは、公開されたグリッドが悪用される可能性のある概要を示しています。 Don\u0026rsquo;t Leave your Grid Wide Open\nDocker Selenium Docker は、コンテナと呼ばれる単位でSelenium Gridインフラストラクチャをプロビジョニングおよびスケーリングする便利な方法を提供します。 コンテナは、さまざまなマシンで信頼性と再現性のある方法で、すべての依存関係を含む目的のアプリケーションを実行するために必要なすべてを含むソフトウェアの標準化されたユニットです。\nSeleniumプロジェクトは、ダウンロードして実行して作業用グリッドを迅速に起動および実行できる一連のDockerイメージを保持しています。 ノードはFirefoxとChromeの両方で使用できます。 グリッドのプロビジョニング方法の詳細は、 Docker Selenium リポジトリ内にあります。\n前提条件 グリッドを実行するための唯一の要件は、Dockerをインストールして動作させることです。 Dockerのインストール.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/getting_started_with_webdriver/locating_elements/",
	"title": "要素を探す",
	"tags": [],
	"description": "",
	"content": "一つの要素を探す ページ上で要素を探す方法は、WebDriverを使う上で最初に学ばなければならない技術です。WebDriverは多数のセレクタを標準で用意しています。その中で、id属性を使って要素を探す方法が次のコードです。\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element(By.ID, \u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     例を見ての通り、WebDriverで要素を特定するには、WebDriverクラスのインスタンスを使います。findElement(By)メソッドはWebElementという別の基本的なオブジェクトを返します。\n WebDriverはブラウザをあらわす WebElementは特定のDOMノード（コントロール、例えばリンクやインプットフィールドなど）をあらわす  一度「見つかった」Web要素への参照を取得すれば、そのインスタンスで同じメソッドを呼ぶことで検索の範囲を狭めることができます。\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(By.ID, \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;) cheddar = cheese.find_element(id: \u0026#39;cheddar\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     これは WebDriver と WebElement クラスの両方がSearchContextインターフェイスを実装しているため可能になっています。 これはWebDriverでは ロールベースインターフェイス (role-based interface) と呼ばれています。 ロールベースインターフェイスは、どのドライバー実装がどの機能をサポートしているかどうかを判断する助けになります。これらのインターフェイスは明確に定義され、単一の役割の責任のみを持つことを守っています。 WebDriverの設計と、どんな役割がどのドライバでサポートされているかはSome Other Section Which Must Be Namedで読むことができます。\nその結果、 上で使っていた By インターフェイスはいくつものロケータストラテジをサポートしています。 ネストした探索はcheeseを探す方法としてもっとも効率的なものではないかもしれません。 なぜなら、この方法は二つに分割されたコマンドをブラウザに発行するからです。具体的には、まずDOMから\u0026quot;cheese\u0026quot;というidの要素を探し出し、それから狭まった範囲で\u0026quot;cheddar\u0026quot;という要素を探しています。\nパフォーマンスをわずかに向上させるために、より効果的なロケータを使ってみましょう。 WebDriverはCSSロケータによる要素の探索をサポートしています。 これは先ほどの二つのロケータを1回の検索に組み合わせることができます。\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   driver.find_element(css: \u0026#39;#cheese #cheddar\u0026#39;)   const cheddar = driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     複数の要素を探す 今作業しているドキュメントに、私たちが一番好きなチーズについての順序付きリストがあるとします。\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; チーズがたくさんある方が良いのは疑いの余地がなく、また一個一個取らなければなければならないのは面倒です。 なので、チーズを取得する上位のテクニックは、複数形のfindElements(By)を使うことです。 このメソッドはWeb要素のコレクションを返します。 もし一つの要素しか見つからなかった場合も、（一つの要素だけの）コレクションを返します。 もしロケータにマッチする要素が一つもなかった場合は、空のリストが返ります。\nJava Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(“#cheese li”));   mucho_cheese = driver.find_elements(css: \u0026#39;#cheese li\u0026#39;)   const muchoCheese = driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))     要素選択の方法 WebDriverには標準のロケータが8種類あります。\n   ロケータ 詳細     class name class名に値を含む要素を探す (複合クラス名は使えない)   css selector CSSセレクタが一致する要素を探す   id id属性が一致する要素を探す   name name属性が一致する要素を探す   link text a要素のテキストが一致する要素を探す   partial link text a要素のテキストが部分一致する要素を探す   tag name タグ名が一致する要素を探す   xpath XPathと一致する要素を探す    セレクタを使うときのコツ 一般に、HTMLのid属性が利用可能でユニークかつ一貫している場合、ページで要素を探す方法として適しています。 idは動作がとても速い傾向があり、複雑なDOMトラバースに伴う処理を省略できます。\nユニークなidが使えない場合、きれいに書かれたCSSセレクタが要素を探す方法として適しています。 XPathはCSSセレクタと同様に動作しますが、シンタックスは複雑で大抵の場合デバッグが困難です。 XPathはとても柔軟ですが、ブラウザベンダは性能テストを通常行っておらず、非常に動作が遅い傾向があります。\nlink textセレクタとpartial linkText セレクタはa要素でしか動作しないという欠点があります。 加えて、これらはWebDriverの内部でXPathの呼び出しに置き換えられます。\nタグ名によるロケータは危険な方法になり得ます。 大抵の場合ページ上には同じタグ名の要素が複数あります。タグ名は要素のコレクションを返す findElements(By) メソッドを使う時にもっとも役に立ちます。\nロケータは可能な限り簡潔に、読みやすい状態を保つことを推奨します。 WebDriverでDOM構造のトラバースを行うのは重い処理となります。 検索の範囲を狭めた方がより良い結果を得られます。\nレラティブ（相対）ロケーター Selenium 4 は、以前は Friendly Locators と呼ばれていたレラティブ ロケーターをもたらします。 この機能は、他の要素の近くにある要素を見つけるのに役立つように追加されました。 使用可能なレラティブ ロケーターは次のとおりです。\n above below toLeftOf toRightOf near  findElement メソッドは、レラティブ ロケーター を返す新しいメソッド withTagName（） を受け入れるようになりました。\nどのように機能するか Seleniumは、JavaScript関数 getBoundingClientRect() を使用して相対要素を見つけます。 この関数は、right、left、bottom、topなどの要素のプロパティを返します。\nレラティブ ロケーターを理解するために、以下の例を考えてみましょう。\nabove() 指定された要素の上に表示されるWebElementを返します。\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement passwordField= driver.findElement(By.id(\u0026#34;password\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .above(passwordField));   #from selenium.webdriver.support.relative_locator import with_tag_name passwordField = driver.find_element(By.ID, \u0026#34;password\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).above(passwordField))   //using static OpenQA.Selenium.RelativeBy; IWebElement passwordField = driver.FindElement(By.Id(\u0026#34;password\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Above(passwordField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      below() 指定された要素の下に表示されるWebElementを返します。\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressField= driver.findElement(By.id(\u0026#34;email\u0026#34;)); WebElement passwordField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .below(emailAddressField));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressField = driver.find_element(By.ID, \u0026#34;email\u0026#34;) passwordField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).below(emailAddressField))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressField = driver.FindElement(By.Id(\u0026#34;email\u0026#34;)); IWebElement passwordField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Below(emailAddressField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toLeftOf() 指定された要素の左側に表示されるWebElementを返します。\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement submitButton= driver.findElement(By.id(\u0026#34;submit\u0026#34;)); WebElement cancelButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toLeftOf(submitButton));   #from selenium.webdriver.support.relative_locator import with_tag_name submitButton = driver.find_element(By.ID, \u0026#34;submit\u0026#34;) cancelButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_left_of(submitButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement submitButton = driver.FindElement(By.Id(\u0026#34;submit\u0026#34;)); IWebElement cancelButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .LeftOf(submitButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toRightOf() 指定された要素の右側に表示されるWebElementを返します。\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement cancelButton= driver.findElement(By.id(\u0026#34;cancel\u0026#34;)); WebElement submitButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toRightOf(cancelButton));   #from selenium.webdriver.support.relative_locator import with_tag_name cancelButton = driver.find_element(By.ID, \u0026#34;cancel\u0026#34;) submitButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_right_of(cancelButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement cancelButton = driver.FindElement(By.Id(\u0026#34;cancel\u0026#34;)); IWebElement submitButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .RightOf(cancelButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      near() 指定した要素から最大 50px 離れたWebElementを返します。\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressLabel= driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .near(emailAddressLabel));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressLabel = driver.find_element(By.ID, \u0026#34;lbl-email\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;). near(emailAddressLabel))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressLabel = driver.FindElement(By.Id(\u0026#34;lbl-email\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Near(emailAddressLabel));   # Please raise a PR   // Please raise a PR    // Please raise a PR      "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/support_packages/working_with_select_elements/",
	"title": "選択要素の操作",
	"tags": [],
	"description": "",
	"content": "一部の要素では、自動化するためにかなりのボイラープレートコードが必要になる場合があります。 これを減らしてテストをきれいにするために、Seleniumサポートパッケージに Select クラスがあります。 それを使用するには、次のimportステートメントが必要です。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.ui.Select     そして、 \u0026lt;select\u0026gt; 要素を参照するWebElementを使用してSelectオブジェクトを作成できます。\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element(By.ID,\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   IWebElement selectElement = driver.FindElement(By.Id(\u0026#34;selectElementID\u0026#34;)); var selectObject = new SelectElement(selectElement);   select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     Selectオブジェクトは、 \u0026lt;select\u0026gt; 要素とやり取りできる一連のコマンドを提供します。 まず、 \u0026lt;select\u0026gt; 要素からオプションを選択するさまざまな方法があります。\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; 上記の要素から最初のオプションを選択するには、3つの方法があります。\nJava Python C# Ruby JavaScript Kotlin // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by_index(1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by_value(\u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.SelectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.SelectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text  selectObject.SelectByText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by(:index, 1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1) // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     以下を使用して、選択されているオプションを確認できます。\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Return a WebElement referencing the first selection option found by walking down the DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Return a list[WebElement] of options that have been selected all_selected_options = select_object.all_selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected var allSelectedOptions = selectObject.AllSelectedOptions; // Return a WebElement referencing the first selection option found by walking down the DOM var firstSelectedOption = selectObject.AllSelectedOptions.FirstOrDefault();   # Return an Array[Element] of options that have been selected all_selected_options = select_object.selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected val allSelectedOptions = selectObject.allSelectedOptions // Return a WebElement referencing the first selection option found by walking down the DOM val firstSelectedOption = selectObject.firstSelectedOption     または、 \u0026lt;select\u0026gt; 要素に含まれる \u0026lt;option\u0026gt; 要素に興味があるかもしれません。\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Return a list[WebElement] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // Return a IList\u0026lt;IWebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains IList\u0026lt;IWebElement\u0026gt; allAvailableOptions = selectObject.Options;   # Return an Array[Element] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains val allAvailableOptions = selectObject.options     要素の選択を解除する場合は、4つの選択肢があります。\nJava Python C# Ruby JavaScript Kotlin // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by_index(1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all()   // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.DeselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.DeselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.DeselectByText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.DeselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by(:index, 1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1) // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll()     最後に、一部の \u0026lt;select\u0026gt; 要素を使用すると、複数のオプションを選択できます。 \u0026lt;select\u0026gt; 要素がこれらの1つであるかどうかを調べるには、下記のように記述します。\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   bool doesThisAllowMultipleSelections = selectObject.IsMultiple;   does_this_allow_multiple_selections = select_object.multiple?   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val doesThisAllowMultipleSelections = selectObject.isMultiple     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "AUT* を操作する",
	"tags": [],
	"description": "",
	"content": "次のようにsendKeysを使うことで、要素にテキストをセットすることができます。\nJava Python C# Ruby JavaScript Kotlin String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(By.NAME, \u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);   val name = \u0026#34;Charles\u0026#34; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name)     JavaScriptライブラリを使ってドラックアンドドロップ機能を追加したWebアプリケーションがあります。 次の例はある要素を別の要素へドラッグする例です。\nJava Python C# Ruby JavaScript Kotlin WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element(By.ID, \u0026#34;source\u0026#34;) target = driver.find_element(By.ID, \u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();   val source = driver.findElement(By.id(\u0026#34;source\u0026#34;)) val target = driver.findElement(By.id(\u0026#34;target\u0026#34;)) Actions(driver).dragAndDrop(source, target).build().perform()     要素をクリックする clickメソッドを使うと要素のクリックができます。\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element(By.CSS_SELECTOR, \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click()     *AUT: Application under test（テスト対象アプリケーション）\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/worst_practices/gmail_email_and_facebook_logins/",
	"title": "Gmail、Eメール、Facebookログイン",
	"tags": [],
	"description": "",
	"content": "複数の理由から、WebDriverを使用してGmailやFacebookなどのサイトにログインすることはお勧めしません。 これらのサイトの使用条件（アカウントがシャットダウンされるリスクがある）に違反することは別として、それは遅く、信頼性がありません。\n理想的なプラクティスは、メールプロバイダーが提供するAPIを使用すること、またはFacebookの場合、テストアカウントや友人などを作成するためのAPIを公開する開発者ツールサービスを使用することです。 APIの使用は少し大変な作業のように思えるかもしれませんが、速度、信頼性、および安定性に見返りがあります。 また、APIが変更されることはほとんどありませんが、WebページとHTMLロケーターは頻繁に変更され、テストフレームワークを更新する必要があります。\nテストの任意の時点でWebDriverを使用してサードパーティのサイトにログインすると、テストが長くなるため、テストが失敗するリスクが高くなります。 一般的な経験則として、テストが長くなるほど脆弱で信頼性が低くなります。\nW3C準拠 のWebDriver実装は、サービス拒否攻撃を軽減できるように、navigatorオブジェクトにWebDriverプロパティで注釈を付けます。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/getting_started_with_webdriver/",
	"title": "WebDriverをはじめよう",
	"tags": [],
	"description": "",
	"content": "WebDriverをはじめよう Seleniumは市場で主要なブラウザの全てを WebDriver を使うことでサポートしています。 WebDriverとはAPI群とプロトコルです。これらはウェブブラウザの動作をコントロールするための言語中立なインターフェイスを定義しています。 それぞれのブラウザは特定のWebDriverの実装を持っており、これらは driver と呼ばれます。 driverはブラウザに委譲する責務を持つコンポーネントであり、Seleniumとブラウザ間の通信を処理します。\nこの分離は、ブラウザベンダーに自分たちのブラウザでの実装の責任を持たせるための意図的な努力のひとつです。 Seleniumは可能な場合これらのサードパーティ製のdriverを使いますが、それが現実的でない場合のためにプロジェクトでメンテナンスしているdriverも提供しています。\nSeleniumフレームワークはこれら全ての要素をユーザ向けのインターフェイスを通して結びつけます。このインターフェイスは異なるブラウザバックエンドを透過的に使えるようにし、クロスブラウザ・クロスプラットフォームの自動化を可能にします。\ndriverのより詳しい資料はDriver Idiosyncrasiesにあります。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/introduction/about_this_documentation/",
	"title": "このドキュメントについて",
	"tags": [],
	"description": "",
	"content": "これらのドキュメントは、コード自体と同様に、Seleniumコミュニティ内のボランティアによって100％維持されます。 当初から多くの人が使用してきましたが、多くの人が短期間しか使用しておらず、新しいユーザーのオンボーディングエクスペリエンスの改善に時間を割いてきました。\nドキュメントに問題がある場合、知りたいです！ 問題を伝える最良の方法は、https://github.com/seleniumhq/seleniumhq.github.io/issuesにアクセスし、問題が既に報告されているかどうかを検索することです。 そうでない場合は、自由に開いてください！\nコミュニティの多くのメンバーは、irc.freenode.netで #selenium IRCチャンネルに頻繁にアクセスします。 気軽に立ち寄って質問してください。 これらのドキュメントで役立つと思われるヘルプを受け取った場合は、必ず貢献を追加してください。 これらのドキュメントを更新することはできますが、通常のコミッター以外から投稿を受け取ると、誰にとってもずっと簡単になります。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/grid/when_to_use_grid/",
	"title": "グリッドを使用する場合",
	"tags": [],
	"description": "",
	"content": "一般的に、グリッドを使用する理由は2つあります。\n 複数のブラウザー、複数のバージョンのブラウザー、および異なるオペレーティングシステムで実行されているブラウザーに対してテストを実行するため。 テストスイートがテストがパスするのに完了するのにかかる時間を短縮するため。  グリッドは、複数のマシンを使用してテストを並行して実行することにより、テストパスの実行を高速化するために使用されます。 たとえば、100個のテストスイートがあり、それらのテストを実行するために4つの異なるマシン（VMまたは個別の物理マシン）をサポートするようにグリッドをセットアップした場合、テストスイートは単一のマシンでテストを連続して実行した場合と比較して（およそ）4分の1の時間で完了します。 大規模なテストスイート、および大量のデータ検証を実行するような長時間実行されるテストスイートの場合、これは大幅な時間の節約になります。 一部のテストスイートの実行には数時間かかる場合があります。 スイートの実行に費やす時間を増やすもう1つの理由は、開発者がAUTのコードをチェックインした後のテスト結果の所要時間を短縮することです。 アジャイルソフトウェア開発を実践しているソフトウェアチームは、一晩テストパスを一晩待つのではなく、できるだけ早くテストフィードバックを求めています。\nグリッドは、複数のランタイム環境、特に異なるブラウザーに対して同時に実行するテストをサポートするためにも使用されます。 たとえば、仮想マシンの\u0026quot;グリッド\u0026quot;は、テスト対象のアプリケーションがサポートする必要がある異なるブラウザーをサポートするようにセットアップできます。 したがって、マシン1にはInternet Explorer 8、マシン2、Internet Explorer 9、マシン3は最新のChrome、マシン4は最新のFirefoxを持っています。 テストスイートが実行されると、Selenium-Gridは各テストブラウザーの組み合わせを受け取り、必要なブラウザーに対して実行する各テストを割り当てます。\nさらに、すべて同じブラウザ、タイプ、およびバージョンのグリッドを持つことができます。 たとえば、それぞれがFirefox 70の3つのインスタンスを実行する4台のマシンのグリッドを持つことができ、利用可能なFirefoxインスタンスの\u0026quot;ある意味\u0026quot;での\u0026quot;サーバーファーム\u0026quot;を可能にします。 スイートが実行されると、各テストはグリッドに渡され、グリッドは次に利用可能なFirefoxインスタンスにテストを割り当てます。 この方法で、おそらく12のテストがすべて同時に並行して実行されるテストパスを取得し、テストパスの完了に必要な時間を大幅に短縮します。\nグリッドは非常に柔軟です。 これらの2つの例を組み合わせて、各ブラウザタイプとバージョンの複数のインスタンスを許可することができます。 このような構成では、迅速にテストがパスすることを完了するための並列実行と、複数のブラウザタイプおよびバージョンの同時サポートの両方が提供されます。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/support_packages/mouse_and_keyboard_actions_in_detail/",
	"title": "マウスアクションの詳細",
	"tags": [],
	"description": "",
	"content": "マウスは、マウスイベントを表します。 マウスアクションは低レベルインターフェイスを使用して実行され、仮想化されたデバイス入力アクションをWebブラウザーに提供できます。\nクリックとホールド 要素に移動し、指定された要素の中央で（解放せずに）クリックします。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform click-and-hold action on the element webdriver.ActionChains(driver).click_and_hold(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ClickAndHold { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.ClickAndHold(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform click-and-hold action on the element driver.action.click_and_hold(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function clickAndHold() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform mouseMove to element and mouseDown (press) action on the element  await actions.move({origin:searchBtn}).press().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform() } finally { driver.quit() } }     コンテキストクリック（右クリック） このメソッドは、最初に要素の位置へのマウス移動を実行し、指定された要素でコンテキストクリック（右クリック）を実行します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class contextClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform context-click action on the element webdriver.ActionChains(driver).context_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ContextClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.ContextClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform context-click action on the element driver.action.context_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function contextClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform context-click action on the element  await actions.contextClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform() } finally { driver.quit() } }     ダブルクリック 要素に移動し、指定された要素の中央でダブルクリックを実行します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class doubleClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform double-click action on the element webdriver.ActionChains(driver).double_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DoubleClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.DoubleClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform double-click action on the element driver.action.double_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function doubleClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform double-click action on the element  await actions.doubleClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform() } finally { driver.quit() } }     要素への移動 このメソッドは、マウスを要素の中央に移動します。 このアクションを実行すると、要素もビューにスクロールされます。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveToElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) # Performs mouse move action onto the element webdriver.ActionChains(driver).move_to_element(gmailLink).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveToElement { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.MoveToElement(gmailLink).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Performs mouse move action onto the element driver.action.move_to(gmail_link).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveToElement() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({origin:gmailLink}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform() } finally { driver.quit() } }     オフセットによる移動 このメソッドは、マウスを現在の位置（または0,0）から指定したオフセットだけ移動します。 座標がビューウィンドウの外側にある場合、マウスはブラウザウィンドウの外側になります。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveByOffset { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture x and y offset positions of element  int xOffset = gmailLink.getRect().getX(); int yOffset = gmailLink.getRect().getY(); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.moveByOffset(xOffset, yOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) #Set x and y offset positions of element xOffset = 100 yOffset = 100 # Performs mouse move action onto the element webdriver.ActionChains(driver).move_by_offset(xOffset,yOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveByOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); // Set x and y offset positions of element  int xOffset = 100; int yOffset = 100; Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.MoveByOffset(xOffset, yOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Capture x and y offset positions of element x_offset = gmail_link.rect.x y_offset = gmail_link.rect.y # Performs mouse move action onto the offset position driver.action.move_to_location(x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveByOffset() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture offset positions of element  let offset = await gmailLink.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({x:parseInt(x),y:parseInt(y)}).pause(3000).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) // Capture x and y offset positions of element  val xOffset = gmailLink.rect.getX() val yOffset = gmailLink.rect.getY() val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveByOffset(xOffset, yOffset).build().perform() } finally { driver.quit() } }     ドラッグアンドドロップ このメソッドは、最初にソース要素でクリックアンドホールドを実行し、ターゲット要素の位置に移動してからマウスを離します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDrop { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs drag and drop action of sourceEle onto the targetEle webdriver.ActionChains(driver).drag_and_drop(sourceEle,targetEle).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDrop { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDrop(sourceEle, targetEle).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) # Store \u0026#39;box B\u0026#39; as source element target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Performs drag and drop action of sourceEle onto the targetEle driver.action.drag_and_drop(source_ele, target_ele).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDrop() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); // Performs drag and drop action of sourceEle onto the targetEle  await actions.dragAndDrop(sourceEle, targetEle).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform() } finally { driver.quit() } }     オフセット分のドラッグアンドドロップ このメソッドは、まずソース要素でクリックアンドホールドを実行し、指定されたオフセットに移動してからマウスを離します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDropBy { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.getLocation().getX(); int targetEleYOffset = targetEle.getLocation().getY(); Actions actionProvider = new Actions(driver); // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) targetEleXOffset = targetEle.location.get(\u0026#34;x\u0026#34;) targetEleYOffset = targetEle.location.get(\u0026#34;y\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).drag_and_drop_by_offset(sourceEle, targetEleXOffset, targetEleYOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDropToOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.Location.X; int targetEleYOffset = targetEle.Location.Y; Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDropToOffset(sourceEle, targetEleXOffset, targetEleYOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Capture x and y offset positions of element x_offset = target_ele.rect.x y_offset = target_ele.rect.y # Performs dragAndDropBy onto the target element offset position driver.action.drag_and_drop_by(source_ele, x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDropBy() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); let offset = await targetEle.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs dragAndDropBy onto the target element offset position  await actions.dragAndDrop(sourceEle, {x:parseInt(x), y:parseInt(y)}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val targetEleXOffset = targetEle.location.getX() val targetEleYOffset = targetEle.location.getY() val actionProvider = Actions(driver) // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform() } finally { driver.quit() } }     リリース このアクションは、押し下げられたマウスの左ボタンをリリースします。 WebElementが渡されると、指定されたWebElementでマウスの左ボタンが押された状態でリリースされます。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class release { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform(); // Performs release event  actionProvider.release().build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).click_and_hold(sourceEle).move_to_element(targetEle).perform() #Performs release event webdriver.ActionChains(driver).release().perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class Release { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.ClickAndHold(sourceEle).MoveToElement(targetEle).Build().Perform(); // Performs release event  actionProvider.Release().Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) driver.action.click_and_hold(source_ele).move_to(target_ele).perform # Performs release event driver.action.release.perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function release() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); await actions.move({origin:sourceEle}).press().perform(); // Performs release event on target element  await actions.move({origin:targetEle}).release().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform() // Performs release event  actionProvider.release().build().perform() } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/mock_external_services/",
	"title": "モック外部サービス",
	"tags": [],
	"description": "",
	"content": "外部サービスへの依存を排除すると、テストの速度と安定性が大幅に向上します。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/legacy_docs/selenium_ide/",
	"title": "レガシー Selenium IDE",
	"tags": [],
	"description": "",
	"content": "紹介 Selenium-IDE (統合開発環境) は、Selenium テストケースを開発するためのツールです。 Selenium-IDE は使いやすい Firefox プラグインで、一般にテストケースを開発するための最も効率的な方法です。 Selenium-IDE ではコンテキストメニューも使用できます。 コンテキストメニューを使うと、まず現在ブラウザに表示されているページ上の UI 要素を選択し、次に Selenium コマンドのリストから目的のコマンドを選択できます。 コマンドのパラメータは、選択された UI 要素のコンテキストに従って、あらかじめ定義されたものが使われます。 Selenium-IDE を使う方法は、時間の節約になるだけでなく、Selenium スクリプトの構文を学ぶ手段としても優れています。\nこの章では Selenium-IDE について詳しく取り上げ、Selenium-IDE を効果的に使う方法について説明します。\nIDEのインストール Firefoxを使用して、最初にSeleniumHQダウンロードページからIDEをダウンロードします。\nFirefoxは、不慣れな場所からアドオンをインストールしないように保護するため、次のスクリーンショットに示すように、インストールを続行するには'許可'をクリックする必要があります。\nFirefoxからダウンロードすると、次のウィンドウが表示されます。\n「今すぐインストール」を選択します。 Firefoxの「アドオン」ウィンドウがポップアップし、最初にプログレスバーが表示されます。 ダウンロードが完了すると、次のような画面になります。\nFirefoxを再起動します。 Firefoxの再起動後、Firefoxの「ツール」メニューには、「Selenium-IDE」が表示されます。\nIDEを開く Selenium-IDEを実行するには、Firefoxの「ツール」メニューから「Selenium-IDE」を選択するだけです。 空のスクリプト編集ウィンドウと、テストケースを読み込んだり新規作成したりするメニューのある Selenium-IDE のウィンドウが表示されます。\nIDEの機能 メニューバー 「ファイル」メニューには、テストケースとテストスイート（テストケースのスイート）のオプションがあります。 これらを使用して、新しいテストケースを追加し、テストケースを開き、テストケースを保存し、選択した言語でテストケースをエクスポートできます。 最近のテストケースを開くこともできます。 これらすべてのオプションは、テストスイートでも使用できます。\n「編集」メニューでは、テストケースのコマンドを編集するためのすべての操作をコピー、貼り付け、削除、元に戻す、選択できます。 「オプション」メニューでは、さまざまな設定を変更できます。 特定のコマンドのタイムアウト値を設定し、Seleniumコマンドの基本セットにユーザー定義のユーザー拡張機能を追加し、テストケースを保存するときに使用する形式（言語）を指定できます。 「ヘルプ」メニューは Firefox 標準の「ヘルプ」メニューで、この中の 「UI-Element Documentation」 だけが Selenium-IDE に関係のある項目です。\nツールバー ツールバーには、テストケースをデバッグするためのステップ実行機能をはじめ、テストケースの実行をコントロールするためのさまざまなボタンが並んでいます。 右端の赤い丸のボタンは、「Record」(記録) ボタンです。\n「Speed Control」 (速度調節): テストケースの実行速度を調節します。\n「Run All」 (すべて実行): 複数のテストケースを持つテストスイートが読み込まれているときにテストスイート全体を実行します。\n「Run」 (実行): 現在選択されているテストを実行します。 テストが1つしか読み込まれていない場合、このボタンと「Run All」ボタンの動作は同じです。\n「Pause」 / 「Resume」 (一時停止/再開) : 実行中のテストを一時停止または再開します。\n「Step」(ステップ実行): コマンドを1つずつ実行し、テストケースの「1ステップ実行」を行います。 テストケースをデバッグするときに使います。\n「TestRunner Mode」 (TestRunner モード): テストケースを Selenium-Core TestRunner で読み込んでブラウザで実行することができます。 TestRunner は今はあまり使われておらず、いずれ非推奨となるでしょう。 このボタンは、テストケースを評価して、TestRunner との後方互換性があるかどうかを調べるために用意されています。 ほとんどのユーザーは、このボタンを使う必要はないでしょう。\n「Apply Rollup Rules」(ロールアップルールを適用): この高度な機能を利用すると、一連の Selenium コマンドの繰り返しを 1 つのアクションにまとめることができます。 ロールアップルールの詳細については、「ヘルプ」 メニューの [UI-Element Documentation] を参照してください。\nテストケース ペイン スクリプトは「テストケース」ペインに表示されます。 ペインには2つのタブがあります。 次に示すのは、コマンドとそのパラメータを読みやすい「テーブル」形式で表示するための [「テーブル」タブです。\nもう 1 つの「ソース」タブには、テストケースがネイティブ形式で表示されます。 ファイルはこのネイティブ形式で保存されます。 デフォルトでは HTML ですが、Java や C# などのプログラミング言語、あるいは Python などのスクリプト言語に変更することもできます。 詳細については、「オプション」 メニューを参照してください。 「ソース」 タブでは、テストケースを生の形式で編集することができ、操作のコピー、切り取り、貼り付けが可能です。\n「コマンド」、「対象」、および 「値」 入力フィールドには、現在選択されているコマンドとそのパラメータが表示されます。 これらの入力フィールドでは、現在選択されているコマンドを修正できます。 一番下のペインの 「リファレンス」 タブで、コマンドに対して指定されている 1 つ目のパラメータは、必ず 「対象」 フィールドに入力します。 「リファレンス」 タブで 2 つ目のパラメータが指定されている場合、このパラメータは 「値」 フィールドに入力します。\n「コマンド」フィールドに文字を入力すると、入力した文字に応じてドロップダウンリストに項目が表示されるので、このリストから目的のコマンドを選択できます。\nログ/参照/UI要素/ロールアップペイン 一番下のペインは、さまざまな機能で使われます。 「ログ」、「リファレンス」、「UI-Element」、および 「Rollup」 の4つのタブがあります。\nログ テストケースを実行すると、「ログ」 タブを選択していなくても、エラーメッセージとテストの進行状況を示す情報メッセージが自動的にこのペインに表示されます。 これらのメッセージは、しばしばテストケースのデバッグに役立ちます。 ログを消去するには 「消去」 ボタンをクリックします。 「情報」 ボタンをクリックすると、ドロップダウンリストが表示されます。 リストで目的の項目を選択すれば、画面に表示する情報のレベルを指定できます。\nリファレンス 「リファレンス」 タブは、「テーブル」 タブで Selenese コマンドとパラメータを入力したり修正したりする場合にデフォルトで選択されるタブです。 「テーブル」 タブが表示されている場合、「リファレンス」 ペインには現在のコマンドのリファレンスが表示されます。 「テーブル」 タブの 「ソース」 タブのどちらで作業している場合も、コマンドを入力または修正するときは、「対象」 フィールドと 「値」 フィールドで指定するパラメータが、「リファレンス」 ペインのパラメータリストに指定されているものと一致していることを確認することが非常に重要です。 指定するパラメータの数は、「リファレンス」 ペインで指定されている数と一致しなければならず、パラメータの順序も 「リファレンス」 ペインのそれと一致しなければなりません。 さらに、指定するパラメータの型も、「リファレンス」 ペインで指定されている型と一致していなければなりません。 これら 3つのうち、1つでも一致しないものがあれば、コマンドは正常に実行されません。\n「リファレンス」 タブはクイックリファレンスとして大いに役立ちますが、Seleniumリファレンスを参照することもしばしば必要になります。\nUI-ElementとRollup これらの2つのペイン (高度な機能を扱うためのペイン) については、Selenium-IDE の 「ヘルプ」 メニューの 「UI-Element Documentation」 を参照してください。\nテストケースの作成 テストケースを開発するための主な方法は3つあります。 多くの場合、テスト開発者はこれら 3 つのテクニックをすべて使う必要があります。\n記録 Selenium を初めて使うユーザーは、Web サイトでの操作を記録してテストケースを作成することが多いようです。Selenium-IDE を最初に開いたとき、「Record」 ボタンはデフォルトでオンになっています。\nSelenium-IDEで自動的に記録を開始したくない場合は、Options \u0026gt; Options… に移動し、\u0026ldquo;Start recording immediately on open.\u0026ldquo;の選択を解除して、これをオフにできます。\n記録中は、ユーザーの操作に基づいて Selenium-IDE がテストケースにコマンドを自動的に挿入します。 次に示すのは、典型的なユーザーの操作です。\n リンクをクリックする - click または clickAndWait コマンド 値を入力する - type コマンド ドロップダウンリストボックスからオプションを選択する - select コマンド チェックボックスまたはラジオボタンをクリックする - click コマンド  いくつか注意すべき点を次に示します。\n typeコマンドが記録されるようにするには、Web ページ上のどこか別の場所をクリックする操作が必要になる場合があります。 リンクをたどる操作は、通常は click コマンドとして記録されます。 多くの場合、 click コマンドは clickAndWait に変更して、新しいページが完全に読み込まれるまでテストケースを確実に停止させる必要があります。 そうしないと、ページに含まれるすべての UI 要素が読み込まれる前にテストケースの実行が先に進み、予期しない形でテストケースが失敗することになります。  コンテキストメニューを使った検証とアサートの追加 テストケースでは、Web ページのプロパティをチェックする必要もあるでしょう。 それには、 assert コマンドと verify コマンドを使う必要があります。 ここでは、これらのコマンドの細かな点には触れません。 テストケースに追加する方法だけを説明します。 コマンドの詳細については、 “Selenese” Selenium コマンド に関する章を参照してください。\nSelenium-IDE の記録機能がオンの状態で、テスト対象のアプリケーションを表示しているブラウザを選択し、ページ上の任意の場所を右クリックします。 すると、 verify コマンドや assert コマンドを含むコンテキストメニューが表示されます。\n初めて Selenium を使う場合には、Selenium コマンドが1つしか表示されないかもしれません。 しかし、IDE を使っていると、メニューに表示されるコマンドがどんどん増えていきます。 Selenium-IDE は、現在の Web ページ上で選択されている UI 要素に応じて、必要なコマンドとパラメータの予測を試みます。\n実際にこの機能をためしてみましょう。 適当な Web ページを開き、ページ上のテキストを選択します。 段落1つか、見出しがいいでしょう。 次に、選択したテキストを右クリックします。 コンテキストメニューが表示され、 verifyTextPresent コマンドと、このコマンドにふさわしいパラメータとして、選択されたテキスト自体が表示されるはずです。\nまた、「利用可能な全てのコマンド」 という項目があることに注目してください。 この項目を選択すると、非常に多くのコマンドが、現在選択されている UI 要素のテストに適したパラメータ案とともに表示されます。\nいくつかほかの UI 要素についても、同じようにためしてみてください。 たとえば、画像を右クリックしたり、ボタンやチェックボックスなどのユーザーコントロールを右クリックしたりしてみてください。 verifyTextPresent 以外のオプションを見るには、「利用可能な全てのコマンド」 を使う必要があるかもしれません。 いったんほかのオプションを選択すると、よく使われるコマンドがトップレベルのコンテキストメニューに表示されるようになります。 たとえば、画像に対して verifyElementPresent を選択すると、次に画像を選択して右クリックしたときに、トップレベルのコンテキストメニューにこのコマンドが表示されるようになります。\n繰り返しになりますが、これらのコマンドの詳細については、Selenium のコマンドに関する章で説明します。 とりあえずここでは、IDE を使ってさまざまなコマンドをテストケースに記録、選択し、テストケースを実行してみてください。IDE を使っていうちに、Selenium のコマンドについても自然に多くのことを学べるはずです。\n編集 コマンドの挿入 テーブル タブ テストケース内のコマンドを挿入する場所を選択します。 右クリックして 「コマンドを挿入」 をクリックします。 コマンド編集用のテキストフィールドを使って、新しいコマンドとそのパラメータを入力します。\nソース タブ テストケース内のコマンドを挿入する場所を選択し、3 列からなる行を 1 つ作成するのに必要な HTML タグを入力します。 この行の 1 列目にはコマンドを、2 列目には最初のパラメータを (パラメータが必要な場合)、3 列目には 2 つ目のパラメータを (パラメータが必要な場合) 入力します。「テーブル」 タグに戻るときは、その前にテストケースを保存します。\n\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Command\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;target (locator)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; コメントの挿入 テストケースの可読性を高めるためにコメントを入力できます。 テストケースの実行時にはコメントは無視されます。\n垂直方向の空白 (1 行以上の空白行) をテストに追加するには、空のコメントを作成する必要があります。 空のコマンドでは実行時にエラーが発生します。\nテーブル タブ テストケース内のコメントを挿入する場所を選択します。 右クリックして 「コメントを挿入」 をクリックします。 「コマンド」 フィールドにコメントを入力します。 入力したコメントは紫色のフォントで表示されます。\nソース タブ テストケース内のコメントを挿入する場所を選択します。 HTML スタイルのコメント、すなわち \u0026lt;!-- これはコメントです -–\u0026gt; を入力します。\nコマンドまたはコメントの編集 テーブル タブ 変更する行を選択し、「コマンド」、「対象」、および 「値」 フィールドを使って内容を編集します。\nソース タブ 「ソース」 タブは WYSIWYG エディタに相当する機能を持っているので、目的の行 (コマンド、パラメータ、またはコメント) を編集します。\nテストケースを開く、保存する ほとんどのプログラムと同様に、「ファイル」メニューには「保存」および「開く」コマンドがあります。 ただし、Seleniumはテストケースとテストスイートを区別します。 後で使用するためにSelenium-IDEテストを保存するには、個々のテストケースを保存するか、テストスイートを保存します。 テストスイートのテストケースが保存されていない場合は、テストスイートを保存する前に保存するよう求められます。\n既存のテストケースまたはスイートを開くと、Selenium-IDEのテストケースペインにSeleniumコマンドが表示されます。\nテストケースの実行 Selenium-IDE には、テストケースを実行するためのさまざまなオプションがあり、1つのテストケースの実行、停止と再開、1 行ずつの実行、現在開発中のコマンドだけの実行、テストスイート全体の実行などが可能です。 Selenium-IDE では、テストケースを非常に柔軟に実行できます。\nテストケースの実行\n「Run」 ボタンをクリックすると、現在表示されているテストケースが実行されます。\nテストスイートの実行\n「Run All」 ボタンをクリックすると、現在読み込まれているテストスイートに含まれるすべてのテストケースが実行されます。\n停止と再開\n「Pause」 ボタンをクリックすると、実行中のテストケースを停止できます。 テストケースの実行を停止すると、ボタンのアイコンは 「Resume」 ボタンのアイコンに変わります。実行を再開するには、「Resume」 ボタンをクリックします。\n途中で実行を停止\nテストケース内でブレークポイントを指定すると、特定のコマンドでテストケースを停止することができます。 この機能は、テストケースをデバッグするときに便利です。 ブレークポイントを指定するには、コマンドを選択し、右クリックして表示されるコンテキストメニューで 「ブレークポイントの指定/解除」 をクリックします。\n途中から実行を開始\nテストケースの途中にある特定のコマンドから実行を開始することができます。 この機能も、テストケースをデバッグするときに便利です。 開始位置を指定するには、コマンドを選択し、右クリックして表示されるコンテキストメニューで 「開始位置の指定/解除」 をクリックします。\n任意のコマンドの実行\n1 つのコマンドだけをダブルクリックすると、そのコマンドを実行することができます。 この機能は、コマンドを 1 つ記述するときに便利です。 作成中のコマンドが適切かどうかわからないときでも、コマンドを即座にテストできます。 コマンドをダブルクリックするだけで、適切に実行されるかどうか確認できます。この機能は、コンテキストメニューからも利用できます。\nBase URL を使った、異なるドメインでのテストケースの実行 Selenium-IDE ウィンドウの上部にある 「Base URL」 フィールドを使うと、テストケースを異なるドメインで実行できるので便利です。 たとえば、 http://news.portal.com という名前のサイトが http://beta.news.portal.com という名前でインハウスのベータサイトを持っていたとします。 この場合、これらのサイトが対象で、 open ステートメントで始まるすべてのテストケースについて、 open の引数に 絶対 URL (http: または https: などのプロトコルで始まる URL) ではなく、 相対 URL を指定します。 すると、Selenium-IDE は、[Base URL] フィールドに入力された値の最後に、 open コマンドの引数を追加して、絶対 URL を作成します。 たとえば次のテストケースは、 http://news.portal.com/about.html を対象に実行されます。\nここで、「Base URL」 フィールドの設定を変更してテストケースを実行すれば、同じテストケースが今度は http://beta.news.portal.com/about.html を対象に実行されます。\nSelenium コマンド- \u0026ldquo;Selenese\u0026rdquo; Selenium コマンドは、多くの場合seleneseと呼ばれ、テストを実行するコマンドのセットです。 これらのコマンドのシーケンスはテストスクリプトです。 ここでは、これらのコマンドを詳細に説明し、Seleniumを使用するときにWebアプリケーションをテストする際に選択できる多くの選択肢を示します。\nSeleniumには、想像できるあらゆる方法でWebアプリを完全にテストするための豊富なコマンドセットが用意されています。 この一連のコマンドは、よくseleneseと呼ばれます。 これらのコマンドは、基本的にテスト言語を作成します。\nseleneseでは、HTMLタグに基づいてUI要素の存在をテストしたり、特定のコンテンツをテストしたり、壊れたリンクをテストしたり、入力フィールド、選択リストオプション、フォームを送信したり、テーブルデータなどをテストできます。 さらに、Seleniumコマンドは、ウィンドウサイズ、マウス位置、アラート、Ajax機能、ポップアップウィンドウ、イベント処理、およびその他の多くのWebアプリケーション機能のテストをサポートしています。 コマンドリファレンスには、使用可能なすべてのコマンドがリストされています。\nコマンドは、Seleniumに何をすべきかを伝えます。 Seleniumコマンドには、 アクション 、 アクセサ 、アサーション という3つの\u0026quot;フレーバー\u0026quot;があります。\n  アクション は、一般的にアプリケーションの状態を操作するコマンドです。 \u0026ldquo;このリンクをクリックする\u0026rdquo; や \u0026ldquo;そのオプションを選択する\u0026rdquo; といったことを実行します。 アクションが失敗するか、エラーがある場合、現在のテストの実行は停止されます。\n\u0026ldquo;AndWait\u0026rdquo; 接尾辞を使用して、多くのアクションを呼び出すことができます。（例 : \u0026ldquo;clickAndWait\u0026rdquo;） この接尾辞は、アクションによってブラウザーがサーバーを呼び出すこと、およびSeleniumが新しいページの読み込みを待つことをSeleniumに伝えます。\n  アクセサー はアプリケーションの状態を調べ、結果を変数に保存します。（例 : \u0026ldquo;storeTitle\u0026rdquo;） また、アサーションを自動的に生成するためにも使用されます。\n  アサーション はアクセサーに似ていますが、アプリケーションの状態が期待どおりになっていることを検証します。 たとえば、\u0026ldquo;ページタイトルがXであることを確認する\u0026rdquo; 、\u0026ldquo;このチェックボックスがオンになっていることを確認する\u0026rdquo; などです。\n  すべてのSeleniumアサーションは、\u0026ldquo;assert\u0026rdquo;、\u0026ldquo;verify\u0026rdquo;、および \u0026ldquo;waitFor\u0026quot;の3つのモードで使用できます。 たとえば、\u0026ldquo;assertText\u0026rdquo;、\u0026ldquo;verifyText\u0026rdquo;、\u0026ldquo;waitForText\u0026quot;を使用できます。 \u0026ldquo;assert\u0026rdquo; が失敗すると、テストは中止されます。 \u0026ldquo;verify\u0026rdquo; が失敗すると、テストは実行を継続し、失敗を記録します。 これにより、単一の \u0026ldquo;assert\u0026rdquo; でアプリケーションが正しいページにあることを確認し、続いてフォームフィールドの値、ラベルなどをテストするための \u0026ldquo;verify\u0026rdquo; アサーションが多数行われます。\n\u0026ldquo;waitFor\u0026rdquo; コマンドは、何らかの条件が真になるまで待機します（Ajaxアプリケーションのテストに役立ちます）。 条件がすでに真であれば、すぐに成功します。 ただし、現在のタイムアウト設定内で条件が真にならない場合、それらは失敗し、テストを停止します（以下のsetTimeoutアクションを参照）。\nスクリプトシンタックス Seleniumコマンドは単純で、コマンドと2つのパラメーターで構成されています。 例えば、\n          verifyText //div//a[2] Login    パラメーターは必ずしも必要ではありません。 コマンドに依存します。 両方のパラメータが必要な場合もあれば、1つのパラメータが必要な場合もあります。 また、コマンドがパラメータをまったく受け取らない場合もあります。 ここにいくつかの例があります。\n          goBackAndWait     verifyTextPresent  Welcome to My Home Page   type id=phone (555) 666-7066   type id=address1 ${myVariableAddress}    コマンドリファレンスでは、各コマンドのパラメーター要件について説明しています。\nパラメーターは異なりますが、通常は、\n ページ内のUI要素を識別するためのロケーター 予想されるページコンテンツを検証またはアサートするためのテキストパターン 入力フィールドにテキストを入力するため、またはオプションリストからオプションを選択するためのテキストパターンまたはSelenium変数  ロケーター、テキストパターン、Selenium変数、およびコマンド自体については、Seleniumコマンドの章で詳しく説明します。\nSelenium-IDEから実行されるSeleniumスクリプトは、HTMLテキストファイル形式で保存されます。 これは、3つの列を持つHTMLテーブルで構成されます。 最初の列はSeleniumコマンドを示し、2番目の列はターゲットであり、最後の列には値が含まれています。 2番目と3番目の列は、選択したSeleniumコマンドによっては値を必要としない場合がありますが、存在する必要があります。 各テーブル行は、新しいSeleniumコマンドを表します。 以下は、ページを開き、ページタイトルをアサートし、ページ上のコンテンツを検証するテストの例です。\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;/download/\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;assertTitle\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;verifyText\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;//h2\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; ブラウザでテーブルとしてレンダリングされると、次のようになります。\n          open /download/    assertTitle  Downloads   verifyText //h2 Downloads    The Selenese HTML syntax can be used to write and run tests without requiring knowledge of a programming language. With a basic knowledge of selenese and Selenium-IDE you can quickly produce and run testcases.\nテストスイート テストスイートは、テストのコレクションです。 多くの場合、テストスイート内のすべてのテストを1つの連続バッチジョブとして実行します。\nSelenium-IDEを使用する場合、テストスイートは単純なHTMLファイルを使用して定義することもできます。 構文も簡単です。 HTMLテーブルはテストのリストを定義し、各行は各テストへのファイルシステムパスを定義します。 例ですべてがわかります。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Suite Function Tests - Priority 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Suite Of Tests\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./Login.html\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SearchValues.html\u0026#34;\u0026gt;Test Searching for Values\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SaveValues.html\u0026#34;\u0026gt;Test Save\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; これと似たファイルを使用すると、Selenium-IDEから次々にテストを実行できます。\nSelenium-RCを使用している場合、テストスイートも維持できます。 これはプログラミングによって行われ、いくつかの方法で行うことができます。 通常、Junitは、JavaでSelenium-RCを使用している場合にテストスイートを維持するために使用されます。 さらに、C#が選択された言語である場合、Nunitを使用できます。 Selenium-RCでPythonのようなインタープリター言語を使用する場合、テストスイートのセットアップにいくつかの簡単なプログラミングが含まれます。 Selenium-RCを使用する理由はすべて、テストにプログラミングロジックを使用することであるため、通常これは問題になりません。\n一般的に使用されるSeleniumコマンド Seleniumの紹介を終了するために、いくつかの典型的なSeleniumコマンドを紹介します。 これらはおそらく、テストを構築するために最も一般的に使用されるコマンドです。\nopen\nURLを使用してページを開きます。\nclick/clickAndWait\nクリック操作を実行し、オプションで新しいページがロードされるのを待ちます。\nverifyTitle/assertTitle\n期待されるページタイトルを検証します。\nverifyTextPresent\n期待されるテキストがページのどこかにあることを確認します。\nverifyElementPresent\nHTMLタグで定義されている、期待されるUI要素がページに存在することを確認します。\nverifyText\n期待されるテキストとそれに対応するHTMLタグがページに存在することを確認します。\nverifyTable\nテーブルの期待される内容を検証します。\nwaitForPageToLoad\n期待される新しいページがロードされるまで実行を一時停止します。 clickAndWaitが使用されると自動的に呼び出されます。\nwaitForElementPresent\nHTMLタグで定義されているように、期待されるUI要素がページに表示されるまで実行を一時停止します。\nページ要素の検証 ページ上の UI 要素の検証は、自動化されたテストではおそらく最もよく使われる機能でしょう。 Selenese では、UI 要素をさまざまな方法でチェックすることができます。 実際のテスト対象はどの方法を使うかによって左右されるので、これらの方法の違いを理解することが重要になります。\nたとえば、現在テストしようとしているのは、次のどれでしょうか\u0026hellip;。\n ある要素がページ上のどこかに存在しているかどうか。 特定のテキストがページ上のどこかに存在しているかどうか。 特定のテキストがページ上の特定の場所に存在しているかどうか。  テキスト見出しをテストする場合、おそらくテスト対象として適しているのは、ページ先頭のテキストとその位置でしょう。 一方、画像がホームページ上に存在するかどうかをテストする場合で、Web デザイナーが具体的な画像ファイルとそのページ上の位置を頻繁に変更しているようなケースでは、(具体的な画像ファイルではなく) 画像 が ページ上のどこかに存在しているかどうかをテストする方が適切でしょう。\nアサーションと検証 “assert” (アサート) と “verify” (検証) のどちらを使うかは、利便性、そしてエラーの扱いをどうするかによって決まります。 期待されたページがブラウザに表示されているかどうかをチェックするテストがすでに失敗しているのに、そのページの最初のパラグラフが正しいものかどうかをチェックしても、ほとんど意味はありません。 目的のページが表示されていなければ、テストケースを中止して、何が原因かすぐ調べて、問題を解決した方がよいでしょう。 一方、最初のエラーでテストケースを中止せず、ページ上の多くの属性をチェックしたい場合もあります。 こうすれば、該当するページ上のすべてのエラーをまとめて見直し、適切な対応策を講じることができます。 Selenium のコマンドを使う場合、”assert” では、テストがエラーになり、現在のテストケースは中止されますが、”verify” では、テストはエラーになるものの、テストケースの実行は続行されます。\nこの機能を上手に活用するには、テストのコマンドを論理的にグループ化し、各グループを “assert” で始め、その後に 1 つまたは複数の “verify” コマンドを続けて記述します。 例を次に示します。\n   Command Target Value     open /download/    assertTitle  Downloads   verifyText //h2 Downloads   assertTable 1.2.1 Selenium IDE   verifyTable 1.2.2 June 3, 2008   verifyTable 1.2.3 1.0 beta 2    上記の例では、最初にページを開き、次にタイトルを期待値と比較することで正しいページがロードされることを“アサート”します。 これが成功した場合にのみ、次のコマンドが実行され、テキストが予想される場所に存在することを“検証”します。 テストケースは、最初のテーブルの2行目の最初の列に期待値が含まれていることを“アサート”します。 これに合格した場合にのみ、その行の残りのセルが“検証”されます。\nverifyTextPresent verifyTextPresent コマンドは、 特定のテキストがページ上のどこかに存在することを検証するのに使います。 このコマンドは引数を 1 つだけ取ります。 引数には、検証するテキストのパターンを指定します。 次に例を示します。\n   Command Target Value     verifyTextPresent Marketing Analysis     この例では、現在テストの対象になっているページ上で “Marketing Analysis” というテキスト文字列を探し、この文字列がページ上のどこかにあるかどうかを検証します。 verifyTextPresent コマンドは、テキストそれ自体がページ上に存在するかどうかだけを調べるときに使います。 テキストがページ上に現れる場所もテストの対象に含める必要がある場合には、このコマンドは使わないでください。\nverifyElementPresent このコマンドは、特定の UI 要素について、その内容ではなく、要素の存在自体をチェックするのに使います。 具体的にはテキストはチェックせず、HTML タグだけをチェックします。 一般的な使い方として、画像が存在するかどうかのチェックなどがあります。\n   Command Target Value     verifyElementPresent //div/p/img     この例では、\u0026lt;img\u0026gt; HTML タグの存在によって指定される画像が、ページ上に存在するかどうか、そして \u0026lt;img\u0026gt; タグが \u0026lt;div\u0026gt; タグと \u0026lt;p\u0026gt; タグに続いて出現するかどうかを検証しています。 最初の (1 つだけの) パラメータは、要素を探す方法を Selenese コマンドに指示するための ロケータ です。 ロケータについては、次のセクションで説明します。\nverifyElementPresentを使用して、ページ内のHTMLタグの存在を確認できます。 リンク、段落、分割 \u0026lt;div\u0026gt;などの存在を確認できます。 さらにいくつかの例を示します。\n   Command Target Value     verifyElementPresent //div/p    verifyElementPresent //div/a    verifyElementPresent id=Login    verifyElementPresent link=Go to Marketing Research    verifyElementPresent //a[2]    verifyElementPresent //head/title     これらの例は、UI要素をテストするさまざまな方法を示しています。 繰り返しになりますが、ロケータについては次のセクションで説明します。\nverifyText テキストとそのUI要素の両方をテストする必要がある場合は、verifyTextを使用します。 verifyTextはロケーターを使用する必要があります。 XPath ロケーターまたは DOM ロケーターを選択した場合、特定のテキストが、ページ上のほかの UI コンポーネントとの相対位置で指定される特定の場所に出現するかどうかを検証できます。\n   Command Target Value     verifyText //table/tr/td/div/p This is my text and it occurs right after the div inside the table.    要素の特定 多くの Selenium コマンドでは、対象を指定する必要があります。 この対象は、Web アプリケーションのコンテキスト内で要素を特定するためのもので、ロケーションストラテジーに続けて、 locatorType=location の形でロケーションを指定します。 多くの場合、ロケーションのタイプは省略できます。 ロケーションのタイプについては、以下で例を挙げながら説明します。\n識別子による特定 この方法は、要素を特定する方法としておそらく最も一般的で、ロケータタイプとして認識されるものが使われていない場合の汎用デフォルトです。 このストラテジーでは、id 属性を持つ要素のうち、ロケーションに一致する最初の要素が使われます。 id 属性に一致する要素がない場合には、name 属性を持つ要素のうち、ロケーションに一致する最初の要素が使われます。\nたとえば、ページソースに次のような id 属性と name 属性があったとします。\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; この場合、次のロケータストラテジーは、上の HTML 断片のうち、行番号で示される部分の要素を返します。\n identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)  identifier タイプのロケーターはデフォルトであるため、上記の最初の3つの例の identifier= は必要ありません。\nidによる特定 このタイプのロケータは identifier ロケータタイプよりも限定の度合いは高くなりますが、それと同時に、より明示的になります。要素の id 属性がわかっている場合に使用します。\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  id=loginForm (3)  Nameによる特定 name ロケータタイプは、nama 属性に一致する最初の要素を特定します。 1つの name 属性に対して、複数の要素が同じ値を持っている場合には、フィルタを使ってロケーションストラテジーの精度を高めることができます。 デフォルトのフィルタタイプは value です (value 属性に一致)。\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7)  注 : 一部のタイプの XPath ロケータや DOM ロケータと異なり、これまでに示した 3 つのタイプのロケータを使えば、ページ上の位置に関係なく UI 要素をテストすることができます。 したがって、ページの構造や構成が変わっても、テストはパスします。 ページの構造が変わったかどうかについては、テストしたい場合もテストしたくない場合もあるでしょう。 Web デザイナーが頻繁にページに手を加えていて、ページの機能を回帰テストの対象にする必要がある場合には、id 属性や name 属性、または任意の HTML プロパティによるテストが非常に重要になります。\nXPathによる特定 XPath は、XML ドキュメント内のノードを特定するために使われる言語です。 HTML は XML (XHTML) の実装でもありうるので、Selenium ユーザーは XPath という強力な言語を使って、Web アプリケーション内の要素を特定することができます。 XPath は、id 属性や name 属性による要素の特定という単純な方法を (サポートすると当時に) さらに拡張しており、ページ上の3番目のチェックボックスを特定するなど、あらゆる種類の新しい可能性を開いてくれる言語です。\nXPathを使う主な理由の1つは、特定したい要素に対応する適切な id 属性や name 属性がない場合があることです。 XPathを使うと、要素を絶対的に特定したり (ただし、このやり方は推奨されません)、id 属性または name 属性を持つ要素からの相対位置で要素を特定したりできます。 XPath ロケータを使って、id や name 以外の属性から要素を特定することもできます。\n絶対 XPath には、ルート (html) からのすべての要素の位置が含まれており、したがって 、アプリケーションにわずかな変更を加えただけで、XPath による特定がうまくいかなる可能性があります。 id 属性または name 属性を持つ近くの要素 (理想的には親要素) を見つけることによって、対象となる要素を相対関係に基づいて特定できるようになります。 これは、アプリケーションに変更が加えられても変わる可能性は低く、テストをより堅牢にすることができます。\nxpath ロケーターのみが \u0026ldquo;//\u0026rdquo; で始まるため、XPathロケーターを指定するときに xpath= ラベルを含める必要はありません。\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  xpath=/html/body/form[1] (3) - 絶対パス（HTMLが少しだけ変更された場合に壊れます） //form[1] (3) - HTMLの最初のフォーム要素 xpath=//form[@id='loginForm'] (3) - \u0026lsquo;id\u0026rsquo; という名前の属性と値 \u0026lsquo;loginForm'を持つフォーム要素 xpath=//form[input/@name='username'] (3) - \u0026lsquo;name'という名前の属性と値 \u0026lsquo;username\u0026rsquo; を持つ入力子要素を持つ最初のフォーム要素 //input[@name='username'] (4) - \u0026lsquo;name'という名前の属性と\u0026rsquo;username\u0026rsquo; という値を持つ最初の入力要素 //form[@id='loginForm']/input[1] (4) - \u0026lsquo;id'という名前の属性と\u0026rsquo;loginForm'という値を持つフォーム要素の最初の入力子要素 //input[@name='continue'][@type='button'] (7) - \u0026lsquo;name'という名前の属性と\u0026rsquo;continue'という値の属性、\u0026lsquo;type'という名前の属性と\u0026rsquo;button'という値の入力 //form[@id='loginForm']/input[4] (7) - \u0026lsquo;id'という名前の属性と\u0026rsquo;loginForm'という値を持つフォーム要素の4番目の入力子要素  これらの例では、いくつかの基本的な使い方を示しています。XPath の指定方法の詳細については、次の参考資料を読むことをお勧めします。\n W3Schools XPath Tutorial W3C XPath Recommendation  また、要素のXPathを検出するのに役立つ非常に便利なFirefoxアドオンがいくつかあります。\n XPath Checker XPathおよびXPath結果のテストに使用できます。 [Firebug](https://addons.mozilla.org/en-US/firefox/addon/1843 - XPathの提案は、この非常に便利なアドオンの多くの強力な機能の1つにすぎません。  リンクテキストによるハイパーリンクの特定 これは、リンクのテキストを使用してWebページのハイパーリンクを特定する簡単な方法です。 同じテキストの2つのリンクが存在する場合、最初に一致したものが使われます。\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Are you sure you want to do this?\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;continue.html\u0026#34;\u0026gt;Continue\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;cancel.html\u0026#34;\u0026gt;Cancel\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  link=Continue (4) link=Cancel (5)  DOMによる特定 ドキュメントオブジェクトモデルはHTMLドキュメントを表し、JavaScriptを使用してアクセスできます。 このロケーションストラテジーでは、ページ上の要素に評価される JavaScript を使用します。 単に階層型ドット記法を使って要素の位置を特定できます。\n\u0026ldquo;document\u0026rdquo; で始まるのは dom ロケーターだけなので、DOMロケーターを指定するときに dom= ラベルを含める必要はありません。\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  dom=document.getElementById('loginForm') (3) dom=document.forms['loginForm'] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements['username'] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7)  Selenium それ自体に加え、ほかのサイトや拡張機能を利用すれば、作成中のアプリケーションの DOM について詳しく知ることができます。 W3Schoolsには適切なリファレンスがあります。\nCSSによる特定 CSS (Cascading Style Sheets) は、HTML ドキュメントと XML ドキュメントのレンダリングについて記述するための言語です。 CSS では、セレクタを使って、ドキュメント内の要素にスタイルプロパティをバインドしています。 Selenium では、これらのセレクタをロケーションストラテジーとして利用できます。\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;required\u0026#34; name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;required passfield\u0026#34; name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  css=form#loginForm (3) css=input[name=\u0026quot;username\u0026quot;] (4) css=input.required[type=\u0026quot;text\u0026quot;] (4) css=input.passfield (5) css=#loginForm input[type=\u0026quot;button\u0026quot;] (7) css=#loginForm input:nth-child(2) (5)  CSSセレクターの詳細については、the W3C publicationをご覧ください。 詳しいリファレンスもここにあります。\n暗黙のロケーター 次の状況では、ロケータータイプを省略することができます。\n  ロケーター戦略が明示的に定義されていないロケーターは、デフォルトで識別子ロケーター戦略を使用します。 idによる特定　をご覧ください。\n  \u0026ldquo;//\u0026rdquo; で始まるロケーターは、XPathロケーター戦略を使用します。 XPathによる特定 をご覧ください。\n  \u0026ldquo;document\u0026rdquo; で始まるロケーターは、DOMロケーター戦略を使用します。 DOMによる特定 をご覧ください。\n  テキストパターンとの一致 ロケータ同様、 パターン も Selenese コマンドでしばしば必要になるタイプのパラメータです。パターンを指定する必要があるコマンドとしては、 verifyTextPresent 、 verifyTitle 、 verifyAlert 、 assertConfirmation 、 verifyText 、 verifyPrompt などがあります。 また、すでに示したリンクロケータでも、パターンを使用できます。 パターンを使うと、テキストを正確に指定しなくても、期待されるテキストを特殊文字の使用を通じて 記述 することができます。\nパターンには、 globbing 、 regular expressions 、 exact の 3 つの種類があります。\nグロビングパターン ほとんどのユーザーは、グロビングについてはすでによく知っていることでしょう。 グロビングは、DOS や Unix/Linux のコマンドラインで ls *.cなどとしてファイル名を展開するときに使われています。 この例では、現在のディレクトリ内に存在する拡張子 .cで終わるすべてのファイルが表示されます。 グロビングにはかなり制限があります。 Selenium の実装でサポートされている特殊文字は、次の 2 つだけです。\n*「何にでも一致」します。すなわち、何もなし、1 文字だけ、複数の文字のすべてに一致します。\n[ ] ( 文字クラス )。\u0026ldquo;角かっこ内の任意の 1 文字に一致\u0026quot;します。 ダッシュ文字 (ハイフン。 “-“) を使って文字の範囲 (ASCII 文字セットで連続する文字の範囲) を指定できます。 文字クラスのはたらきについては、いくつか実例を挙げた方がわかりやすいでしょう。\n[aeiou] は任意の小文字の母音に一致します。\n[0-9] は任意の数字に一致します。\n[a-zA-Z0-9] は任意の英数字に一致します。\nグロビングのほとんどの実装では、3 つ目の特殊文字として ? が含まれています。 しかし、Selenium のグロビングパターンでサポートされているのは、アスタリスク (*) と文字クラスだけです。\nSelenese コマンドでグロビングパターンを指定するには、指定するパターンの前に glob: ラベルを付けます。 ただし、グロビングパターンはデフォルトなので、このラベルを省略してパターンだけを指定することもできます。\n次に示すのは、グロビングパターンの使用例です。 ページ上の実際のリンクテキストは “Film/Television Department” でした。 正確に一致するテキストではなく、パターンを使うと、リンクのテキストが “Film \u0026amp; Television Department” や “Film and Television Department” に変更された場合でも、 click コマンドが動作するようになります。 グロビングパターンのアスタリスクは、 “Film” という単語と “Television” という単語の間に何もなくても、または何があっても一致します。\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle glob:*Film*Television*     リンクをクリックして表示されるページの実際のタイトルは “De Anza Film And Television Department - Menu” でした。正確に一致するテキストではなく、パターンを使うと、ページのタイトルに “Film” と “Television” の 2 つの単語が (この順序で) 出現する限り、 verifyTitle はパスします。 たとえば、ページのオーナーがタイトルを短縮して “Film \u0026amp; Television Department” としても、テストはパスします。リンクとリンクが動作するかどうかのテスト (上の例では verifyTitle) との両方でパターンを使うことで、こうしたテストケースの保守の手間を大幅に減らすことができます。\n正規表現パターン 正規表現 パターンは、Selenese がサポートしている 3 種類のパターンの中で最も強力です。 正規表現はほとんどの高水準プログラミング言語、多くのテキストエディタ、さらに Linux/Unix のコマンドラインユーティリティである grep や sed 、 awk など、さまざまなツールでもサポートされています。 Selenese では、正規表現パターンを使うと、それ以外の方法では実現が難しい数多くのタスクを実行することができます。 たとえば、テーブルの特定のセルに入力されているのが数字だけかどうかをテストする必要があるとします。 この場合、 regexp: [0-9]+ と指定するだけで、任意の長さの数字に一致させることができます。\nSelenese のグロビングパターンでサポートしているのは * と [ ] (文字クラス) だけですが、Selenese の正規表現パターンでは JavaScript に存在するものと同じ幅広い特殊文字を使用できます。 次に示すのは、これらの特殊文字です。\n   PATTERN MATCH     . any single character   [ ] character class: any single character that appears inside the brackets   * quantifier: 0 or more of the preceding character (or group)   + quantifier: 1 or more of the preceding character (or group)   ? quantifier: 0 or 1 of the preceding character (or group)   {1,5} quantifier: 1 through 5 of the preceding character (or group)   | alternation: the character/group on the left or the character/group on the right   ( ) grouping: often used with alternation and/or quantifier    Selenese の正規表現パターンでは、先頭に regexp: または regexpi: を付ける必要があります。 前者は大文字と小文字を区別しますが、後者は大文字と小文字を区別しません。\nSelenese コマンドでの正規表現パターンの使い方については、いくつか実例を挙げた方がわかりやすいでしょう。 最初の例は、おそらく最もよく使われる正規表現である .* (“ドットスター”) を使ったものです。 この 2 文字の並びは、「任意の文字の 0 回以上の繰り返し」、もっとかみくだいて言えば、「すべて、または何もない」ものに一致します。1 文字のグロビングパターンで * (アスタリスク 1 つ) と指定するのと等価です。\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle regexp:.*Film.*Television.*     上のテスト例は、すでに示したグロビングパターンを使ったテストの例と機能的には同じです。 違いは、プリフィックス (glob: の代わりに regexp: が使われていること) と、「すべて、または何もない」パターンが指定されていること ( * の代わりに .* が使われていること) だけです。\n次に示すのは、アラスカ州アンカレジの日の出時刻に関する情報が掲載されている Yahoo! Weather のページを対象としたもう少し複雑なテスト例です。\n   Command Target Value     open http://weather.yahoo.com/forecast/USAK0012.html    verifyTextPresent regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m     上の例で使われている正規表現を 1 つずつ見てみましょう。\n         Sunrise: * Sunrise: という文字列とそれに続く 0 個以上の空白   [0-9]{1,2} 1 個または 2 個の数字 (時間を表す)   : 文字 : そのもの (特殊文字は使われていない)   [0-9]{2} 2 個の数字 (分を表す) とそれに続く 1 個の空白   [ap]m 文字 “a” または “p” とそれに続く “m” (am または pm)    完全一致 Selenium の 完全一致 パターンは、それほど使う機会はないでしょう。 完全一致パターンでは、特殊文字は一切使いません。 したがって、(グロビングパターンと正規表現パターンでは特別な意味を持つ) アスタリスク文字を検索する必要がある場合には、完全一致パターンを使うのも 1 つの方法です。 たとえば、ドロップダウンリストで “Real *” というラベルの付いた項目を選択する場合、次のようなコードでは、期待どおりに動作する場合もそうでない場合もあります。 glob:Real *パターンに含まれるアスタリスクは、「すべて、または何もない」ものに一致します。 したがって、目的の select のオプションより前に “Real Numbers” というラベルの付いたオプションがあれば、それが選択され、目的の “Real *” というオプションは選択されないことになります。\n   Command Target Value     select //select glob:Real *    項目 “Real *” が確実に選択されるようにするには、 exact: プリフィックスを使って次のように 完全一致 パターンを指定します。\n   Command Target Value     select //select exact:Real *    ただし、正規表現パターンで次のようにアスタリスクをエスケープしても同じ結果が得られます。\n   Command Target Value     select //select regexp:Real \\*    ほとんどのテスターは、アスタリスクや、文字が間に入った角かっこの対 (グロビングパターンの文字クラス指定) を検索する必要はないでしょう。 したがって、大半のユーザーにとっては、グロビングパターンと正規表現パターンだけで十分なはずです。\n“AndWait” コマンド あるコマンドとそのコマンドに対応する AndWait コマンドとの違いは、通常のコマンド (click など) が、操作を実行すると可能な限り速やかに次のコマンドの実行を続けるのに対し、 AndWait コマンド (clickAndWait など) は、操作が実行された後、ページが読み込まれるまで 待機する よう Selenium に指示する点にあります。\n目的の操作によってブラウザがほかのページに移動したり、現在のページをリロードしたりする場合には、常に AndWait コマンドを使います。\nただし、ほかのページへの移動やページの更新を伴わない操作に対して AndWait コマンドを使うと、テストは失敗します。 テストが失敗する理由は、ほかのページへの移動や更新が行われないまま AndWait のタイムアウトに達して、Selenium がタイムアウト例外を発生させるためです。\nAJAX アプリケーションにおける waitFor コマンド AJAX 駆動型 Web アプリケーションでは、ページを更新することなく、サーバーからデータが取得されます。 この場合、実際にはページが更新されないため、 andWait コマンドは動作しません。 一定時間、テストの実行を停止するやり方も、優れた対応策とは言えません。 当該時点でのシステムの応答性能、負荷、その他の制御不可能な要素によって、指定された時間よりも早く、あるいは遅く、目的の Web 要素が表示されることがあり、その場合にはテストが失敗するからです。 最も適切なアプローチは、動的な期間、必要な要素が表示されるのを待って、要素が見つかり次第、テストの実行を続行するやり方です。\nwaitFor コマンドを使うと、このようなやり方を実現できます。 waitForElementPresent や waitForVisible は、動的な期間、待機し、目的の条件が満たされるかどうかを毎秒チェックし、条件が満たされると同時にスクリプトの次のコマンドの実行を続けます。\n評価順序とフロー制御 スクリプトを実行すると、そのスクリプトに含まれるコマンドが順序に従って実行されます。\nSelenese それ自体は、条件判定文 (if-else など) または反復 (for、while など) をサポートしていません。 フロー制御を使わなくても、多くの有用なテストは実行できます。 しかし、複数のページが関係することが多い動的コンテンツをきちんとテストするには、プログラミングロジックがしばしば必要になります。\nフロー制御が必要になった場合には、次の 3 つの選択肢があります。\na) Selenium-RC と、Java や PHP といったクライアントライブラリを使ってスクリプトを実行し、プログラミング言語の持つフロー制御機能を利用する。 b) スクリプトの内部から storeEval コマンドを使って小さな JavaScript コードの断片を実行する。 c) goto_sel_ide.js extension 拡張スクリプトをインストールする。\nほとんどのテスターは、テストスクリプトをプログラミング言語ファイルにエクスポートし、Selenium-RC API を利用する方法を選択することになるでしょう (Selenium-RC API については、Selenium-RC に関する章を参照)。 ただし、組織によっては、可能な限りテストスクリプトを Selenium-IDE から実行した方が都合がよい場合もあります (テストの実行を多数の契約社員に担当させている組織や、十分なプログラミングスキルを期待できないケースなど)。 このような場合には、JavaScript コードの断片を利用する方法か、goto_sel_ide.js 拡張スクリプトを使う方法を検討するとよいでしょう。\nstore コマンド群と Selenium 変数 Selenium 変数を使うと、スクリプトの冒頭で定数を格納することができます。 また、データ駆動型テスト設計と組み合わせて使う場合には (あとのセクションで取り上げます)、コマンドライン、ほかのプログラム、またはファイルからテストプログラムに渡す値を Selenium 変数に格納することができます。\nプレーンな store コマンドは、たくさんある store コマンド群の中で最も基本的なコマンドで、Selenium 変数に単純に定数値を格納するのに使用できます。 store コマンドは、変数に格納するテキスト値と Selenium 変数の 2 つのパラメータを取ります。 変数の名前を付けるときは、英数文字だけを使う標準的な命名規則に従ってください。\n   Command Target Value     store paul@mysite.org     上のように記述すると、スクリプトのあとの方で、変数に格納された値を利用できます。 変数の値にアクセスするには、次に示すように、変数をブレース ({}) で囲み、先頭にドル記号を付けます。\n   Command Target Value     verifyText //div/p \\${userName}    変数の一般的な使い方の 1 つに、入力フィールドへの入力を格納する操作があります。\n   Command Target Value     type id=login \\${userName}    Selenium 変数は、最初のパラメータにも 2 番目のパラメータにも使用することができます。 コマンドのパラメータに変数が使われている場合、変数は、このコマンドが実行するほかのあらゆる操作に先立って Selenium によって解釈されます。 Selenium 変数をロケータ表現の内部で使うこともできます。\nverify および assert コマンドのそれぞれに対し、対応する store コマンドが存在します。 これらのコマンドのうち、よく使われるものを以下に示します。\nstoreElementPresent storeElementPresent は、verifyElementPresent に対応するコマンドです。 このコマンドは、UI 要素が見つかったかどうかに応じて、ブール値 (“true” または “false” のいずれか) を格納します。\nstoreText StoreText は、verifyText に対応するコマンドです。 このコマンドはロケータを使ってページ上の特定のテキストを探します。 テキストが見つかった場合には、そのテキストが変数に格納されます。 storeText を使うと、テスト対象のページからテキストを抽出することができます。\nstoreEval storeEval の最初のパラメータにはスクリプトを指定します。 JavaScript を Selenese に埋め込む方法については、次のセクションで取り上げます。 テストの中で storeEval を使うと、スクリプトの実行結果を変数に格納することができます。\nJavaScript と Selenese パラメータ JavaScript は、 スクリプト と非スクリプト (一般には式) の 2 つの種類の Selenese パラメータで使用できます。 ほとんどの場合は、Selenese パラメータに指定された JavaScript コードの断片の中で、テストケース変数にアクセスしたり操作したりすることが多いでしょう。 テストケース内で作成されたすべての変数は、JavaScript の 連想配列 に格納されます。連想配列とは、連番の添字ではなく、文字列を添字にもつ配列のことです。 作成したテストケースの変数が格納される連想配列には、 storedVars という名前が付けられます。 JavaScript コードの断片で変数にアクセスしたり操作したりするには、必ず storedVars[\u0026lsquo;yourVariableName\u0026rsquo;] の形で参照する必要があります。\nスクリプトパラメータでの JavaScript の使用 いくつかの Selenese コマンド、たとえば assertEval 、 verifyEval 、 storeEval 、 waitForEval などのコマンドでは、 スクリプト パラメータを指定します。これらのパラメータでは特別な構文は必要ありません。 Selenium-IDE ユーザーなら、JavaScript コードの断片の適切なフィールドを入力するだけです (通常、入力先のフィールドは 対象 フィールドです。 スクリプト パラメータは一般に、最初のパラメータか唯一のパラメータのいずれかだからです) 。\n次に示すのは、JavaScript コードの断片を使って簡単な算術演算を行う例です。\n   Command Target Value     store 10 hits   storeXpathCount //blockquote blockquotes   storeEval storedVars[\u0026lsquo;hits\u0026rsquo;].storedVars[\u0026lsquo;blockquotes\u0026rsquo;] paragraphs    次に示すのは、JavaScript コードの断片でメソッドを呼び出す例です。 この例では、JavaScript String オブジェクトの toUpperCase メソッドと toLowerCase メソッドを呼び出しています。\n   Command Target Value     store Edith Wharton name   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() uc   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() lc    非スクリプトパラメータでの JavaScript の使用 コマンドが取るパラメータの種類が スクリプト ではない場合でも、パラメータに使う値を JavaScript を使って生成することができます。 ただし、この場合には特別な構文が必要になり、JavaScript コードの断片をブレースで囲み、その前にラベル javascript を付ける必要があります。 具体的には、 javascript {*ここにコードを記述*} のように指定します。 次に示すのは、 type コマンドの 2 番目のパラメータ value を、特別な構文を使って JavaScript コードから生成する例です。\n   Command Target Value     store league of nations searchString   type q javascript{storedVars[\u0026lsquo;searchString\u0026rsquo;].toUpperCase()}    echo - Selenese の Print コマンド Selenese には、テスト出力にテキストを書き込むことができる簡単なコマンドが用意されています。 このコマンドを使うと、テストの実行中に進捗状況を示す情報をコンソールに表示できるので便利です。 これらの情報を使えば、テスト結果のレポートに実行時の状況を埋め込むこともできるので、テストで問題が見つかったときに、ページ上のどこにバグがあるのか探すのに役立ちます。 また、echo 文を使うと、Selenium 変数の内容を出力できます。次に例を示します。\n   Command Target Value     echo Testing page footer now.    echo Username is \\${userName}     警告、ポップアップ、および複数のウィンドウ 次のようなページをテストしているとします。\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function output(resultText){ document.getElementById(\u0026#39;output\u0026#39;).childNodes[0].nodeValue=resultText; } function show_confirm(){ var confirmation=confirm(\u0026#34;Chose an option.\u0026#34;); if (confirmation==true){ output(\u0026#34;Confirmed.\u0026#34;); } else{ output(\u0026#34;Rejected!\u0026#34;); } } function show_alert(){ alert(\u0026#34;I\u0026#39;m blocking!\u0026#34;); output(\u0026#34;Alert is gone.\u0026#34;); } function show_prompt(){ var response = prompt(\u0026#34;What\u0026#39;s the best web QA tool?\u0026#34;,\u0026#34;Selenium\u0026#34;); output(response); } function open_window(windowName){ window.open(\u0026#34;newWindow.html\u0026#34;,windowName); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnConfirm\u0026#34; onclick=\u0026#34;show_confirm()\u0026#34; value=\u0026#34;Show confirm box\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnAlert\u0026#34; onclick=\u0026#34;show_alert()\u0026#34; value=\u0026#34;Show alert\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPrompt\u0026#34; onclick=\u0026#34;show_prompt()\u0026#34; value=\u0026#34;Show prompt\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;newWindow.html\u0026#34; id=\u0026#34;lnkNewWindow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;New Window Link\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamelessWindow\u0026#34; onclick=\u0026#34;open_window()\u0026#34; value=\u0026#34;Open Nameless Window\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamedWindow\u0026#34; onclick=\u0026#34;open_window(\u0026#39;Mike\u0026#39;)\u0026#34; value=\u0026#34;Open Named Window\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span id=\u0026#34;output\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ユーザーは、アラート/確認ボックスに応答するとともに、新しく開いたポップアップウィンドウにフォーカスを移動する必要があります。 幸いなことに、SeleniumはJavaScriptポップアップをカバーできます。\nただし、アラート/確認/プロンプトを個別に詳細に説明する前に、それらの共通点を理解しておくと役立ちます。 アラート、確認ボックス、プロンプトにはすべて次のバリエーションがあります。\n   Command Description     assertFoo(pattern) パターンがポップアップのテキストと一致しない場合、エラーをスローします   assertFooPresent ポップアップが利用できない場合はエラーをスローします   assertFooNotPresent ポップアップが存在する場合、エラーをスローします   storeFoo(variable) ポップアップのテキストを変数に保存します   storeFooPresent(variable) ポップアップのテキストを変数に保存し、trueまたはfalseを返します    Seleniumで実行している場合、JavaScriptポップアップは表示されません。 これは、関数呼び出しが実行時に実際にSeleniumのJavaScriptによってオーバーライドされるためです。 ただし、ポップアップが表示されないからといって、ポップアップを処理する必要はありません。 ポップアップを処理するには、その assertFoo(pattern) 関数を呼び出す必要があります。 ポップアップの存在をアサートしないと、次のコマンドがブロックされ、次のようなエラーが表示されます。 [エラー]エラー：予期しない確認がありました！ [オプションを選択してください。]\nアラート アラートは処理が最も簡単なポップアップなので、始めましょう。 まず、ブラウザで上記のHTMLサンプルを開き、\u0026ldquo;Show alert\u0026rdquo; ボタンをクリックします。 アラートを閉じると、\u0026ldquo;Alert is gone.\u0026rdquo; というテキストが表示されます。 ページに表示されます。 次に、Selenium IDE記録で同じ手順を実行し、アラートを閉じた後にテキストが追加されたことを確認します。 テストは次のようになります。\n   Command Target Value     open /    click btnAlert    assertAlert I’m blocking!    verifyTextPresent Alert is gone.     あなたは「それはおかしい、私はそのアラートをアサートしようとしたことはない」と考えているかもしれません。 ただし、これはSelenium-IDEの処理であり、アラートを閉じます。 そのステップを削除してテストを再生すると、次のエラーが表示されます [エラー]エラー：予期しないアラートがありました！ [I'm blocking!] 。 アラートの存在を確認するには、アラートのアサーションを含める必要があります。\nアラートが存在することをアサートしたいが、アラートに含まれるテキストがわからないか気にする必要がない場合は、assertAlertPresentを使うことができます。 これはtrueまたはfalseを返し、falseはテストを停止します。\n確認 確認はアラートとほぼ同じように動作し、 assertConfirmation と assertConfirmationPresent は対応するアラートと同じ特性を提供します。 ただし、デフォルトでは、確認が表示されたときにSeleniumはOKを選択します。 サンプルページの\u0026quot;確認ダイアログを表示\u0026quot;ボタンをクリックして記録を試みますが、ポップアップの\u0026quot;キャンセル\u0026quot;ボタンをクリックして、出力テキストをアサートします。 テストは次のようになります。\n   Command Target Value     open /    click btnConfirm    chooseCancelOnNextConfirmation     assertConfirmation Choose an option.    verifyTextPresent Rejected     chooseCancelOnNextConfirmation 関数は、後続のすべての確認がfalseを返すことをSeleniumに伝えます。 chooseOkOnNextConfirmationを呼び出すことでリセットできます。\nSeleniumは未処理の確認があると苦情を言うので、このテストを再生できないことに気付くかもしれません。 これは、Selenium-IDEが記録するイベントの順序により、クリックしてchooseCancelOnNextConfirmationが間違った順序になるためです（考えてみれば、Seleniumは、確認を開く前にキャンセルしていることを知ることができません）。 これら2つのコマンドを切り替えると、テストは正常に実行されます。\nプロンプト プロンプトは、assertPrompt および assertPromptPresent が対応するアラートと同じ特性を提供することで、アラートとほぼ同じように動作します。 デフォルトでは、Seleniumはプロンプトがポップアップしたときにデータの入力を待機します。 サンプルページの \u0026ldquo;Show prompt\u0026rdquo; ボタンをクリックして記録を試み、プロンプトに \u0026ldquo;Selenium\u0026rdquo; と入力します。 テストは次のようになります。\n   Command Target Value     open /    answerOnNextPrompt Selenium!    click id=btnPrompt    assertPrompt What’s the best web QA tool?    verifyTextPresent Selenium!     プロンプトで\u0026quot;キャンセル\u0026quot;を選択すると、 answerOnNextPrompt が単に空白のターゲットを表示することに気付くかもしれません。 Seleniumは、プロンプトのキャンセルと空白のエントリを基本的に同じものとして扱います。\nデバッグ デバッグとはテストケースのエラーを見つけて解決する作業のことです。 デバッグはテストケース開発に含まれる通常の工程です。\nほとんどの Selenium 初心者もデバッグについてはすでに基礎知識を持っているでしょうから、ここではデバッグそのものについてはふれません。 デバッグをするのがまったく初めてという場合には、社内や組織内の開発者にアドバイスをもらってください。\nブレークポイントと開始位置 Selenium-IDE では、テストケース内の任意の位置でテストケースの実行を開始または停止するためのブレークポイントの指定と開始位置の指定がサポートされています。 この機能を使うと、テストケースの途中の特定のコマンドでテストケースの実行を停止させ、その時点でのテストケースの動作を調べることができます。 この場合、具体的には、調べようとするコマンドの直前のコマンドにブレークポイントを指定します。\nブレークポイントを指定するには、コマンドを選択し、右クリックして表示されるコンテキストメニューで ブレークポイントの指定/解除 をクリックします。 テストケースを最初からブレークポイントまで実行するには、\u0026ldquo;Run\u0026rdquo; ボタンをクリックします。\nテストケースの途中から最後まで、または最初からブレークポイントまでの部分を実行できると便利なことがあります。 たとえば、最初に Web サイトにログインし、次に一連のテストを実行するテストケースを作成していて、ログイン後の一連のテストのいずれかをデバッグしたい場合などです。 この場合、ログインは 1 度すれば不要になりますが、その後のテストは繰り返し実行する必要があります。 このようなテストケースでは、いったんログインした後、ログイン操作の後に開始位置を指定し、この開始位置からテストケースを実行することができます。 こうすれば、テストケースを再実行するたびに手動で Web サイトからログアウトする必要はなくなります。\n開始位置を指定するには、コマンドを選択し、右クリックして表示されるコンテキストメニューで 開始位置の指定/解除 をクリックします。テストケースを開始位置から実行するには、\u0026ldquo;Run\u0026rdquo; ボタンをクリックします。\nテストケースのステップ実行 テストケースのコマンドを 1 つずつ実行 (ステップ実行) するには、次の手順に従います。\n  ツールバーの \u0026ldquo;Run\u0026rdquo; ボタンをクリックしてテストケースの実行を開始します。\n  すぐに \u0026ldquo;Pause\u0026rdquo; ボタンをクリックして、テストケースの実行を一時停止します。\n  \u0026ldquo;Step\u0026rdquo; ボタンを繰り返しクリックします。\n  検索ボタン 検索ボタンを使うと、現在 (ブラウザに) 表示されている Web ページ上の UI 要素のうち、現在選択されている Selenium コマンドで使われているのはどの UI 要素かを知ることができます。 この機能は、コマンドの最初のパラメータでロケータを使う場合に便利です (Selenium のコマンドに関する章の 要素の特定 を参照)。 検索ボタンは、Web ページ上の UI 要素を指定する必要があるあらゆるコマンド、すなわち click 、 clickAndWait 、 type 、および一部の assert と verify コマンドなどで使用できます。\nテーブルタブで、ロケータパラメータを持ついずれかのコマンドを選択します。 検索ボタンをクリックします。 Firebox ブラウザに表示されている Web ページに注目します。 ロケータパラメータで指定されている要素が、明るい緑の四角で囲んで表示されます。\nデバッグ時のページソースの参照 テストケースをデバッグするときは、しばしばページソース (テスト対象の Web ページの HTML) を参照して問題を解決しなければなりません。 Firefox では、ページソースも簡単に参照できます。 具体的には、目的の Web ページを右クリックし、\u0026ldquo;ページのソースを表示\u0026rdquo; を選択するだけです。 これで、ソースの HTML が別のウィンドウに表示されます。 テスト対象の UI 要素を HTML から見つけるためのキーワードを検索するには、このウィンドウの \u0026ldquo;編集\u0026rdquo; メニューにある \u0026ldquo;検索\u0026rdquo; を使ってください。\nまた、ソースを見たい Web ページの一部を選択し、右クリックして表示されるメニューから \u0026ldquo;選択した部分のソースを表示\u0026rdquo; をクリックする方法もあります。 この場合は、ソースの一部だけが別のウィンドウに表示され、選択した部分が強調表示されます。\nロケータアシスタンス Selenium-IDE は、ロケータ型引数を記録するたびに追加情報を保存し、この追加情報を使って、代わりに使用できるほかのロケータ型引数をユーザーに提示できるようにしています。 この機能は、ロケータについて詳しく学ぶ上で非常に有益なだけでなく、記録された型とは異なる型のロケータを使う場合にしばしば必要となります。\nロケータアシスタンスは、Selenium-IDE ウィンドウ内の \u0026ldquo;対象\u0026rdquo; フィールドの右端にドロップダウンリストとして表示されます (ドロップダウンリストが表示されるのは、\u0026ldquo;対象\u0026rdquo; フィールドに入力されている引数が、記録されたロケータ型引数である場合だけです)。 次に示すのは、あるコマンドのドロップダウンリストの内容です。 ドロップダウンリストの最初の列には、代わりに使用できるロケータが表示され、2 列目にはそれぞれの型が表示されることに注意してください。\nテストスイートの作成 テストスイートとはテストケースの集合のことで、Selenium-IDE ウィンドウの一番左にある \u0026ldquo;テストスイート\u0026rdquo; ペインに表示されます。 \u0026ldquo;テストスイート\u0026rdquo; ペインを手動で開いたり閉じたりするには、\u0026ldquo;テストケース\u0026rdquo; ペインの右端 (ペインが閉じている場合は Selenium-IDE ウィンドウ全体の左端になります) の半分ほど下にある小さな点を選択します。\n\u0026ldquo;テストスイート\u0026rdquo; ペインは、既存のテストスイートが開かれるか、 または ユーザーが \u0026ldquo;ファイル\u0026rdquo; メニューの \u0026ldquo;テストケースを新規作成\u0026rdquo; をクリックすると、自動的に開きます。 後者の場合、新しいテストケースは直前のテストケースのすぐ下に表示されます。\n既存のテストケースをテストスイートに読み込む操作は、Selenium-IDE ではまだサポートされていません。既存のテストケースを追加して、テストスイートを作成または修正するには、ユーザーが手動でテストスイートファイルを編集する必要があります。\nテストスイートファイルは、1 列のテーブルを含む HTML ファイルです。 \u0026lt;tbody\u0026gt; セクション内の各行のセルには、テストケースへのリンクが収められています。 次に示すのは、4 つのテストケースを含むテストスイートの例です。\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Sample Selenium Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Test Cases for De Anza A-Z Directory Links\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./a.html\u0026#34;\u0026gt;A Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./b.html\u0026#34;\u0026gt;B Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./c.html\u0026#34;\u0026gt;C Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./d.html\u0026#34;\u0026gt;D Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注 : テストケースファイルは、呼び出し元のテストスイートファイルと同じ場所に置く必要はありません。 実際、Mac OS と Linux システムではそのとおりです。 ただし、この項目の執筆時点では、Windows システムで使う場合にはバグがあって、テストケースファイルを呼び出し元のテストスイートファイルと別の場所に置くことはできません。\nユーザー拡張スクリプト ユーザー拡張スクリプトは、ユーザー独自のカスタマイズや機能を作成して Selenium の機能を拡張できる JavaScript ファイルです。 多くの場合、コマンドのカスタマイズという形を取りますが、ユーザー拡張スクリプトによる機能拡張はコマンドの追加だけに限定されません。\n重要 : このセクションは期限切れです。近日中に改訂します。\nユーザーが作成した多くの有益な 拡張スクリプト があります。\n _extensions: http://wiki.openqa.org/display/SEL/Contributed+User-Extensions  .. _goto_sel_ide.js extension:\nおそらく Selenium-IDE のすべての拡張スクリプトの中で最も人気があるのは、while ループとプリミティブな条件判定によってフロー制御を可能にする goto_sel_ide.js でしょう。 この拡張スクリプトの使用例については、作者が用意した ページ を参照してください。\nこの拡張スクリプトをインストールするには、Selenium-IDE の \u0026ldquo;オプション\u0026rdquo; メニューで \u0026ldquo;設定\u0026rdquo; をクリックし、 \u0026ldquo;一般\u0026rdquo; タブの Selenium Core 拡張スクリプト (user-extension.js) のパス フィールドに、ファイルのパス名を入力します。\nOK ボタンをクリックしたら、拡張スクリプトを読み込むために、Selenium-IDE をいったん閉じて開く必要があります。 また、拡張スクリプトに変更を加えた場合も、Selenium-IDE をいったん閉じて開く必要があります。\n独自の拡張スクリプトを作成する方法については、Selenium リファレンス ドキュメントの終わりの方に説明があります。\nステップごとにSelenium IDEとユーザー拡張機能をデバッグすると非常に役立つことがあります。 XUL/Chromeベースの拡張機能をデバッグできると思われる唯一のデバッガーは、バージョン32が含まれるまでFirefoxでサポートされているVenkmanです。 段階的なデバッグは、Firefox 32およびSelenium IDE 2.9.0で動作することが確認されています。\nフォーマット (形式) \u0026ldquo;オプション\u0026rdquo; メニューの \u0026ldquo;設定\u0026rdquo; をクリックすると表示される \u0026ldquo;フォーマット\u0026rdquo; タブでは、テストケースの保存と表示に使う言語を選択できます。 デフォルトは \u0026ldquo;HTML\u0026rdquo; です。\n作成したテストケースを Selenium-RC を使って実行する場合には、作成されたテストケースをプログラミング言語に変換するためにこの機能が使われます。 テストプログラムの開発用に Selenium-RC で使う言語 (\u0026ldquo;Java\u0026rdquo;、\u0026ldquo;PHP\u0026rdquo; など) を選択し、次に \u0026ldquo;ファイル\u0026rdquo; メニューの \u0026ldquo;保存\u0026rdquo; を使ってテストケースを保存します。 これで、テストケースは、選択した言語の一連の関数に変換されます。 テストをサポートするプログラムコードは、基本的に、ユーザーに代わって Selenium-IDE によって生成されます。\n生成されたコードが自分のニーズに合わないときは、生成プロセスが定義された設定ファイルを編集することで、生成されるコードを変更できることに注意してください。サポートされている言語ごとに設定があり、これらの設定を編集できます。設定は、\u0026ldquo;オプション\u0026rdquo; メニューの \u0026ldquo;設定\u0026rdquo; をクリックすると表示される \u0026ldquo;フォーマット\u0026rdquo; タブにあります。\n異なるブラウザでの Selenium-IDE テストの実行 Selenium-IDE 自体は Firefox を対象にしたテストしか実行できませんが、Selenium-IDE で作成したテストは、Selenium-RC サーバーを呼び出すシンプルなコマンドラインインタフェースを使うことで、ほかのブラウザを対象に実行することができます。 詳細については、Selenium-RC に関する章の Selenese テストの実行 を参照してください。 特に関連性が高いのは、 -htmlSuite コマンドラインオプションです。\nトラブルシューティング 以下は、Selenium-IDE で発生することが多いさまざまな問題について、実際の画面を示しながら説明したものです。\nTable view is not available with this format.\nこのメッセージは、Selenium IDEの起動時に\u0026quot;テーブル\u0026quot;タブに表示されることがあります。 回避策は、Selenium IDEを閉じて再度開くことです。 詳細については、 issue 1008 を参照してください。 これを確実に再現できる場合は、修正に取り組むことができるように詳細を提供してください。\n error loading test case: no command found\n「ファイル」メニューの「開く」を使用して、テストスイートファイルを開こうとしました。 代わりに「ファイル」メニューの「テストスイートを開く」を使用してください。\nこのエラーメッセージを改善するために、機能の拡張がリクエストされました。 詳細は、issue 1010を参照してください。\n このタイプの エラー は、タイミングの問題を示している可能性があります。 つまり、コマンドのロケーターによって指定された要素が、コマンドの実行時に完全にロードされていません。 コマンドの前に pause 5000 を入れて、問題が本当にタイミングに関連しているかどうかを判断してください。 その場合、失敗したコマンドの前に適切な waitFor* または *AndWait コマンドを使って調査してください。\n 上記の open コマンドの場合のように変数置換を使用しようとして失敗した場合は、アクセスしようとしている値を持つ変数を実際に作成していないことを示します。 これは、変数を Target フィールドに配置する必要がある場合に Value フィールドに配置するか、その逆の場合があります。 上記の例では、storeコマンドの2つのパラメーターが、必要なものと逆の順序で誤って配置されています。 Seleneseコマンドの場合、最初の必須パラメーターは Target フィールドに入力し、2番目の必須パラメーター（存在する場合）は Value フィールドに入力する必要があります。\n error loading test case: [Exception\u0026hellip; \u0026ldquo;Component returned failure code: 0x80520012 (NS_ERROR_FILE_NOT_FOUND) [nsIFileInputStream.init]\u0026rdquo; nresult: \u0026ldquo;0x80520012 (NS_ERROR_FILE_NOT_FOUND)\u0026rdquo; location: \u0026ldquo;JS frame :: chrome://selenium-ide/content/file-utils.js :: anonymous :: line 48\u0026rdquo; data: no]\nテストスイートのテストケースの1つが見つかりません。 テストケースが配置されていることを示すテストスイートが実際に配置されていることを確認してください。 また、実際のテストケースファイルのファイル名と参照先のテストスイートファイルの両方に.html拡張子が付いていることを確認してください。\nこのエラーメッセージを改善するために、機能の拡張がリクエストされました。 詳細は、issue 1011を参照してください。\n 拡張ファイルの内容が、Selenium-IDEによって読み取られていません。 Selenium-IDE の “オプション” メニューで “設定” をクリックし、 “一般” タブ の Selenium Core 拡張スクリプト (user-extension.js) のパス フィールドに適切なパス名を指定していることを確認してください。 また、 Selenium Core 拡張スクリプト (user-extension.js) のパス フィールドの内容を変更した後は、Selenium-IDEを再起動する必要があります。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/waits/",
	"title": "待機",
	"tags": [],
	"description": "",
	"content": "WebDriverは一般にブロッキングAPIを持っていると言えます。 ブラウザーに処理を 指示する Out-of-Processライブラリであり、Webプラットフォームは本質的に非同期の性質を持っているため、WebDriverはDOMのアクティブでリアルタイムな状態を追跡しません。 このことは、ここで説明するいくつかの課題が出てきます。\n経験から、SeleniumとWebDriverの使用から生じる断続的なもののほとんどは、ブラウザーとユーザーの指示の間で発生する 競合状態 に関連しています。 たとえば、ユーザーがブラウザーにページに移動するように指示し、要素を見つけようとすると、no such element エラーが表示される場合があります。\n次のドキュメントを考えてみましょう。\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; WebDriverの指示は十分問題なく見えるかもしれません。\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Get and store Paragraph Text search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     ここでは、WebDriverで使用されるデフォルトの ページロード戦略 がdocument.readyStateをリッスンして、ナビゲーションの呼び出しから戻る前に\u0026quot;complete\u0026quot;に変更することが問題です。ドキュメントの読み込みが完了した後にp要素が追加されるため、このWebDriverスクリプトは断続的になる 可能性があります。 これらのイベントを明示的に待機（またはブロック）せずに非同期でトリガーする要素またはイベントについては保証できないため、断続的である可能性があります。\n幸いなことに、 WebElement.click や WebElement.sendKeys などのWebElementインターフェイスで使用可能な通常の命令セットを使用すると、コマンドの呼び出しがブラウザーで完了するまで関数呼び出しが返されない（または、コールバックはコールバックスタイルの言語ではトリガーされない）ため、同期が保証されます。高度なユーザーインタラクションAPIであるキーボードとマウスは、 \u0026ldquo;言うことをする\u0026rdquo; 非同期コマンドとして明示的に意図されているため、例外です。\n待機とは、自動化されたタスクの実行を一定時間経過させてから次のステップに進むことです。\nブラウザーとWebDriverスクリプト間の競合状態の問題を克服するために、ほとんどのSeleniumクライアントには待機パッケージが付属しています。待機を使用する場合、一般に明示的な待機と呼ばれるものを使用しています。\n明示的な待機 Seleniumクライアントは、命令型の手続き型言語の 明示的な待機 を利用できます。 これにより、 条件 が解決するまで、コードでプログラムの実行を停止したり、スレッドをフリーズしたりできます。 条件は、明示的な待機のタイムアウトが経過するまで特定の頻度で呼び出されます。 つまり、条件がfalseの値を返す限り、試行、待機し続けます。\n明示的な待機により条件が発生するのを待機できるため、ブラウザーとそのDOM、およびWebDriverスクリプトの間で状態を同期するのに適しています。\n以前のバグのある命令セットを修正するには、スクリプトから動的に追加された要素がDOMに追加されるまで、 findElement 呼び出しを待機させるために待機を採用できます。\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Initialize and wait till element(link) became clickable - timeout in 10 seconds WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Print the first result System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Initialize and wait till element(link) became clickable - timeout in 10 seconds val firstResult = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Print the first result println(firstResult.text)     戻り値がtrueになるまで 待機 が繰り返し実行される関数リファレンスとして 条件 を渡します。 \u0026ldquo;真の\u0026quot;戻り値とは、文字列、数値、ブール値、オブジェクト（ WebElement を含む）、または入力された（空でない）シーケンスまたはリストなど、手元の言語でブール値trueと評価されるものです。 つまり、 空のリスト はfalseと評価されます。 条件がtrueで、ブロッキング待機が中止されると、条件からの戻り値が待機の戻り値になります。\nこのナレッジと、ウェイトユーティリティはデフォルトで no such element エラーを無視するため、より簡潔になるように命令をリファクタリングできます。\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3)) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); }   driver.get \u0026#39;file:///race_condition.html\u0026#39; wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) ele = wait.until { driver.find_element(css: \u0026#39;p\u0026#39;)} foo = ele.text assert_match foo, \u0026#39;Hello from JavaScript\u0026#39;   let ele = await driver.wait(until.elementLocated(By.css(\u0026#39;p\u0026#39;)),10000); let foo = await ele.getText(); assert(foo == \u0026#34;Hello from JavaScript\u0026#34;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val ele = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026#34;p\u0026#34;))) assert(ele.text == \u0026#34;Hello from JavaScript!\u0026#34;)     この例では、匿名関数を渡します（ただし、以前に行ったように明示的に定義して再利用できるようにすることもできます）。 条件に渡される最初で唯一の引数は、常にドライバーオブジェクト　WebDriver　（この例ではdと呼ばれます）への参照です。 マルチスレッド環境では、外部スコープ内のドライバーへのリファレンスではなく、条件に渡されたドライバーのリファレンスを操作するように注意する必要があります。\n待機は、要素が見つからないときに発生する no such element エラーを飲み込むため、要素が見つかるまで条件は再試行されます。 次に、戻り値である WebElement を取得して、スクリプトに渡します。\n条件が失敗した場合、例えば条件からの真の戻り値に到達しない場合、待機は timeout error と呼ばれるエラー/例外をスロー/発生させます。\nオプション 待機条件は、ニーズに合わせてカスタマイズできます。 成功した条件にヒットしないことに対するペナルティは高額になる可能性があるため、デフォルトのタイムアウトの全範囲を待つ必要がない場合があります。\nWebDriverWaitに引数を渡してタイムアウトをオーバーライドできます。\nJava Python C# Ruby JavaScript Kotlin new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) wait.until { driver.find_element(:id, \u0026#39;message\u0026#39;).displayed? }   await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000);   WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     期待される条件 DOMと指示を同期しなければならないことは非常に一般的であるため、ほとんどのクライアントには事前に定義された一連の _期待される条件_もあります。 名前から明らかなように、これらは頻繁な待機操作に対して事前定義されている条件です。\n異なる言語バインディングで利用可能な条件は異なりますが、これは少数の抜粋したリストです。\n alert is present element exists element is visible title contains title is element staleness visible text  各クライアントバインディングのAPIドキュメントを参照して、予想される条件の完全なリストを見つけることができます。\n Java\u0026rsquo;s org.openqa.selenium.support.ui.ExpectedConditions class Python\u0026rsquo;s selenium.webdriver.support.expected_conditions class .NET\u0026rsquo;s OpenQA.Selenium.Support.UI.ExpectedConditions type  暗黙的な待機 暗黙的な待機 と呼ばれる明示的な待機とは異なる2番目の種類の待機があります。 暗黙的に待機することにより、WebDriverは 何か 要素を見つけようとするときに特定の期間DOMをポーリングします。 これは、Webページ上の特定の要素がすぐに利用できず、ロードに時間がかかる場合に役立ちます。\n要素の表示を暗黙的に待機することはデフォルトで無効になっており、セッションごとに手動で有効にする必要があります。 明示的な待機と暗黙的な待機を混在させると、意図しない結果、すなわち、要素が利用可能または条件が真であっても、最大時間スリープする待機が発生します。\n警告 : 暗黙的な待機と明示的な待機を混在させないでください。 これを行うと、予測できない待機時間が発生する可能性があります。 たとえば、10秒の暗黙的な待機と15秒の明示的な待機を設定すると、20秒後にタイムアウトが発生する可能性があります。\n暗黙的な待機は、1つまたは複数の要素がすぐに利用できない場合にそれらを見つけようとするときにWebDriverにDOMを一定時間ポーリングするように指示することです。 デフォルト設定は0で、無効を意味します。 設定すると、セッションの存続期間中、暗黙的な待機が設定されます。\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element(By.ID, \u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Apply timeout for 10 seconds await driver.manage().setTimeouts( { implicit: 10000 } ); // Navigate to url await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     FluentWait FluentWaitインスタンスは、条件を待機する最大時間を定義します。 状態を確認する頻度も同様です。\nユーザーは、ページ上の要素を検索するときのNoSuchElementExceptionなど、待機中に特定の種類の例外を無視するように待機を構成できます。\nJava Python C# Ruby JavaScript Kotlin // Waiting 30 seconds for an element to be present on the page, checking // for its presence once every 5 seconds. Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox exception = Selenium::WebDriver::Error::NoSuchElementError begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; wait = Selenium::WebDriver::Wait.new(timeout: 30, interval: 5, message: \u0026#39;Timed out after 30 sec\u0026#39;, ignore: exception) foo = wait.until { driver.find_element(id: \u0026#39;foo\u0026#39;)} ensure driver.quit end   const {Builder, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); // Waiting 30 seconds for an element to be present on the page, checking  // for its presence once every 5 seconds.  let foo = await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000, \u0026#39;Timed out after 30 seconds\u0026#39;, 5000); })();   val wait = FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": "WebDriver WebDriverは、ユーザーがローカルまたはSeleniumサーバーを使用するリモートマシンで行うように、ブラウザをネイティブに動かし、ブラウザの自動化に関して大きく前進します。\nSelenium WebDriverは言語バインディングと個々のブラウザ制御コードの実装の両方を参照します。\nこれは通常、単に WebDriver と呼ばれます。\nSelenium WebDriverは、W3C勧告です。\n  WebDriverはシンプルでより簡潔なプログラミングインターフェイスとして設計されています。\n  WebDriverはコンパクトなオブジェクト指向APIです。\n  ブラウザーを効果的に動かします。\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/support_classes/",
	"title": "サポートクラス",
	"tags": [],
	"description": "",
	"content": "WebDriverサポートクラスは、コードのメンテナンスを簡素化するために提供されています。 ドメインオブジェクトとしてのHTML要素のモデリングを容易にする優れた抽象化を提供し、そのようなオブジェクトの使用を推論しやすくするヘルパーメソッドも提供します。 ここでは下記について学びます。\n Locator Strategies Events LoadableComponent ThreadGuard etc.  さぁ、始めましょう。\nThreadGuard  このクラスは、Javaバインディングでのみ使用可能です。\n ThreadGuardは、ドライバーが、それを作成した同じスレッドからのみ呼び出されることを確認します。 特に並行してテストを実行する場合のスレッドの問題は、不可解でエラーの診断が難しい場合があります。 このラッパーを使用すると、このカテゴリのエラーが防止され、発生時に例外が発生します。\n次の例は、スレッドの衝突をシミュレートします。\npublic class DriverClash { //thread main (id 1) created this driver  private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;\u0026lt;Set path to your Chromedriver\u0026gt;\u0026#34;); } //Thread-1 (id 24) is calling the same driver causing the clash to happen  Runnable r1 = () -\u0026gt; {protectedDriver.get(\u0026#34;https://selenium.dev\u0026#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } 結果は以下のとおりです。\nException in thread \u0026#34;Thread-1\u0026#34; org.openqa.selenium.WebDriverException: Thread safety error; this instance of WebDriver was constructed on thread main (id 1)and is being accessed by thread Thread-1 (id 24) This is not permitted and *will* cause undefined behaviour 下記例を参照してください。\n protectedDriver はメインスレッドで作成されます Java Runnableを使用して新しいプロセスを起動し、新しいスレッドを使用してプロセスを実行します メインスレッドのメモリにprotectedDriverがないため、両方のスレッドが衝突します。 ThreadGuard.protectは例外をスローします。  注意: これは、並列実行時にドライバーを管理するために ThreadLocalを使用する必要性を置き換えるものではありません。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/worst_practices/test_dependency/",
	"title": "テストの依存関係",
	"tags": [],
	"description": "",
	"content": "自動テストに関する一般的な考え方と誤解は、特定のテスト順序に関するものです。 テストは 任意 の順序で実行でき、成功するために完了するために他のテストに依存してはなりません。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/improved_reporting/",
	"title": "改善されたレポート",
	"tags": [],
	"description": "",
	"content": "Seleniumは、実行されたテストケースのステータスをレポートするようには設計されていません。 単体テストフレームワークの組み込みのレポート機能を利用することは、良いスタートです。 ほとんどの単体テストフレームワークには、xUnitまたはHTML形式のレポートを生成できるレポートがあります。 xUnitレポートは、Jenkins、Travis、Bambooなどの継続的インテグレーション（CI）サーバーに結果をインポートするのに人気があります。 いくつかの言語のレポート出力に関する詳細情報へのリンクがあります。\nNUnit 3 Console Runner\nNUnit 3 Console Command Line\nxUnit getting test results in TeamCity\nxUnit getting test results in CruiseControl.NET\nxUnit getting test results in Azure DevOps\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/js_alerts_prompts_and_confirmations/",
	"title": "JavaScript アラート、プロンプトおよび確認",
	"tags": [],
	"description": "",
	"content": "WebDriverは、JavaScriptが提供する3種類のネイティブポップアップメッセージを操作するためのAPIを提供します。 これらのポップアップはブラウザーによってスタイルが設定され、カスタマイズが制限されています。\nアラート これらの最も単純なものはアラートと呼ばれ、カスタムメッセージと、ほとんどのブラウザーでOKのラベルが付いたアラートを非表示にする単一のボタンを表示します。 ほとんどのブラウザーでは閉じるボタンを押すことで閉じることもできますが、これは常にOKボタンと同じことを行います。 アラートの例を参照してください。\nWebDriverはポップアップからテキストを取得し、これらのアラートを受け入れるか、または閉じることができます。\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See an example alert\u0026#34;).click() # Wait for the alert to be displayed and store it in a variable alert = wait.until(expected_conditions.alert_is_present()) # Store the alert text in a variable text = alert.text # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert text in a variable string text = alert.Text; //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on OK button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the OK button await alert.accept(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Store the alert text in a variable val text = alert.getText() //Press the OK button alert.accept()     確認 確認ダイアログボックスはアラートに似ていますが、ユーザーがメッセージをキャンセルすることも選択できる点が異なります。 サンプルを確認してください。\nこの例は、アラートを保存する別の方法も示しています。\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()); //Store the alert in a variable Alert alert = driver.switchTo().alert(); //Store the alert in a variable for reuse String text = alert.getText(); //Press the Cancel button alert.dismiss();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample confirm\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = driver.switch_to.alert # Store the alert text in a variable text = alert.text # Press the Cancel button alert.dismiss()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Wait for the alert to be displayed wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert in a variable IAlert alert = driver.SwitchTo().Alert(); //Store the alert in a variable for reuse string text = alert.Text; //Press the Cancel button alert.Dismiss();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on Cancel button alert.dismiss   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the Cancel button await alert.dismiss(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()) //Store the alert in a variable val alert = driver.switchTo().alert() //Store the alert in a variable for reuse val text = alert.text //Press the Cancel button alert.dismiss()     プロンプト プロンプトは確認ボックスに似ていますが、テキスト入力も含まれている点が異なります。 フォーム要素の操作と同様に、WebDriverの送信キーを使用して応答を入力できます。 これにより、プレースホルダーテキストが完全に置き換えられます。 キャンセルボタンを押してもテキストは送信されません。 サンプルプロンプトを参照してください。\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample prompt\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = Alert(driver) # Type your message alert.send_keys(\u0026#34;Selenium\u0026#34;) # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Type your message alert.SendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Type a message alert.send_keys(\u0026#34;selenium\u0026#34;) # Press on Ok button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Type your message await alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button await alert.accept(); //Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;) //Press the OK button alert.accept()     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/support_packages/working_with_cookies/",
	"title": "クッキーの使用",
	"tags": [],
	"description": "",
	"content": "Cookieは、Webサイトから送信され、コンピューターに保存される小さなデータです。 Cookieは、主にユーザーを認識し、保存されている情報を読み込むために使用されます。\nWebDriver APIは、組み込みメソッドでCookieと対話するメソッドを提供します。\nクッキーの追加 現在のブラウジングコンテキストにCookieを追加するために使用されます。 Cookieの追加では、一連の定義済みのシリアル化可能なJSONオブジェクトのみを受け入れます。 受け入れられたJSONキー値のリストへのリンクはこちらにあります。\nまず、Cookieが有効になるドメインにいる必要があります。 サイトとの対話を開始する前にCookieを事前設定しようとしていて、ホームページが大きい場合/代替の読み込みに時間がかかる場合は、サイトで小さいページを見つけることです。（通常、たとえば http://example.com/some404page のような、404ページは小さいです。）\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Adds the cookie into current browser context  driver.manage().addCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;})   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace AddCookie { class AddCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Adds the cookie into current browser context  driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context driver.manage.add_cookie(name: \u0026#34;key\u0026#34;, value: \u0026#34;value\u0026#34;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;}); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Adds the cookie into current browser context  driver.manage().addCookie(Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit() } }     命名されたクッキーの取得 関連付けられているすべてのCookieの中で、Cookie名と一致するシリアル化されたCookieデータを返します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class getCookieNamed { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  Cookie cookie1 = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); System.out.println(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bar\u0026#34;}) # Get cookie details with named cookie \u0026#39;foo\u0026#39; print(driver.get_cookie(\u0026#34;foo\u0026#34;))   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetCookieNamed { class GetCookieNamed { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  var cookie = driver.Manage().Cookies.GetCookieNamed(\u0026#34;foo\u0026#34;); System.Console.WriteLine(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;) # Get cookie details with named cookie \u0026#39;foo\u0026#39; puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;foo\u0026#39;, value: \u0026#39;bar\u0026#39;}); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  driver.manage().getCookie(\u0026#39;foo\u0026#39;).then(function (cookie) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookie); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  val cookie = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); println(cookie); } finally { driver.quit() } }     全てのクッキーの取得 現在のブラウジングコンテキストの \u0026lsquo;成功したシリアル化されたCookieデータ\u0026rsquo; を返します。 ブラウザが使用できなくなった場合、エラーが返されます。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Set; public class getAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Add few cookies  driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  Set\u0026lt;Cookie\u0026gt; cookies = driver.manage().getCookies(); System.out.println(cookies); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Get all available cookies print(driver.get_cookies())   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetAllCookies { class GetAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  var cookies = driver.Manage().Cookies.AllCookies; } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Get all available cookies puts driver.manage.all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  val cookies = driver.manage().cookies; println(cookies); } finally { driver.quit() } }     クッキーの削除 指定されたCookie名と一致するCookieデータを削除します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); Cookie cookie1 = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); /* Selenium Java bindings also provides a way to delete cookie by passing cookie object of current browsing context */ driver.manage().deleteCookie(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Delete a cookie with name \u0026#39;test1\u0026#39; driver.delete_cookie(\u0026#34;test1\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteCookie { class DeleteCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); var cookie = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.Manage().Cookies.AddCookie(cookie); // delete a cookie with name \u0026#39;test1\u0026#39;\t driver.Manage().Cookies.DeleteCookieNamed(\u0026#34;test1\u0026#34;); // Selenium .net bindings also provides a way to delete  // cookie by passing cookie object of current browsing context  driver.Manage().Cookies.DeleteCookie(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # delete a cookie with name \u0026#39;test1\u0026#39; driver.manage.delete_cookie(\u0026#39;test1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete a cookie with name \u0026#39;test1\u0026#39;  await driver.manage().deleteCookie(\u0026#39;test1\u0026#39;); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); val cookie1 = Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;) driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); // delete cookie by passing cookie object of current browsing context.  driver.manage().deleteCookie(cookie1); } finally { driver.quit() } }     全てのクッキーの削除 現在のブラウジングコンテキストの全てのCookieを削除します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Deletes all cookies driver.delete_all_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteAllCookies { class DeleteAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.Manage().Cookies.DeleteAllCookies(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # deletes all cookies driver.manage.delete_all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete all cookies  await driver.manage().deleteAllCookies(); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit() } }     SameSite Cookie属性 これにより、ユーザーは、サードパーティのサイトによって開始されたリクエストとともに Cookieを送信するかどうかをブラウザに指示できます。 CSRF（クロスサイトリクエストフォージェリ）攻撃を防ぐために導入されました。\nSameSite Cookie属性は、2つのパラメーターを命令として受け入れます。\nStrict: SameSite属性が Strict に設定されている場合、CookieはサードパーティのWebサイトによって 開始されたリクエストとともに送信されません。\nLax: CookieのSameSite属性を Lax に設定すると、CookieはサードパーティのWebサイトによって 開始されたGETリクエストとともに送信されます。\n注: 現在、この機能はchrome（80 + version）に組み込まれており、 Selenium 4以降のバージョンで動作します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class cookieTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); Cookie cookie = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build(); Cookie cookie1 = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build(); driver.manage().addCookie(cookie); driver.manage().addCookie(cookie1); System.out.println(cookie.getSameSite()); System.out.println(cookie1.getSameSite()); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Strict\u0026#39;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Lax\u0026#39;}) cookie1 = driver.get_cookie(\u0026#39;foo\u0026#39;) cookie2 = driver.get_cookie(\u0026#39;foo1\u0026#39;) print(cookie1) print(cookie2)   // Please raise a PR    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Strict\u0026#34;) driver.manage.add_cookie(name: \u0026#34;foo1\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Lax\u0026#34;) puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) puts driver.manage.cookie_named(\u0026#39;foo1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39;  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Strict\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Lax\u0026#39;}); console.log(await driver.manage().getCookie(\u0026#39;key\u0026#39;)); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;http://www.example.com\u0026#34;) val cookie = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build() val cookie1 = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build() driver.manage().addCookie(cookie) driver.manage().addCookie(cookie1) println(cookie.getSameSite()) println(cookie1.getSameSite()) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/worst_practices/performance_testing/",
	"title": "パフォーマンステスト",
	"tags": [],
	"description": "",
	"content": "通常、SeleniumとWebDriverを使用したパフォーマンステストはお勧めしません。 それができないからではなく、ジョブに最適化されておらず、良い結果が得られないからです。\nユーザーのコンテキストでパフォーマンステストを行うのが理想的なように思えるかもしれませんが、WebDriverテストスイートは、外部および内部の脆弱性の多くのポイントにさらされます。 たとえば、ブラウザの起動速度、HTTPサーバーの速度、JavaScriptまたはCSSをホストするサードパーティサーバーの応答、およびWebDriver実装自体の計測ペナルティ。 これらのポイントが変わることで、結果が変わります。 Webサイトのパフォーマンスと外部リソースのパフォーマンスの違いを区別することは困難です。また、ブラウザでWebDriverを使用すること、特にスクリプトを挿入する場合のパフォーマンスの低下を把握することも困難です。\n他の潜在的な魅力は \u0026ldquo;時間の節約\u0026rdquo; です。 機能テストとパフォーマンステストを同時に実行します。 ただし、機能テストとパフォーマンステストには反対の目的があります。 機能をテストするために、テスターは忍耐強くロードを待つ必要があるかもしれませんが、これはパフォーマンステスト結果を曖昧にし、その逆もまた同様です。\nWebサイトのパフォーマンスを改善するには、改善すべき点を知るために、環境の違いに関係なく全体的なパフォーマンスを分析し、貧弱なコードプラクティス、個々のリソース（例えば、CSSまたはJavaScript）のパフォーマンスの内訳を特定できる必要があります。 このジョブを実行できるパフォーマンステストツールが既にあり、それらは改善を提案できるレポートと分析を提供します。\n使用する（オープンソース）パッケージの例は次のとおりです。: JMeter\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/remote_webdriver/",
	"title": "リモートWebDriver",
	"tags": [],
	"description": "",
	"content": "リモートWebDriver WebDriverは、ローカルで使用するのと同じ方法でリモートで使用できます。 主な違いは、リモートWebDriverを設定して、別のマシンでテストを実行できるようにする必要があることです。\nリモートWebDriverは、クライアントとサーバーの2つの部分で構成されています。 クライアントはWebDriverテストであり、サーバーは単純なJavaサーブレットで最新のJEEアプリサーバーでホストすることができます。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/avoid_sharing_state/",
	"title": "状態を共有しない",
	"tags": [],
	"description": "",
	"content": "いくつかの場所で言及されていますが、再度言及する価値があります。 テストが互いに分離されていることを確認してください。\n  テストデータを共有しないでください。 アクションを実行する1つを選択する前に、それぞれが有効な注文をデータベースに照会するいくつかのテストを想像してください。 2つのテストで同じ順序を選択すると、予期しない動作が発生する可能性があります。\n  別のテストで取得される可能性のあるアプリケーション内の古いデータを削除します。 例: 無効な注文レコード\n  テストごとに新しいWebDriverインスタンスを作成します。 これにより、テストの分離が保証され、並列化がより簡単になります。\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/http_proxies/",
	"title": "Httpプロキシ",
	"tags": [],
	"description": "",
	"content": "プロキシサーバーは、クライアントとサーバー間の要求の仲介役として機能します。 簡単に言えば、トラフィックはプロキシサーバーを経由して、要求したアドレスに戻り、戻ってきます。\nSeleniumを使用した自動化スクリプト用のプロキシサーバーは、\n ネットワークトラフィックをキャプチャする ウェブサイトによって行われた模擬バックエンドを呼び出す 複雑なネットワークトポロジーまたは厳格な企業の制限/ポリシーの下で、必要なWebサイトにアクセスします。  企業環境でブラウザがURLへの接続に失敗した場合、環境にアクセスするにはプロキシが必要であることが原因であることが最も可能性が高いです。\nSelenium WebDriverは設定をプロキシする方法を提供します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Proxy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.chrome.ChromeOptions; public class proxyTest { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;); ChromeOptions options = new ChromeOptions(); options.setCapability(\u0026#34;proxy\u0026#34;, proxy); WebDriver driver = new ChromeDriver(options); driver.get(\u0026#34;https://www.google.com/\u0026#34;); driver.manage().window().maximize(); driver.quit(); } }   from selenium import webdriver PROXY = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34; webdriver.DesiredCapabilities.FIREFOX[\u0026#39;proxy\u0026#39;] = { \u0026#34;httpProxy\u0026#34;: PROXY, \u0026#34;ftpProxy\u0026#34;: PROXY, \u0026#34;sslProxy\u0026#34;: PROXY, \u0026#34;proxyType\u0026#34;: \u0026#34;MANUAL\u0026#34;, } with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://selenium.dev\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; public class ProxyTest{ public static void Main() { ChromeOptions options = new ChromeOptions(); Proxy proxy = new Proxy(); proxy.Kind = ProxyKind.Manual; proxy.IsAutoDetect = false; proxy.SslProxy = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;; options.Proxy = proxy; options.AddArgument(\u0026#34;ignore-certificate-errors\u0026#34;); IWebDriver driver = new ChromeDriver(options); driver.Navigate().GoToUrl(\u0026#34;https://www.selenium.dev/\u0026#34;); } }   # Need PR   // need PR    import org.openqa.selenium.Proxy import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions class proxyTest { fun main() { val proxy = Proxy() proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;) val options = ChromeOptions() options.setCapability(\u0026#34;proxy\u0026#34;, proxy) val driver: WebDriver = ChromeDriver(options) driver[\u0026#34;https://www.google.com/\u0026#34;] driver.manage().window().maximize() driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/",
	"title": "ガイドラインとレコメンデーション",
	"tags": [],
	"description": "",
	"content": "ガイドラインとレコメンデーション 「ベストプラクティス」に関するメモ：このドキュメントでは、\u0026ldquo;ベストプラクティス\u0026quot;というフレーズを意図的に避けています。 すべての状況に有効なアプローチはありません。 \u0026ldquo;ガイドラインとレコメンデーション\u0026quot;というアイデアを好みます。 これらを一通り読み、特定の環境でどのアプローチが効果的かを慎重に決定することをお勧めします。\n機能テストは、多くの理由で適切に行うのが困難です。 まるでアプリケーションの状態、複雑さ、および依存関係が、テストを十分に難しくしないと思えるほど、ブラウザ（特にクロスブラウザの非互換性）を扱うのは、良いテストの作成を難しくします。\nSeleniumは、機能的なユーザーインタラクションを簡単にするツールを提供しますが、適切に設計されたテストスイートの作成には役立ちません。 この章では、機能的なWebページの自動化に取り組む方法に関するアドバイス、ガイドライン、および推奨事項を提供します。\nこの章では、長年にわたって成功を収めてきたSeleniumの多くのユーザーの間で人気のあるソフトウェア設計パターンを記録します。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/test_independency/",
	"title": "テストの独立性",
	"tags": [],
	"description": "",
	"content": "各テストを独自のユニットとして記述します。 他のテストに依存しない方法でテストを記述してください。\n公開後にモジュールとしてWebサイトに表示されるカスタムコンテンツを作成できるコンテンツ管理システム（CMS）があり、CMSとアプリケーション間の同期に時間がかかる場合があるとします。\nモジュールをテストする間違った方法は、1つのテストでコンテンツが作成および公開され、別のテストでモジュールをチェックすることです。 コンテンツは公開後、他のテストですぐに利用できない可能性があるため、この方法はふさわしくありません。\n代わりに、影響を受けるテスト内でオン/オフできるスタブコンテンツを作成し、それをモジュールの検証に使用できます。 ただし、コンテンツの作成については、別のテストを行うことができます。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/worst_practices/link_spidering/",
	"title": "リンクスパイダー",
	"tags": [],
	"description": "",
	"content": "WebDriverを使用してリンクをスパイダーすることは、実行できないためではなく、最も理想的なツールではないため明らかに推奨される方法ではありません。 WebDriverの起動には時間が必要であり、テストの記述方法によっては、ページに到達してDOMを通過するために数秒から1分かかる場合があります。\nこのためにWebDriverを使用する代わりに、curl コマンドを実行するか、BeautifulSoupなどのライブラリを使用することにより、これらの方法はブラウザーの作成やページへの移動に依存しないため、時間を大幅に節約できます。 このタスクにWebDriverを使用しないことで、時間を大幅に節約できます。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/consider_using_a_fluent_api/",
	"title": "Fluent APIの使用を検討する",
	"tags": [],
	"description": "",
	"content": "マーチン・ファウラーは\u0026ldquo;Fluent API\u0026rdquo;という用語を作り出しました。 Seleniumは既に、FluentWaitクラスでこのようなものを実装しています。 これは、標準のWaitクラスの代替としてのものです。 ページオブジェクトでFluent APIデザインパターンを有効にしてから、次のようなコードスニペットを使用してGoogle検索ページを照会できます。\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); この流暢な動作を持つGoogleページオブジェクトクラスは次のようになります。\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // If load() fails, calls isLoaded() until page is finished loading  PageFactory.initElements(driver, this); // Initialize WebElements on page  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, Duration.ofSeconds(3) ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } } "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/page_loading_strategy/",
	"title": "ページ読み込み戦略",
	"tags": [],
	"description": "",
	"content": "現在のセッションのページ読み込み戦略を定義します。 デフォルトでは、Selenium WebDriverがページを読み込む場合、 pageLoadStrategy は normal となります。 ページの読み込みに時間がかかる場合は、追加のリソース（画像、CSS、JSなど）のダウンロードを停止することを常にお勧めします。\nドキュメントの document.readyState プロパティは、現在のドキュメントの読み込み状態を記述します。 デフォルトでは、WebDriverは、ドキュメントの準備完了状態が complete になるまで、 driver.get()（または）driver.navigate().to() の呼び出しへの応答を保留します。\nSPAアプリケーション（Angular、react、Emberなど）では、動的コンテンツが既にロードされている（つまり、一度 pageLoadStrategy のステータスがCOMPLETEになっている）場合、リンクをクリックするか、ページ内で何らかのアクションを実行しても、コンテンツは、プルページの更新なしでクライアント側で動的に読み込まれるので、サーバーに新しいリクエストは行われません。\nSPAアプリケーションはサーバーのリクエストなしで多くのビューを動的にロードできるため、新たに driver.get() および driver.navigate().to() を実行するまで、pageLoadStrategyは常に COMPLETE ステータスを表示します。\nWebDriverの pageLoadStrategy は以下の値をサポートします。\nnormal この値は、Selenium WebDriverはページ全体がロードされるまで待機します。 normal に設定すると、Selenium WebDriverは、ロードイベントの発生が返却されるまで待機します。\n何も指定されていない場合、デフォルトでは、 normal がブラウザに設定されます。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;normal\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Normal; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;normal\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;normal\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     eager この値は、Selenium WebDriverは最初のHTMLドキュメントが完全に読み込まれて解析されるまで待機し、スタイルシート、画像、およびサブフレームの読み込みを破棄します。\neager に設定すると、Selenium WebDriverは DOMContentLoaded イベントの発生が返却されるまで待機します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;eager\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Eager; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;eager\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;eager\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     none none に設定すると、Selenium WebDriverは最初のページがダウンロードされるまで待機します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;none\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.None; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;none\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;none\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/worst_practices/",
	"title": "最悪の慣行",
	"tags": [],
	"description": "",
	"content": "最悪の慣行 "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/grid/",
	"title": "Grid",
	"tags": [],
	"description": "",
	"content": "Grid Selenium Grid は、SeleniumテストがコマンドをリモートWebブラウザーインスタンスにルーティングできるようにする賢いプロキシサーバーです。 その目的は、複数のマシンで並行してテストを実行する簡単な方法を提供することです。\nSelenium Gridでは、1つのサーバーが、JSON形式のテストコマンドを1つ以上の登録済みのグリッドノードにルーティングするハブとして機能します。 テストはハブに接続して、リモートブラウザーインスタンスへのアクセスを取得します。 ハブには、アクセスを提供する登録済みサーバーのリストがあり、これらのインスタンスを制御できます。\nSelenium Gridを使用すると、複数のマシンで並行してテストを実行し、さまざまなブラウザーバージョンとブラウザー構成を（個々のテストではなく）一元的に管理できます。\nSelenium Gridは特効薬ではありません。 一般的な委任および配布の問題のサブセットを解決しますが、たとえばインフラストラクチャを管理せず、特定のニーズに適さない場合があります。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/web_element/",
	"title": "Web要素",
	"tags": [],
	"description": "",
	"content": "Web要素はDOM要素を表します。 Web要素は、WebDriverインスタンスを使用してドキュメントルートから検索するか、別のWeb要素の下で検索することで見つけることができます。\nWebDriver APIは、ID、名前、クラス、XPath、CSSセレクター、リンクテキストなどのさまざまなプロパティに基づいたWeb要素を見つけるための組み込みメソッドを提供します。\n要素の検索 要素を検索するために使用され、最初の一致する単一のWeb要素の参照を返します。 これは、将来の要素アクションに使用できます。\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element WebElement searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_box = driver.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_bar = driver.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element let searchBar = driver.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element val searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     複数の要素の検索 \u0026lsquo;要素の検索'に似ていますが、一致するWeb要素のリストを返します。 リストから特定のWeb要素を使用するには、要素のリストをループして、選択した要素に対してアクションを実行する必要があります。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import java.util.List; public class findElementsExample { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement element : elements) { System.out.println(\u0026#34;Paragraph text:\u0026#34; + element.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() # Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using System.Collections.Generic; namespace FindElementsExample { class FindElementsExample { public static void Main(string[] args) { IWebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = driver.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await driver.findElements(By.tagName(\u0026#39;p\u0026#39;)); for(let e of elements) { console.log(await e.getText()); } } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (element in elements) { println(\u0026#34;Paragraph text:\u0026#34; + element.text) } } finally { driver.quit() } }     要素から要素の検索 親要素のコンテキスト内で子要素を見つけるために使用します。 これを実現するには、親Web要素を\u0026rsquo;findElement'と連鎖して、子要素にアクセスします。\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element(By.TAG_NAME, \u0026#34;form\u0026#34;) search_box = search_form.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = searchForm.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Get search box element from webElement \u0026#39;form\u0026#39; search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; let searchForm = driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Get search box element from webElement \u0026#39;form\u0026#39; let searchBar = searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     要素から複数の要素の検索 親要素のコンテキスト内で一致する子Web要素のリストを見つけるために使用します。 これを実現するために、親Web要素は’findElements'と連鎖して子要素にアクセスします。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import java.util.List; public class findElementsFromElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  WebElement element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement e : elements) { System.out.println(e.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(By.TAG_NAME, \u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System.Collections.Generic; namespace FindElementsFromElement { class FindElementsFromElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  IWebElement element = driver.FindElement(By.TagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = element.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(:tag_name,\u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get element with tag name \u0026#39;div\u0026#39;  let element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for(let e of elements) { console.log(await e.getText()); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get element with tag name \u0026#39;div\u0026#39;  val element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (e in elements) { println(e.text) } } finally { driver.quit() } }     アクティブな要素の取得 現在のブラウジングコンテキストにフォーカスがあるDOM要素を追跡（または）検索するために使用します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class activeElementTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  String attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); System.out.println(attr); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.find_element(By.CSS_SELECTOR, \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#34;webElement\u0026#34;) # Get attribute of current active element attr = driver.switch_to.active_element.get_attribute(\u0026#34;title\u0026#34;) print(attr)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace ActiveElement { class ActiveElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://www.google.com\u0026#34;); driver.FindElement(By.CssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).SendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  string attr = driver.SwitchTo().ActiveElement().GetAttribute(\u0026#34;title\u0026#34;); System.Console.WriteLine(attr); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.google.com\u0026#39; driver.find_element(css: \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#39;webElement\u0026#39;) # Get attribute of current active element attr = driver.switch_to.active_element.attribute(\u0026#39;title\u0026#39;) puts attr ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); await driver.get(\u0026#39;https://www.google.com\u0026#39;); await driver.findElement(By.css(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  let attr = await driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); console.log(`${attr}`) })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;) // Get attribute of current active element  val attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); print(attr); } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/guidelines_and_recommendations/fresh_browser_per_test/",
	"title": "テストごとに新しいブラウザを起動する",
	"tags": [],
	"description": "",
	"content": "クリーンな既知の状態から各テストを開始します。 理想的には、テストごとに新しい仮想マシンを起動します。 新しい仮想マシンの起動が実用的でない場合は、少なくともテストごとに新しいWebDriverを起動してください。 Firefoxの場合、既知のプロファイルでWebDriverを起動します。\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile); "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/support_packages/chrome_devtools/",
	"title": "Chrome Devtools",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests!\n Selenium 4 alpha versions have much awaited native support for Chrome Dev Protocol through \u0026ldquo;DevTools\u0026rdquo; interface. This helps us getting Chrome Development properties such as Application Cache, Fetch, Network, Performance, Profiler, Resource Timing, Security and Target CDP domains etc.\nChrome DevTools is a set of web developer tools built directly into the Google Chrome browser. DevTools can help you edit pages on-the-fly and diagnose problems quickly, which ultimately helps you build better websites, faster.\nEmulate Geo Location: Some applications have different features and functionalities across different locations. Automating such applications is difficult because it is hard to emulate the geo locations in the browser using Selenium. But with the help of Devtools, we can easily emulate them. Below code snippet demonstrates that.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.devtools.DevTools; public void geoLocationTest(){ ChromeDriver driver = new ChromeDriver(); Map coordinates = new HashMap() {{ put(\u0026#34;latitude\u0026#34;, 50.2334); put(\u0026#34;longitude\u0026#34;, 0.2334); put(\u0026#34;accuracy\u0026#34;, 1); }}; driver.executeCdpCommand(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, coordinates); driver.get(\u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;); }   # Please raise a PR to add code sample   // Please raise a PR to add code sample    # Please raise a PR to add code sample   // Please raise a PR to add code sample    // Please raise a PR to add code sample      "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/webdriver/keyboard/",
	"title": "キーボード",
	"tags": [],
	"description": "",
	"content": "キーボードはキーボードイベントを表します。 キーボードアクションは、仮想化されたデバイス入力をWebブラウザーに提供できる低レベルインターフェイスを使用して実行されます。\nsendKeys sendKeysは、修飾キーシーケンスが検出された場合でも、DOM要素にキーシーケンスを入力します。 WebDriverがサポートする可能なキーストロークのリストは、こちらにあります。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER);\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Firefox()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r \rusing (var driver = new FirefoxDriver())\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :firefox\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.firefox.FirefoxDriver\rfun main() {\rval driver = FirefoxDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER)\r} finally {\rdriver.quit()\r}\r}\r \r  keyDown keyDownは、修飾キー（CONTROL、SHIFT、ALT）を押す動作をシミュレートするために使用します。\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER);\rActions actionProvider = new Actions(driver);\rAction keydown = actionProvider.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build();\rkeydown.perform();\r} finally {\rdriver.quit();\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r webdriver.ActionChains(driver).key_down(Keys.CONTROL).send_keys(\u0026#34;a\u0026#34;).perform()\r \rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r Actions actionProvider = new Actions(driver);\rIAction keydown = actionProvider.KeyDown(Keys.Control).SendKeys(\u0026#34;a\u0026#34;).Build();\rkeydown.Perform();\r}\rfinally\r{\rdriver.Quit();\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r driver.action.key_down(:control).send_keys(\u0026#39;a\u0026#39;).perform\rensure\rdriver.quit\rend\r \r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r await driver.actions().keyDown(Key.CONTROL).sendKeys(\u0026#39;a\u0026#39;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\rval action = Actions(driver)\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r action.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  keyUp keyUpは、修飾キー（CONTROL、SHIFT、ALT）のキーアップ（または）キーリリース操作をシミュレートするために使用します。\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rimport org.openqa.selenium.interactions.Actions;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r WebElement search = driver.findElement(By.name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search,\u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store google search box WebElement\r search = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\raction = webdriver.ActionChains(driver)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.key_down(Keys.SHIFT).send_keys_to_element(search, \u0026#34;qwerty\u0026#34;).key_up(Keys.SHIFT).send_keys(\u0026#34;qwerty\u0026#34;).perform()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing OpenQA.Selenium.Interactions;\rnamespace HelloSelenium\r{\rclass HelloSelenium\r{\rpublic static void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r IWebElement search = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.KeyDown(Keys.Shift).SendKeys(search, \u0026#34;qwerty\u0026#34;).KeyUp(Keys.Shift).SendKeys(\u0026#34;qwerty\u0026#34;).Perform();\r}\rfinally {\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Store google search box WebElement\r search = driver.find_element(name: \u0026#39;q\u0026#39;)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r driver.action.key_down(:shift).send_keys(search,\u0026#39;qwerty\u0026#39;).key_up(:shift).send_keys(\u0026#34;qwerty\u0026#34;).perform\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store google search box WebElement\r let search = driver.findElement(By.name(\u0026#39;q\u0026#39;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r await driver.actions().click(search).keyDown(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).keyUp(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Store google search box WebElement\r val search = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rval action = Actions(driver)\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search, \u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  clear 編集可能な要素のコンテンツをクリアします。 これは、編集可能かつ対話可能な要素にのみ適用されます。 そうでない場合、seleniumはエラーを返します（無効な要素状態（または）要素は対話不可能）\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.chrome.ChromeDriver;\rpublic class clear {\rpublic static void main(String[] args) {\rWebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r WebElement searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;));\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.clear();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store \u0026#39;SearchInput\u0026#39; element\r SearchInput = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\rSearchInput.send_keys(\u0026#34;selenium\u0026#34;)\r# Clears the entered text\r SearchInput.clear()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing System;\rnamespace SnipetProjectDelete\r{\rclass Program\r{\rstatic void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(@\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r IWebElement searchInput = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\rsearchInput.SendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.Clear();\r}\rfinally\r{\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# store \u0026#39;search_input\u0026#39; element\r search_input = driver.find_element(name: \u0026#39;q\u0026#39;)\rsearch_input.send_keys(\u0026#39;selenium\u0026#39;)\r# Clears the entered text\r search_input.clear\rensure\rdriver.quit\rend\r \rconst {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store \u0026#39;SearchInput\u0026#39; element\r let searchInput = driver.findElement(By.name(\u0026#39;q\u0026#39;));\rawait searchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r await searchInput.clear();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.chrome.ChromeDriver\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;)\r// Store \u0026#39;searchInput\u0026#39; element\r val searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;)\r// Clears the entered text\r searchInput.clear()\r} finally {\rdriver.quit()\r}\r}\r \r  "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/driver_idiosyncrasies/",
	"title": "ドライバーの特異性",
	"tags": [],
	"description": "",
	"content": "ドライバーの特異性 "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/support_packages/",
	"title": "サポートパッケージ",
	"tags": [],
	"description": "",
	"content": "サポートパッケージ "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/legacy_docs/",
	"title": "レガシー",
	"tags": [],
	"description": "",
	"content": "レガシー このセクションでは、Seleniumのレガシーコンポーネントに関連するすべてのドキュメントを見つけることができます。 これは、非推奨コンポーネントを使用する動機としてではなく、純粋に歴史的な理由で保持されることを意図しています。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/front_matter/",
	"title": "奥付け",
	"tags": [],
	"description": "",
	"content": "奥付け "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.selenium.dev/documentation/ja/contributing/",
	"title": "Seleniumのサイトとドキュメントに貢献する",
	"tags": [],
	"description": "",
	"content": "Seleniumは大きなソフトウェアプロジェクトであり、そのサイトとドキュメントは、物事の仕組みを理解し、その可能性を活用する効果的な方法を学ぶための鍵となります。\nこのプロジェクトには、Seleniumのサイトとドキュメントの両方が含まれています。これは、Seleniumを効果的に使用する方法、Seleniumに参加する方法、およびSeleniumに貢献する方法に関する最新情報を提供するための継続的な取り組みです（特定のリリースを対象としていません）。\nサイトおよびドキュメントへの貢献は、以下のセクションで説明されているプロセスに従います。 このドキュメントについてをよく読み、本ドキュメントに慣れてください。\n Seleniumプロジェクトは、皆様からのコントリビューションを歓迎します。 お手伝いをいただくには、いくつかの方法があります:\nイシュー報告 新しい問題を報告したり、既存の問題についてコメントしたりするときは、議論がSeleniumソフトウェア、そのサイトおよび/またはドキュメントに関する具体的な技術問題に関連していることを確認してください。\nSeleniumのすべてのコンポーネントは、時間の経過とともに非常に速く変化するため、ドキュメントが古くなる可能性があります。 このようなケースを見つけた場合には、遠慮なくイシューを作成してください。 また、ドキュメントを最新の状態に更新する方法をご存知でしたら、関連する変更を含むプルリクエストを送ってしてください。\n見つかったものが問題であるかどうかわからない場合、https://selenium.dev/supportに記載されているコミュニケーション手段にて質問してください。\n貢献 Seleniumプロジェクトは新しいコントリビュータを歓迎します。目立った価値ある貢献を継続的に行った個人は コミッター として認められ、プロジェクトへのコミットアクセス件が与えられます。\n本ガイドでは、貢献のプロセスについて説明します。\nステップ 1: フォーク Github上のプロジェクトをフォークし、コピーをローカルにチェックアウトしてください。\n% git clone git@github.com:seleniumhq/seleniumhq.github.io.git % cd seleniumhq.github.io 依存関係: Hugo 本プロジェクトでは、サイトとドキュメントのビルド及びレンダリングにHugoを使用しています。 何らかの変更をコミットする前にローカルで検証を行うには、Hugoをインストールし、慣れたうえで、ローカルサーバーを起動してローカルでサイトをレンダリングしてください。（詳細な方法は次の手順で説明します。）\nステップ 2: ブランチの作成 フィーチャーブランチを作成し、ハックを開始します。:\n% git checkout -b my-feature-branch 我々はHEADベースの開発を行っています。つまり、全ての変更はmasterブランチ上に直接適用されます。\nステップ 3: 変更を加える リポジトリには、サイトとドキュメントの２つの異なるHugoプロジェクトが含まれます。 サイトを変更したい場合は、site_source_files ディレクトリで作業します。 変更のライブプレビューを確認したい場合は、サイトのルートディレクトリでhugo serverを実行します。\n% cd site_source_files % hugo server ドキュメントを変更したい場合は、docs_source_files ディレクトリに移動します。\n% cd docs_source_files % hugo server ドキュメントは複数の言語に翻訳されており、翻訳は英語版に基づいて行われます。 ファイルに変更を加えたときは、他の翻訳済みファイル全てに必ず同様の変更を加えてください。 ただし、変更内容によって異なります。以下に例を示します:\n browser_manipulation.en.mdファイルにコード例を加えた場合、browser_manipulation.es.md、 browser_manipulation.ef.md及びすべての翻訳ファイルに追加してください。 browser_manipulation.ja.md 翻訳の改善を行う場合は、各言語のファイルのみを変更してください。 新しい言語向けの翻訳を追加したい場合、適切な接尾辞を付けてファイルを追加してください。プルリクエストを送信するために全てを翻訳する必要はありません、イテレーティブに行うことができます。config.tomlファイルで必要な設定値の確認を忘れないでください。 英語版の文章に変更を加えたい場合は、翻訳されたファイルの同じ箇所をあなたの変更で（英語で）書き換えたうえで、以下の注意書きをファイルの先頭に追加してください。  {{% notice info %}} \u0026lt;i class=\u0026#34;fas fa-language\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Page being translated from English to {LANGUAGE}. Do you speak {LANGUAGE}? Help us to translate it by sending us pull requests! {{% /notice %}} ステップ 4: コミット まず、gitがあなたの名前とメールアドレスを知っていることを確認してください:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; **適切なコミットメッセージを書くことは重要です。**コミットメッセージには、変更された内容、理由、修正されたイシューへの参照（ある場合）を記述する必要があります。作成するときは、次のガイドラインに従ってください。:\n 最初の行は約50文字以下で、変更の簡単な説明を含める必要があります。 2行目は空白のままにします。 他のすべての行を72列で折り返します。 Fixes #Nを含めてください。ここでは N がこのコミットで修正したイシュー番号です（存在する場合）。  適切なコミットメッセージは次のようになります:\nexplain commit normatively in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way `git log` will show things nicely even when it is indented. Fixes #141 最初の行はgit shortlogやgit log --onelineを実行した際に他人が最初に目にするため、意味のあるものでなければなりません。\nステップ 5: リベース あなたの作業を同期するため、(git mergeではなく)git rebaseを時々実行してください。\n% git fetch upstream % git rebase upstream/master ステップ 6: テスト あなたの変更が何も問題を起こしていないことを確認するため、常に忘れずにローカルサーバーの実行を行ってください。\nステップ 7: プッシュ % git push origin my-feature-branch https://github.com/yourusername/seleniumhq.github.io.git を開き、_Pull Request_を押し、フォームを入力してください。 CLAに署名したことを示してください (ステップ7を参照)\nプルリクエストは通常数日以内にレビューされます。対応すべきコメントがある場合は、新しく(できれば fixupsで)コミットし、同じブランチにプッシュしてください。\nステップ 8: 統合 コードレビューが完了すると、コミッターがPRを取得し、リポジトリのmasterブランチに統合します。 マスターブランチで履歴を線形に保持するのが好きなので、通常はブランチの履歴をスカッシュしてリベースします。\nコミュニケーション プロジェクトのコントリビューターおよびコミュニティ全体と交流する方法については、全て https://selenium.dev/support で詳細が記載されています。\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ja/",
	"title": "Seleniumブラウザー自動化プロジェクト",
	"tags": [],
	"description": "",
	"content": "Seleniumブラウザー自動化プロジェクト Seleniumはブラウザー自動化を可能にし、それを支えるツール群とライブラリー群プロジェクトです。\nユーザーとブラウザーのやり取りのエミュレーション、ブラウザーの割当を増強したり縮減する分散型サーバー、そしてすべてのメジャーなブラウザー用に置換可能なコードの実装を可能にするW3C WebDriver 仕様インフラの提供します。\nこのプロジェクトは多くの有志貢献者の何千時間に及ぶ個々の時間を費やした事とソースコード自由に利用可能を誰にでも利用、楽しめ、そして改良できることによって実現しました。\nSeleniumはウェブプラットフォームの自動化のより開かれた議論をするためブラウザーベンダー、エンジニア、愛好家をまとめます。このプロジェクトはコミュニティーを導きと育成のために年次カンファレンス開催します。\nSeleniumの中核はWebDriverであり、様々なブラウザーを変えてインストラクション集を実行できるインターフェースです。これは作りえる一番基本的な インストラクションの一つです:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; import java.time.Duration; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #This example requires Selenium WebDriver 3.13 or newer with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located(By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;)) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;a\u0026#34;))); Console.WriteLine(firstResult.Text); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;a\u0026#39;) } puts first_result.text ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { await driver.get(\u0026#39;https://www.google.com/ncr\u0026#39;); await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.RETURN); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;a\u0026#39;)),10000); console.log(await firstResult.getText()); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated import org.openqa.selenium.support.ui.WebDriverWait import java.time.Duration fun main() { val driver = FirefoxDriver() val wait = WebDriverWait(driver, Duration.ofSeconds(10)) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))) println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } }     上記のコードを実行した時、舞台裏で何が起きているかの詳しい説明にはクイックツアーを参照してください。 どのようにインストールするのか、そしてSeleniumをテスト自動化ツールとして上手く利用し、上記の様な基本的なテストを大きいスケールの分散型環境で複数のブラウザー、様々オペレーティングシステムで実行するため拡張方法を理解するため順序順ドキュメンテーションに進んでください。\n入門 もしSeleniumが初めてでしたら、素早く知識を得るためのリソースを用意しました。\n クイックツアー  WebDriver IDE Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/ja/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]