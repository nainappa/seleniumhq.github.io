<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>紹介 on Seleniumドキュメント</title>
    <link>https://www.selenium.dev/documentation/ja/introduction/</link>
    <description>Recent content in 紹介 on Seleniumドキュメント</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>2013-{year}</copyright>
    
	<atom:link href="https://www.selenium.dev/documentation/ja/introduction/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Seleniumプロジェクトとツール</title>
      <link>https://www.selenium.dev/documentation/ja/introduction/the_selenium_project_and_tools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/ja/introduction/the_selenium_project_and_tools/</guid>
      <description>SeleniumはWebブラウザーを制御します Selenium はいろいろなものがありますが中核となるのは、ブラウザインスタンスをリモートで制御し、ブラウザとのユーザーの対話をエミュレートするために利用可能な最良の技術を使用するWebブラウザ自動化用のツールセットです。
ユーザーは、エンドユーザーが実行する一般的なアクティビティをシミュレートできます。 フィールドにテキストを入力し、ドロップダウン値とチェックボックスを選択し、ドキュメント内のリンクをクリックします。 また、マウスの移動、任意のJavaScriptの実行など、他の多くのコントロールも提供します。
主にWebサイトのフロントエンドテストに使用されますが、Seleniumはブラウザーユーザーエージェント ライブラリ の中核です。 インターフェイスはアプリケーションに遍在しているため、目的に合わせて他のライブラリとの組み合わせて使うことを奨励します。
すべてを支配する1つのインターフェース プロジェクトの指針の1つは、すべての（主要な）ブラウザーテクノロジーに共通インターフェイスをサポートすることです。 Webブラウザーは非常に複雑で高度に設計されたアプリケーションであり、まったく異なる方法で操作を実行しますが、実行中に同じように見えることがよくあります。 テキストは同じフォントで表示されますが、画像は同じ場所に表示され、リンクは同じリンク先に移動します。 下で起こっていることは、昼と夜と同じくらい異なっています。 Seleniumはこれらの違いを &amp;ldquo;抽象化&amp;rdquo; し、コードを書いている人から詳細や複雑さを隠します。 これにより、数行のコードを記述して複雑なワークフローを実行できますが、これらの同じ行はFirefox、Internet Explorer、Chrome、およびサポートされている他のすべてのブラウザーで実行されます。
ツールとサポート Seleniumのミニマリストデザインアプローチは、より大きなアプリケーションのコンポーネントとして含まれる汎用性を提供します。 Selenium傘下で提供される周囲のインフラストラクチャは、 ブラウザのグリッド をまとめるツールを提供するため、さまざまなマシンで異なるブラウザーおよび複数のオペレーティングシステムでテストを実行できます。
サーバールームまたはデータセンターにある積み重なったのコンピューターがすべてブラウザーを同時に起動してサイトのリンク、フォーム、およびテーブルにアクセスし、アプリケーションを24時間テストすることを想像してください。 最も一般的な言語用に提供されたシンプルなプログラミングインターフェイスを介して、これらのテストは休むことなく並行して実行され、エラーが発生したときにレポートを返します。
ブラウザを制御するだけでなく、そのようなグリッドを簡単に拡張および展開できるツールとドキュメントをユーザーに提供することで、これを実現することを目指しています。
誰がSeleniumを使うか 世界で最も重要な企業の多くは、ブラウザベースのテストにSeleniumを採用しており、多くの場合、他の独自のツールを使用した長年の努力に取って代わりました。 人気が高まるにつれて、その要件と課題が倍増しています。
ウェブがより複雑になり、新しいテクノロジーがウェブサイトに追加されるにつれて、可能な限りそれらに遅れずについていくことがこのプロジェクトの使命です。 オープンソースプロジェクトであるこのサポートは、&amp;ldquo;本業&amp;quot;をもっている多くのボランティアからの寛大な時間の寄付によって提供されます。
プロジェクトのもう1つの使命は、より多くのボランティアがこの取り組みに参加することを奨励し、プロジェクトが引き続き新しいテクノロジーに追いつき、機能テスト自動化の主要なプラットフォームであり続けることができるよう、強力なコミュニティを構築することです。
歴史 2004年にSelenium 1がリリースされたとき、Webアプリケーションのフロントエンドで一貫した動作を手動で検証するために費やす時間を削減する必要はありませんでした。 当時利用可能なツールを利用し、テスト中のWebページへのJavaScriptの注入に大きく依存して、ユーザーのインタラクションをエミュレートしました。
JavaScriptは、DOMのプロパティを内観し、他の方法では実行できない特定のクライアント側の観察を行うことができる優れたツールですが、キーボードが使っているようなマウスとマウスの操作を自然に複製する機能には不十分です。
それ以来、Seleniumは多くの成長と成熟を遂げ、世界中のほとんどの大規模な組織ではなく、多くの人々が広く使用するツールになりました。 Seleniumは、ニッチな聴衆と特定のユースケースのためにThoughtworksで開発された自作のテスト自動化ツールキットから、世界の デファクト ブラウザ自動化ライブラリになりました。
Selenium RCが当時利用可能な業界のツールを利用したように、Selenium WebDriverは、ブラウザインタラクションの部分をブラウザベンダーの本拠地に持ち込み、バックエンドのブラウザー対応実装の責任を取るよう依頼することにより、その伝統を推進しています。 最近、この作業は、SeleniumのWebDriverコンポーネントをユーザーエージェント用の 最新の リモートコントロールライブラリにすることを目標とするW3C標準化プロセスに進化しました。</description>
    </item>
    
    <item>
      <title>テスト自動化について</title>
      <link>https://www.selenium.dev/documentation/ja/introduction/on_test_automation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/ja/introduction/on_test_automation/</guid>
      <description>まず、本当にブラウザを使用する必要があるかどうかを自問することから始めます。 ある時点で複雑なWebアプリケーションで作業している場合、おそらくブラウザを開いて実際にテストする必要があるでしょう。
ただし、Seleniumテストなどの機能的なエンドユーザーテストの実行には費用がかかります。 さらに、それらは通常、効果的に実行するために適切なインフラストラクチャを配置する必要があります。 単体テストなどのより軽量なテストアプローチを使用して、または下位レベルのアプローチを使用して、テストすることを実行できるかどうかを常に自問するのは良いルールです。
Webブラウザーのテストビジネスに参加していることを確認し、Selenium環境でテストの記述を開始できるようになったら、通常は3つのステップを組み合わせて実行します。
 データを設定する 個別の一連のアクションを実行する 結果を評価する  これらの手順はできるだけ短くしてください。 ほとんどの場合、1つまたは2つの操作で十分です。 ブラウザの自動化は&amp;quot;不安定&amp;quot;であるという評判がありますが、実際には、ユーザーが頻繁に多くを求めることが多いためです。 後の章では、特にブラウザーとWebDriver間の競合状態を克服する方法に関する、テストでの断続的な問題を軽減するために使用できる手法に戻ります。
テストを短くして、代替手段がまったくない場合にのみWebブラウザーを使用することで、不安定さを最小限にして多くのテストを実行できます。
Seleniumテストの明確な利点は、ユーザーの観点から、バックエンドからフロントエンドまで、アプリケーションのすべてのコンポーネントをテストする固有の機能です。 つまり、機能テストは実行に費用がかかる可能性がありますが、同時にビジネスに不可欠な大規模な部分も含まれます。
テスト要件 前述のように、Seleniumテストの実行には費用がかかる場合があります。 どの程度までテストを実行しているブラウザーに依存しますが、歴史的にブラウザーの動作は非常に多様であるため、多くの場合、複数のブラウザーに対するクロステストの目標として述べられてきました。
Seleniumを使用すると、複数のオペレーティングシステム上の複数のブラウザーに対して同じ命令を実行できますが、すべての可能なブラウザー、それらの異なるバージョン、およびそれらが実行される多くのオペレーティングシステムの列挙はすぐに重要な作業になります。
例から始めましょう ラリーは、ユーザーがカスタムユニコーンを注文できるWebサイトを作成しました。
一般的なワークフロー（&amp;ldquo;ハッピーパス&amp;quot;と呼ぶ）は次のようなものです。
 アカウントを作成する ユニコーンを設定する ショッピングカートにユニコーンを追加します チェックアウトしてお支払い ユニコーンについてフィードバックを送る  これらのすべての操作を実行するために1つの壮大なSeleniumスクリプトを作成するのは魅力的です。 その誘惑に抵抗しましょう！ そうすると、
a）時間がかかる
b）ページレンダリングのタイミングの問題に関する一般的な問題が発生する
c）失敗した場合、簡潔で&amp;quot;一目瞭然&amp;quot;にならない、何がうまくいかなかったかを診断する方法がない
というテストになります。
このシナリオをテストするための好ましい戦略は、一連の独立した迅速なテストに分割することです。 各テストには、1つの&amp;quot;理由&amp;quot;が存在します。
2番目のステップであるユニコーンの構成をテストしたいと思います。 次のアクションを実行します。
 アカウントを作成する ユニコーンを設定する  これらの手順の残りをスキップしていることに注意してください。 この手順を完了した後、他の小さな個別のテストケースで残りのワークフローをテストします。
開始するには、アカウントを作成する必要があります。 ここには、いくつかの選択があります。
 既存のアカウントを使用しますか？ 新しいアカウントを作成しますか？ 設定を開始する前に考慮する必要があるそのようなユーザーの特別なプロパティはありますか？  この質問への回答方法に関係なく、テストの&amp;quot;データのセットアップ&amp;quot;部分の一部にすると解決します。 ラリーが、ユーザー（またはだれでも）がユーザーアカウントを作成および更新できるAPIを公開している場合は、それを使用してこの質問に回答してください。 可能であれば、資格情報を使用してログインできるユーザーが&amp;quot;手元に&amp;quot;いる場合にのみブラウザを起動します。
各ワークフローの各テストがユーザーアカウントの作成から始まる場合、各テストの実行に何秒も追加されます。 APIの呼び出しとデータベースとの対話は、ブラウザを開いたり、適切なページに移動したり、フォームをクリックして送信されるのを待つなどの高価なプロセスを必要としない、迅速な&amp;quot;ヘッドレス&amp;quot;操作です。
理想的には、1行のコードでこのセットアップフェーズに対処できます。 これは、ブラウザーが起動する前に実行されます。
Java Python C# Ruby JavaScript Kotlin // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges.</description>
    </item>
    
    <item>
      <title>テストの種類</title>
      <link>https://www.selenium.dev/documentation/ja/introduction/types_of_testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/ja/introduction/types_of_testing/</guid>
      <description>受け入れテスト このタイプのテストは、機能またはシステムが顧客の期待と要件を満たしているかどうかを判断するために行われます。 このタイプのテストには通常、顧客の協力またはフィードバックが関与します。 下記質問に答えることで確認することができます。
 正しい 製品を作っていますか？
 Webアプリケーションの場合、ユーザーの予想される動作をシミュレートすることで、 このテストの自動化をSeleniumで直接実行できます。 このシミュレーションは、このドキュメントで説明されているように、記録/再生によって、 またはサポートされているさまざまな言語によって実行できます。 注：受け入れテストは 機能テスト のサブタイプであり、一部の人はこれにも言及する場合があります。
機能テスト このタイプのテストは、機能またはシステムが問題なく正常に機能するかどうかを判断するために行われます。 システムをさまざまなレベルでチェックして、すべてのシナリオがカバーされていること、 およびシステムが実行すべきことを実行していることを確認します。 下記質問に答えることで確認することができます。
 製品を 正しく 作っていますか？
 これは通常以下を含みます。 テストがエラーなし（404、例外&amp;hellip;）、使用可能な方法（正しいリダイレクト）で機能する、 利用しやすく、仕様に一致します（上記の 受け入れテスト を参照）。
Webアプリケーションの場合、期待されるリターンをシミュレートすることにより、このテストの自動化をSeleniumで直接実行できます。 このシミュレーションは、このドキュメントで説明されているように、記録/再生またはサポートされているさまざまな言語で実行できます。
パフォーマンステスト その名前が示すように、パフォーマンステストは、アプリケーションのパフォーマンスを測定するために行われます。
パフォーマンステストには2つの主なサブタイプがあります。
ロードテスト ロードテストは、定義されたさまざまな負荷（通常、特定の数のユーザーが同時に接続されている場合）でアプリケーションがどの程度機能するかを確認するために行われます。
ストレステスト ストレステストは、ストレス下（またはサポートされている最大負荷以上）でアプリケーションがどの程度機能するかを確認するために行われます。
一般に、パフォーマンステストは、Seleniumで書かれたテストを実行して、さまざまなユーザーがWebアプリの特定の機能を押して、意味のある測定値を取得することをシミュレートして実行されます。
これは通常、メトリックを取得する他のツールによって行われます。 そのようなツールの1つが JMeter です。
Webアプリケーションの場合、測定する詳細には、スループット、待ち時間、データ損失、個々のコンポーネントの読み込み時間などが含まれます…
注1：すべてのブラウザには、開発者のツールセクションにパフォーマンスタブがあります（F12キーを押すとアクセス可能）
注2：これは一般に機能/機能ごとではなくシステムごとに測定されるため、 非機能テスト のサブタイプです。
回帰テスト このテストは通常、変更、修正、または機能の追加後に行われます。
変更によって既存の機能が破壊されないようにするために、すでに実行されたいくつかのテストが再度実行されます。
再実行されるテストのセットは、完全または部分的なものにすることができ、アプリケーションおよび開発チームに応じて、いくつかの異なるタイプを含めることができます。
テスト駆動開発 (TDD) テストタイプそのものではなく、TDDはテストが機能の設計を推進する反復的な開発方法論です。
各サイクルは、機能がパスする単体テストのセットを作成することから始まります（最初に実行すると失敗します）。
この後、テストに合格するための開発が行われます。 別のサイクルを開始してテストが再度実行され、すべてのテストに合格するまでこのプロセスが続行されます。
これは、欠陥が発見されるほどコストが安くなるという事実に基づいて、アプリケーションの開発をスピードアップすることを目的としています。
ビヘイビア駆動開発 (BDD) BDDは、上記に基づいた反復開発方法論（TDD）でもあり、その目的は、アプリケーションの開発にすべての関係者を関与させることです。
各サイクルは、いくつかの仕様を作成することから始まります（これは失敗するはずです）。 次に、失敗する単体テスト（これも失敗するはずです）を作成し、開発を作成します。
このサイクルは、すべてのタイプのテストに合格するまで繰り返されます。
そのためには、仕様言語が使用されます。 すべての関係者が理解でき、単純で、標準的かつ明示的でなければなりません。 ほとんどのツールは、この言語として Gherkin を使用します。</description>
    </item>
    
    <item>
      <title>このドキュメントについて</title>
      <link>https://www.selenium.dev/documentation/ja/introduction/about_this_documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.selenium.dev/documentation/ja/introduction/about_this_documentation/</guid>
      <description>これらのドキュメントは、コード自体と同様に、Seleniumコミュニティ内のボランティアによって100％維持されます。 当初から多くの人が使用してきましたが、多くの人が短期間しか使用しておらず、新しいユーザーのオンボーディングエクスペリエンスの改善に時間を割いてきました。
ドキュメントに問題がある場合、知りたいです！ 問題を伝える最良の方法は、https://github.com/seleniumhq/seleniumhq.github.io/issuesにアクセスし、問題が既に報告されているかどうかを検索することです。 そうでない場合は、自由に開いてください！
コミュニティの多くのメンバーは、irc.freenode.netで #selenium IRCチャンネルに頻繁にアクセスします。 気軽に立ち寄って質問してください。 これらのドキュメントで役立つと思われるヘルプを受け取った場合は、必ず貢献を追加してください。 これらのドキュメントを更新することはできますが、通常のコミッター以外から投稿を受け取ると、誰にとってもずっと簡単になります。</description>
    </item>
    
  </channel>
</rss>