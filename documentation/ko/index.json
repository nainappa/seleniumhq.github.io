[
{
	"uri": "https://www.selenium.dev/documentation/ko/front_matter/copyright_and_attributions/",
	"title": "Copyright and attributions",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n The Documentation of Selenium Copyright \u0026copy; 2013-2020 , Software Freedom Conservancy.\nEvery effort has been made to make this documentation as complete and as accurate as possible, but no warranty or fitness is implied. The information provided is on an “as-is” basis. The authors and the publisher shall have neither liability nor responsibility to any person or entity with respect to any loss or damages arising from the information contained in this book. No patent liability is assumed with respect to the use of the information contained herein.\nAttributions Thanks to: Selenium Main Repository Selenium IDE Docker Selenium Selenium Website \u0026amp; Docs Previous Selenium Website Previous Documentation Rewrite Project Third-Party software used by Selenium documentation project:    Software Version License     Hugo v0.59.0 Apache 2.0   Hugo Learn Theme v2.4.0 MIT   Code Tabs Style \u0026mdash; MIT    License All code and documentation originating from the Selenium project is licensed under the Apache 2.0 license, with the Software Freedom Conservancy as the copyright holder.\nThe license is included here for convenience, but you can also find it on the Apache Foundation\u0026rsquo;s websites:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/page_object_models/",
	"title": "Page object models",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Page Object is a Design Pattern which has become popular in test automation for enhancing test maintenance and reducing code duplication. A page object is an object-oriented class that serves as an interface to a page of your AUT. The tests then use the methods of this page object class whenever they need to interact with the UI of that page. The benefit is that if the UI changes for the page, the tests themselves don’t need to change, only the code within the page object needs to change. Subsequently all changes to support that new UI are located in one place.\nThe Page Object Design Pattern provides the following advantages:\n There is a clean separation between test code and page specific code such as locators (or their use if you’re using a UI Map) and layout. There is a single repository for the services or operations offered by the page rather than having these services scattered throughout the tests.  In both cases this allows any modifications required due to UI changes to all be made in one place. Useful information on this technique can be found on numerous blogs as this ‘test design pattern’ is becoming widely used. We encourage the reader who wishes to know more to search the internet for blogs on this subject. Many have written on this design pattern and can provide useful tips beyond the scope of this user guide. To get you started, though, we’ll illustrate page objects with a simple example.\nFirst, consider an example, typical of test automation, that does not use a page object:\n/*** * Tests login feature */ public class Login { public void testLogin() { // fill login data on sign-in page  driver.findElement(By.name(\u0026#34;user_name\u0026#34;)).sendKeys(\u0026#34;testUser\u0026#34;); driver.findElement(By.name(\u0026#34;password\u0026#34;)).sendKeys(\u0026#34;my supersecret password\u0026#34;); driver.findElement(By.name(\u0026#34;sign-in\u0026#34;)).click(); // verify h1 tag is \u0026#34;Hello userName\u0026#34; after login  driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).isDisplayed(); assertThat(driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).getText(), is(\u0026#34;Hello userName\u0026#34;)); } } There are two problems with this approach.\n There is no separation between the test method and the AUT’s locators (IDs in this example); both are intertwined in a single method. If the AUT’s UI changes its identifiers, layout, or how a login is input and processed, the test itself must change. The ID-locators would be spread in multiple tests, in all tests that had to use this login page.  Applying the page object techniques, this example could be rewritten like this in the following example of a page object for a Sign-in page.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Sign-in page. */ public class SignInPage { protected static WebDriver driver; // \u0026lt;input name=\u0026#34;user_name\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By usernameBy = By.name(\u0026#34;user_name\u0026#34;); // \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By passwordBy = By.name(\u0026#34;password\u0026#34;); // \u0026lt;input name=\u0026#34;sign_in\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;SignIn\u0026#34;\u0026gt;  private By signinBy = By.name(\u0026#34;sign_in\u0026#34;); public SignInPage(WebDriver driver){ this.driver = driver; } /** * Login as valid user * * @param userName * @param password * @return HomePage object */ public HomePage loginValidUser(String userName, String password) { driver.findElement(usernameBy).sendKeys(userName); driver.findElement(passwordBy).sendKeys(password); driver.findElement(signinBy).click(); return new HomePage(driver); } } and page object for a Home page could look like this.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Home Page */ public class HomePage { protected static WebDriver driver; // \u0026lt;h1\u0026gt;Hello userName\u0026lt;/h1\u0026gt;  private By messageBy = By.tagName(\u0026#34;h1\u0026#34;); public HomePage(WebDriver driver){ this.driver = driver; if (!driver.getTitle().equals(\u0026#34;Home Page of logged in user\u0026#34;)) { throw new IllegalStateException(\u0026#34;This is not Home Page of logged in user,\u0026#34; + \u0026#34; current page is: \u0026#34; + driver.getCurrentUrl()); } } /** * Get message (h1 tag) * * @return String message text */ public String getMessageText() { return driver.findElement(messageBy).getText(); } public HomePage manageProfile() { // Page encapsulation to manage profile functionality  return new HomePage(driver); } /* More methods offering the services represented by Home Page of Logged User. These methods in turn might return more Page Objects for example click on Compose mail button could return ComposeMail class object */ } So now, the login test would use these two page objects as follows.\n/*** * Tests login feature */ public class TestLogin { @Test public void testLogin() { SignInPage signInPage = new SignInPage(driver); HomePage homePage = signInPage.loginValidUser(\u0026#34;userName\u0026#34;, \u0026#34;password\u0026#34;); assertThat(homePage.getMessageText(), is(\u0026#34;Hello userName\u0026#34;)); } } There is a lot of flexibility in how the page objects may be designed, but there are a few basic rules for getting the desired maintainability of your test code.\nPage objects themselves should never make verifications or assertions. This is part of your test and should always be within the test’s code, never in an page object. The page object will contain the representation of the page, and the services the page provides via methods but no code related to what is being tested should be within the page object.\nThere is one, single, verification which can, and should, be within the page object and that is to verify that the page, and possibly critical elements on the page, were loaded correctly. This verification should be done while instantiating the page object. In the examples above, both the SignInPage and HomePage constructors check that the expected page is available and ready for requests from the test.\nA page object does not necessarily need to represent all the parts of a page itself. The same principles used for page objects can be used to create \u0026ldquo;Page Component Objects\u0026rdquo; that represent discrete chunks of the page and can be included in page objects. These component objects can provide references the elements inside those discrete chunks, and methods to leverage the functionality provided by them. You can even nest component objects inside other component objects for more complex pages. If a page in the AUT has multiple components, or common components used throughout the site (e.g. a navigation bar), then it may improve maintainability and reduce code duplication.\nThere are other design patterns that also may be used in testing. Some use a Page Factory for instantiating their page objects. Discussing all of these is beyond the scope of this user guide. Here, we merely want to introduce the concepts to make the reader aware of some of the things that can be done. As was mentioned earlier, many have blogged on this topic and we encourage the reader to search for blogs on these topics.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/remote_webdriver/remote_webdriver_server/",
	"title": "Remote WebDriver server",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n The server will always run on the machine with the browser you want to test. The server can be used either from the command line or through code configuration.\nStarting the server from the command line Once you have downloaded selenium-server-standalone-{VERSION}.jar, place it on the computer with the browser you want to test. Then, from the directory with the jar, run the following:\njava -jar selenium-server-standalone-{VERSION}.jar Considerations for running the server The caller is expected to terminate each session properly, calling either Selenium#stop() or WebDriver#quit.\nThe selenium-server keeps in-memory logs for each ongoing session, which are cleared when Selenium#stop() or WebDriver#quit is called. If you forget to terminate these sessions, your server may leak memory. If you keep extremely long-running sessions, you will probably need to stop/quit every now and then (or increase memory with -Xmx jvm option).\nTimeouts (from version 2.21) The server has two different timeouts, which can be set as follows:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  Controls how long the browser is allowed to hang (value in seconds).   timeout  Controls how long the client is allowed to be gone before the session is reclaimed (value in seconds).    The system property selenium.server.session.timeout is no longer supported as of 2.21.\nPlease note that the browserTimeout is intended as a backup timeout mechanism when the ordinary timeout mechanism fails, which should be used mostly in grid/server environments to ensure that crashed/lost processes do not stay around for too long, polluting the runtime environment.\nConfiguring the server programmatically In theory, the process is as simple as mapping the DriverServlet to a URL, but it is also possible to host the page in a lightweight container, such as Jetty, configured entirely in code.\n Download the selenium-server.zip and unpack. Put the JARs on the CLASSPATH. Create a new class called AppServer. Here, we are using Jetty, so you will need to download that as well:  import org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } } "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/legacy_docs/selenium_rc/",
	"title": "Selenium 1 (Selenium RC)",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Introduction Selenium RC was the main Selenium project for a long time, before the WebDriver/Selenium merge brought up Selenium 2, a more powerful tool. It is worth to highlight that Selenium 1 is not supported anymore.\nHow Selenium RC Works First, we will describe how the components of Selenium RC operate and the role each plays in running your test scripts.\nRC Components Selenium RC components are:\n The Selenium Server which launches and kills browsers, interprets and runs the Selenese commands passed from the test program, and acts as an HTTP proxy, intercepting and verifying HTTP messages passed between the browser and the AUT. Client libraries which provide the interface between each programming language and the Selenium RC Server.  Here is a simplified architecture diagram:\nThe diagram shows the client libraries communicate with the Server passing each Selenium command for execution. Then the server passes the Selenium command to the browser using Selenium-Core JavaScript commands. The browser, using its JavaScript interpreter, executes the Selenium command. This runs the Selenese action or verification you specified in your test script.\nSelenium Server Selenium Server receives Selenium commands from your test program, interprets them, and reports back to your program the results of running those tests.\nThe RC server bundles Selenium Core and automatically injects it into the browser. This occurs when your test program opens the browser (using a client library API function). Selenium-Core is a JavaScript program, actually a set of JavaScript functions which interprets and executes Selenese commands using the browser\u0026rsquo;s built-in JavaScript interpreter.\nThe Server receives the Selenese commands from your test program using simple HTTP GET/POST requests. This means you can use any programming language that can send HTTP requests to automate Selenium tests on the browser.\nClient Libraries The client libraries provide the programming support that allows you to run Selenium commands from a program of your own design. There is a different client library for each supported language. A Selenium client library provides a programming interface (API), i.e., a set of functions, which run Selenium commands from your own program. Within each interface, there is a programming function that supports each Selenese command.\nThe client library takes a Selenese command and passes it to the Selenium Server for processing a specific action or test against the application under test (AUT). The client library also receives the result of that command and passes it back to your program. Your program can receive the result and store it into a program variable and report it as a success or failure, or possibly take corrective action if it was an unexpected error.\nSo to create a test program, you simply write a program that runs a set of Selenium commands using a client library API. And, optionally, if you already have a Selenese test script created in the Selenium-IDE, you can generate the Selenium RC code. The Selenium-IDE can translate (using its Export menu item) its Selenium commands into a client-driver\u0026rsquo;s API function calls. See the Selenium-IDE chapter for specifics on exporting RC code from Selenium-IDE.\nInstallation Installation is rather a misnomer for Selenium. Selenium has a set of libraries available in the programming language of your choice. You could download them from the downloads page.\nOnce you\u0026rsquo;ve chosen a language to work with, you simply need to:\n Install the Selenium RC Server. Set up a programming project using a language specific client driver.  Installing Selenium Server The Selenium RC server is simply a Java jar file (selenium-server-standalone-.jar), which doesn\u0026rsquo;t require any special installation. Just downloading the zip file and extracting the server in the desired directory is sufficient.\nRunning Selenium Server Before starting any tests you must start the server. Go to the directory where Selenium RC\u0026rsquo;s server is located and run the following from a command-line console.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar This can be simplified by creating a batch or shell executable file (.bat on Windows and .sh on Linux) containing the command above. Then make a shortcut to that executable on your desktop and simply double-click the icon to start the server.\nFor the server to run you\u0026rsquo;ll need Java installed and the PATH environment variable correctly configured to run it from the console. You can check that you have Java correctly installed by running the following on a console.\njava -version If you get a version number (which needs to be 1.5 or later), you\u0026rsquo;re ready to start using Selenium RC.\nUsing the Java Client Driver  Download Selenium java client driver zip from the SeleniumHQ downloads page. Extract selenium-java-.jar file Open your desired Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.) Create a java project. Add the selenium-java-.jar files to your project as references. Add to your project classpath the file selenium-java-.jar. From Selenium-IDE, export a script to a Java file and include it in your Java project, or write your Selenium test in Java using the selenium-java-client API. The API is presented later in this chapter. You can either use JUnit, or TestNg to run your test, or you can write your own simple main() program. These concepts are explained later in this section. Run Selenium server from the console. Execute your test from the Java IDE or from the command-line.  For details on Java test project configuration, see the Appendix sections Configuring Selenium RC With Eclipse and Configuring Selenium RC With Intellij.\nUsing the Python Client Driver  Install Selenium via PIP, instructions linked at SeleniumHQ downloads page Either write your Selenium test in Python or export a script from Selenium-IDE to a python file. Run Selenium server from the console Execute your test from a console or your Python IDE  For details on Python client driver configuration, see the appendix Python Client Driver Configuration.\nUsing the .NET Client Driver  Download Selenium RC from the SeleniumHQ downloads page Extract the folder Download and install NUnit ( Note: You can use NUnit as your test engine. If you\u0026rsquo;re not familiar yet with NUnit, you can also write a simple main() function to run your tests; however NUnit is very useful as a test engine.) Open your desired .Net IDE (Visual Studio, SharpDevelop, MonoDevelop) Create a class library (.dll) Add references to the following DLLs: nmock.dll, nunit.core.dll, nunit. framework.dll, ThoughtWorks.Selenium.Core.dll, ThoughtWorks.Selenium.IntegrationTests.dll and ThoughtWorks.Selenium.UnitTests.dll Write your Selenium test in a .Net language (C#, VB.Net), or export a script from Selenium-IDE to a C# file and copy this code into the class file you just created. Write your own simple main() program or you can include NUnit in your project for running your test. These concepts are explained later in this chapter. Run Selenium server from console Run your test either from the IDE, from the NUnit GUI or from the command line  For specific details on .NET client driver configuration with Visual Studio, see the appendix .NET client driver configuration.\nUsing the Ruby Client Driver  If you do not already have RubyGems, install it from RubyForge. Run gem install selenium-client At the top of your test script, add require \u0026quot;selenium/client\u0026quot; Write your test script using any Ruby test harness (eg Test::Unit, Mini::Test or RSpec). Run Selenium RC server from the console. Execute your test in the same way you would run any other Ruby script.  For details on Ruby client driver configuration, see the Selenium-Client documentation_\nFrom Selenese to a Program The primary task for using Selenium RC is to convert your Selenese into a programming language. In this section, we provide several different language-specific examples.\nSample Test Script Let\u0026rsquo;s start with an example Selenese test script. Imagine recording the following test with Selenium-IDE.\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     Note: This example would work with the Google search page http://www.google.com\nSelenese as Programming Code Here is the test script exported (via Selenium-IDE) to each of the supported programming languages. If you have at least basic knowledge of an object- oriented programming language, you will understand how Selenium runs Selenese commands by reading one of these examples. To see an example in a specific language, select one of these buttons.\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } } Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt; Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end In the next section we\u0026rsquo;ll explain how to build a test program using the generated code.\nProgramming Your Test Now we\u0026rsquo;ll illustrate how to program your own tests using examples in each of the supported programming languages. There are essentially two tasks:\n Generate your script into a programming language from Selenium-IDE, optionally modifying the result. Write a very simple main program that executes the generated code.  Optionally, you can adopt a test engine platform like JUnit or TestNG for Java, or NUnit for .NET if you are using one of those languages.\nHere, we show language-specific examples. The language-specific APIs tend to differ from one to another, so you\u0026rsquo;ll find a separate explanation for each.\n Java C# Python Ruby Perl, PHP  Java For Java, people use either JUnit or TestNG as the test engine.\nSome development environments like Eclipse have direct support for these via plug-ins. This makes it even easier. Teaching JUnit or TestNG is beyond the scope of this document however materials may be found online and there are publications available. If you are already a \u0026ldquo;java-shop\u0026rdquo; chances are your developers will already have some experience with one of these test frameworks.\nYou will probably want to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); The Selenium-IDE generated code will look like this. This example has comments added manually for additional clarity.\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# The .NET Client Driver works with Microsoft.NET. It can be used with any .NET testing framework like NUnit or the Visual Studio 2005 Team System.\nSelenium-IDE assumes you will use NUnit as your testing framework. You can see this in the generated code below. It includes the using statement for NUnit along with corresponding NUnit attributes identifying the role for each member function of the test class.\nYou will probably have to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); The generated code will look similar to this.\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } } You can allow NUnit to manage the execution of your tests. Or alternatively, you can write a simple main() program that instantiates the test object and runs each of the three methods, SetupTest(), TheNewTest(), and TeardownTest() in turn.\nPython Pyunit is the test framework to use for Python.\nThe basic test structure is:\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Old (pre 2.0) versions of Selenium-IDE generate Ruby code that requires the old Selenium gem. Therefore, it is advisable to update any Ruby scripts generated by the IDE as follows:\n  On line 1, change require \u0026quot;selenium\u0026quot; to require \u0026quot;selenium/client\u0026quot;\n  On line 11, change Selenium::SeleniumDriver.new to Selenium::Client::Driver.new\n  You probably also want to change the class name to something more informative than \u0026ldquo;Untitled,\u0026rdquo; and change the test method\u0026rsquo;s name to something other than \u0026ldquo;test_untitled.\u0026rdquo;\nHere is a simple example created by modifying the Ruby code generated by Selenium IDE, as described above.\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP The members of the documentation team have not used Selenium RC with Perl or PHP. If you are using Selenium RC with either of these two languages please contact the Documentation Team (see the chapter on contributing). We would love to include some examples from you and your experiences, to support Perl and PHP users.\nLearning the API The Selenium RC API uses naming conventions that, assuming you understand Selenese, much of the interface\nwill be self-explanatory. Here, however, we explain the most critical and possibly less obvious aspects.\nStarting the Browser CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start Each of these examples opens the browser and represents that browser by assigning a \u0026ldquo;browser instance\u0026rdquo; to a program variable. This program variable is then used to call methods from the browser. These methods execute the Selenium commands, i.e. like open or type or the verify commands.\nThe parameters required when creating the browser instance are:\n  host Specifies the IP address of the computer where the server is located. Usually, this is the same machine as where the client is running, so in this case localhost is passed. In some clients this is an optional parameter.\n  port Specifies the TCP/IP socket where the server is listening waiting for the client to establish a connection. This also is optional in some client drivers.\n  browser The browser in which you want to run the tests. This is a required parameter.\n  url The base url of the application under test. This is required by all the client libs and is integral information for starting up the browser-proxy-AUT communication.\n  Note that some of the client libraries require the browser to be started explicitly by calling its start() method.\nRunning Commands Once you have the browser initialized and assigned to a variable (generally named \u0026ldquo;selenium\u0026rdquo;) you can make it run Selenese commands by calling the respective methods from the browser variable. For example, to call the type method of the selenium object:\nselenium.type(\u0026#34;field-id\u0026#34;,\u0026#34;string to type\u0026#34;) In the background the browser will actually perform a type operation, essentially identical to a user typing input into the browser, by\nusing the locator and the string you specified during the method call.\nReporting Results Selenium RC does not have its own mechanism for reporting results. Rather, it allows you to build your reporting customized to your needs using features of your chosen programming language. That\u0026rsquo;s great, but what if you simply want something quick that\u0026rsquo;s already done for you? Often an existing library or test framework can meet your needs faster than developing your own test reporting code.\nTest Framework Reporting Tools Test frameworks are available for many programming languages. These, along with their primary function of providing a flexible test engine for executing your tests, include library code for reporting results. For example, Java has two commonly used test frameworks, JUnit and TestNG. .NET also has its own, NUnit.\nWe won\u0026rsquo;t teach the frameworks themselves here; that\u0026rsquo;s beyond the scope of this user guide. We will simply introduce the framework features that relate to Selenium along with some techniques you can apply. There are good books available on these test frameworks however along with information on the internet.\nTest Report Libraries Also available are third-party libraries specifically created for reporting test results in your chosen programming language. These often support a variety of formats such as HTML or PDF.\nWhat\u0026rsquo;s The Best Approach? Most people new to the testing frameworks will begin with the framework\u0026rsquo;s built-in reporting features. From there most will examine any available libraries as that\u0026rsquo;s less time consuming than developing your own. As you begin to use Selenium no doubt you will start putting in your own \u0026ldquo;print statements\u0026rdquo; for reporting progress. That may gradually lead to you developing your own reporting, possibly in parallel to using a library or test framework. Regardless, after the initial, but short, learning curve you will naturally develop what works best for your own situation.\nTest Reporting Examples To illustrate, we\u0026rsquo;ll direct you to some specific tools in some of the other languages supported by Selenium. The ones listed here are commonly used and have been used extensively (and therefore recommended) by the authors of this guide.\nTest Reports in Java   If Selenium Test cases are developed using JUnit then JUnit Report can be used to generate test reports.\n  If Selenium Test cases are developed using TestNG then no external task is required to generate test reports. The TestNG framework generates an HTML report which list details of tests.\n  ReportNG is a HTML reporting plug-in for the TestNG framework. It is intended as a replacement for the default TestNG HTML report. ReportNG provides a simple, colour-coded view of the test results.\n  Logging the Selenese Commands  Logging Selenium can be used to generate a report of all the Selenese commands in your test along with the success or failure of each. Logging Selenium extends the Java client driver to add this Selenese logging ability.  Test Reports for Python  When using Python Client Driver then HTMLTestRunner can be used to generate a Test Report.  Test Reports for Ruby  If RSpec framework is used for writing Selenium Test Cases in Ruby then its HTML report can be used to generate a test report.  Adding Some Spice to Your Tests Now we\u0026rsquo;ll get to the whole reason for using Selenium RC, adding programming logic to your tests. It\u0026rsquo;s the same as for any program. Program flow is controlled using condition statements and iteration. In addition you can report progress information using I/O. In this section we\u0026rsquo;ll show some examples of how programming language constructs can be combined with Selenium to solve common testing problems.\nYou will find as you transition from the simple tests of the existence of page elements to tests of dynamic functionality involving multiple web-pages and varying data that you will require programming logic for verifying expected results. Basically, the Selenium-IDE does not support iteration and standard condition statements. You can do some conditions by embedding JavaScript in Selenese parameters, however iteration is impossible, and most conditions will be much easier in a\nprogramming language. In addition, you may need exception handling for error recovery. For these reasons and others, we have written this section to illustrate the use of common programming techniques to give you greater \u0026lsquo;verification power\u0026rsquo; in your automated testing.\nThe examples in this section are written in C# and Java, although the code is simple and can be easily adapted to the other supported languages. If you have some basic knowledge of an object-oriented programming language you shouldn\u0026rsquo;t have difficulty understanding this section.\nIteration Iteration is one of the most common things people need to do in their tests. For example, you may want to to execute a search multiple times. Or, perhaps for verifying your test results you need to process a \u0026ldquo;result set\u0026rdquo; returned from a database.\nUsing the same Google search example we used earlier, let\u0026rsquo;s check the Selenium search results. This test could use the Selenese:\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     The code has been repeated to run the same steps 3 times. But multiple copies of the same code is not good program practice because it\u0026rsquo;s more work to maintain. By using a programming language, we can iterate over the search results for a more flexible and maintainable solution.\nIn C# // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); } Condition Statements To illustrate using conditions in tests we\u0026rsquo;ll start with an example. A common problem encountered while running Selenium tests occurs when an expected element is not available on page. For example, when running the following line:\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); If element \u0026lsquo;q\u0026rsquo; is not on the page then an exception is thrown:\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found This can cause your test to abort. For some tests that\u0026rsquo;s what you want. But often that is not desirable as your test script has many other subsequent tests to perform.\nA better approach is to first validate whether the element is really present and then take alternatives when it it is not. Let\u0026rsquo;s look at this using Java.\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } The advantage of this approach is to continue with test execution even if some UI elements are not available on page.\nExecuting JavaScript from Your Test JavaScript comes very handy in exercising an application which is not directly supported by Selenium. The getEval method of Selenium API can be used to execute JavaScript from Selenium RC.\nConsider an application having check boxes with no static identifiers. In this case one could evaluate JavaScript from Selenium RC to get ids of all check boxes and then exercise them.\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } To count number of images on a page:\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); Remember to use window object in case of DOM expressions as by default selenium window is referred to, not the test window.\nServer Options When the server is launched, command line options can be used to change the default server behaviour.\nRecall, the server is started by running the following.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar To see the list of options, run the server with the -h option.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h You\u0026rsquo;ll see a list of all the options you can use with the server and a brief description of each. The provided descriptions will not always be enough, so we\u0026rsquo;ve provided explanations for some of the more important options.\nProxy Configuration If your AUT is behind an HTTP proxy which requires authentication then you should configure http.proxyHost, http.proxyPort, http.proxyUser and http.proxyPassword using the following command.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password Multi-Window Mode If you are using Selenium 1.0 you can probably skip this section, since multiwindow mode is the default behavior. However, prior to version 1.0, Selenium by default ran the application under test in a sub frame as shown here.\nSome applications didn\u0026rsquo;t run correctly in a sub frame, and needed to be loaded into the top frame of the window. The multi-window mode option allowed the AUT to run in a separate window rather than in the default frame where it could then have the top frame it required.\nFor older versions of Selenium you must specify multiwindow mode explicitly with the following option:\n-multiwindow As of Selenium RC 1.0, if you want to run your test within a single frame (i.e. using the standard for earlier Selenium versions) you can state this to the Selenium Server using the option\n-singlewindow Specifying the Firefox Profile Firefox will not run two instances simultaneously unless you specify a separate profile for each instance. Selenium RC 1.0 and later runs in a separate profile automatically, so if you are using Selenium 1.0, you can probably skip this section. However, if you\u0026rsquo;re using an older version of Selenium or if you need to use a specific profile for your tests (such as adding an https certificate or having some addons installed), you will need to explicitly specify the profile.\nFirst, to create a separate Firefox profile, follow this procedure. Open the Windows Start menu, select \u0026ldquo;Run\u0026rdquo;, then type and enter one of the following:\nfirefox.exe -profilemanager firefox.exe -P Create the new profile using the dialog. Then when you run Selenium Server, tell it to use this new Firefox profile with the server command-line option -firefoxProfileTemplate and specify the path to the profile using its filename and directory path.\n-firefoxProfileTemplate \u0026#34;path to the profile\u0026#34; Warning: Be sure to put your profile in a new folder separate from the default!!! The Firefox profile manager tool will delete all files in a folder if you delete a profile, regardless of whether they are profile files or not.\nMore information about Firefox profiles can be found in Mozilla\u0026rsquo;s Knowledge Base\nRun Selenese Directly Within the Server Using -htmlSuite You can run Selenese html files directly within the Selenium Server by passing the html file to the server\u0026rsquo;s command line. For instance:\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; This will automatically launch your HTML suite, run all the tests and save a nice HTML report with the results.\nNote: When using this option, the server will start the tests and wait for a specified number of seconds for the test to complete; if the test doesn\u0026rsquo;t complete within that amount of time, the command will exit with a non-zero exit code and no results file will be generated.\nThis command line is very long so be careful when you type it. Note this requires you to pass in an HTML Selenese suite, not a single test. Also be aware the -htmlSuite option is incompatible with -interactive You cannot run both at the same time.\nSelenium Server Logging Server-Side Logs When launching Selenium server the -log option can be used to record valuable debugging information reported by the Selenium Server to a text file.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log This log file is more verbose than the standard console logs (it includes DEBUG level logging messages). The log file also includes the logger name, and the ID number of the thread that logged the message. For example:\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW The message format is\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE This message may be multiline.\nBrowser-Side Logs JavaScript on the browser side (Selenium Core) also logs important messages; in many cases, these can be more useful to the end-user than the regular Selenium Server logs. To access browser-side logs, pass the -browserSideLog argument to the Selenium Server.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog must be combined with the -log argument, to log browserSideLogs (as well as all other DEBUG level logging messages) to a file.\nSpecifying the Path to a Specific Browser You can specify to Selenium RC a path to a specific browser. This is useful if you have different versions of the same browser and you wish to use a specific one. Also, this is used to allow your tests to run against a browser not directly supported by Selenium RC. When specifying the run mode, use the *custom specifier followed by the full path to the browser\u0026rsquo;s executable:\n*custom \u0026lt;path to browser\u0026gt; Selenium RC Architecture Note: This topic tries to explain the technical implementation behind Selenium RC. It\u0026rsquo;s not fundamental for a Selenium user to know this, but could be useful for understanding some of the problems you might find in the future.\nTo understand in detail how Selenium RC Server works and why it uses proxy injection and heightened privilege modes you must first understand the same origin policy_.\nThe Same Origin Policy The main restriction that Selenium faces is the Same Origin Policy. This security restriction is applied by every browser in the market and its objective is to ensure that a site\u0026rsquo;s content will never be accessible by a script from another site. The Same Origin Policy dictates that any code loaded within the browser can only operate within that website\u0026rsquo;s domain. It cannot perform functions on another website. So for example, if the browser loads JavaScript code when it loads www.mysite.com, it cannot run that loaded code against www.mysite2.com\u0026ndash;even if that\u0026rsquo;s another of your sites. If this were possible, a script placed on any website you open would be able to read information on your bank account if you had the account page opened on other tab. This is called XSS (Cross-site Scripting).\nTo work within this policy, Selenium-Core (and its JavaScript commands that make all the magic happen) must be placed in the same origin as the Application Under Test (same URL).\nHistorically, Selenium-Core was limited by this problem since it was implemented in JavaScript. Selenium RC is not, however, restricted by the Same Origin Policy. Its use of the Selenium Server as a proxy avoids this problem. It, essentially, tells the browser that the browser is working on a single \u0026ldquo;spoofed\u0026rdquo; website that the Server provides.\nNote: You can find additional information about this topic on Wikipedia pages about Same Origin Policy and XSS.\nProxy Injection The first method Selenium used to avoid the The Same Origin Policy was Proxy Injection. In Proxy Injection Mode, the Selenium Server acts as a client-configured HTTP proxy1, that sits between the browser and the Application Under Test2. It then masks the AUT under a fictional URL (embedding Selenium-Core and the set of tests and delivering them as if they were coming from the same origin).\nHere is an architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that injects Selenium-Core\u0026rsquo;s JavaScript into the browser-loaded web page. The client-driver passes a Selenese command to the server. The Server interprets the command and then triggers the corresponding JavaScript execution to execute that command within the browser. Selenium-Core instructs the browser to act on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks for the website\u0026rsquo;s content from the Selenium RC server (set as the HTTP proxy for the browser to use). Selenium RC server communicates with the Web server asking for the page and once it receives it, it sends the page to the browser masking the origin to look like the page comes from the same server as Selenium-Core (this allows Selenium-Core to comply with the Same Origin Policy). The browser receives the web page and renders it in the frame/window reserved for it.  Heightened Privileges Browsers This workflow in this method is very similar to Proxy Injection but the main difference is that the browsers are launched in a special mode called Heightened Privileges, which allows websites to do things that are not commonly permitted (as doing XSS_, or filling file upload inputs and pretty useful stuff for Selenium). By using these browser modes, Selenium Core is able to directly open the AUT and read/interact with its content without having to pass the whole AUT through the Selenium RC server.\nHere is the architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that will load Selenium-Core in the web page. Selenium-Core gets the first instruction from the client/driver (via another HTTP request made to the Selenium RC Server). Selenium-Core acts on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks the Web Server for the page. Once the browser receives the web page, renders it in the frame/window reserved for it.  Handling HTTPS and Security Popups Many applications switch from using HTTP to HTTPS when they need to send encrypted information such as passwords or credit card information. This is common with many of today\u0026rsquo;s web applications. Selenium RC supports this.\nTo ensure the HTTPS site is genuine, the browser will need a security certificate. Otherwise, when the browser accesses the AUT using HTTPS, it will assume that application is not \u0026lsquo;trusted\u0026rsquo;. When this occurs the browser displays security popups, and these popups cannot be closed using Selenium RC.\nWhen dealing with HTTPS in a Selenium RC test, you must use a run mode that supports this and handles the security certificate for you. You specify the run mode when your test program initializes Selenium.\nIn Selenium RC 1.0 beta 2 and later use *firefox or *iexplore for the run mode. In earlier versions, including Selenium RC 1.0 beta 1, use *chrome or *iehta, for the run mode. Using these run modes, you will not need to install any special security certificates; Selenium RC will handle it for you.\nIn version 1.0 the run modes *firefox or *iexplore are recommended. However, there are additional run modes of *iexploreproxy and *firefoxproxy. These are provided for backwards compatibility only, and should not be used unless required by legacy test programs. Their use will present limitations with security certificate handling and with the running of multiple windows if your application opens additional browser windows.\nIn earlier versions of Selenium RC, *chrome or *iehta were the run modes that supported HTTPS and the handling of security popups. These were considered ‘experimental modes although they became quite stable and many people used them. If you are using Selenium 1.0 you do not need, and should not use, these older run modes.\nSecurity Certificates Explained Normally, your browser will trust the application you are testing by installing a security certificate which you already own. You can check this in your browser\u0026rsquo;s options or Internet properties (if you don\u0026rsquo;t know your AUT\u0026rsquo;s security certificate ask your system administrator). When Selenium loads your browser it injects code to intercept messages between the browser and the server. The browser now thinks untrusted software is trying to look like your application. It responds by alerting you with popup messages.\nTo get around this, Selenium RC, (again when using a run mode that support this) will install its own security certificate, temporarily, to your client machine in a place where the browser can access it. This tricks the browser into thinking it\u0026rsquo;s accessing a site different from your AUT and effectively suppresses the popups.\nAnother method used with earlier versions of Selenium was to install the Cybervillians security certificate provided with your Selenium installation. Most users should no longer need to do this however; if you are running Selenium RC in proxy injection mode, you may need to explicitly install this security certificate.\nSupporting Additional Browsers and Browser Configurations The Selenium API supports running against multiple browsers in addition to Internet Explorer and Mozilla Firefox. See the https://selenium.dev website for supported browsers. In addition, when a browser is not directly supported, you may still run your Selenium tests against a browser of your choosing by using the \u0026ldquo;*custom\u0026rdquo; run-mode (i.e. in place of *firefox or *iexplore) when your test application starts the browser. With this, you pass in the path to the browsers executable within the API call. This can also be done from the Server in interactive mode.\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com Running Tests with Different Browser Configurations Normally Selenium RC automatically configures the browser, but if you launch the browser using the \u0026ldquo;*custom\u0026rdquo; run mode, you can force Selenium RC to launch the browser as-is, without using an automatic configuration.\nFor example, you can launch Firefox with a custom configuration like this:\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com Note that when launching the browser this way, you must manually configure the browser to use the Selenium Server as a proxy. Normally this just means opening your browser preferences and specifying \u0026ldquo;localhost:4444\u0026rdquo; as an HTTP proxy, but instructions for this can differ radically from browser to browser. Consult your browser\u0026rsquo;s documentation for details.\nBe aware that Mozilla browsers can vary in how they start and stop. One may need to set the MOZ_NO_REMOTE environment variable to make Mozilla browsers behave a little more predictably. Unix users should avoid launching the browser using a shell script; it\u0026rsquo;s generally better to use the binary executable (e.g. firefox-bin) directly.\nTroubleshooting Common Problems When getting started with Selenium RC there\u0026rsquo;s a few potential problems that are commonly encountered. We present them along with their solutions here.\nUnable to Connect to Server When your test program cannot connect to the Selenium Server, Selenium throws an exception in your test program. It should display this message or a similar one:\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2) If you see a message like this, be sure you started the Selenium Server. If so, then there is a problem with the connectivity between the Selenium Client Library and the Selenium Server.\nWhen starting with Selenium RC, most people begin by running their test program (with a Selenium Client Library) and the Selenium Server on the same machine. To do this use \u0026ldquo;localhost\u0026rdquo; as your connection parameter. We recommend beginning this way since it reduces the influence of potential networking problems which you\u0026rsquo;re getting started. Assuming your operating system has typical networking and TCP/IP settings you should have little difficulty. In truth, many people choose to run the tests this way.\nIf, however, you do want to run Selenium Server on a remote machine, the connectivity should be fine assuming you have valid TCP/IP connectivity between the two machines.\nIf you have difficulty connecting, you can use common networking tools like ping, telnet, ifconfig(Unix)/ipconfig (Windows), etc to ensure you have a valid network connection. If unfamilar with these, your system administrator can assist you.\nUnable to Load the Browser Ok, not a friendly error message, sorry, but if the Selenium Server cannot load the browser you will likely see this error.\n(500) Internal Server Error This could be caused by\n Firefox (prior to Selenium 1.0) cannot start because the browser is already open and you did not specify a separate profile. See the section on Firefox profiles under Server Options. The run mode you\u0026rsquo;re using doesn\u0026rsquo;t match any browser on your machine. Check the parameters you passed to Selenium when you program opens the browser. You specified the path to the browser explicitly (using \u0026ldquo;*custom\u0026rdquo;\u0026ndash;see above) but the path is incorrect. Check to be sure the path is correct. Also check the user group to be sure there are no known issues with your browser and the \u0026ldquo;*custom\u0026rdquo; parameters.  Selenium Cannot Find the AUT If your test program starts the browser successfully, but the browser doesn\u0026rsquo;t display the website you\u0026rsquo;re testing, the most likely cause is your test program is not using the correct URL.\nThis can easily happen. When you use Selenium-IDE to export your script, it inserts a dummy URL. You must manually change the URL to the correct one for your application to be tested.\nFirefox Refused Shutdown While Preparing a Profile This most often occurs when you run your Selenium RC test program against Firefox, but you already have a Firefox browser session running and, you didn\u0026rsquo;t specify a separate profile when you started the Selenium Server. The error from the test program looks like this:\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile Here\u0026rsquo;s the complete error message from the server:\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock To resolve this, see the section on Specifying a Separate Firefox Profile\nVersioning Problems Make sure your version of Selenium supports the version of your browser. For example, Selenium RC 0.92 does not support Firefox 3. At times you may be lucky (I was). But don\u0026rsquo;t forget to check which browser versions are supported by the version of Selenium you are using. When in doubt, use the latest release version of Selenium with the most widely used version of your browser.\nError message: \u0026ldquo;(Unsupported major.minor version 49.0)\u0026rdquo; while starting server This error says you\u0026rsquo;re not using a correct version of Java. The Selenium Server requires Java 1.5 or higher.\nTo check double-check your java version, run this from the command line.\njava -version You should see a message showing the Java version.\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) If you see a lower version number, you may need to update the JRE, or you may simply need to add it to your PATH environment variable.\n404 error when running the getNewBrowserSession command If you\u0026rsquo;re getting a 404 error while attempting to open a page on \u0026ldquo;http://www.google.com/selenium-server/\u0026quot;, then it must be because the Selenium Server was not correctly configured as a proxy. The \u0026ldquo;selenium-server\u0026rdquo; directory doesn\u0026rsquo;t exist on google.com; it only appears to exist when the proxy is properly configured. Proxy Configuration highly depends on how the browser is launched with firefox, iexplore, opera, or custom.\n  iexplore: If the browser is launched using *iexplore, you could be having a problem with Internet Explorer\u0026rsquo;s proxy settings. Selenium Server attempts To configure the global proxy settings in the Internet Options Control Panel. You must make sure that those are correctly configured when Selenium Server launches the browser. Try looking at your Internet Options control panel. Click on the \u0026ldquo;Connections\u0026rdquo; tab and click on \u0026ldquo;LAN Settings\u0026rdquo;.\n If you need to use a proxy to access the application you want to test, you\u0026rsquo;ll need to start Selenium Server with \u0026ldquo;-Dhttp.proxyHost\u0026rdquo;; see the Proxy Configuration_ for more details. You may also try configuring your proxy manually and then launching the browser with *custom, or with *iehta browser launcher.    custom: When using *custom you must configure the proxy correctly(manually), otherwise you\u0026rsquo;ll get a 404 error. Double-check that you\u0026rsquo;ve configured your proxy settings correctly. To check whether you\u0026rsquo;ve configured the proxy correctly is to attempt to intentionally configure the browser incorrectly. Try configuring the browser to use the wrong proxy server hostname, or the wrong port. If you had successfully configured the browser\u0026rsquo;s proxy settings incorrectly, then the browser will be unable to connect to the Internet, which is one way to make sure that one is adjusting the relevant settings.\n  For other browsers (*firefox, *opera) we automatically hard-code the proxy for you, and so there are no known issues with this functionality. If you\u0026rsquo;re encountering 404 errors and have followed this user guide carefully post your results to user group for some help from the user community.\n  Permission Denied Error The most common reason for this error is that your session is attempting to violate the same-origin policy by crossing domain boundaries (e.g., accesses a page from http://domain1 and then accesses a page from http://domain2) or switching protocols (moving from http://domainX to https://domainX).\nThis error can also occur when JavaScript attempts to find UI objects which are not yet available (before the page has completely loaded), or are no longer available (after the page has started to be unloaded). This is most typically encountered with AJAX pages which are working with sections of a page or subframes that load and/or reload independently of the larger page.\nThis error can be intermittent. Often it is impossible to reproduce the problem with a debugger because the trouble stems from race conditions which are not reproducible when the debugger\u0026rsquo;s overhead is added to the system. Permission issues are covered in some detail in the tutorial. Read the section about the The Same Origin Policy_, Proxy Injection_ carefully.\nHandling Browser Popup Windows There are several kinds of \u0026ldquo;Popups\u0026rdquo; that you can get during a Selenium test. You may not be able to close these popups by running Selenium commands if they are initiated by the browser and not your AUT. You may need to know how to manage these. Each type of popup needs to be addressed differently.\n  HTTP basic authentication dialogs: These dialogs prompt for a username/password to login to the site. To login to a site that requires HTTP basic authentication, use a username and password in the URL, as described in RFC 1738_, like this: open(\u0026ldquo;http://myusername:myuserpassword@myexample.com/blah/blah/blah\u0026quot;).\n  SSL certificate warnings: Selenium RC automatically attempts to spoof SSL certificates when it is enabled as a proxy; see more on this in the section on HTTPS. If your browser is configured correctly, you should never see SSL certificate warnings, but you may need to configure your browser to trust our dangerous \u0026ldquo;CyberVillains\u0026rdquo; SSL certificate authority. Again, refer to the HTTPS section for how to do this.\n  modal JavaScript alert/confirmation/prompt dialogs: Selenium tries to conceal those dialogs from you (by replacing window.alert, window.confirm and window.prompt) so they won\u0026rsquo;t stop the execution of your page. If you\u0026rsquo;re seeing an alert pop-up, it\u0026rsquo;s probably because it fired during the page load process, which is usually too early for us to protect the page. Selenese contains commands for asserting or verifying alert and confirmation popups. See the sections on these topics in Chapter 4.\n  On Linux, why isn\u0026rsquo;t my Firefox browser session closing? On Unix/Linux you must invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so make sure that executable is on the path. If executing Firefox through a shell script, when it comes time to kill the browser Selenium RC will kill the shell script, leaving the browser running. You can specify the path to firefox-bin directly, like this.\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome doesn\u0026rsquo;t work with custom profile Check Firefox profile folder -\u0026gt; prefs.js -\u0026gt; user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0); Comment this line like this: \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; and try again.\nIs it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page\u0026rsquo;s javascript window.onload() function runs)? No. Selenium relies on interceptors to determine window names as they are being loaded. These interceptors work best in catching new windows if the windows are loaded AFTER the onload() function. Selenium may not recognize windows loaded before the onload function.\nFirefox on Linux On Unix/Linux, versions of Selenium before 1.0 needed to invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so if you are using a previous version, make sure that the real executable is on the path.\nOn most Linux distributions, the real firefox-bin is located on:\n/usr/lib/firefox-x.x.x/ Where the x.x.x is the version number you currently have. So, to add that path to the user\u0026rsquo;s path. you will have to add the following to your .bashrc file:\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; If necessary, you can specify the path to firefox-bin directly in your test, like this:\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IE and Style Attributes If you are running your tests on Internet Explorer and you cannot locate elements using their style attribute. For example:\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] This would work perfectly in Firefox, Opera or Safari but not with IE. IE interprets the keys in @style as uppercase. So, even if the source code is in lowercase, you should use:\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] This is a problem if your test is intended to work on multiple browsers, but you can easily code your test to detect the situation and try the alternative locator that only works in IE.\nError encountered - \u0026ldquo;Cannot convert object to primitive value\u0026rdquo; with shut down of *googlechrome browser To avoid this error you have to start browser with an option that disables same origin policy checks:\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); Error encountered in IE - \u0026ldquo;Couldn\u0026rsquo;t open app window; is the pop-up blocker enabled?\u0026rdquo; To avoid this error you have to configure the browser: disable the popup blocker AND uncheck \u0026lsquo;Enable Protected Mode\u0026rsquo; option in Tools \u0026raquo; Options \u0026raquo; Security.\n  The proxy is a third person in the middle that passes the ball between the two parts. It acts as a \u0026ldquo;web server\u0026rdquo; that delivers the AUT to the browser. Being a proxy gives Selenium Server the capability of \u0026ldquo;lying\u0026rdquo; about the AUT\u0026rsquo;s real URL. \u0026#x21a9;\u0026#xfe0e;\n The browser is launched with a configuration profile that has set localhost:4444 as the HTTP proxy, this is why any HTTP request that the browser does will pass through Selenium server and the response will pass through it and not from the real server. \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/selenium_installation/installing_selenium_libraries/",
	"title": "Selenium 라이브러리 설치",
	"tags": [],
	"description": "",
	"content": "당신의 자동화 프로젝트를 위해서 첫 번째로 Selenium 바인딩을 설치해야 합니다. 당신이 사용할 언어에 따른 라이브러리 설치 절차입니다.\nJava Maven을 사용한 Java용 Selenium 라이브러리 설치입니다. 프로젝트안에 있는 pom.xml에 selenium-java 의존 라이브러리를 추가하세요.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; selenium-java 의존성 라이브러리는 Selenium이 자동화할 수 있는 모든 브라우저의 자동화를 지원합니다. 만약 당신이 특정 브라우저에서만 테스트를 실행하기 원한다면, 원하는 브라우저를 pom.xml 파일에 의존성을 추가합니다. 예를 들어, Firefox에서 테스트를 실행하고 싶다면 다음과 같은 의존성을 pom.xml 파일에 추가해야 합니다.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 이와 비슷하게, 만약 크롬에서만 테스트하길 원한다면, 다음과 같은 의존성을 추가해야 합니다.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python 파이썬을 위한 Selenium 라이브러리는 pip로 설치할 수 있습니다.\npip install selenium 혹은, PyPI source archive를 다운로드해서 setup.py 를 통해 설치할 수 있습니다.\npython setup.py install C# C#을 위한 Selenium 라이브러리는 NuGet으로 설치할 수 있습니다.\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby Ruby를 위한 Selenium 라이브러리는 gem으로 설치할 수 있습니다.\ngem install selenium-webdriver JavaScript 자바스크립트를 위한 Selenium 라이브러리는 npm으로 설치할 수 있습니다.\nnpm install selenium-webdriver Kotlin Kotlin을 위한 네이티브 언어 바인딩이 없기 때문에, 자바 바인딩을 사용해야 합니다. e.g. 메이븐 Java\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/introduction/the_selenium_project_and_tools/",
	"title": "Selenium 프로젝트와 도구들",
	"tags": [],
	"description": "",
	"content": "Selenium 은 웹브라우저를 제어합니다. Selenium 은 여러 프로젝트를 포함하지만, 웹 브라우저 자동화를 위한 도구가 핵심입니다.\n브라우저 인스턴스를 원격으로 제어하고, 사용자와 브라우저와의 상호작용을 에뮬레이트 하기 위한 최고의 기술들이 적용되어 있습니다.\n최종 사용자가 수행하는 일반적인 활동들을 시뮬레이션 할 수 있습니다.\n필드에 텍스트 입력, 드롭 다운 및 체크 박스 선택, 링크 클릭, 마우스 이동, 임의의 JavaScript 실행 등의 기능이 제공됩니다.\n웹 사이트의 프론트-엔드 테스트에 주로 사용되지만, Selenium은 브라우저 사용자 에이전트 라이브러리 의 핵심입니다. 인터페이스는 응용 프로그램에 맞게 어디서나 사용될 수 있도록 최적화 되어있고, 당신의 목적에 맞게 다른 라이브러리와의 구성을 장려합니다.\n모든것을 지배하는 하나의 인터페이스 프로젝트의 대원칙 중 하나는 모든 (주요) 브라우저 기숭레 대한 공통 인터페이스를 지원하는 것입니다. 웹 브라우저는 매우 복잡하고 고도의 공학이 적용된 응용 프로그램으로, 완전히 다른 방식으로 작업을 수행하지만, 종종 실행 결과는 똑같이 보입니다.\n텍스트가 동일한 글꼴로 렌더링 되더라도 이미지는 같은 곳에 표시되고, 링크는 같은 목적지로 이동합니다. 보이지 않는 내부에서 일어나는 일은 낮과 밤처럼 아예 다릅니다.\nSelenium은 이러한 차이점들을 \u0026ldquo;추상화\u0026quot;하여, 코드를 작성하는 사람으로부터 웹 브라우저의 세부 사항과 복잡성을 숨깁니다. 이를 통해 몇 줄의 코드만으로 복잡한 워크플로를 수행할 수 있으며, 이 코드는 Firefox, Internet Explorer, Chrome 및 기타 지원하는 모든 브라우저에서 작동합니다.\n도구 및 지원 Selenium의 미니멀리스트 디자인 접근방식은 대규모 어플리케이션의 구성요소로 포함되는 다용도성을 제공합니다. Selenium umbrella 프로젝트의 이름 하에 제공되는 인프라는 당신의 웹 브라우저의 그리드를 결합할 수 있는 도구들을 제공합니다. 여러 장치에 걸친 색다른 브라우저들과 여러 운영 체제에서 테스트를 할 수 있도록 돕습니다.\n서버실이나 데이터 센터에 있는 컴퓨터 뱅크가 하루종일 응용프로그램을 테스트하는 환경에서 사이트의 링크, 양식 및 테이블을 동시에 작동한다고 상상해 보십시오. 간단한 프로그래밍 인터페이스가 가장 대중적인 언어로 제공되므로, 이 테스트는 지칠 줄 모르게 병렬로 실행되고, 오류가 발생하면 다시 보고합니다.\n브라우저를 제어할 뿐만 아니라, 도구와 문서를 사용자에게 제공하여, 이러한 그리드를 쉽게 확장하고 배포 할 수 있도록 하는것이 목표입니다.\nSelenium을 사용하는 사람들에게 세계에서 가장 중요한 회사들이 브라우저 기반 테스트를 위해 Selenium을 채택했고, 종종 다른 독점 도구와 관련된 수년간의 노력을 대체했습니다. Selenium이 인기를 얻으며, 요구 사항과 해결할 과제도 배가 되었습니다.\n웹이 더욱 복잡해지고 새로운 기술이 웹사이트에 추가됨에 따라, 이 프로젝트의 사명은 가능한 한 최신 기술을 따라잡는 것입니다. 오픈소스 프로젝트인 만큼, 이 지원은 각자의 일이 있는 수많은 기여자들의 아낌없는 시간 기부를 통해 제공됩니다.\n이 프로젝트의 또 다른 임무는 더 많은 기여자들이 이 노력에 합세하여 더 강력한 커뮤니티를 구축하고, 프로젝트가 새로운 기술을 게속 유지하여 기능 테스트 자동화를 위한 주요 플랫폼으로 남아 있는 것입니다.\n역사 Selenium 1이 출시 되었던 2004년에는, 웹 응용프로그램의 프론트-엔드에서 일관된 동작을 수동으로 확인하는 데 소요되는 시간을 줄일 필요가 없었습니다. 버전 1은 그 당시 사용가능한 도구를 이용하여 사용자의 상호작용을 모방하기 위해 시험 중인 웹 페이지에 JavaScript를 주입하는 것에 크게 의존했습니다.\nJavaScript는 DOM의 속성을 조사하고, 특정 클라이언트측을 관찰할 수 있는 좋은 도구이지만, 마우스와 키보드를 사용하는 것처럼 사용자의 상호작용을 자연스럽게 복제할 수 있는 능력은 부족합니다.\n그 이후로, Selenium은 많이 발전하고 성숙해졌습니다. —전 세계 대부분의 거대 조직은 아니지만— 많은 사람들이 널리 사용하는 도구로 성장했습니다. Selenium 은 틈새시장의 잠재 고객들과 특정한 사용 사례를 위해 Thinkworks에서 개발한 가정용 테스트 자동화 툴킷에서, 사실상 세계 최고의 브라우저 자동화 라이브러리로 발전했습니다..\nSelenium RC 당시 이용가능한 거래 도구를 활용한 것처럼, Selenium WebDriver는 브라우저 공급 업체의 앞마당을 사용하듯 브라우저 상호 작용 부분이 백-엔드 브라우저를 향한 구현을 책임지도록 요구함으로써 전통을 이어갑니다. 최근 이 작업은 W3C 표준화 프로세스로 발전하여, Selenium의 WebDriver 구성 요소를 사용자 에이전트를 위한 오늘날의 원격 제어 라이브러리로 전환하는 것이 목표입니다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/driver_idiosyncrasies/shared_capabilities/",
	"title": "Shared capabilities",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n In-order to create a new session by Selenium WebDriver, local end should provide the basic capabilities to remote end. The remote end uses the same set of capabilities to create a session and describes the current session features.\nWebDriver provides capabilities that each remote end will/should support the implementation. Following are the capabilities that WebDriver supports:\nbrowserName: This capability is used to set the browserName for a given session. If the specified browser is not installed at the remote end, the session creation will fail\nbrowserVersion: This capability is optional, this is used to set the available browser version at remote end. For Example, if ask for Chrome version 75 on a system that only has 80 installed, the session creation will fail\npageLoadStrategy: When navigating to a new page via URL, by default Selenium will wait until the page has fully loaded before responding. This works well for beginners, but can cause long wait times on pages that load a large number of third party resources. Using a non default strategy can make test execution faster in cases like this, but can also introduce flakiness where elements on the page change position as elements load in and change size.\nThe page load strategy queries the document.readyState as described in the table below:\n   Strategy Ready State Notes     normal complete Used by default, waits for all resources to download   eager interactive DOM access is ready, but other resources like images may still be loading   none Any Does not block WebDriver at all    platformName This identifies the operating system at the remote-end, fetching the platformName returns the OS name.\nIn cloud-based providers, setting platformName sets the OS at the remote-end.\nacceptInsecureCerts This capability checks whether an expired (or) invalid TLS Certificate is used while navigating during a session.\nIf the capability is set to false, an insecure certificate error will be returned as navigation encounters any domain certificate problems. If set to true, invalid certificate will be trusted by the browser.\nAll self-signed certificates will be trusted by this capability by default. Once set, acceptInsecureCerts capability will have an effect for the entire session.\nSession timeouts A WebDriver session is imposed with a certain session timeout interval, during which the user can control the behaviour of executing scripts or retrieving information from the browser.\nEach session timeout is configured with combination of different timeouts as described below:\nScript Timeout: Specifies when to interrupt an executing script in a current browsing context. The default timeout 30,000 is imposed when a new session is created by WebDriver.\nPage Load Timeout: Specifies the time interval in which web page needs to be loaded in a current browsing context. The default timeout 300,000 is imposed when a new session is created by WebDriver. If page load limits a given/default time frame, the script will be stopped by TimeoutException.\nImplicit Wait Timeout This specifies the time to wait for the implicit element location strategy when locating elements. The default timeout 0 is imposed when a new session is created by WebDriver.\nunhandledPromptBehavior Specifies the state of current session\u0026rsquo;s user prompt handler. Defaults to dismiss and notify state\nUser Prompt Handler This defines what action must take when a user prompt encounters at remote-end. This is defined by unhandledPromptBehavior capability and has the following states:\n dismiss accept dismiss and notify accept and notify ignore  setWindowRect This command alters the size and position of the current browsing context window. This command acts as setter to getWindowRect command which accepts width, height, x, y as optional arguments.\nDuring automation, the current browsing context will be associated with window states, that describe visibility state of the browser window. The window states are\n maximized minimized normal fullscreen  Setting Width or Height does not guaranteed that the resulting window size will exactly match that which was quested. This is because some drivers may not be able to resize in single-pixel increments. Due to this, fetching the window state/details by getWindowRect may not equally match the values set to the browser.\nstrictFileInteractability The new capabilitiy indicates if strict interactability checks should be applied to input type=file elements. As strict interactability checks are off by default, there is a change in behaviour when using Element Send Keys with hidden file upload controls.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/understanding_the_components/",
	"title": "구성 요소 이해",
	"tags": [],
	"description": "",
	"content": "WebDriver를 사용하여 테스트 스위트를 빌드하려면 이해하고 이해해야합니다. 다양한 구성 요소를 효과적으로 사용합니다. 모든 것과 마찬가지로 소프트웨어, 다른 사람들은 동일한 아이디어에 대해 다른 용어를 사용합니다. 아래는 이 설명에서 용어가 사용되는 방식에 대한 분석.\n술어  API: Application Programming Interface. 이것은 \u0026ldquo;명령\u0026quot;세트입니다 WebDriver를 조작하는 데 사용합니다. Library: API와 필요한 코드를 포함하는 코드 모듈 그것들을 구현하기 위해. 라이브러리는 각 언어 바인딩에 따라 다릅니다 (예 : .jar). Java 용 파일, .NET 용 .dll 파일 등 Driver: 실제 브라우저를 제어합니다. 대부분의 운전자 브라우저 공급 업체 자체에 의해 생성됩니다. 드라이버는 일반적으로 브라우저 자체를 사용하여 시스템에서 실행되는 실행 가능 모듈 테스트 스위트를 실행하는 시스템에는 없습니다. (그것들이 참고 : 일부 사람들은 드라이버를 프록시라고합니다. Framework: WebDriver 지원으로 사용되는 추가 라이브러리 스위트. 이러한 프레임 워크는 JUnit 또는 NUnit과 같은 테스트 프레임 워크 일 수 있습니다. 또한 자연 언어 기능을 지원하는 프레임 워크 일 수도 있습니다. 오이 또는 로보 티움으로. 프레임 워크는 다음을 위해 작성되고 사용될 수도 있습니다. 테스트중인 시스템 조작 또는 구성, 데이터 제작, 테스트 오라클 등  부품과 조각 최소한 WebDriver는 드라이버를 통해 브라우저와 통신합니다. 통신 WebDriver는 드라이버를 통해 브라우저에 명령을 전달합니다. 동일한 경로를 통해 정보를 다시받습니다.\n드라이버는 Google의 ChromeDriver와 같은 브라우저에 따라 다릅니다. Chrome/Chromium, Mozilla Firefox 용 GeckoDriver 등 드라이버는 다음에서 실행됩니다. 브라우저와 동일한 시스템. 이것은 동일한 시스템 일 수도 있고 아닐 수도 있습니다. 테스트 자체가 실행 중입니다.\n위의 간단한 예는 direct 통신 입니다. 통신 브라우저는 Selenium 서버를 통한 remote 통신 일 수도 있고 RemoteWebDriver. RemoteWebDriver는 드라이버와 동일한 시스템에서 실행됩니다. 그리고 브라우저.\nSelenium Server 또는 Selenium을 사용하여 원격 통신을 수행 할 수도 있습니다. 그리드, 둘 다 호스트 시스템의 드라이버와 통신\n프레임 워크가 적합한 곳 WebDriver에는 하나의 작업과 하나의 작업 만 있습니다. 위의 방법 중 하나입니다. WebDriver는 테스트에 대해 알지 못합니다. 사물을 비교하는 방법을 알고, 통과 또는 실패를 주장하며, 확실하지 않습니다 보고 또는 주어진 / 언제 / 그럼 문법에 관한 것.\n다양한 프레임 워크가 등장합니다. 최소한 당신은 필요합니다 언어 바인딩과 일치하는 테스트 프레임 워크 (예 : .NET, JUnit 용 NUnit Java, Ruby 용 RSpec 등\n테스트 프레임 워크는 WebDriver 실행 및 실행을 담당합니다. 그리고 테스트의 관련 단계. 따라서, 당신은 비슷한 것으로 생각할 수 있습니다 다음 이미지에.\nCucumber와 같은 자연 언어 프레임 워크 / 도구는 그 일부로 존재할 수 있습니다. 위 그림의 테스트 프레임 워크 상자 또는 테스트 프레임 워크를 래핑 할 수 있습니다. 전적으로 자신의 구현에.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/grid/purposes_and_main_functionalities/",
	"title": "목적 및 주요 기능",
	"tags": [],
	"description": "",
	"content": " 모든 테스트의 중앙 진입 지점 브라우저가 실행되는 환경과 노드의 관리 및 제어 스케일링 병렬로 테스트 실행 교차 플랫폼 테스트 부하분산  "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/getting_started_with_webdriver/browsers/",
	"title": "브라우저",
	"tags": [],
	"description": "",
	"content": "일반적인 브라우저 Selenium 프레임워크는 공식적으로 다음과 같은 브라우저를 지원합니다.\n   브라우저 관리자 지원 버전     Chrome Chromium 모든 버전   Firefox Mozilla 54 이상   Internet Explorer Selenium 6 이상   Opera Opera Chromium / Presto 10.5 이상   Safari Apple 10 이상    전문화된 브라우저 개발 환경에서 전형적으로 사용되는 특수 브라우저 세트도 있습니다.\n우리는 자동화 목적으로 이러한 브라우저를 사용할 수 있으며, Selenium은 다음과 같은 전문화된 드라이버를 지원합니다.\n   드라이버명 목적 관리자     HtmlUnitDriver Headless browser emulator backed by Rhino Selenium 프로젝트    "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/getting_started/quick/",
	"title": "빠르게 살펴보기",
	"tags": [],
	"description": "",
	"content": "셀레니움은 그저 하나의 도구(tool)나 API가 아니라, 여러 도구들로 구성되어 있습니다.\n웹 드라이버(WebDriver) 컴퓨터나 모바일 웹사이트 테스트를 자동화하는 것부터 시작하신다면, 아마 웹 드라이버 APIs부터 쓰게 될 겁니다. 웹 드라이버WebDriver 는 브라우저를 조종하고 테스트를 진행할 수 있도록 제작사에서 제공하는 브라우저 자동화 API들을 사용합니다. 이는 진짜 사용자가 브라우저를 이용하는 것과 비슷합니다. 웹 드라이버 API를 애플리케이션의 코드로 컴파일할 필요가 없기 때문에, 뒤섞이지 않습니다(not intrusive). 더 나아가, 실시간으로 사용하는 것과 같은 애플리케이션을 테스트합니다.\n통합개발환경 (IDE) IDE (통합개발환경 Integrated Development Environment) 은 자신만의 셀레니움 테스트 케이스를 개발하기 위해 사용할 도구입니다. 크롬이나 파이어폭스 확장으로 사용하기 쉽고, 이는 보통 테스트 케이스를 개발하는데 가장 효율적인 방법이기도 합니다. 이 도구는 여러분을 위해 브라우저 상에서 사용자의 행동을 기록합니다. 기존의 셀레니움 커맨드를 이용해서, 각 요소의 문맥에 따라 정의된 매개변수로 말이죠. 이는 시간을 절약해줄 뿐만 아니라 셀레니움 스크립트 문법을 배우는데 탁월한(excellent) 방법입니다.\n조합 격자 (Grid) Selenium Grid allows you to run test cases in different machines across different platforms. The control of triggering the test cases is on the local end, and when the test cases are triggered, they are automatically executed by the remote end.\nAfter the development of the WebDriver tests, you may face the need of running your tests on multiple browser and operating system combinations. This is where Grid comes into the picture.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/getting_started/",
	"title": "시작하기",
	"tags": [],
	"description": "",
	"content": "시작하기 Selenium이 처음이신가요? 빠르게 시작할 수 있도록 돕기 위해서 몇 가지 자료를 준비했습니다.\n 빠르게 살펴보기  웹 드라이버WebDriver 통합개발환경 IDE 격자 Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/worst_practices/captchas/",
	"title": "자동화 튜링 테스트",
	"tags": [],
	"description": "",
	"content": "캡차(CAPTCHA)는 컴퓨터와 인간을 구분하기 위한 완전 자동화된 공공 튜링 테스트(Completely Automated Public Turing Test to telling Computer and Humans addition)의 줄임말로, 자동화를 방지하도록 명시되어 있으므로 시도하지 마시오! CAPTCHA 검사를 수행하기 위한 두 가지 주요 전략이 있다.\n 테스트 환경에서 CAPTCHA 비활성화 테스트가 CAPTCHA를 우회할 수 있도록 후크 추가  "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/grid/components_of_a_grid/",
	"title": "Components of a Grid",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Hub  Intermediary and manager Accepts requests to run tests Takes instructions from client and executes them remotely on the nodes Manages threads  A Hub is a central point where all your tests are sent. Each Selenium Grid consists of exactly one hub. The hub needs to be reachable from the respective clients (i.e. CI server, Developer machine etc.) The hub will connect one or more nodes that tests will be delegated to.\nNodes  Where the browsers live Registers itself to the hub and communicates its capabilities Receives requests from the hub and executes them  Nodes are different Selenium instances that will execute tests on individual computer systems. There can be many nodes in a grid. The machines which are nodes do not need to be the same platform or have the same browser selection as that of the hub or the other nodes. A node on Windows might have the capability of offering Internet Explorer as a browser option, whereas this wouldn\u0026rsquo;t be possible on Linux or Mac.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/domain_specific_language/",
	"title": "Domain specific language",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n A domain specific language (DSL) is a system which provides the user with an expressive means of solving a problem. It allows a user to interact with the system on their terms – not just programmer-speak.\nYour users, in general, do not care how your site looks. They do not care about the decoration, animations, or graphics. They want to use your system to push their new employees through the process with minimal difficulty; they want to book travel to Alaska; they want to configure and buy unicorns at a discount. Your job as tester is to come as close as you can to “capturing” this mind-set. With that in mind, we set about “modeling” the application you are working on, such that the test scripts (the user\u0026rsquo;s only pre-release proxy) “speak” for, and represent the user.\nWith Selenium, DSL is usually represented by methods, written to make the API simple and readable – they enable a report between the developers and the stakeholders (users, product owners, business intelligence specialists, etc.).\nBenefits  Readable: Business stakeholders can understand it. Writable: Easy to write, avoids unnecessary duplication. Extensible: Functionality can (reasonably) be added without breaking contracts and existing functionality. Maintainable: By leaving the implementation details out of test cases, you are well-insulated against changes to the AUT*.  Java Here is an example of a reasonable DSL method in Java. For brevity\u0026rsquo;s sake, it assumes the driver object is pre-defined and available to the method.\n/** * Takes a username and password, fills out the fields, and clicks \u0026#34;login\u0026#34;. * @return An instance of the AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Fill out the password field. The locator we\u0026#39;re using is \u0026#34;By.id\u0026#34;, and we should  // have it defined elsewhere in the class.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Click the login button, which happens to have the id \u0026#34;submit\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Create and return a new instance of the AccountPage (via the built-in Selenium  // PageFactory).  return PageFactory.newInstance(AccountPage.class); } This method completely abstracts the concepts of input fields, buttons, clicking, and even pages from your test code. Using this approach, all a tester has to do is call this method. This gives you a maintenance advantage: if the login fields ever changed, you would only ever have to change this method - not your tests.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Now that we\u0026#39;re logged in, do some other stuff--since we used a DSL to support  // our testers, it\u0026#39;s as easy as choosing from available methods.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Something should have been done!\u0026#34;, something.wasDone()); // Note that we still haven\u0026#39;t referred to a button or web control anywhere in this  // script... } It bears repeating: one of your primary goals should be writing an API that allows your tests to address the problem at hand, and NOT the problem of the UI. The UI is a secondary concern for your users – they do not care about the UI, they just want to get their job done. Your test scripts should read like a laundry list of things the user wants to DO, and the things they want to KNOW. The tests should not concern themselves with HOW the UI requires you to go about it.\n*AUT: Application under test\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/driver_idiosyncrasies/driver_specific_capabilities/",
	"title": "Driver specific capabilities",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Firefox Define Capabilities using FirefoxOptions FirefoxOptions is the new way to define capabilities for the Firefox browser and should generally be used in preference to DesiredCapabilities.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   require \u0026#39;selenium-webdriver\u0026#39; opts = Selenium::WebDriver::Firefox::Options.new(args: [\u0026#39;-headless\u0026#39;]) driver = Selenium::WebDriver.for(:firefox, options: opts)   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.headless(); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     Setting a custom profile It is possible to create a custom profile for Firefox as demonstrated below.\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   profile = Selenium::WebDriver::Firefox::Profile.new profile[\u0026#39;browser.download.dir\u0026#39;] = \u0026#34;/tmp/webdriver-downloads\u0026#34; options = Selenium::WebDriver::Firefox::Options.new(profile: profile) driver = Selenium::WebDriver.for :firefox, options: options   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); let profile = \u0026#39;/path to custom profile\u0026#39;; options.setProfile(profile); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer fileUploadDialogTimeout In some environments, Internet Explorer may timeout when opening the File Upload dialog. IEDriver has a default timeout of 1000ms, but you can increase the timeout using the fileUploadDialogTimeout capability.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.waitForUploadDialogUpTo(Duration.ofSeconds(2)); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.file_upload_dialog_timeout = 2000 driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.file_upload_dialog_timeout = 2000 driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().fileUploadDialogTimeout(2000); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.waitForUploadDialogUpTo(Duration.ofSeconds(2)) val driver = RemoteWebDriver(options)     ensureCleanSession When set to true, this capability clears the Cache, Browser History and Cookies for all running instances of InternetExplorer including those started manually or by the driver. By default, it is set to false.\nUsing this capability will cause performance drop while launching the browser, as the driver will wait until the cache gets cleared before launching the IE browser.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.destructivelyEnsureCleanSession(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ensure_clean_session = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.EnsureCleanSession = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ensure_clean_session = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ensureCleanSession(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.destructivelyEnsureCleanSession() val driver = RemoteWebDriver(options)     ignoreZoomSetting InternetExplorer driver expects the browser zoom level to be 100%, else the driver will throw an exception. This default behaviour can be disabled by setting the ignoreZoomSetting to true.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.ignoreZoomSettings(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_zoom_level = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IgnoreZoomLevel = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_zoom_level = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().ignoreZoomSetting(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.ignoreZoomSettings() val driver = RemoteWebDriver(options)     ignoreProtectedModeSettings Whether to skip the Protected Mode check while launching a new IE session.\nIf not set and Protected Mode settings are not same for for all zones, an exception will be thrown by the driver.\nIf capability is set to true, tests may become flaky, unresponsive, or browsers may hang. However, this is still by far a second-best choice, and the first choice should always be to actually set the Protected Mode settings of each zone manually. If a user is using this property, only a \u0026ldquo;best effort\u0026rdquo; at support will be given.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.introduceFlakinessByIgnoringSecurityDomains(); WebDriver driver = new RemoteWebDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.ignore_protected_mode_settings = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var options = new InternetExplorerOptions(); options.IntroduceInstabilityByIgnoringProtectedModeSettings = true; var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.ignore_protected_mode_settings = true driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().introduceFlakinessByIgnoringProtectedModeSettings(true); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.introduceFlakinessByIgnoringSecurityDomains() val driver = RemoteWebDriver(options)     silent When set to true, this capability suppresses the diagnostic output of the IEDriverServer.\nThis capability accepts a Boolean value as parameter.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.setCapability(\u0026#34;silent\u0026#34;, true); WebDriver driver = new InternetExplorerDriver(options);   from selenium import webdriver options = webdriver.IeOptions() options.set_capability(\u0026#34;silent\u0026#34;, True) driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   InternetExplorerOptions options = new InternetExplorerOptions(); options.AddAdditionalInternetExplorerOption(\u0026#34;silent\u0026#34;, true); IWebDriver driver = new InternetExplorerDriver(options);   # Please raise a PR to add code sample   const {Builder,By, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); let caps = Capabilities.ie(); caps.set(\u0026#39;silent\u0026#39;, true); (async function example() { let driver = await new Builder() .forBrowser(\u0026#39;internet explorer\u0026#39;) .withCapabilities(caps) .build(); try { await driver.get(\u0026#39;http://www.google.com/ncr\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.Capabilities import org.openqa.selenium.ie.InternetExplorerDriver import org.openqa.selenium.ie.InternetExplorerOptions fun main() { val options = InternetExplorerOptions() options.setCapability(\u0026#34;silent\u0026#34;, true) val driver = InternetExplorerDriver(options) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) val caps = driver.getCapabilities() println(caps) } finally { driver.quit() } }     IE Command-Line Options Internet Explorer includes several command-line options that enable you to troubleshoot and configure the browser.\nThe following describes few supported command-line options\n  -private : Used to start IE in private browsing mode. This works for IE 8 and later versions.\n  -k : Starts Internet Explorer in kiosk mode. The browser opens in a maximized window that does not display the address bar, the navigation buttons, or the status bar.\n  -extoff : Starts IE in no add-on mode. This option specifically used to troubleshoot problems with browser add-ons. Works in IE 7 and later versions.\n  Note: forceCreateProcessApi should to enabled in-order for command line arguments to work.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.add_argument(\u0026#39;-private\u0026#39;) options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; options.BrowserCommandLineArguments = \u0026#34;-k\u0026#34;; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true options.add_argument(\u0026#39;-k\u0026#39;) driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.addBrowserCommandSwitches(\u0026#39;-k\u0026#39;); options.addBrowserCommandSwitches(\u0026#39;-private\u0026#39;); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); options.addCommandSwitches(\u0026#34;-k\u0026#34;); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps); } finally { driver.quit(); } }     forceCreateProcessApi Forces launching Internet Explorer using the CreateProcess API. The default value is false.\nFor IE 8 and above, this option requires the \u0026ldquo;TabProcGrowth\u0026rdquo; registry value to be set to 0.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; public class ieTest { public static void main(String[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); InternetExplorerDriver driver = new InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); Capabilities caps = driver.getCapabilities(); System.out.println(caps); } finally { driver.quit(); } } }   from selenium import webdriver options = webdriver.IeOptions() options.force_create_process_api = True driver = webdriver.Ie(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using System; using OpenQA.Selenium; using OpenQA.Selenium.IE; namespace ieTest { class Program { static void Main(string[] args) { InternetExplorerOptions options = new InternetExplorerOptions(); options.ForceCreateProcessApi = true; IWebDriver driver = new InternetExplorerDriver(options); driver.Url = \u0026#34;https://google.com/ncr\u0026#34;; } } }   require \u0026#39;selenium-webdriver\u0026#39; options = Selenium::WebDriver::IE::Options.new options.force_create_process_api = true driver = Selenium::WebDriver.for(:ie, options: options) begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; puts(driver.capabilities.to_json) ensure driver.quit end   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options(); options.forceCreateProcessApi(true); driver = await env.builder() .setIeOptions(options) .build();   import org.openqa.selenium.Capabilities; import org.openqa.selenium.ie.InternetExplorerDriver; import org.openqa.selenium.ie.InternetExplorerOptions; fun main() { val options = InternetExplorerOptions(); options.useCreateProcessApiToLaunchIe(); val driver = InternetExplorerDriver(options); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); val caps = driver.getCapabilities(); println(caps) } finally { driver.quit(); } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/legacy_docs/migrating_from_rc_to_webdriver/",
	"title": "Migrating from RC to WebDriver",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n How to Migrate to Selenium WebDriver A common question when adopting Selenium 2 is what\u0026rsquo;s the correct thing to do when adding new tests to an existing set of tests? Users who are new to the framework can begin by using the new WebDriver APIs for writing their tests. But what of users who already have suites of existing tests? This guide is designed to demonstrate how to migrate your existing tests to the new APIs, allowing all new tests to be written using the new features offered by WebDriver.\nThe method presented here describes a piecemeal migration to the WebDriver APIs without needing to rework everything in one massive push. This means that you can allow more time for migrating your existing tests, which may make it easier for you to decide where to spend your effort.\nThis guide is written using Java, because this has the best support for making the migration. As we provide better tools for other languages, this guide shall be expanded to include those languages.\nWhy Migrate to WebDriver Moving a suite of tests from one API to another API requires an enormous amount of effort. Why would you and your team consider making this move? Here are some reasons why you should consider migrating your Selenium Tests to use WebDriver.\n Smaller, compact API. WebDriver\u0026rsquo;s API is more Object Oriented than the original Selenium RC API. This can make it easier to work with. Better emulation of user interactions. Where possible, WebDriver makes use of native events in order to interact with a web page. This more closely mimics the way that your users work with your site and apps. In addition, WebDriver offers the advanced user interactions APIs which allow you to model complex interactions with your site. Support by browser vendors. Opera, Mozilla and Google are all active participants in WebDriver\u0026rsquo;s development, and each have engineers working to improve the framework. Often, this means that support for WebDriver is baked into the browser itself: your tests run as fast and as stably as possible.  Before Starting In order to make the process of migrating as painless as possible, make sure that all your tests run properly with the latest Selenium release. This may sound obvious, but it\u0026rsquo;s best to have it said!\nGetting Started The first step when starting the migration is to change how you obtain your instance of Selenium. When using Selenium RC, this is done like so:\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); This should be replaced like so:\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); Next Steps Once your tests execute without errors, the next stage is to migrate the actual test code to use the WebDriver APIs. Depending on how well abstracted your code is, this might be a short process or a long one. In either case, the approach is the same and can be summed up simply: modify code to use the new API when you come to edit it.\nIf you need to extract the underlying WebDriver implementation from the Selenium instance, you can simply cast it to WrapsDriver:\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); This allows you to continue passing the Selenium instance around as normal, but to unwrap the WebDriver instance as required.\nAt some point, you\u0026rsquo;re codebase will mostly be using the newer APIs. At this point, you can flip the relationship, using WebDriver throughout and instantiating a Selenium instance on demand:\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); Common Problems Fortunately, you\u0026rsquo;re not the first person to go through this migration, so here are some common problems that others have seen, and how to solve them.\nClicking and Typing is More Complete A common pattern in a Selenium RC test is to see something like:\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); This relies on the fact that \u0026ldquo;type\u0026rdquo; simply replaces the content of the identified element without also firing all the events that would normally be fired if a user interacts with the page. The final direct invocations of \u0026ldquo;key*\u0026rdquo; cause the JS handlers to fire as expected.\nWhen using the WebDriverBackedSelenium, the result of filling in the form field would be \u0026ldquo;exciting texttt\u0026rdquo;: not what you\u0026rsquo;d expect! The reason for this is that WebDriver more accurately emulates user behavior, and so will have been firing events all along.\nThis same fact may sometimes cause a page load to fire earlier than it would do in a Selenium 1 test. You can tell that this has happened if a \u0026ldquo;StaleElementException\u0026rdquo; is thrown by WebDriver.\nWaitForPageToLoad Returns Too Soon Discovering when a page load is complete is a tricky business. Do we mean \u0026ldquo;when the load event fires\u0026rdquo;, \u0026ldquo;when all AJAX requests are complete\u0026rdquo;, \u0026ldquo;when there\u0026rsquo;s no network traffic\u0026rdquo;, \u0026ldquo;when document.readyState has changed\u0026rdquo; or something else entirely?\nWebDriver attempts to simulate the original Selenium behavior, but this doesn\u0026rsquo;t always work perfectly for various reasons. The most common reason is that it\u0026rsquo;s hard to tell the difference between a page load not having started yet, and a page load having completed between method calls. This sometimes means that control is returned to your test before the page has finished (or even started!) loading.\nThe solution to this is to wait on something specific. Commonly, this might be for the element you want to interact with next, or for some Javascript variable to be set to a specific value. An example would be:\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, Duration.ofSeconds(30)); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); Where \u0026ldquo;visibilityOfElementLocated\u0026rdquo; is implemented as:\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } This may look complex, but it\u0026rsquo;s almost all boiler-plate code. The only interesting bit is that the \u0026ldquo;ExpectedCondition\u0026rdquo; will be evaluated repeatedly until the \u0026ldquo;apply\u0026rdquo; method returns something that is neither \u0026ldquo;null\u0026rdquo; nor Boolean.FALSE.\nOf course, adding all these \u0026ldquo;wait\u0026rdquo; calls may clutter up your code. If that\u0026rsquo;s the case, and your needs are simple, consider using the implicit waits:\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); By doing this, every time an element is located, if the element is not present, the location is retried until either it is present, or until 30 seconds have passed.\nFinding By XPath or CSS Selectors Doesn\u0026rsquo;t Always Work, But It Does In Selenium 1 In Selenium 1, it was common for xpath to use a bundled library rather than the capabilities of the browser itself. WebDriver will always use the native browser methods unless there\u0026rsquo;s no alternative. That means that complex xpath expressions may break on some browsers.\nCSS Selectors in Selenium 1 were implemented using the Sizzle library. This implements a superset of the CSS Selector spec, and it\u0026rsquo;s not always clear where you\u0026rsquo;ve crossed the line. If you\u0026rsquo;re using the WebDriverBackedSelenium and use a Sizzle locator instead of a CSS Selector for finding elements, a warning will be logged to the console. It\u0026rsquo;s worth taking the time to look for these, particularly if tests are failing because of not being able to find elements.\nThere is No Browserbot Selenium RC was based on Selenium Core, and therefore when you executed Javascript, you could access bits of Selenium Core to make things easier. As WebDriver is not based on Selenium Core, this is no longer possible. How can you tell if you\u0026rsquo;re using Selenium Core? Simple! Just look to see if your \u0026ldquo;getEval\u0026rdquo; or similar calls are using \u0026ldquo;selenium\u0026rdquo; or \u0026ldquo;browserbot\u0026rdquo; in the evaluated Javascript.\nYou might be using the browserbot to obtain a handle to the current window or document of the test. Fortunately, WebDriver always evaluates JS in the context of the current window, so you can use \u0026ldquo;window\u0026rdquo; or \u0026ldquo;document\u0026rdquo; directly.\nAlternatively, you might be using the browserbot to locate elements. In WebDriver, the idiom for doing this is to first locate the element, and then pass that as an argument to the Javascript. Thus:\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); becomes:\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); Notice how the passed in \u0026ldquo;element\u0026rdquo; variable appears as the first item in the JS standard \u0026ldquo;arguments\u0026rdquo; array.\nExecuting Javascript Doesn\u0026rsquo;t Return Anything WebDriver\u0026rsquo;s JavascriptExecutor will wrap all JS and evaluate it as an anonymous expression. This means that you need to use the \u0026ldquo;return\u0026rdquo; keyword:\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); becomes:\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;); "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/introduction/on_test_automation/",
	"title": "On test automation",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n First, start by asking yourself whether or not you really need to use a browser. Odds are that, at some point, if you are working on a complex web application, you will need to open a browser and actually test it.\nFunctional end-user tests such as Selenium tests are expensive to run, however. Furthermore, they typically require substantial infrastructure to be in place to be run effectively. It is a good rule to always ask yourself if what you want to test can be done using more lightweight test approaches such as unit tests or with a lower-level approach.\nOnce you have made the determination that you are in the web browser testing business, and you have your Selenium environment ready to begin writing tests, you will generally perform some combination of three steps:\n Set up the data Perform a discrete set of actions Evaluate the results  You will want to keep these steps as short as possible; one or two operations should be enough most of the time. Browser automation has the reputation of being “flaky”, but in reality, that is because users frequently demand too much of it. In later chapters, we will return to techniques you can use to mitigate apparent intermittent problems in tests, in particular on how to overcome race conditions between the browser and WebDriver.\nBy keeping your tests short and using the web browser only when you have absolutely no alternative, you can have many tests with minimal flake.\nA distinct advantage of Selenium tests is their inherent ability to test all components of the application, from backend to frontend, from a user\u0026rsquo;s perspective. So in other words, whilst functional tests may be expensive to run, they also encompass large business-critical portions at one time.\nTesting requirements As mentioned before, Selenium tests can be expensive to run. To what extent depends on the browser you are running the tests against, but historically browsers\u0026rsquo; behaviour has varied so much that it has often been a stated goal to cross-test against multiple browsers.\nSelenium allows you to run the same instructions against multiple browsers on multiple operating systems, but the enumeration of all the possible browsers, their different versions, and the many operating systems they run on will quickly become a non-trivial undertaking.\nLet’s start with an example Larry has written a web site which allows users to order their custom unicorns.\nThe general workflow (what we will call the “happy path”) is something like this:\n Create an account Configure the unicorn Add it to the shopping cart Check out and pay Give feedback about the unicorn  It would be tempting to write one grand Selenium script to perform all these operations–many will try. Resist the temptation! Doing so will result in a test that a) takes a long time, b) will be subject to some common issues around page rendering timing issues, and c) is such that if it fails, it will not give you a concise, “glanceable” method for diagnosing what went wrong.\nThe preferred strategy for testing this scenario would be to break it down to a series of independent, speedy tests, each of which has one “reason” to exist.\nLet us pretend you want to test the second step: Configuring your unicorn. It will perform the following actions:\n Create an account Configure a unicorn  Note that we are skipping the rest of these steps, we will test the rest of the workflow in other small, discrete test cases after we are done with this one.\nTo start, you need to create an account. Here you have some choices to make:\n Do you want to use an existing account? Do you want to create a new account? Are there any special properties of such a user that need to be taken into account before configuration begins?  Regardless of how you answer this question, the solution is to make it part of the \u0026ldquo;set up the data\u0026rdquo; portion of the test. If Larry has exposed an API that enables you (or anyone) to create and update user accounts, be sure to use that to answer this question. If possible, you want to launch the browser only after you have a user \u0026ldquo;in hand\u0026rdquo;, whose credentials you can just log in with.\nIf each test for each workflow begins with the creation of a user account, many seconds will be added to the execution of each test. Calling an API and talking to a database are quick, “headless” operations that don\u0026rsquo;t require the expensive process of opening a browser, navigating to the right pages, clicking and waiting for the forms to be submitted, etc.\nIdeally, you can address this set-up phase in one line of code, which will execute before any browser is launched:\nJava Python C# Ruby JavaScript Kotlin // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = user_factory.create_common_user() #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.get_email(), user.get_password())   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.CreateCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = LoginAs(user.Email, user.Password);   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = UserFactory.create_common_user #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.email, user.password)   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. var user = userFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. var accountPage = loginAs(user.email, user.password);   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. val user = UserFactory.createCommonUser() //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     As you can imagine, the UserFactory can be extended to provide methods such as createAdminUser(), and createUserWithPayment(). The point is, these two lines of code do not distract you from the ultimate purpose of this test: configuring a unicorn.\nThe intricacies of the Page Object model will be discussed in later chapters, but we will introduce the concept here:\nYour tests should be composed of actions, performed from the user\u0026rsquo;s point of view, within the context of pages in the site. These pages are stored as objects, which will contain specific information about how the web page is composed and how actions are performed– very little of which should concern you as a tester.\nWhat kind of unicorn do you want? You might want pink, but not necessarily. Purple has been quite popular lately. Does she need sunglasses? Star tattoos? These choices, while difficult, are your primary concern as a tester– you need to ensure that your order fulfillment center sends out the right unicorn to the right person, and that starts with these choices.\nNotice that nowhere in that paragraph do we talk about buttons, fields, drop-downs, radio buttons, or web forms. Neither should your tests! You want to write your code like the user trying to solve their problem. Here is one way of doing this (continuing from the previous example):\nJava Python C# Ruby JavaScript Kotlin // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn() # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.Purple, UnicornAccessories.Sunglasses, UnicornAdornments.StarTattoos); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.AddUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.CreateUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn.new(\u0026#39;Sparkles\u0026#39;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. var sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there.  var addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. var unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. val addUnicornPage = accountPage.addUnicorn() // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     Now that you have configured your unicorn, you need to move on to step 3: making sure it actually worked.\nJava Python C# Ruby JavaScript Kotlin // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles));   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.True(unicornConfirmationPage.Exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. expect(unicorn_confirmation_page.exists?(sparkles)).to be, \u0026#39;Sparkles should have been created, with all attributes intact\u0026#39;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assert(unicornConfirmationPage.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles))     Note that the tester still has not done anything but talk about unicorns in this code– no buttons, no locators, no browser controls. This method of modelling the application allows you to keep these test-level commands in place and unchanging, even if Larry decides next week that he no longer likes Ruby-on-Rails and decides to re-implement the entire site in the latest Haskell bindings with a Fortran front-end.\nYour page objects will require some small maintenance in order to conform to the site redesign, but these tests will remain the same. Taking this basic design, you will want to keep going through your workflows with the fewest browser-facing steps possible. Your next workflow will involve adding a unicorn to the shopping cart. You will probably want many iterations of this test in order to make sure the cart is keeping its state properly: Is there more than one unicorn in the cart before you start? How many can fit in the shopping cart? If you create more than one with the same name and/or features, will it break? Will it only keep the existing one or will it add another?\nEach time you move through the workflow, you want to try to avoid having to create an account, login as the user, and configure the unicorn. Ideally, you will be able to create an account and pre-configure a unicorn via the API or database. Then all you have to do is log in as the user, locate Sparkles, and add her to the cart.\nTo automate or not to automate? Is automation always advantageous? When should one decide to automate test cases?\nIt is not always advantageous to automate test cases. There are times when manual testing may be more appropriate. For instance, if the application’s user interface will change considerably in the near future, then any automation might need to be rewritten anyway. Also, sometimes there simply is not enough time to build test automation. For the short term, manual testing may be more effective. If an application has a very tight deadline, there is currently no test automation available, and it’s imperative that the testing gets done within that time frame, then manual testing is the best solution.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/remote_webdriver/remote_webdriver_client/",
	"title": "Remote WebDriver client",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n To run a remote WebDriver client, we first need to connect to the RemoteWebDriver. We do this by pointing the URL to the address of the server running our tests. In order to customize our configuration, we set desired capabilities. Below is an example of instantiating a remote WebDriver object pointing to our remote web server, www.example.com, running our tests on Firefox.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver firefox_options = webdriver.FirefoxOptions() driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=firefox_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); var capabilities = Capabilities.firefox(); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     To further customize our test configuration, we can add other desired capabilities.\nBrowser options For example, suppose you wanted to run Chrome on Windows XP, using Chrome version 67:\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.set_capability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chrome_options.set_capability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=chrome_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var chromeOptions = new ChromeOptions(); chromeOptions.BrowserVersion = \u0026#34;67\u0026#34;; chromeOptions.PlatformName = \u0026#34;Windows XP\u0026#34;; IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); const chrome = require(\u0026#34;selenium-webdriver/chrome\u0026#34;) var capabilities = Capabilities.chrome(); //To avoid InsecureCertificateError for selenium4-aplha5 capabilities.setAcceptInsecureCerts(true); capabilities.set(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); capabilities.set(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit();     Local file detector The Local File Detector allows the transfer of files from the client machine to the remote server. For example, if a test needs to upload a file to a web application, a remote WebDriver can automatically transfer the file from the local machine to the remote web server during runtime. This allows the file to be uploaded from the remote machine running the test. It is not enabled by default and can be enabled in the following way:\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   from selenium.webdriver.remote.file_detector import LocalFileDetector driver.file_detector = LocalFileDetector()   var allowsDetection = this.driver as IAllowsFileDetection; if (allowsDetection != null) { allowsDetection.FileDetector = new LocalFileDetector(); }   @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   var remote = require(\u0026#39;selenium-webdriver/remote\u0026#39;); driver.setFileDetector(new remote.FileDetector);   driver.fileDetector = LocalFileDetector()     Once the above code is defined, you can upload a file in your test in the following way:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) driver.find_element(By.ID, \u0026#34;myfile\u0026#34;).send_keys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)   driver.Navigate().GoToUrl(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); IWebElement upload = driver.FindElement(By.Id(\u0026#34;myfile\u0026#34;)); upload.SendKeys(@\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); var upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/front_matter/typographical_conventions/",
	"title": "Typographical conventions",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Capitalisation of titles One should avoid title capitalisation, such as A Very Fine Heading, and instead go for A very fine heading. Gratutious capitalisation, or title case, often show a misunderstanding of – or a disregard for – orthographic conventions. We prefer what is known as sentence case, with a single initial capital to start headers.\nLine length When editing the documentation’s source, which is written in plain HTML, limit your line lengths to around 72 characters.\nSome of us take this one step further and use what is called semantic linefeeds, which is a technique whereby the HTML source lines, which are not read by the public, are split at ‘natural breaks’ in the prose. In other words, sentences are split at natural breaks between clauses. Instead of fussing with the lines of each paragraph so that they all end near the right margin, linefeeds can be added anywhere that there is a break between ideas.\nThis can make diffs very easy to read when collaborating through git, but it is not something we enforce contributors to use.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/support_packages/working_with_colours/",
	"title": "Working with colours",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n You will occasionally want to validate the colour of something as part of your tests; the problem is that colour definitions on the web are not constant. Would it not be nice if there was an easy way to compare a HEX representation of a colour with a RGB representation of a colour, or a RGBA representation of a colour with a HSLA representation of a colour?\nWorry not. There is a solution: the Color class!\nFirst of all, you will need to import the class:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.Color    You can now start creating colour objects. Every colour object will need to be created from a string representation of your colour. Supported colour representations are:\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     The Color class also supports all of the base colour definitions specified in http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     Sometimes browsers will return a colour value of \u0026ldquo;transparent\u0026rdquo; if no colour has been set on an element. The Color class also supports this:\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     You can now safely query an element to get its colour/background colour knowing that any response will be correctly parsed and converted into a valid Color object:\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)); Color loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;));   login_button_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(By.ID,\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;))   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    login_button_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;))   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)) val loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;))     You can then directly compare colour objects:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour == HOTPINK)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.equals(HOTPINK))     Or you can convert the colour into one of the following formats and perform a static validation:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     Colours are no longer a problem.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/driver_requirements/",
	"title": "드라이버 요구사항",
	"tags": [],
	"description": "",
	"content": "Selenium은 WebDriver를 이용하여 Chrom(ium), Firefox, Internet Explorer, Opera, Safari와 같은 시장의 모든 주요 브라우저들을 지원합니다. 모든 브라우저가 원격 제어에 대한 공식적인 지원을 가지고 있는 것은 아니지만, WebDriver는 가능한 경우 브라우저에 내장된 자동화 지원을 이용하여 브라우저를 구동합니다.\nWebDriver의 목적은 브라우저와 실제 사용자의 상호작용을 최대한 모방하는 것이며, 이는 브라우저마다 다른 수준으로 진행될 수 있습니다. 다양한 드라이버 특성에 대한 자세한 내용은 _드라이버 특성_을 참조하십시오.\n브라우저 제어를 위한 사용자 대면 인터페이스는 모든 드라이버가 동일하지만, 브라우저 세션을 설정하는 방법에는 약간의 차이가 존재합니다. 드라이버 구현의 많은 부분들은 서드파티에 의해 제공되기 때문에 표준 Selenium 배포에 포함되지 않습니다.\n브라우저에 따라 요구사항이 다른 매개변수의 예시에는 드라이버의 인스턴스화, 프로필 관리 및 다양한 브라우저별 설정 등의 작업 등이 있습니다. 여기서는 다른 브라우저를 시작하기 위한 기초적인 요구사항을 안내합니다.\nPATH에 실행 파일을 추가합니다. 대부분의 드라이버들은 Selenium이 브라우저를 이용하여 통신하기 위한 추가 실행 파일을 필요로 합니다. WebDriver를 시작하기 전에 실행 파일의 위치를 수동으로 지정할 수 있습니다. 그러나 실행 파일이 모든 시스템에서 동일한 위치에 있거나, 테스트 코드 저장소에 실행 파일이 포함되어야 하기 때문에 이식성이 떨어질 수 있습니다.\nSelenium은 시스템 경로에 WebDriver의 바이너리가 들어 있는 폴더를 추가함으로써, 테스트 코드가 드라이버의 정확한 위치를 찾도록 요구하지 않아도 추가 바이너리를 찾도록 할 수 있습니다.\n 실행 파일을 넣을 디렉토리를 다음과 같이 만듭니다. C:\\WebDriver\\bin or /opt/WebDriver/bin PATH에 디렉토리를 추가합니다:  Windows의 경우 - CMD를 관리자 권한으로 실행한 뒤, 다음 명령을 실행하여 컴퓨터의 모든 사용자에 대한 디렉터리를 경로에 영구적으로 추가합니다.    setx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34;  Mac OS와 Linux의 Bash 사용자의 경우 - terminal을 사용합니다:  export PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile   이제 변경 사항을 테스트 할 준비가 되었습니다. 열려있는 모든 CMD를 닫고, 새 CMD를 실행한 뒤, 이전 단계에서 생성한 폴더에 바이너리 중 하나의 이름을 다음과 같이 입력합니다.\nchromedriver   만약 PATH가 올바르게 구성되었다면, 다음과 같이 드라이버 시작과 관련된 일부 출력을 볼 수 있을 것입니다.:\n  Starting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed. 이 상태에선 Ctrl+C를 눌러 CMD를 다시 제어할 수 있습니다.\n빠른 참조    브라우저 지원하는 OS 유지 및 관리 다운로드 이슈 트래커     Chromium/Chrome Windows/macOS/Linux Google Downloads Issues   Firefox Windows/macOS/Linux Mozilla DownLoads Issues   Edge Windows 10 Microsoft DownLoads Issues   Internet Explorer Windows Selenium Project DownLoads Issues   Safari macOS El Capitan and newer Apple Built in Issues   Opera Windows/macOS/Linux Opera DownLoads Issues    Chromium/Chrome Chrome 또는 Chromium에서 구동하기 위해 chromedriver 를 다운받은 뒤, 시스템 경로에 넣어야 합니다.\nLinux 또는 MacOS에서 이는 PATH 환경 변수 수정을 의미하므로, 다음 명령을 실행하여 콜론(:)으로 구분된 디렉토리를 시스템 경로를 구성할 수 있습니다:\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 경로에 chromedriver를 포함할 때, chromedriver 바이너리의 상위 디렉토리를 포함하는지 확인 해야 합니다. 다음 줄은 PATH 환경 변수의 현재 내용과 콜론(:) 뒤에 추가 경로를 덧붙여야 합니다:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; 경로에서 chromedriver를 사용할 수 있는 경우, 모든 디렉토리에서 chromedriver 실행 파일을 실행할 수 있어야 합니다.\n다음을 이용하여 Chrome/Chromium 세션을 인스턴스화 할 수 있습니다:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Simple assignment from selenium.webdriver import Chrome driver = Chrome() #Or use the context manager from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     chromedriver 실행 파일의 경로 설정은 다음과 같이 가능합니다:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     chromedriver는 Chrome의 내부 자동화 프록시 인터페이스를 노출하여 브라우저에게 수행할 작업을 지시하는 웹 드라이버 원격 서버로 구현됩니다.\nFirefox Mozilla는 Selenium 3을 시작으로 Firefox 드라이버 geckodriver의 구현을 이어받았으며, geckodriver라고 불립니다. 이는 Firefox 48 이상 버전에서 작동하고, Firefox WebDriver가 꾸준히 개발중이기 때문에 새로운 Firefox 버전이 나올때마다 더 나은 지원을 제공합니다.\ngeckodriver은 Firefox를 시작하는 기본적인 방법이기 때문에 Selenium 2와 같은 방법으로 Firefox를 인스턴스화 할 수 있습니다:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Simple assignment from selenium.webdriver import Firefox driver = Firefox() #Or use the context manager from selenium.webdriver import Firefox with Firefox() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     PATH를 사용하지 않고 geckodriver의 위치를 설정하려면, 프로그램적으로 geckodriver의 바이너리 위치를 설정해야 합니다:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.setBinary(\u0026#34;/path/to/geckodriver\u0026#34;);   System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     런타임의 속성을 설정하는 것 또한 가능합니다:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver 현재 Firefox 47.0.1 또는 45 ESR)을 설치하고 원하는 marionette 기능을 false로 지정함으로써 이전의, 보다 완전한 Firefox 드라이버로 되돌릴 수 있습니다. 그러나 이후 출시된 Firefox는 더 이상 호환이 불가능합니다.\nEdge Edge는 Windows 10과 Server 2016에 포함된 microsoft의 최신 브라우저입니다.\nEdge의 업데이트는 주요 Windows 업데이트와 함께 번들로 제공되기 때문에 바이너리를 다운로드 할 때는 현재 설치된 Windows 빌드 번호와 바이너리의 빌드 번호가 일치하는지 확인이 필요합니다.\nEdge Developer sites는 사용 가능한 모든 바이너리 파일에 대한 링크를 포함합니다. EdgeDriver 구현에 대한 버그는 Microsoft에 올라올 수 있습니다. microsoft는 Windows 10을 실행하지 않고 Edge에 대해 테스트를 하려는 테스터를 위해 다음 사이트에서 무료 VM을 제공합니다. Edge Developer sites\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Simple assignment from selenium.webdriver import Edge driver = Edge() #Or use the context manager from selenium.webdriver import Edge with Edge() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     경로에 Edge 드라이버가 없는 경우 다음과 같이 경로를 설정할 수 있습니다:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const edge = require(\u0026#39;selenium-webdriver/edge\u0026#39;); let service = new edge.ServiceBuilder(\u0026#34;/path/to/msedgedriver.exe\u0026#34;); (async function test() { let driver = await new Builder() .setEdgeService(service) .forBrowser(\u0026#39;MicrosoftEdge\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     Internet Explorer Internet Explorer는 windows 10에 포함되며, windows 10까지 microsoft의 기본 브라우저였습니다. Internet Explorer 드라이버는 Selenium 프로젝트와 동일한 릴리즈를 지원하는 것을 목표로 하는 유일한 드라이버입니다.Microsoft considers current 또한 이전 릴리즈들은 작동할 수 있지만 지원은 되지 않을 예정입니다.\nSelenium 프로젝트는 32-bit와 64-bit 버전의 Internet Explorer에 모두 바이너리를 제공합니다. 32-bit 드라이버를 사용하는 것은 계속해서 잘 작동하는 반면 64-bit 드라이버가 있는 Internet Explorer 10 \u0026amp; 11에는 몇가지 제한이 존재합니다. limitations\nInternet Explorer은 로그인한 사용자 계정에 대해 설정이 저장되므로 일부 추가 설정 additional setup is required이 필요하다는 점을 유의해야 합니다.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Simple assignment from selenium.webdriver import Ie driver = Ie() #Or use the context manager from selenium.webdriver import Ie with Ie() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     경로에 Internet Explorer 드라이버가 없는 경우 다음과 같이 경로를 설정할 수 있습니다:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let service = new ie.ServiceBuilder(\u0026#34;/path/to/IEDriverServer.exe\u0026#34;); (async function test() { let driver = await new Builder() .setIeService(service) .forBrowser(\u0026#39;internet explorer\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     microsoft는 또한 Internet Explorer 11 on Windows 7 \u0026amp; 8.1에서 Windows 7 \u0026amp; 8.1에 존재하는 Internet Explorer 11을 위한 WebDriver 바이너리를 제공합니다. 이는 2014년 이후 업데이트되지 않았지만, W3 규격 초안을 기반으로 하고 있습니다.\nJim Evans는 microsoft의 구현에 대한 훌륭한 기록을 가지고 있습니다.\nOpera 현재 출시된 Opera는 Chromium 엔진 위에 구축되어 있으며, WebDriver는 이제 closed-source Opera Chromium Driver를 통해 PATH에 추가 added to your PATH 또는 시스템 속성으로 지원됩니다.\n드라이버 세션을 인스턴스화하는 것은 Firefox, Chromium과 유사합니다:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Simple assignment from selenium.webdriver import Opera driver = Opera() #Or use the context manager from selenium.webdriver import Opera with Opera() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const opera = require(\u0026#39;selenium-webdriver/opera\u0026#39;); (async function test() { let driver = await new Builder() .forBrowser(\u0026#39;opera\u0026#39;) .build(); })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari High Sierra 이상 버전:\n 터미널에서 다음 명령을 한 뒤, WebDriver를 승인하기 위해 프롬프트에 암호를 입력합니다.  safaridriver --enable El Capitan과 Sierra:\n Safari 기본 설정에서 개발자 메뉴를 사용합니다. 개발 메뉴에서 \u0026lsquo;원격 자동화 허용\u0026rsquo; 옵션을 확인합니다. 터미널에서 다음 명령을 한 뒤, WebDriver를 승인하기 위해 프롬프트에 암호를 입력합니다.  /usr/bin/safaridriver -p 1337\u0026lt;/ 이후 아래를 사용하여 드라이버 세션을 시작할 수 있습니다:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Simple assignment from selenium.webdriver import Safari driver = Safari() #Or use the context manager from selenium.webdriver import Safari with Safari() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     iOS에서 Safari 자동화를 원하는 사용자는 Appium project를 참조해야 합니다. 이전에는 Windows용 Safari를 사용할 수 있었지만, 오랫동안 중단된 Apple의 지원으로 인해 Safari의 시험용 플랫폼으로서의 가치가 낮아졌습니다.\nMock browsers HtmlUnit HTMLUnit은 \u0026ldquo;Java 프로그램을 위한 GUI-Less 브라우저\u0026quot;입니다. 이는 HTML 문서를 모델링하고 페이지 호출, 양식 작성, 클릭링크 등이 가능한 API를 제공합니다. 또한 JavaScript 지원 기능이 있으며, 사용되는 구성에 따라 Chrome, Firefox 또는 Internet Explorer를 시뮬레이션하여 AJAX 라이브러리와 작업할 수 있습니다. 이것은 new location)로 옮겨졌으며, 소스는 svn으로 유지됩니다.\nPhantomJS PhantomJS는 Google Chrome이나 Safari가 사용하는 것 보다 훨씬 오래된 버전의 Webkit을 기반으로 한 헤드리스 브라우저입니다. 역사적으로 대중적인 선택이었지만, 이제 이 프로젝트는 유지되지 않으므로 PhantomJS를 피하는 것이 현명할 것입니다. since the 5th of August 2017, 따라서 웹이 계속 바뀌는 동안, PhantomJS는 업데이트되지 않을 것입니다.\n프로젝트의 유지 중단은 Google이 Chrome을 헤드리스로 실행할 수 있는 능력을 발표한 후였는데, 지금은 Mozilla의 Firefox도 이 기능을 제공하고 있습니다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/introduction/",
	"title": "소개",
	"tags": [],
	"description": "",
	"content": "소개 셀레니움(Selenium)은 웹브라우저를 자동화할 수 있게 돕는 일련의 도구 모음인 엄브렐라 프로젝트(umbrella project) 중 일부입니다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "써드파티 드라이버와 플러그인",
	"tags": [],
	"description": "",
	"content": "Selenium은 플러그인의 사용으로 확장될 수 있습니다.\n다음은 제3자에 의해 생성되고 유지되는 많은 플러그인 입니다.\n고유한 플러그인을 만들거나 플러그인이 나열되는 자세한 내용은 문서를 참조하세요.\n이러한 플러그인은 Selenium 프로젝트에서 지원, 유지 관리, 호스팅 또는 보증하지 않는다는 점에서 유의하십시오.\n또한 아래 나열된 플러그인이 반드시 Apache License v2.0에 따라 라이센스가 부여되지 않는다는 것을 유념하십시오.\n일부 플러그인은 다른 모료 오픈소스 소프트웨어 라이센스로 사용할 수 있으며, 다른 플러그인은 독점 라이센스로만 사용할 수 있습니다.\n플러그인과 해당 플러그인의 배포 라이센스에 대한 모든 질문은 해당 개발자와 함께 제기해 주세요.\n   브라우저 최신 버전 변경 내역 이슈 위키     Google ChromeDriver 2.29 changelog issues wiki    "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/selenium_installation/installing_webdriver_binaries/",
	"title": "웹드라이버 바이너리 설치",
	"tags": [],
	"description": "",
	"content": "당신의 프로젝트와 브라우저 제어를 시작하기 위해서 특정 브라우저의 웹드라이버 바이너리가 설치돼있어야 합니다.\n당신의 브라우저가 지원하는 웹드라이버 바이너리 를 다운로드하고, 시스템 경로에 위치하세요.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/worst_practices/file_downloads/",
	"title": "파일 다운로드",
	"tags": [],
	"description": "",
	"content": "Selenium의 제어 하에 브라우저로 링크를 클릭하면 다운로드를 시작할 수 있지만, API는 다운로드 진행 상황을 노출시키지 않아 다운로드 파일 테스트에 이상적이지 않다. 이것은 파일 다운로드가 웹 플랫폼과의 사용자 상호작용을 모방하는 중요한 측면으로 여겨지지 않기 때문이다. 대신 Selenium(및 필요한 쿠키)을 사용하여 링크를 찾아 HTTP 요청 라이브러리 like libcurl.에 전달하라.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/browser_manipulation/",
	"title": "Browser manipulation",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Ruby Ruby is not installed by default on Windows. Download the latest version and run the installer. You can leave all settings at default values, except at the Installation Destination and Optional Tasks screen check where you need to check the Add Ruby executables to your PATH checkbox. To drive any browser, you have to install selenium-webdriver Ruby gem. To install it, open command prompt and type this:\ngem install selenium-webdriver Or, if you use Bundler, add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#34;selenium-webdriver\u0026#34; And then execute the following command in command prompt:\nbundle install Internet Explorer Internet Explorer is installed by default on Windows, so no installation is needed. To drive Internet Explorer on Windows, you have to download the latest Internet Explorer Driver and put the file into a folder that is in PATH. To find out which directories are in PATH, type echo %PATH% in command prompt.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin looks like a good place. Unzip IEDriverServer file and move IEDriverServer.exe there.\nThis should open a new Internet Explorer window:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Browser navigation Navigate to The first thing you will want to do after launching a browser is to open your website. This can be achieved in a single line:\nJava Python C# Ruby JavaScript Kotlin //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   # Convenient way driver.get \u0026#39;https://selenium.dev\u0026#39; # Longer Way driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;) //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     Get current URL You can read the current URL from the browser\u0026rsquo;s address bar using:\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.currentUrl    Back Pressing the browser\u0026rsquo;s back button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     Forward Pressing the browser\u0026rsquo;s forward button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward()    Refresh Refresh the current page:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    Get title You can read the current page title from the browser:\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.title    Windows and tabs Get window handle WebDriver does not make the distinction between windows and tabs. If your site opens a new tab or window, Selenium will let you work with it using a window handle. Each window has a unique identifier which remains persistent in a single session. You can get the window handle of the current window by using:\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.windowHandle    Switching windows or tabs Clicking a link which opens in a new windowwill focus the new window or tab on screen, but WebDriver will not know which window the Operating System considers active. To work with the new window you will need to switch to it. If you have only two tabs or windows open, and you know which window you start with, by the process of elimination you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nHowever, Selenium 4 provides a new api NewWindow which creates a new tab (or) new window and automatically switches to it.\nJava Python C# Ruby JavaScript Kotlin //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element(By.LINK_TEXT, \u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;Selenium documentation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   //Store the ID of the original window val originalWindow = driver.getWindowHandle() //Check we don\u0026#39;t have other windows open already assert(driver.getWindowHandles().size() === 1) //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)) //Loop through until we find a new window handle for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     Create new window (or) new tab and switch Creates a new window (or) tab and will focus the new window or tab on screen. You don\u0026rsquo;t need to switch to work with the new window (or) tab. If you have more than two windows (or) tabs opened other than the new window, you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nNote: This feature works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB); // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW);   # Opens a new tab and switches to new tab driver.switch_to.new_window(\u0026#39;tab\u0026#39;) # Opens a new window and switches to new window driver.switch_to.new_window(\u0026#39;window\u0026#39;)   // Opens a new tab and switches to new tab driver.SwitchTo().NewWindow(WindowType.Tab) // Opens a new window and switches to new window driver.SwitchTo().NewWindow(WindowType.Window)   # Note: The new_window in ruby only opens a new tab (or) Window and will not switch automatically # The user has to switch to new tab (or) new window # Opens a new tab and switches to new tab driver.manage.new_window(:tab) # Opens a new window and switches to new window driver.manage.new_window(:window)   // Opens a new tab and switches to new tab await driver.switchTo().newWindow(\u0026#39;tab\u0026#39;); // Opens a new window and switches to new window await driver.switchTo().newWindow(\u0026#39;window\u0026#39;);   // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB) // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW)     Closing a window or tab When you are finished with a window or tab and it is not the last window or tab open in your browser, you should close it and switch back to the window you were using previously. Assuming you followed the code sample in the previous section you will have the previous window handle stored in a variable. Put this together and you will get:\nJava Python C# Ruby JavaScript Kotlin //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);   //Close the tab or window driver.close() //Switch back to the old tab or window driver.switchTo().window(originalWindow)     Forgetting to switch back to another window handle after closing a window will leave WebDriver executing on the now closed page, and will trigger a No Such Window Exception. You must switch back to a valid window handle in order to continue execution.\nQuitting the browser at the end of a session When you are finished with the browser session you should call quit, instead of close:\nJava Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()     Quit will:  Close all the windows and tabs associated with that WebDriver session Close the browser process Close the background driver process Notify Selenium Grid that the browser is no longer in use so it can be used by another session (if you are using Selenium Grid)    Failure to call quit will leave extra background processes and ports running on your machine which could cause you problems later.\nSome test frameworks offer methods and annotations which you can hook into to tear down at the end of a test.\nJava Python C# Ruby JavaScript Kotlin /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # unittest teardown # https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown def tearDown(self): self.driver.quit()   /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # UnitTest Teardown # https://www.rubydoc.info/github/test-unit/test-unit/Test/Unit/TestCase def teardown @driver.quit end   /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });   /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() { driver.quit() }     If not running WebDriver in a test context, you may consider using try / finally which is offered by most languages so that an exception will still clean up the WebDriver session.\nJava Python C# Ruby JavaScript Kotlin try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { //WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }   try { //WebDriver code here... } finally { driver.quit() }     Python\u0026rsquo;s WebDriver now supports the python context manager, which when using the with keyword can automatically quit the driver at the end of execution.\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation Frames and Iframes Frames are a now deprecated means of building a site layout from multiple documents on the same domain. You are unlikely to work with them unless you are working with an pre HTML5 webapp. Iframes allow the insertion of a document from an entirely different domain, and are still commonly used.\nIf you need to work with frames or iframes, WebDriver allows you to work with them in the same way. Consider a button within an iframe. If we inspect the element using the browser development tools, we might see the following:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; If it was not for the iframe we would expect to click on the button using something like:\nJava Python C# Ruby JavaScript Kotlin //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # This Wont work driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # This won\u0026#39;t work driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     However, if there are no buttons outside of the iframe, you might instead get a no such element error. This happens because Selenium is only aware of the elements in the top level document. To interact with the button, we will need to first switch to the frame, in a similar way to how we switch windows. WebDriver offers three ways of switching to a frame.\nUsing a WebElement Switching using a WebElement is the most flexible option. You can find the frame using your preferred selector and switch to it.\nJava Python C# Ruby JavaScript Kotlin //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Store iframe web element iframe = driver.find_element(By.CSS_SELECTOR, \u0026#34;#modal \u0026gt; iframe\u0026#34;) # switch to selected iframe driver.switch_to.frame(iframe) # Now click on button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Store iframe web element iframe = driver.find_element(:css,\u0026#39;#modal \u0026gt; iframe\u0026#39;) # Switch to the frame driver.switch_to.frame iframe # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Store the web element const iframe = driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Store the web element val iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) //Switch to the frame driver.switchTo().frame(iframe) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using a name or ID If your frame or iframe has an id or name attribute, this can be used instead. If the name or ID is not unique on the page, then the first one found will be switched to.\nJava Python C# Ruby JavaScript Kotlin //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Switch frame by id driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # Now, Click on the button driver.find_element(By.TAG_NAME, \u0026#39;button\u0026#39;).click()   //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Switch by ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using an index It is also possible to use the index of the frame, such as can be queried using window.frames in JavaScript.\nJava Python C# Ruby JavaScript Kotlin // Switches to the second frame driver.switchTo().frame(1);   # Switch to the second frame driver.switch_to.frame(1)   // Switches to the second frame driver.SwitchTo().Frame(1);   # switching to second iframe based on index iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # switch to selected iframe driver.switch_to.frame(iframe)   // Switches to the second frame await driver.switchTo().frame(1);   // Switches to the second frame driver.switchTo().frame(1)     Leaving a frame To leave an iframe or frameset, switch back to the default content like so:\nJava Python C# Ruby JavaScript Kotlin // Return to the top level driver.switchTo().defaultContent();   # switch back to default content driver.switch_to.default_content()   // Return to the top level driver.SwitchTo().DefaultContent();   # Return to the top level driver.switch_to.default_content   // Return to the top level await driver.switchTo().defaultContent();   // Return to the top level driver.switchTo().defaultContent()     Window management Screen resolution can impact how your web application renders, so WebDriver provides mechanisms for moving and resizing the browser window.\nGet window size Fetches the size of the browser window in pixels.\nJava Python C# Ruby JavaScript Kotlin //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # Access each dimension individually width = driver.manage.window.size.width height = driver.manage.window.size.height # Or store the dimensions and query them later size = driver.manage.window.size width1 = size.width height1 = size.height   // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   //Access each dimension individually val width = driver.manage().window().size.width val height = driver.manage().window().size.height //Or store the dimensions and query them later val size = driver.manage().window().size val width1 = size.width val height1 = size.height     Set window size Restores the window and sets the window size. Java Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });   driver.manage().window().size = Dimension(1024, 768)   \nGet window position Fetches the coordinates of the top left coordinate of the browser window.\nJava Python C# Ruby JavaScript Kotlin // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   #Access each dimension individually x = driver.manage.window.position.x y = driver.manage.window.position.y # Or store the dimensions and query them later rect = driver.manage.window.rect x1 = rect.x y1 = rect.y   // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // Access each dimension individually val x = driver.manage().window().position.x val y = driver.manage().window().position.y // Or store the dimensions and query them later val position = driver.manage().window().position val x1 = position.x val y1 = position.y     Set window position Moves the window to the chosen position.\nJava Python C# Ruby JavaScript Kotlin // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   # Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });   // Move the window to the top left of the primary monitor driver.manage().window().position = Point(0,0)     Maximise window Enlarges the window. For most operating systems, the window will fill the screen, without blocking the operating system\u0026rsquo;s own menus and toolbars.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    Minimize window Minimizes the window of current browsing context. The exact behavior of this command is specific to individual window managers.\nMinimize Window typically hides the window in the system tray.\nNote: This feature works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().minimize();  driver.minimize_window()  driver.Manage().Window.Minimize();   driver.manage.window.minimize  await driver.manage().window().minimize();   driver.manage().window().minimize()    Fullscreen window Fills the entire screen, similar to pressing F11 in most browsers.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/getting_started_with_webdriver/locating_elements/",
	"title": "Element 찾기",
	"tags": [],
	"description": "",
	"content": "하나의 element 찾기 웹드라이버를 사용할 때 알아야할 가장 기본적인 테크닉 중 하나는 페이지에서 element들을 찾는 것입니다. 웹드라이버는 다양한 종류의 내장된 셀렉터 타입들을 제공해주고, 그 중 하나는 ID 속성을 통해 element들을 찾는 것입니다:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element(By.ID, \u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     예시와 같이, 웹드라이버에서 element들을 찾는 것은 WebDriver 인스턴스 객체에서 시행됩니다. findElement(By) 메소드는 WebElement라는 기초적인 객체를 반환합니다.\n WebDriver 는 브라우저를 나타냅니다. WebElement 는 특정한 DOM 노드를 나타냅니다. (링크나 인풋 필드 등)  발견된 웹 element에 대한 참조가 있다면, 그 참조를 통해 검색 범위를 좁힐 수 있습니다:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(By.ID, \u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;) cheddar = cheese.find_element(id: \u0026#39;cheddar\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     이것이 가능한 이유는 WebDriver 과 WebElement 모두 SearchContext라는 인터페이스를 구현한 것이기 때문입니다.이것은 웹드라이버에서 role-based(역할 기반) 인터페이스라고 알려져 있습니다. Role-based 인터페이스는 특정 드라이버 구현이 주어진 기능을 지원하는지 확인할 수 있게 해줍니다. 이러한 인터페이스는 명확하게 정의되어 있으며, 단 하나의 역할만을 가지고 있는 것을 고수하려고 노력합니다. 웹드라이버의 디자인이나 어떠한 드라이버에서 어떠한 역할을 지원하는지에 대해서는 여기(아직 미구현)를 참고하십시오.\n따라서, 위에서 사용한 By인터페이스도 다양한 추가 locator 전략을 지원합니다. 중첩된 조회는 브라우저에 별도의 두 개 명령을 실행해야하므로 가장 효과적인 cheese 찾기 전략이 아닐 수 있습니다. 별도의 두 개 명령은 ID \u0026ldquo;cheese\u0026quot;를 DOM에서 찾는 명령과 그 곳에서 \u0026ldquo;cheddar\u0026quot;를 그 다음에 찾는 명령을 말합니다.\n성능을 향상시키기 위해서는 좀 더 세부적인 locator를 사용해야합니다. 웹드라이버는 CSS locator를 통해 element를 검색하는 기능을 지원하고, 이는 위처럼 두 개의 locator를 사용할 필요가 없게 해줍니다:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   driver.find_element(css: \u0026#39;#cheese #cheddar\u0026#39;)   const cheddar = driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     다수의 element 찾기 우리가 작업하고 있는 문서가 다음과 같이 우리가 제일 좋아하는 치즈들의 정렬된 리스트일 수 있습니다:\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; 더 많은 치즈는 의심할 여지 없이 더 좋지만, 각각의 아이템들을 따로 회수하기에는 너무 복잡하고 힘들어질 것입니다. 이를 위한 좀 더 상급 테크닉은 바로 다수 버전의 findElements(By)를 사용하는 것입니다. 이 메소드는 web elements들의 컬렉션을 반환합니다. 하나의 element만 발견되어도 여전히 컬렉션을 반환합니다. (이 때의 컬렉션은 하나의 element로 이루어져 있습니다). 만약 아무 element가 발견되지 않는다면, 빈 리스트가 반환됩니다.\nJava Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(“#cheese li”));   mucho_cheese = driver.find_elements(css: \u0026#39;#cheese li\u0026#39;)   const muchoCheese = driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))     Element 선택 전략 웹드라이버에는 여덟 가지의 내장된 element location 전략이 있습니다:\n   Locator Description     class name class name 중에서 검색한 값이 있는지 찾습니다.   css selector CSS selector 속성 중에서 검색한 값이 있는지 찾습니다.   id ID 속성 중에서 검색한 값이 있는지 찾습니다.   name NAME 속성 중에서 검색한 값이 있는지 찾습니다.   link text 보이는 텍스트 중에서 검색한 값이 있는지 찾습니다.   partial link text 보이는 텍스트 중에서 검색한 값이 있는지 찾습니다.   tag name tag name 중에서 검색한 값이 있는지 찾습니다.   xpath Xpath expression 중에서 검색한 값이 있는지 찾습니다.    Selector 사용 팁 일반적으로 HTML ID가 사용가능하고, 고유하며, 예측가능하다면 검색할 때 HTML ID를 통해 하는 것이 좋습니다. HTML ID로 검색하는 것은 매우 빠르며, 복잡하게 DOM을 이용하는 방법들을 속도에서 앞섭니다.\n고유한 ID가 없다면, CSS selector이 그 다음으로 선호되는 방법입니다. XPath 또한 CSS selector만큼 잘 작동되지만, 구문이 복잡하며 디버깅을 하기 힘듭니다. 하지만 XPath selector는 매우 유연하기 때문에 일반적으로 브라우저 벤더에 의해 성능 테스트를 받지 않으며 꽤 느린 경향이 있다.\nlinkText와 partialLinkText를 이용한 전략은 link element에서만 사용이 가능합니다. 또한, 웹드라이버 내부적으로는 XPath selector를 사용하여 작동합니다.\nTag name은 element 검색을 할 때 위험한 방법이 될 수도 있습니다. 한 페이지에는 종종 동일한 tag를 가진 여러 element들이 있습니다. 이 방법은 주로 findElements(By) 메소드를 통해 element의 컬렉션을 반환할 때 유용합니다.\nLocator들을 최대한 가독성 있고 간단하게 유지하는 것을 추천드립니다. 웹 드라이버에게 DOM 전체를 검색하라는 것은 성능이 많이 들어가기 때문에, 검색범위를 좁히면 좁힐수록 좋습니다.\nRelative Locators Selenium 4는 Relative Locators, 또는 _Friendly Locators_를 지원합니다. 이 기능은 다른 element 근처에 있는 element를 검색할 때 도움이 됩니다.\n사용가능한 Relative Locators들은 다음과 같습니다:\n above below toLeftOf toRightOf near  findElement 메소드는 또다른 메소드 withTagName() 를 받습니다. 이 메소드는 Relative Locator를 반환합니다.\n어떻게 작동하는가 셀레니움은 자바스크립트 함수 getBoundingClientRect() 를 사용해서 releative element를 찾습니다. 이 함수는 right(오른쪽), left(왼쪽), bottom(아래), top(위)와 같은 element의 속성들을 반환합니다.\n아래 사진을 예시로 relative locator에 대해 알아봅시다.\nabove() 특정 element 위의 WebElement를 반환합니다.\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement passwordField= driver.findElement(By.id(\u0026#34;password\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .above(passwordField));   #from selenium.webdriver.support.relative_locator import with_tag_name passwordField = driver.find_element(By.ID, \u0026#34;password\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).above(passwordField))   //using static OpenQA.Selenium.RelativeBy; IWebElement passwordField = driver.FindElement(By.Id(\u0026#34;password\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Above(passwordField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      below() 특정 element 아래의 WebElement를 반환합니다.\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressField= driver.findElement(By.id(\u0026#34;email\u0026#34;)); WebElement passwordField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .below(emailAddressField));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressField = driver.find_element(By.ID, \u0026#34;email\u0026#34;) passwordField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;).below(emailAddressField))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressField = driver.FindElement(By.Id(\u0026#34;email\u0026#34;)); IWebElement passwordField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Below(emailAddressField));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toLeftOf() 특정 element 왼쪽의 WebElement를 반환합니다.\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement submitButton= driver.findElement(By.id(\u0026#34;submit\u0026#34;)); WebElement cancelButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toLeftOf(submitButton));   #from selenium.webdriver.support.relative_locator import with_tag_name submitButton = driver.find_element(By.ID, \u0026#34;submit\u0026#34;) cancelButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_left_of(submitButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement submitButton = driver.FindElement(By.Id(\u0026#34;submit\u0026#34;)); IWebElement cancelButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .LeftOf(submitButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      toRightOf() 특정 element 오른쪽의 WebElement를 반환합니다.\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement cancelButton= driver.findElement(By.id(\u0026#34;cancel\u0026#34;)); WebElement submitButton= driver.findElement(withTagName(\u0026#34;button\u0026#34;) .toRightOf(cancelButton));   #from selenium.webdriver.support.relative_locator import with_tag_name cancelButton = driver.find_element(By.ID, \u0026#34;cancel\u0026#34;) submitButton = driver.find_element(with_tag_name(\u0026#34;button\u0026#34;). to_right_of(cancelButton))   //using static OpenQA.Selenium.RelativeBy; IWebElement cancelButton = driver.FindElement(By.Id(\u0026#34;cancel\u0026#34;)); IWebElement submitButton = driver.FindElement(WithTagName(\u0026#34;button\u0026#34;) .RightOf(cancelButton));   # Please raise a PR   // Please raise a PR    // Please raise a PR      near() 특정 element의 최대 50px 근처의 WebElement를 반환합니다.\nJava Python C# Ruby JavaScript Kotlin //import static org.openqa.selenium.support.locators.RelativeLocator.withTagName; WebElement emailAddressLabel= driver.findElement(By.id(\u0026#34;lbl-email\u0026#34;)); WebElement emailAddressField = driver.findElement(withTagName(\u0026#34;input\u0026#34;) .near(emailAddressLabel));   #from selenium.webdriver.support.relative_locator import with_tag_name emailAddressLabel = driver.find_element(By.ID, \u0026#34;lbl-email\u0026#34;) emailAddressField = driver.find_element(with_tag_name(\u0026#34;input\u0026#34;). near(emailAddressLabel))   //using static OpenQA.Selenium.RelativeBy; IWebElement emailAddressLabel = driver.FindElement(By.Id(\u0026#34;lbl-email\u0026#34;)); IWebElement emailAddressField = driver.FindElement(WithTagName(\u0026#34;input\u0026#34;) .Near(emailAddressLabel));   # Please raise a PR   // Please raise a PR    // Please raise a PR      "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/generating_application_state/",
	"title": "Generating application state",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Selenium should not be used to prepare a test case. All repetitive actions and preparations for a test case, should be done through other methods. For example, most web UIs have authentication (e.g. a login form). Eliminating logging in via web browser before every test will improve both the speed and stability of the test. A method should be created to gain access to the AUT* (e.g. using an API to login and set a cookie). Also, creating methods to pre-load data for testing should not be done using Selenium. As mentioned previously, existing APIs should be leveraged to create data for the AUT*.\n*AUT: Application under test\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/legacy_docs/html-runner/",
	"title": "HTML runner",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Selenium HTML-runner allows you to run Test Suites from a command line. Test Suites are HTML exports from Selenium IDE or campatible tools.\nCommon information  Combination of releases of geckodriver / firefox / selenium-html-runner matters. There might be a software compatibility matrix somewhere. selenium-html-runner runs only Test Suite (not Test Case - for example an export from Monitis Transaction Monitor). Be sure you comply with this. For Linux users with no DISPLAY - you need to start html-runner with Virtual display (search for xvfb)  Example Linux environment Install / download following software packages:\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Test Suite example:\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;YOUR-TEST-SCENARIO\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; How to run selenium-html-runner headless Now, the most important part, an example of how to run the selenium-html-runner! Your experience might vary depending on software combinations - geckodriver/FF/html-runner releases.\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html [user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/worst_practices/http_response_codes/",
	"title": "HTTP 응답 코드",
	"tags": [],
	"description": "",
	"content": "Selenium RC의 일부 브라우저 구성에서 Selenium은 자동화되고 있는 브라우저와 사이트 사이의 프록시 역할을 했다. 이것은 셀레니움을 통과하는 모든 브라우저 트래픽이 캡처되거나 조작될 수 있다는 것을 의미했다. captureNetworkTraffic() 방법은 HTTP 응답 코드를 포함하여 자동화되고 있는 브라우저와 사이트 사이의 모든 네트워크 트래픽을 캡처하기 위한 것이다.\nSelenium WebDriver는 브라우저 자동화에 대한 완전히 다른 접근방식으로, 사용자처럼 행동하는 것을 선호한다. 이는 당신이 WebDriver로 시험을 작성하는 방식으로 표현된다. 자동 기능 테스트에서 상태 코드 확인은 테스트 실패의 특별히 중요한 세부 사항은 아니다; 그 이전의 단계들이 더 중요하다.\n브라우저는 항상 HTTP 상태 코드, 예를 들어 404 또는 500 오류 페이지를 나타낸다. 이러한 오류 페이지 중 하나에 부딪쳤을 때 \u0026ldquo;빠르게 실패\u0026quot;하는 간단한 방법은 페이지 로드 때마다 신뢰할 수 있는 지점(예: \u0026ldquo;h1\u0026rdquo; 태그)의 페이지 제목이나 내용을 확인하는 것이다. 페이지 개체 모델을 사용하는 경우, 이 검사를 클래스 생성자 또는 페이지 로드가 예상되는 유사한 지점에 포함할 수 있다. 때때로, HTTP 코드는 브라우저의 에러 페이지에 표시될 수 있고 당신은 이것을 읽고 당신의 디버깅 출력을 향상시키기 위해 WebDriver를 사용할 수 있다.\n웹페이지 자체를 확인하는 것은 웹브라이버의 이상적인 관행과 일치한다.\n당신이 주장한다면, HTTP 상태 코드를 캡처하는 고급 해결책은 프록시를 사용하여 Selenium RC의 행동을 복제하는 것이다. WebDriver API는 브라우저의 프록시를 설정할 수 있는 기능을 제공하며, 웹 서버로부터 송수신되는 요청의 내용을 프로그램적으로 조작할 수 있는 다수의 프록시가 있다. 프록시를 사용하면 리디렉션 응답 코드에 응답할 방법을 결정할 수 있다. 또한, 모든 브라우저가 WebDriver에서 응답 코드를 사용할 수 있게 하는 것은 아니므로, 프록시를 사용하기로 선택하면 모든 브라우저에 적합한 솔루션을 가질 수 있다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/selenium_installation/",
	"title": "Selenium 설치",
	"tags": [],
	"description": "",
	"content": "Selenium 설치 Selenium 설치는 다른 상용도구들과는 꽤 다릅니다. Selenium을 자동화 프로젝트에 사용하기 위해서는 당신이 선택한 언어로 바인딩된 라이브러리 설치가 필요합니다. 자동화와 테스트를 실행할 브라우저를 위한 웹드라이버 바이너리가 추가적으로 필요합니다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/grid/setting_up_your_own_grid/",
	"title": "Setting up your own Grid",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n To use Selenium Grid, you need to maintain your own infrastructure for the nodes. As this can be a cumbersome and time intense effort, many organizations use IaaS providers such as Amazon EC2 and Google Compute to provide this infrastructure.\nOther options include using providers such as Sauce Labs or Testing Bot who provide a Selenium Grid as a service in the cloud. It is certainly possible to also run nodes on your own hardware. This chapter will go into detail about the option of running your own grid, complete with its own node infrastructure.\nQuick start This example will show you how to start the Selenium 2 Grid Hub, and register both a WebDriver node and a Selenium 1 RC legacy node. We will also show you how to call the grid from Java. The hub and nodes are shown here running on the same machine, but of course you can copy the selenium-server-standalone to multiple machines.\nThe selenium-server-standalone package includes the hub, WebDriver, and legacy RC needed to run the Grid, ant is not required anymore. You can download the selenium-server-standalone.jar from https://selenium.dev/downloads/.\nStep 1: Start the Hub The Hub is the central point that will receive test requests and distribute them to the right nodes. The distribution is done on a capabilities basis, meaning a test requiring a set of capabilities will only be distributed to nodes offering that set or subset of capabilities.\nBecause a test\u0026rsquo;s desired capabilities are just what the name implies, desired, the hub cannot guarantee that it will locate a node fully matching the requested desired capabilities set.\nOpen a command prompt and navigate to the directory where you copied the selenium-server-standalone.jar file. You start the hub by passing the -role hub flag to the standalone server:\njava -jar selenium-server-standalone.jar -role hub The Hub will listen to port 4444 by default. You can view the status of the hub by opening a browser window and navigating to http://localhost:4444/grid/console.\nTo change the default port, you can add the optional -port flag with an integer representing the port to listen to when you run the command. Also, all of the other options you see in the JSON config file (seen below) are possible command-line flags.\nYou certainly can get by with only the simple command shown above, but if you need more advanced configuration, you can also specify a JSON format config file, for convenience, to configure the hub when you start it. You can do it like so:\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug Below you will see an example of a hubConfig.json file. We will go into more detail on how to provide node configuration files in step 2.\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} Step 2: Start the Nodes Regardless of whether you want to run a grid with new WebDriver functionality, or a grid with Selenium 1 RC functionality, or both at the same time, you use the same selenium-server-standalone.jar file to start the nodes:\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 If a port is not specified through the -port flag, a free port will be chosen. You can run multiple nodes on one machine but if you do so, you need to be aware of your systems memory resources and problems with screenshots if your tests take them.\nConfiguration of Node with options As mentioned, for backwards compatibility “wd” and “rc” roles are still a valid subset of the “node” role. But those roles limit the types of remote connections to their corresponding API, while “node” allows both RC and WebDriver remote connections.\nPassing JVM properties (using the -D flag before the -jar argument) on the command line as well, and these will be picked up and propagated to the nodes:\n-Dwebdriver.chrome.driver=chromedriver.exe\nConfiguration of Node with JSON You can also start grid nodes that are configured with a JSON configuration file\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json And here is an example of a nodeConfig.json file:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } A note about the -host flag\nFor both hub and node, if the -host flag is not specified, 0.0.0.0 will be used by default. This will bind to all the public (non-loopback) IPv4 interfaces of the machine. If you have a special network configuration or any component that creates extra network interfaces, it is advised to set the -host flag with a value that allows the hub/node to be reachable from a different machine.\nSpecifying the port The default TCP/IP port used by the hub is 4444. If you need to change the port please use above mentioned configurations.\nTroubleshooting Using Log file For advanced troubleshooting you can specify a log file to log system messages. Start Selenium GRID hub or node with -log argument. Please see the below example:\njava -jar selenium-server-standalone.jar -role hub -log log.txt Use your favorite text editor to open log file (log.txt in the example above) to find \u0026ldquo;ERROR\u0026rdquo; logs if you get issues.\nUsing -debug argument Also you can use -debug argument to print debug logs to console. Start Selenium Grid Hub or Node with -debug argument. Please see the below example:\njava -jar selenium-server-standalone.jar -role hub -debug Warning The Selenium Grid must be protected from external access using appropriate firewall permissions.\nFailure to protect your Grid could result in one or more of the following occurring:\n You provide open access to your Grid infrastructure You allow third parties to access internal web applications and files You allow third parties to run custom binaries  See this blog post on Detectify, which gives a good overview of how a publicly exposed Grid could be misused: Don\u0026rsquo;t Leave your Grid Wide Open.\nDocker Selenium Docker provides a convenient way to provision and scale Selenium Grid infrastructure in a unit known as a container. Containers are standardised units of software that contain everything required to run the desired application, including all dependencies, in a reliable and repeatable way on different machines.\nThe Selenium project maintains a set of Docker images which you can download and run to get a working grid up and running quickly. Nodes are available for both Firefox and Chrome. Full details of how to provision a grid can be found within the Docker Selenium repository.\nPrerequisite The only requirement to run a Grid is to have Docker installed and working. Install Docker.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/support_packages/working_with_select_elements/",
	"title": "Working with select elements",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Select elements can require quite a bit of boiler plate code to automate. To reduce this, and make your tests cleaner, there is a Select class in the Selenium support package. To use it, you will need the following import statement:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.ui.Select     You are then able to create a Select object using a WebElement that references a \u0026lt;select\u0026gt; element.\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element(By.ID,\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   IWebElement selectElement = driver.FindElement(By.Id(\u0026#34;selectElementID\u0026#34;)); var selectObject = new SelectElement(selectElement);   select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     The Select object will now give you a series of commands that allow you to interact with a \u0026lt;select\u0026gt; element. First of all, there are different ways of selecting an option from the \u0026lt;select\u0026gt; element.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; There are three ways to select the first option from the above element:\nJava Python C# Ruby JavaScript Kotlin // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by_index(1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by_value(\u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.SelectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.SelectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text  selectObject.SelectByText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by(:index, 1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1) // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     You can then check which options are selected by using:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Return a WebElement referencing the first selection option found by walking down the DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Return a list[WebElement] of options that have been selected all_selected_options = select_object.all_selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected var allSelectedOptions = selectObject.AllSelectedOptions; // Return a WebElement referencing the first selection option found by walking down the DOM var firstSelectedOption = selectObject.AllSelectedOptions.FirstOrDefault();   # Return an Array[Element] of options that have been selected all_selected_options = select_object.selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected val allSelectedOptions = selectObject.allSelectedOptions // Return a WebElement referencing the first selection option found by walking down the DOM val firstSelectedOption = selectObject.firstSelectedOption     Or you may just be interested in what \u0026lt;option\u0026gt; elements the \u0026lt;select\u0026gt; element contains:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Return a list[WebElement] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // Return a IList\u0026lt;IWebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains IList\u0026lt;IWebElement\u0026gt; allAvailableOptions = selectObject.Options;   # Return an Array[Element] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains val allAvailableOptions = selectObject.options     If you want to deselect any elements, you now have four options:\nJava Python C# Ruby JavaScript Kotlin // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by_index(1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all()   // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.DeselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.DeselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.DeselectByText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.DeselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by(:index, 1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1) // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll()     Finally, some \u0026lt;select\u0026gt; elements allow you to select more than one option. You can find out if your \u0026lt;select\u0026gt; element is one of these by using:\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   bool doesThisAllowMultipleSelections = selectObject.IsMultiple;   does_this_allow_multiple_selections = select_object.multiple?   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val doesThisAllowMultipleSelections = selectObject.isMultiple     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/selenium_installation/installing_standalone_server/",
	"title": "독립형 서버 설치",
	"tags": [],
	"description": "",
	"content": "Grid를 사용하려면 selenium-server-standalone JAR 파일을 다운로드하십시오. 모든 구성요소는 selenium-server를 통해 이용할 수 있습니다. 독립형 JAR에는 원격 Selenium 서버와 클라이언트측 바인딩을 포함한 모든 것이 들어 있습니다. 즉, 프로젝트에서 selenium 서버 독립형 jar을 사용할 경우 selenium-java 또는 브라우저별 jar을 추가하지 않아도 됩니다.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/introduction/types_of_testing/",
	"title": "테스트의 종류",
	"tags": [],
	"description": "",
	"content": "적합 테스트 이러한 유형의 테스트는 기능이나 시스템이\n고객의 기대와 요구사항을 충족하는지 판단하기 위해 수행됩니다.\n이러한 유형의 테스트는 일반적으로 고객의 협조나 피드백을 포함하며,\n이는 다음 질문에 대한 답을 제공하는 검증활동입니다.\n 우리가 올바른 제품을 만들고 있나요?.\n 웹 애플리케이션의 경우, 이 테스트의 자동화는 사용자의 예상 행동을\n시뮬레이션하여 Selenium과 간접적으로 연계할 수 있습니다.\n이 시뮬레이션은 기록/재생 또는 이 문서에 설명된 지원하는 다른 프로그래밍 언어를 통해 수행될 수 있습니다.\n참고: 적합 테스트는 **기능 테스트**의 하위 유형이며, 일부 사람들이 이를 언급하기도 합니다.\n기능 테스트 이러한 유형의 테스트는 기능이나 시스템이\n문제 없이 제기능을 하는지 판단하기 위해 수행됩니다.\n모든 시나리오가 적용되고 시스템이 해야 할 일을 하는지를\n확인하기 위해 다른 레벨에서 시스템을 점검합니다. 이는 다음과 같은 질문에 대한 답을 제공하는 검증 활동입니다.\n 우리가 제품을 올바르게 만들고 있나요?.\n 여기에는 일반적으로 오류(404, exceptions 등\u0026hellip;) 없이, 사용하능한 방법으로,\n접근 가능하고 규격에 부합하는 테스트(위의 적합 테스트 참고)가 포함됩니다.\n웹 애플리케이션의 경우, 이 테스트의 자동하는 예상 리턴값을\n시뮬레이션 하여 Selenium과 직접 수행될 수 있습니다.\n이 시뮬레이션은 기록/재생 또는 이 문서에 설명된 지원하는 다른 프로그래밍 언어를 통해 수행될 수 있습니다.\n성능 테스트 이름에서 알 수 있듯이, 성능 테스트가 수행됩니다. 응용 프로그램이 얼마나 제기능을 잘 수행하는지 측정합니다.\n성능 테스트를 위한 두 가지 주요 하위 유형이 있습니다:\n로드 테스트 로드 테스트는 애플리케이션이 서로 다르게 정의된 부하(보통 한 번에 연결된 특정 사용자 수) 에서 얼마나 잘 작동하는지 검증하기 위해 수행됩니다.\n스트레스 테스트 스트레스 테스트는 애플리케이션이 스트레스(또는 최대 부하 이상)\n에서 얼마나 잘 작동하는지 확인하기 위해 수행됩니다.\n이 작업은 일반적으로 메트릭스를 검색하는 다른 도구에 의해 수행됩니다.\n예를들어, JMeter 가 그러한 도구 중 하나가 될 수 있습니다..\n웹 애플리케이션의 경우, 측정해야 할 세부 정보에는 처리량, 지연 시간, 데이터 손설, 개별 구성 요소 로딩 시간 등이 있습니다.\n참고 1: 모든 브라우저의 개발자 도구 섹션에 성능 탭이 있습니다. (F12를 눌러 접근합니다.)\n참고 2: 기능/비기능 시스템별로 일반적으로 측정되므로, 이는 비기능성 시험의 하위 유형입니다.\n회귀 테스트 이 테스트는 일반적으로 변경, 수정 또는 기능 추가 후에 수행됩니다.\n변경으로 인해 기존 기능이 손상되지 않았는지 확인하기 위해 이미 실행된 일부 테스트를 다시 실행합니다.\n재실행 테스트 집합은 전체 또는 부분적일 수 있으며,\n애플리케이션 및 개발 팀에 따라 몇 가지 다른 유형을 포함할 수 있습니다.\n테스트 주도 개발 (TDD;Test-driven Development) TDD는 테스트 유형 자체가 아니라, 테스트가 기능의 디자인을 주도하는 반복적인 개발 방법론입니다.\n각 사이클은 기능이 최종적으로 통과해야 하는 장치 테스트 집합을 생성하는 것으로 시작합니다.\n(첫 번째 실행 시 실패해야 합니다.)\n그 후, 테스트를 통과하기 위한 개발이 이루어집니다.\n테스트는 다시 실행되어 다른 사이클을 시작하고, 이 프로세스는 모든 테스트가 통과될 때까지 계속됩니다.\n이는 결함이 조기에 발견될수록 비용이 덜 든다는 사실에 근거하여 애플리케이션의 개발을 가속화하기 위한 것입니다.\n행위 주도 개발 (BDD;Behavior-driven development) BDD는 위의 TDD에 기초한 반복적인 개발 방법론으로서,\n애플리케이션 개발에 모든 당사자를 참여시키는 것을 목표로 합니다.\n각 사이클은 실패해야 하는 몇 가지 사양을 작성하여 시작합니다.\n그런 다음 실패한 단위 테스트(이 또한 실패해야 합니다.)를 작성하고 개발을 수행하십시오.\n이 사이클은 모든 유형의 시험이 통과할 때까지 반복됩니다.\n이를 위해 명세언어(Specification language)가 사용됩니다.\n모든 당사자가 이해할 수 있어야하며 단순하고 표준이며 명시적이어야 합니다.\n대부분의 도구는 명세언어로 Gherkin 을 사용합니다.\n사양을 작성하고 코드 기능을 일치시키기 위해 Cucumber 나 SpecFlow 와 같은 도구를 사용할 수 있습니다.\nBDD 사양을 실행 가능한 코드로 직접 변환하여 이 프로세스를 더욱 빠르게 수행할 수 있도록 Selenium에 JBehave, Capybara 나 Robot Framework 와 같은 도구 세트가 구축되어 있습니다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "AUT*에 대한 작업 수행",
	"tags": [],
	"description": "",
	"content": "sendKeys 메소드를 이용하여 element의 텍스트를 설정할 수 있습니다:\nJava Python C# Ruby JavaScript Kotlin String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(By.NAME, \u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);   val name = \u0026#34;Charles\u0026#34; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name)     몇몇 웹 어플리케이션들은 자바스크립트 라이브러리를 이용하여 드래그-앤-드롭 기능을 구현합니다. 아래는 하나의 element를 또다른 element로 드래그하는 가장 기본적인 예시입니다:\nJava Python C# Ruby JavaScript Kotlin WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element(By.ID, \u0026#34;source\u0026#34;) target = driver.find_element(By.ID, \u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();   val source = driver.findElement(By.id(\u0026#34;source\u0026#34;)) val target = driver.findElement(By.id(\u0026#34;target\u0026#34;)) Actions(driver).dragAndDrop(source, target).build().perform()     Element 클릭하기 click 메소드를 이용하여 element를 클릭할 수 있습니다:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element(By.CSS_SELECTOR, \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click()     *AUT: Application under test\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/worst_practices/gmail_email_and_facebook_logins/",
	"title": "Gmail, 이메일과 Facebook logins",
	"tags": [],
	"description": "",
	"content": "여러 가지 이유로, WebDriver를 사용하여 Gmail이나 Facebook과 같은 사이트에 로그인하는 것은 권장되지 않는다. 이러한 사이트의 사용 조건에 반대하는 것 외에도(계정 종료의 위험이 있는 경우) 느리고 신뢰할 수 없다.\n이상적인 방법은 이메일 제공자들이 제공하는 API를 사용하는 것이다. 또는 Facebook의 경우 시험 계정, 친구 등을 만들기 위한 API를 공개하는 개발자 도구 서비스를 이용하는 것이다. 비록 API를 사용하는 것이 조금 더 힘든 일처럼 보일지 모르지만, 당신은 속도, 신뢰성, 그리고 안정성에 대한 보상을 받을 것이다. 반면에 웹 페이지 및 HTMLlocators가 자주 당신의 시험 프레임워크 업데이트하는 것을 요구하기를 변화시키고 있는 API도 변경될 것 같지는 않다.\n테스트의 어느 지점에서 WebDriver를 사용하여 제3자 사이트에 로그인하면 테스트가 더 길어지기 때문에 테스트 실패의 위험이 증가한다. 일반적인 경험의 법칙은 긴 테스트가 더 취약하고 신뢰할 수 없다는 것이다.\nWebDriver 구현[W3C conformant]//w3c.github.io/webdriver/webdriver-spec.html) 또한 서비스 거부 공격이 완화될 수 있도록 WebDriver 속성으로 navigator 물체에 주석을 달아야 한다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/legacy_docs/selenium_ide/",
	"title": "Legacy Selenium IDE",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Introduction The Selenium-IDE (Integrated Development Environment) is the tool you use to develop your Selenium test cases. It’s an easy-to-use Firefox plug-in and is generally the most efficient way to develop test cases. It also contains a context menu that allows you to first select a UI element from the browser’s currently displayed page and then select from a list of Selenium commands with parameters pre-defined according to the context of the selected UI element. This is not only a time-saver, but also an excellent way of learning Selenium script syntax.\nThis chapter is all about the Selenium IDE and how to use it effectively.\nInstalling the IDE Using Firefox, first, download the IDE from the SeleniumHQ downloads page\nFirefox will protect you from installing addons from unfamiliar locations, so you will need to click ‘Allow’ to proceed with the installation, as shown in the following screenshot.\nWhen downloading from Firefox, you’ll be presented with the following window.\nSelect Install Now. The Firefox Add-ons window pops up, first showing a progress bar, and when the download is complete, displays the following.\nRestart Firefox. After Firefox reboots you will find the Selenium-IDE listed under the Firefox Tools menu.\nOpening the IDE To run the Selenium-IDE, simply select it from the Firefox Tools menu. It opens as follows with an empty script-editing window and a menu for loading, or creating new test cases.\nIDE Features Menu Bar The File menu has options for Test Case and Test Suite (suite of Test Cases). Using these you can add a new Test Case, open a Test Case, save a Test Case, export Test Case in a language of your choice. You can also open the recent Test Case. All these options are also available for Test Suite.\nThe Edit menu allows copy, paste, delete, undo, and select all operations for editing the commands in your test case. The Options menu allows the changing of settings. You can set the timeout value for certain commands, add user-defined user extensions to the base set of Selenium commands, and specify the format (language) used when saving your test cases. The Help menu is the standard Firefox Help menu; only one item on this menu–UI-Element Documentation–pertains to Selenium-IDE.\nToolbar The toolbar contains buttons for controlling the execution of your test cases, including a step feature for debugging your test cases. The right-most button, the one with the red-dot, is the record button.\nSpeed Control: controls how fast your test case runs.\nRun All: Runs the entire test suite when a test suite with multiple test cases is loaded.\nRun: Runs the currently selected test. When only a single test is loaded this button and the Run All button have the same effect.\nPause/Resume: Allows stopping and re-starting of a running test case.\nStep: Allows you to “step” through a test case by running it one command at a time. Use for debugging test cases.\nTestRunner Mode: Allows you to run the test case in a browser loaded with the Selenium-Core TestRunner. The TestRunner is not commonly used now and is likely to be deprecated. This button is for evaluating test cases for backwards compatibility with the TestRunner. Most users will probably not need this button.\nApply Rollup Rules: This advanced feature allows repetitive sequences of Selenium commands to be grouped into a single action. Detailed documentation on rollup rules can be found in the UI-Element Documentation on the Help menu.\nTest Case Pane Your script is displayed in the test case pane. It has two tabs, one for displaying the command and their parameters in a readable “table” format.\nThe other tab - Source displays the test case in the native format in which the file will be stored. By default, this is HTML although it can be changed to a programming language such as Java or C#, or a scripting language like Python. See the Options menu for details. The Source view also allows one to edit the test case in its raw form, including copy, cut and paste operations.\nThe Command, Target, and Value entry fields display the currently selected command along with its parameters. These are entry fields where you can modify the currently selected command. The first parameter specified for a command in the Reference tab of the bottom pane always goes in the Target field. If a second parameter is specified by the Reference tab, it always goes in the Value field.\nIf you start typing in the Command field, a drop-down list will be populated based on the first characters you type; you can then select your desired command from the drop-down.\nLog/Reference/UI-Element/Rollup Pane The bottom pane is used for four different functions–Log, Reference, UI-Element, and Rollup–depending on which tab is selected.\nLog When you run your test case, error messages and information messages showing the progress are displayed in this pane automatically, even if you do not first select the Log tab. These messages are often useful for test case debugging. Notice the Clear button for clearing the Log. Also notice the Info button is a drop-down allowing selection of different levels of information to log.\nReference The Reference tab is the default selection whenever you are entering or modifying Selenese commands and parameters in Table mode. In Table mode, the Reference pane will display documentation on the current command. When entering or modifying commands, whether from Table or Source mode, it is critically important to ensure that the parameters specified in the Target and Value fields match those specified in the parameter list in the Reference pane. The number of parameters provided must match the number specified, the order of parameters provided must match the order specified, and the type of parameters provided must match the type specified. If there is a mismatch in any of these three areas, the command will not run correctly.\nWhile the Reference tab is invaluable as a quick reference, it is still often necessary to consult the Selenium Reference document.\nUI-Element and Rollup Detailed information on these two panes (which cover advanced features) can be found in the UI-Element Documentation on the Help menu of Selenium-IDE.\nBuilding Test Cases There are three primary methods for developing test cases. Frequently, a test developer will require all three techniques.\nRecording Many first-time users begin by recording a test case from their interactions with a website. When Selenium-IDE is first opened, the record button is ON by default. If you do not want Selenium-IDE to begin recording automatically you can turn this off by going under Options \u0026gt; Options… and deselecting “Start recording immediately on open.”\nDuring recording, Selenium-IDE will automatically insert commands into your test case based on your actions. Typically, this will include:\n clicking a link - click or clickAndWait commands entering values - type command selecting options from a drop-down listbox - select command clicking checkboxes or radio buttons - click command  Here are some “gotchas” to be aware of:\n The type command may require clicking on some other area of the web page for it to record. Following a link usually records a click command. You will often need to change this to clickAndWait to ensure your test case pauses until the new page is completely loaded. Otherwise, your test case will continue running commands before the page has loaded all its UI elements. This will cause unexpected test case failures.  Adding Verifications and Asserts With the Context Menu Your test cases will also need to check the properties of a web-page. This requires assert and verify commands. We won’t describe the specifics of these commands here; that is in the chapter on Selenium Commands – “Selenese”. Here we’ll simply describe how to add them to your test case.\nWith Selenium-IDE recording, go to the browser displaying your test application and right click anywhere on the page. You will see a context menu showing verify and/or assert commands.\nThe first time you use Selenium, there may only be one Selenium command listed. As you use the IDE however, you will find additional commands will quickly be added to this menu. Selenium-IDE will attempt to predict what command, along with the parameters, you will need for a selected UI element on the current web-page.\nLet’s see how this works. Open a web-page of your choosing and select a block of text on the page. A paragraph or a heading will work fine. Now, right-click the selected text. The context menu should give you a verifyTextPresent command and the suggested parameter should be the text itself.\nAlso, notice the Show All Available Commands menu option. This shows many, many more commands, again, along with suggested parameters, for testing your currently selected UI element.\nTry a few more UI elements. Try right-clicking an image, or a user control like a button or a checkbox. You may need to use Show All Available Commands to see options other than verifyTextPresent. Once you select these other options, the more commonly used ones will show up on the primary context menu. For example, selecting verifyElementPresent for an image should later cause that command to be available on the primary context menu the next time you select an image and right-click.\nAgain, these commands will be explained in detail in the chapter on Selenium commands. For now though, feel free to use the IDE to record and select commands into a test case and then run it. You can learn a lot about the Selenium commands simply by experimenting with the IDE.\nEditing Insert Command Table View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click on the line where you want to insert a new command. Right-click and select Insert Command; the IDE will add a blank line just ahead of the line you selected. Now use the command editing text fields to enter your new command and its parameters.\nSource View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click between the commands where you want to insert a new command, and enter the HTML tags needed to create a 3-column row containing the Command, first parameter (if one is required by the Command), and second parameter (again, if one is required to locate an element) and third parameter(again, if one is required to have a value). Example:\n\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Command\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;target (locator)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Insert Comment Comments may be added to make your test case more readable. These comments are ignored when the test case is run.\nComments may also be used to add vertical white space (one or more blank lines) in your tests; just create empty comments. An empty command will cause an error during execution; an empty comment won’t.\nTable View Select the line in your test case where you want to insert the comment. Right-click and select Insert Comment. Now use the Command field to enter the comment. Your comment will appear in purple text.\nSource View Select the point in your test case where you want to insert the comment. Add an HTML-style comment, i.e., \u0026lt;!-- your comment here --\u0026gt;.\nEdit a Command or Comment Table View Simply select the line to be changed and edit it using the Command, Target, and Value fields.\nSource View Since Source view provides the equivalent of a WYSIWYG (What You See is What You Get) editor, simply modify which line you wish–command, parameter, or comment.\nOpening and Saving a Test Case Like most programs, there are Save and Open commands under the File menu. However, Selenium distinguishes between test cases and test suites. To save your Selenium-IDE tests for later use you can either save the individual test cases, or save the test suite. If the test cases of your test suite have not been saved, you’ll be prompted to save them before saving the test suite.\nWhen you open an existing test case or suite, Selenium-IDE displays its Selenium commands in the Test Case Pane.\nRunning Test Cases The IDE allows many options for running your test case. You can run a test case all at once, stop and start it, run it one line at a time, run a single command you are currently developing, and you can do a batch run of an entire test suite. Execution of test cases is very flexible in the IDE.\nRun a Test Case\nClick the Run button to run the currently displayed test case.\nRun a Test Suite\nClick the Run All button to run all the test cases in the currently loaded test suite.\nStop and Start\nThe Pause button can be used to stop the test case while it is running. The icon of this button then changes to indicate the Resume button. To continue click Resume.\nStop in the Middle\nYou can set a breakpoint in the test case to cause it to stop on a particular command. This is useful for debugging your test case. To set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint.\nStart from the Middle\nYou can tell the IDE to begin running from a specific command in the middle of the test case. This also is used for debugging. To set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point.\nRun Any Single Command\nDouble-click any single command to run it by itself. This is useful when writing a single command. It lets you immediately test a command you are constructing, when you are not sure if it is correct. You can double-click it to see if it runs correctly. This is also available from the context menu.\nUsing Base URL to Run Test Cases in Different Domains The Base URL field at the top of the Selenium-IDE window is very useful for allowing test cases to be run across different domains. Suppose that a site named http://news.portal.com had an in-house beta site named http://beta.news.portal.com. Any test cases for these sites that begin with an open statement should specify a relative URL as the argument to open rather than an absolute URL (one starting with a protocol such as http: or https:). Selenium-IDE will then create an absolute URL by appending the open command’s argument onto the end of the value of Base URL. For example, the test case below would be run against http://news.portal.com/about.html:\nThis same test case with a modified Base URL setting would be run against http://beta.news.portal.com/about.html:\nSelenium Commands – “Selenese” Selenium commands, often called selenese, are the set of commands that run your tests. A sequence of these commands is a test script. Here we explain those commands in detail, and we present the many choices you have in testing your web application when using Selenium.\nSelenium provides a rich set of commands for fully testing your web-app in virtually any way you can imagine. The command set is often called selenese. These commands essentially create a testing language.\nIn selenese, one can test the existence of UI elements based on their HTML tags, test for specific content, test for broken links, input fields, selection list options, submitting forms, and table data among other things. In addition Selenium commands support testing of window size, mouse position, alerts, Ajax functionality, pop up windows, event handling, and many other web-application features. The Command Reference lists all the available commands.\nA command tells Selenium what to do. Selenium commands come in three “flavors”: Actions, Accessors, and Assertions.\n  Actions are commands that generally manipulate the state of the application. They do things like “click this link” and “select that option”. If an Action fails, or has an error, the execution of the current test is stopped.\nMany Actions can be called with the “AndWait” suffix, e.g. “clickAndWait”. This suffix tells Selenium that the action will cause the browser to make a call to the server, and that Selenium should wait for a new page to load.\n  Accessors examine the state of the application and store the results in variables, e.g. “storeTitle”. They are also used to automatically generate Assertions.\n  Assertions are like Accessors, but they verify that the state of the application conforms to what is expected. Examples include “make sure the page title is X” and “verify that this checkbox is checked”.\n  All Selenium Assertions can be used in 3 modes: “assert”, “verify”, and ” waitFor”. For example, you can “assertText”, “verifyText” and “waitForText”. When an “assert” fails, the test is aborted. When a “verify” fails, the test will continue execution, logging the failure. This allows a single “assert” to ensure that the application is on the correct page, followed by a bunch of “verify” assertions to test form field values, labels, etc.\n“waitFor” commands wait for some condition to become true (which can be useful for testing Ajax applications). They will succeed immediately if the condition is already true. However, they will fail and halt the test if the condition does not become true within the current timeout setting (see the setTimeout action below).\nScript Syntax Selenium commands are simple, they consist of the command and two parameters. For example:\n          verifyText //div//a[2] Login    The parameters are not always required; it depends on the command. In some cases both are required, in others one parameter is required, and in still others the command may take no parameters at all. Here are a couple more examples:\n          goBackAndWait     verifyTextPresent  Welcome to My Home Page   type id=phone (555) 666-7066   type id=address1 ${myVariableAddress}    The command reference describes the parameter requirements for each command.\nParameters vary, however they are typically:\n a locator for identifying a UI element within a page. a text pattern for verifying or asserting expected page content a text pattern or a Selenium variable for entering text in an input field or for selecting an option from an option list.  Locators, text patterns, Selenium variables, and the commands themselves are described in considerable detail in the section on Selenium Commands.\nSelenium scripts that will be run from Selenium-IDE will be stored in an HTML text file format. This consists of an HTML table with three columns. The first column identifies the Selenium command, the second is a target, and the final column contains a value. The second and third columns may not require values depending on the chosen Selenium command, but they should be present. Each table row represents a new Selenium command. Here is an example of a test that opens a page, asserts the page title and then verifies some content on the page:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;/download/\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;assertTitle\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;verifyText\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;//h2\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Rendered as a table in a browser this would look like the following:\n          open /download/    assertTitle  Downloads   verifyText //h2 Downloads    The Selenese HTML syntax can be used to write and run tests without requiring knowledge of a programming language. With a basic knowledge of selenese and Selenium-IDE you can quickly produce and run testcases.\nTest Suites A test suite is a collection of tests. Often one will run all the tests in a test suite as one continuous batch-job.\nWhen using Selenium-IDE, test suites also can be defined using a simple HTML file. The syntax again is simple. An HTML table defines a list of tests where each row defines the filesystem path to each test. An example tells it all.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Suite Function Tests - Priority 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Suite Of Tests\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./Login.html\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SearchValues.html\u0026#34;\u0026gt;Test Searching for Values\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SaveValues.html\u0026#34;\u0026gt;Test Save\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; A file similar to this would allow running the tests all at once, one after another, from the Selenium-IDE.\nTest suites can also be maintained when using Selenium-RC. This is done via programming and can be done a number of ways. Commonly Junit is used to maintain a test suite if one is using Selenium-RC with Java. Additionally, if C# is the chosen language, Nunit could be employed. If using an interpreted language like Python with Selenium-RC then some simple programming would be involved in setting up a test suite. Since the whole reason for using Selenium-RC is to make use of programming logic for your testing this usually isn’t a problem.\nCommonly Used Selenium Commands To conclude our introduction of Selenium, we’ll show you a few typical Selenium commands. These are probably the most commonly used commands for building tests.\nopen\nopens a page using a URL.\nclick/clickAndWait\nperforms a click operation, and optionally waits for a new page to load.\nverifyTitle/assertTitle\nverifies an expected page title.\nverifyTextPresent\nverifies expected text is somewhere on the page.\nverifyElementPresent\nverifies an expected UI element, as defined by its HTML tag, is present on the page.\nverifyText\nverifies expected text and its corresponding HTML tag are present on the page.\nverifyTable\nverifies a table’s expected contents.\nwaitForPageToLoad\npauses execution until an expected new page loads. Called automatically when clickAndWait is used.\nwaitForElementPresent\npauses execution until an expected UI element, as defined by its HTML tag, is present on the page.\nVerifying Page Elements Verifying UI elements on a web page is probably the most common feature of your automated tests. Selenese allows multiple ways of checking for UI elements. It is important that you understand these different methods because these methods define what you are actually testing.\nFor example, will you test that…\n an element is present somewhere on the page? specific text is somewhere on the page? specific text is at a specific location on the page?  For example, if you are testing a text heading, the text and its position at the top of the page are probably relevant for your test. If, however, you are testing for the existence of an image on the home page, and the web designers frequently change the specific image file along with its position on the page, then you only want to test that an image (as opposed to the specific image file) exists somewhere on the page.\nAssertion or Verification? Choosing between “assert” and “verify” comes down to convenience and management of failures. There’s very little point checking that the first paragraph on the page is the correct one if your test has already failed when checking that the browser is displaying the expected page. If you’re not on the correct page, you’ll probably want to abort your test case so that you can investigate the cause and fix the issue(s) promptly. On the other hand, you may want to check many attributes of a page without aborting the test case on the first failure as this will allow you to review all failures on the page and take the appropriate action. Effectively an “assert” will fail the test and abort the current test case, whereas a “verify” will fail the test and continue to run the test case.\nThe best use of this feature is to logically group your test commands, and start each group with an “assert” followed by one or more “verify” test commands. An example follows:\n   Command Target Value     open /download/    assertTitle  Downloads   verifyText //h2 Downloads   assertTable 1.2.1 Selenium IDE   verifyTable 1.2.2 June 3, 2008   verifyTable 1.2.3 1.0 beta 2    The above example first opens a page and then “asserts” that the correct page is loaded by comparing the title with the expected value. Only if this passes will the following command run and “verify” that the text is present in the expected location. The test case then “asserts” the first column in the second row of the first table contains the expected value, and only if this passed will the remaining cells in that row be “verified”.\nverifyTextPresent The command verifyTextPresent is used to verify specific text exists somewhere on the page. It takes a single argument–the text pattern to be verified. For example:\n   Command Target Value     verifyTextPresent Marketing Analysis     This would cause Selenium to search for, and verify, that the text string “Marketing Analysis” appears somewhere on the page currently being tested. Use verifyTextPresent when you are interested in only the text itself being present on the page. Do not use this when you also need to test where the text occurs on the page.\nverifyElementPresent Use this command when you must test for the presence of a specific UI element, rather than its content. This verification does not check the text, only the HTML tag. One common use is to check for the presence of an image.\n   Command Target Value     verifyElementPresent //div/p/img     This command verifies that an image, specified by the existence of an HTML tag, is present on the page, and that it follows a tag and a tag. The first (and only) parameter is a locator for telling the Selenese command how to find the element. Locators are explained in the next section.\nverifyElementPresent can be used to check the existence of any HTML tag within the page. You can check the existence of links, paragraphs, divisions , etc. Here are a few more examples.\n   Command Target Value     verifyElementPresent //div/p    verifyElementPresent //div/a    verifyElementPresent id=Login    verifyElementPresent link=Go to Marketing Research    verifyElementPresent //a[2]    verifyElementPresent //head/title     These examples illustrate the variety of ways a UI element may be tested. Again, locators are explained in the next section.\nverifyText Use verifyText when both the text and its UI element must be tested. verifyText must use a locator. If you choose an XPath or DOM locator, you can verify that specific text appears at a specific location on the page relative to other UI components on the page.\n   Command Target Value     verifyText //table/tr/td/div/p This is my text and it occurs right after the div inside the table.    Locating Elements For many Selenium commands, a target is required. This target identifies an element in the content of the web application, and consists of the location strategy followed by the location in the format locatorType=location. The locator type can be omitted in many cases. The various locator types are explained below with examples for each.\nLocating by Identifier This is probably the most common method of locating elements and is the catch-all default when no recognized locator type is used. With this strategy, the first element with the id attribute value matching the location will be used. If no element has a matching id attribute, then the first element with a name attribute matching the location will be used.\nFor instance, your page source could have id and name attributes as follows:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; The following locator strategies would return the elements from the HTML snippet above indicated by line number:\n identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)  Since the identifier type of locator is the default, the identifier= in the first three examples above is not necessary.\nLocating by Id This type of locator is more limited than the identifier locator type, but also more explicit. Use this when you know an element\u0026rsquo;s id attribute.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  id=loginForm (3)  Locating by Name The name locator type will locate the first element with a matching name attribute. If multiple elements have the same value for a name attribute, then you can use filters to further refine your location strategy. The default filter type is value (matching the value attribute).\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7)  Note: Unlike some types of XPath and DOM locators, the three types of locators above allow Selenium to test a UI element independent of its location on the page. So if the page structure and organization is altered, the test will still pass. You may or may not want to also test whether the page structure changes. In the case where web designers frequently alter the page, but its functionality must be regression tested, testing via id and name attributes, or really via any HTML property, becomes very important.\nLocating by XPath XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.\nOne of the main reasons for using XPath is when you don\u0026rsquo;t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.\nAbsolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.\nSince only xpath locators start with \u0026ldquo;//\u0026quot;, it is not necessary to include the xpath= label when specifying an XPath locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  xpath=/html/body/form[1] (3) - Absolute path (would break if the HTML was changed only slightly) //form[1] (3) - First form element in the HTML xpath=//form[@id='loginForm'] (3) - The form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; xpath=//form[input/@name='username'] (3) - First form element with an input child element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //input[@name='username'] (4) - First input element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //form[@id='loginForm']/input[1] (4) - First input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; //input[@name='continue'][@type='button'] (7) - Input with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;continue\u0026rsquo; and attribute named \u0026lsquo;type\u0026rsquo; and the value \u0026lsquo;button\u0026rsquo; //form[@id='loginForm']/input[4] (7) - Fourth input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and value \u0026lsquo;loginForm\u0026rsquo;  These examples cover some basics, but in order to learn more, the following references are recommended:\n W3Schools XPath Tutorial W3C XPath Recommendation  There are also a couple of very useful Firefox Add-ons that can assist in discovering the XPath of an element:\n XPath Checker XPath and can be used to test XPath results. [Firebug](https://addons.mozilla.org/en-US/firefox/addon/1843 - XPath suggestions are just one of the many powerful features of this very useful add-on.  Locating Hyperlinks by Link Text This is a simple method of locating a hyperlink in your web page by using the text of the link. If two links with the same text are present, then the first match will be used.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Are you sure you want to do this?\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;continue.html\u0026#34;\u0026gt;Continue\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;cancel.html\u0026#34;\u0026gt;Cancel\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  link=Continue (4) link=Cancel (5)  Locating by DOM The Document Object Model represents an HTML document and can be accessed using JavaScript. This location strategy takes JavaScript that evaluates to an element on the page, which can be simply the element\u0026rsquo;s location using the hierarchical dotted notation.\nSince only dom locators start with \u0026ldquo;document\u0026rdquo;, it is not necessary to include the dom= label when specifying a DOM locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  dom=document.getElementById('loginForm') (3) dom=document.forms['loginForm'] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements['username'] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7)  You can use Selenium itself as well as other sites and extensions to explore the DOM of your web application. A good reference exists on W3Schools.\nLocating by CSS CSS (Cascading Style Sheets) is a language for describing the rendering of HTML and XML documents. CSS uses Selectors for binding style properties to elements in the document. These Selectors can be used by Selenium as another locating strategy.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;required\u0026#34; name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;required passfield\u0026#34; name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  css=form#loginForm (3) css=input[name=\u0026quot;username\u0026quot;] (4) css=input.required[type=\u0026quot;text\u0026quot;] (4) css=input.passfield (5) css=#loginForm input[type=\u0026quot;button\u0026quot;] (7) css=#loginForm input:nth-child(2) (5)  For more information about CSS Selectors, the best place to go is the W3C publication. You\u0026rsquo;ll find additional references there.\nImplicit Locators You can choose to omit the locator type in the following situations:\n  Locators without an explicitly defined locator strategy will default to using the identifier locator strategy. See Locating by Identifier_.\n  Locators starting with \u0026ldquo;//\u0026rdquo; will use the XPath locator strategy. See Locating by XPath_.\n  Locators starting with \u0026ldquo;document\u0026rdquo; will use the DOM locator strategy. See Locating by DOM_\n  Matching Text Patterns Like locators, patterns are a type of parameter frequently required by Selenese commands. Examples of commands which require patterns are verifyTextPresent, verifyTitle, verifyAlert, assertConfirmation, verifyText, and verifyPrompt. And as has been mentioned above, link locators can utilize a pattern. Patterns allow you to describe, via the use of special characters, what text is expected rather than having to specify that text exactly.\nThere are three types of patterns: globbing, regular expressions, and exact.\nGlobbing Patterns Most people are familiar with globbing as it is utilized in filename expansion at a DOS or Unix/Linux command line such as ls *.c. In this case, globbing is used to display all the files ending with a .c extension that exist in the current directory. Globbing is fairly limited.\nOnly two special characters are supported in the Selenium implementation:\n* which translates to \u0026ldquo;match anything,\u0026rdquo; i.e., nothing, a single character, or many characters.\n[ ] (character class) which translates to \u0026ldquo;match any single character found inside the square brackets.\u0026rdquo; A dash (hyphen) can be used as a shorthand to specify a range of characters (which are contiguous in the ASCII character set). A few examples will make the functionality of a character class clear:\n[aeiou] matches any lowercase vowel\n[0-9] matches any digit\n[a-zA-Z0-9] matches any alphanumeric character\nIn most other contexts, globbing includes a third special character, the ?. However, Selenium globbing patterns only support the asterisk and character class.\nTo specify a globbing pattern parameter for a Selenese command, you can prefix the pattern with a glob: label. However, because globbing patterns are the default, you can also omit the label and specify just the pattern itself.\nBelow is an example of two commands that use globbing patterns. The actual link text on the page being tested was \u0026ldquo;Film/Television Department\u0026rdquo;; by using a pattern rather than the exact text, the click command will work even if the link text is changed to \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo; or \u0026ldquo;Film and Television Department\u0026rdquo;. The glob pattern\u0026rsquo;s asterisk will match \u0026ldquo;anything or nothing\u0026rdquo; between the word \u0026ldquo;Film\u0026rdquo; and the word \u0026ldquo;Television\u0026rdquo;.\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle glob:*Film*Television*     The actual title of the page reached by clicking on the link was \u0026ldquo;De Anza Film And Television Department - Menu\u0026rdquo;. By using a pattern rather than the exact text, the verifyTitle will pass as long as the two words \u0026ldquo;Film\u0026rdquo; and \u0026ldquo;Television\u0026rdquo; appear (in that order) anywhere in the page\u0026rsquo;s title. For example, if the page\u0026rsquo;s owner should shorten the title to just \u0026ldquo;Film \u0026amp; Television Department,\u0026rdquo; the test would still pass. Using a pattern for both a link and a simple test that the link worked (such as the verifyTitle above does) can greatly reduce the maintenance for such test cases.\nRegular Expression Patterns Regular expression patterns are the most powerful of the three types of patterns that Selenese supports. Regular expressions are also supported by most high-level programming languages, many text editors, and a host of tools, including the Linux/Unix command-line utilities grep, sed, and awk. In Selenese, regular expression patterns allow a user to perform many tasks that would be very difficult otherwise. For example, suppose your test needed to ensure that a particular table cell contained nothing but a number. regexp: [0-9]+ is a simple pattern that will match a decimal number of any length.\nWhereas Selenese globbing patterns support only the * and [ ] (character class) features, Selenese regular expression patterns offer the same wide array of special characters that exist in JavaScript. Below are a subset of those special characters:\n   PATTERN MATCH     . any single character   [ ] character class: any single character that appears inside the brackets   * quantifier: 0 or more of the preceding character (or group)   + quantifier: 1 or more of the preceding character (or group)   ? quantifier: 0 or 1 of the preceding character (or group)   {1,5} quantifier: 1 through 5 of the preceding character (or group)   | alternation: the character/group on the left or the character/group on the right   ( ) grouping: often used with alternation and/or quantifier    Regular expression patterns in Selenese need to be prefixed with either regexp: or regexpi:. The former is case-sensitive; the latter is case-insensitive.\nA few examples will help clarify how regular expression patterns can be used with Selenese commands. The first one uses what is probably the most commonly used regular expression pattern\u0026ndash;.* (\u0026ldquo;dot star\u0026rdquo;). This two-character sequence can be translated as \u0026ldquo;0 or more occurrences of any character\u0026rdquo; or more simply, \u0026ldquo;anything or nothing.\u0026rdquo; It is the equivalent of the one-character globbing pattern * (a single asterisk).\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle regexp:.*Film.*Television.*     The example above is functionally equivalent to the earlier example that used globbing patterns for this same test. The only differences are the prefix (regexp: instead of glob:) and the \u0026ldquo;anything or nothing\u0026rdquo; pattern (.* instead of just *).\nThe more complex example below tests that the Yahoo! Weather page for Anchorage, Alaska contains info on the sunrise time:\n   Command Target Value     open http://weather.yahoo.com/forecast/USAK0012.html    verifyTextPresent regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m     Let\u0026rsquo;s examine the regular expression above one part at a time:\n         Sunrise: * The string Sunrise: followed by 0 or more spaces   [0-9]{1,2} 1 or 2 digits (for the hour of the day)   : The character : (no special characters involved)   [0-9]{2} 2 digits (for the minutes) followed by a space   [ap]m \u0026ldquo;a\u0026rdquo; or \u0026ldquo;p\u0026rdquo; followed by \u0026ldquo;m\u0026rdquo; (am or pm)    Exact Patterns The exact type of Selenium pattern is of marginal usefulness. It uses no special characters at all. So, if you needed to look for an actual asterisk character (which is special for both globbing and regular expression patterns), the exact pattern would be one way to do that. For example, if you wanted to select an item labeled \u0026ldquo;Real *\u0026rdquo; from a dropdown, the following code might work or it might not. The asterisk in the glob:Real * pattern will match anything or nothing. So, if there was an earlier select option labeled \u0026ldquo;Real Numbers,\u0026rdquo; it would be the option selected rather than the \u0026ldquo;Real *\u0026rdquo; option.\n   Command Target Value     select //select glob:Real *    In order to ensure that the \u0026ldquo;Real *\u0026rdquo; item would be selected, the exact: prefix could be used to create an exact pattern as shown below:\n   Command Target Value     select //select exact:Real *    But the same effect could be achieved via escaping the asterisk in a regular expression pattern:\n   Command Target Value     select //select regexp:Real \\*    It\u0026rsquo;s rather unlikely that most testers will ever need to look for an asterisk or a set of square brackets with characters inside them (the character class for globbing patterns). Thus, globbing patterns and regular expression patterns are sufficient for the vast majority of us.\nThe \u0026ldquo;AndWait\u0026rdquo; Commands The difference between a command and its AndWait alternative is that the regular command (e.g. click) will do the action and continue with the following command as fast as it can, while the AndWait alternative (e.g. clickAndWait) tells Selenium to wait for the page to load after the action has been done.\nThe AndWait alternative is always used when the action causes the browser to navigate to another page or reload the present one.\nBe aware, if you use an AndWait command for an action that does not trigger a navigation/refresh, your test will fail. This happens because Selenium will reach the AndWait\u0026lsquo;s timeout without seeing any navigation or refresh being made, causing Selenium to raise a timeout exception.\nThe waitFor Commands in AJAX applications In AJAX driven web applications, data is retrieved from server without refreshing the page. Using andWait commands will not work as the page is not actually refreshed. Pausing the test execution for a certain period of time is also not a good approach as web element might appear later or earlier than the stipulated period depending on the system\u0026rsquo;s responsiveness, load or other uncontrolled factors of the moment, leading to test failures. The best approach would be to wait for the needed element in a dynamic period and then continue the execution as soon as the element is found.\nThis is done using waitFor commands, as waitForElementPresent or waitForVisible, which wait dynamically, checking for the desired condition every second and continuing to the next command in the script as soon as the condition is met.\nSequence of Evaluation and Flow Control When a script runs, it simply runs in sequence, one command after another.\nSelenese, by itself, does not support condition statements (if-else, etc.) or iteration (for, while, etc.). Many useful tests can be conducted without flow control. However, for a functional test of dynamic content, possibly involving multiple pages, programming logic is often needed.\nWhen flow control is needed, there are three options:\na) Run the script using Selenium-RC and a client library such as Java or PHP to utilize the programming language\u0026rsquo;s flow control features. b) Run a small JavaScript snippet from within the script using the storeEval command. c) Install the goto_sel_ide.js extension.\nMost testers will export the test script into a programming language file that uses the Selenium-RC API (see the Selenium-IDE chapter). However, some organizations prefer to run their scripts from Selenium-IDE whenever possible (for instance, when they have many junior-level people running tests for them, or when programming skills are lacking). If this is your case, consider a JavaScript snippet or the goto_sel_ide.js extension.\nStore Commands and Selenium Variables You can use Selenium variables to store constants at the beginning of a script. Also, when combined with a data-driven test design (discussed in a later section), Selenium variables can be used to store values passed to your test program from the command-line, from another program, or from a file.\nThe plain store command is the most basic of the many store commands and can be used to simply store a constant value in a Selenium variable. It takes two parameters, the text value to be stored and a Selenium variable. Use the standard variable naming conventions of only alphanumeric characters when choosing a name for your variable.\n   Command Target Value     store paul@mysite.org     Later in your script, you\u0026rsquo;ll want to use the stored value of your variable. To access the value of a variable, enclose the variable in curly brackets ({}) and precede it with a dollar sign like this.\n   Command Target Value     verifyText //div/p \\${userName}    A common use of variables is for storing input for an input field.\n   Command Target Value     type id=login \\${userName}    Selenium variables can be used in either the first or second parameter and are interpreted by Selenium prior to any other operations performed by the command. A Selenium variable may also be used within a locator expression.\nAn equivalent store command exists for each verify and assert command. Here are a couple more commonly used store commands.\nstoreElementPresent This corresponds to verifyElementPresent. It simply stores a boolean value\u0026ndash;\u0026ldquo;true\u0026rdquo; or \u0026ldquo;false\u0026rdquo;\u0026ndash;depending on whether the UI element is found.\nstoreText StoreText corresponds to verifyText. It uses a locator to identify specific page text. The text, if found, is stored in the variable. StoreText can be used to extract text from the page being tested.\nstoreEval This command takes a script as its first parameter. Embedding JavaScript within Selenese is covered in the next section. StoreEval allows the test to store the result of running the script in a variable.\nJavaScript and Selenese Parameters JavaScript can be used with two types of Selenese parameters: script and non-script (usually expressions). In most cases, you\u0026rsquo;ll want to access and/or manipulate a test case variable inside the JavaScript snippet used as a Selenese parameter. All variables created in your test case are stored in a JavaScript associative array. An associative array has string indexes rather than sequential numeric indexes. The associative array containing your test case\u0026rsquo;s variables is named storedVars. Whenever you wish to access or manipulate a variable within a JavaScript snippet, you must refer to it as storedVars[\u0026lsquo;yourVariableName\u0026rsquo;].\nJavaScript Usage with Script Parameters Several Selenese commands specify a script parameter including assertEval, verifyEval, storeEval, and waitForEval. These parameters require no special syntax. A Selenium-IDE user would simply place a snippet of JavaScript code into the appropriate field, normally the Target field (because a script parameter is normally the first or only parameter).\nThe example below illustrates how a JavaScript snippet can be used to perform a simple numerical calculation:\n   Command Target Value     store 10 hits   storeXpathCount //blockquote blockquotes   storeEval storedVars[\u0026lsquo;hits\u0026rsquo;].storedVars[\u0026lsquo;blockquotes\u0026rsquo;] paragraphs    This next example illustrates how a JavaScript snippet can include calls to methods, in this case the JavaScript String object\u0026rsquo;s toUpperCase method and toLowerCase method.\n   Command Target Value     store Edith Wharton name   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() uc   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() lc    JavaScript Usage with Non-Script Parameters JavaScript can also be used to help generate values for parameters, even when the parameter is not specified to be of type script.\nHowever, in this case, special syntax is required\u0026ndash;the entire parameter value must be prefixed by javascript{ with a trailing }, which encloses the JavaScript snippet, as in javascript{*yourCodeHere*}. Below is an example in which the type command\u0026rsquo;s second parameter value is generated via JavaScript code using this special syntax:\n   Command Target Value     store league of nations searchString   type q javascript{storedVars[\u0026lsquo;searchString\u0026rsquo;].toUpperCase()}    echo - The Selenese Print Command Selenese has a simple command that allows you to print text to your test\u0026rsquo;s output. This is useful for providing informational progress notes in your test which display on the console as your test is running. These notes also can be used to provide context within your test result reports, which can be useful for finding where a defect exists on a page in the event your test finds a problem. Finally, echo statements can be used to print the contents of Selenium variables.\n   Command Target Value     echo Testing page footer now.    echo Username is \\${userName}     Alerts, Popups, and Multiple Windows Suppose that you are testing a page that looks like this.\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function output(resultText){ document.getElementById(\u0026#39;output\u0026#39;).childNodes[0].nodeValue=resultText; } function show_confirm(){ var confirmation=confirm(\u0026#34;Chose an option.\u0026#34;); if (confirmation==true){ output(\u0026#34;Confirmed.\u0026#34;); } else{ output(\u0026#34;Rejected!\u0026#34;); } } function show_alert(){ alert(\u0026#34;I\u0026#39;m blocking!\u0026#34;); output(\u0026#34;Alert is gone.\u0026#34;); } function show_prompt(){ var response = prompt(\u0026#34;What\u0026#39;s the best web QA tool?\u0026#34;,\u0026#34;Selenium\u0026#34;); output(response); } function open_window(windowName){ window.open(\u0026#34;newWindow.html\u0026#34;,windowName); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnConfirm\u0026#34; onclick=\u0026#34;show_confirm()\u0026#34; value=\u0026#34;Show confirm box\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnAlert\u0026#34; onclick=\u0026#34;show_alert()\u0026#34; value=\u0026#34;Show alert\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPrompt\u0026#34; onclick=\u0026#34;show_prompt()\u0026#34; value=\u0026#34;Show prompt\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;newWindow.html\u0026#34; id=\u0026#34;lnkNewWindow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;New Window Link\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamelessWindow\u0026#34; onclick=\u0026#34;open_window()\u0026#34; value=\u0026#34;Open Nameless Window\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamedWindow\u0026#34; onclick=\u0026#34;open_window(\u0026#39;Mike\u0026#39;)\u0026#34; value=\u0026#34;Open Named Window\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span id=\u0026#34;output\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The user must respond to alert/confirm boxes, as well as moving focus to newly opened popup windows. Fortunately, Selenium can cover JavaScript pop-ups.\nBut before we begin covering alerts/confirms/prompts in individual detail, it is helpful to understand the commonality between them. Alerts, confirmation boxes and prompts all have variations of the following\n   Command Description     assertFoo(pattern) throws error if pattern doesn’t match the text of the pop-up   assertFooPresent throws error if pop-up is not available   assertFooNotPresent throws error if any pop-up is present   storeFoo(variable) stores the text of the pop-up in a variable   storeFooPresent(variable) stores the text of the pop-up in a variable and returns true or false    When running under Selenium, JavaScript pop-ups will not appear. This is because the function calls are actually being overridden at runtime by Selenium\u0026rsquo;s own JavaScript. However, just because you cannot see the pop-up doesn\u0026rsquo;t mean you don\u0026rsquo;t have to deal with it. To handle a pop-up, you must call its assertFoo(pattern) function. If you fail to assert the presence of a pop-up your next command will be blocked and you will get an error similar to the following [error] Error: There was an unexpected Confirmation! [Chose an option.]\nAlerts Let\u0026rsquo;s start with alerts because they are the simplest pop-up to handle. To begin, open the HTML sample above in a browser and click on the \u0026ldquo;Show alert\u0026rdquo; button. You\u0026rsquo;ll notice that after you close the alert the text \u0026ldquo;Alert is gone.\u0026rdquo; is displayed on the page. Now run through the same steps with Selenium IDE recording, and verify the text is added after you close the alert. Your test will look something like this:\n   Command Target Value     open /    click btnAlert    assertAlert I’m blocking!    verifyTextPresent Alert is gone.     You may be thinking \u0026ldquo;That\u0026rsquo;s odd, I never tried to assert that alert.\u0026rdquo; But this is Selenium-IDE handling and closing the alert for you. If you remove that step and replay the test you will get the following error [error] Error: There was an unexpected Alert! [I'm blocking!]. You must include an assertion of the alert to acknowledge its presence.\nIf you just want to assert that an alert is present but either don\u0026rsquo;t know or don\u0026rsquo;t care what text it contains, you can use assertAlertPresent. This will return true or false, with false halting the test.\nConfirmations Confirmations behave in much the same way as alerts, with assertConfirmation and assertConfirmationPresent offering the same characteristics as their alert counterparts. However, by default Selenium will select OK when a confirmation pops up. Try recording clicking on the \u0026ldquo;Show confirm box\u0026rdquo; button in the sample page, but click on the \u0026ldquo;Cancel\u0026rdquo; button in the popup, then assert the output text. Your test may look something like this:\n   Command Target Value     open /    click btnConfirm    chooseCancelOnNextConfirmation     assertConfirmation Choose an option.    verifyTextPresent Rejected     The chooseCancelOnNextConfirmation function tells Selenium that all following confirmation should return false. It can be reset by calling chooseOkOnNextConfirmation.\nYou may notice that you cannot replay this test, because Selenium complains that there is an unhandled confirmation. This is because the order of events Selenium-IDE records causes the click and chooseCancelOnNextConfirmation to be put in the wrong order (it makes sense if you think about it, Selenium can\u0026rsquo;t know that you\u0026rsquo;re cancelling before you open a confirmation) Simply switch these two commands and your test will run fine.\nPrompts Prompts behave in much the same way as alerts, with assertPrompt and assertPromptPresent offering the same characteristics as their alert counterparts. By default, Selenium will wait for you to input data when the prompt pops up. Try recording clicking on the \u0026ldquo;Show prompt\u0026rdquo; button in the sample page and enter \u0026ldquo;Selenium\u0026rdquo; into the prompt. Your test may look something like this:\n   Command Target Value     open /    answerOnNextPrompt Selenium!    click id=btnPrompt    assertPrompt What’s the best web QA tool?    verifyTextPresent Selenium!     If you choose cancel on the prompt, you may notice that answerOnNextPrompt will simply show a target of blank. Selenium treats cancel and a blank entry on the prompt basically as the same thing.\nDebugging Debugging means finding and fixing errors in your test case. This is a normal part of test case development.\nWe won\u0026rsquo;t teach debugging here as most new users to Selenium will already have some basic experience with debugging. If this is new to you, we recommend you ask one of the developers in your organization.\nBreakpoints and Startpoints The Sel-IDE supports the setting of breakpoints and the ability to start and stop the running of a test case, from any point within the test case. That is, one can run up to a specific command in the middle of the test case and inspect how the test case behaves at that point. To do this, set a breakpoint on the command just before the one to be examined.\nTo set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint. Then click the Run button to run your test case from the beginning up to the breakpoint.\nIt is also sometimes useful to run a test case from somewhere in the middle to the end of the test case or up to a breakpoint that follows the starting point.\nFor example, suppose your test case first logs into the website and then performs a series of tests and you are trying to debug one of those tests.\nHowever, you only need to login once, but you need to keep rerunning your tests as you are developing them. You can login once, then run your test case from a startpoint placed after the login portion of your test case. That will prevent you from having to manually logout each time you rerun your test case.\nTo set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point. Then click the Run button to execute the test case beginning at that startpoint.\nStepping Through a Testcase To execute a test case one command at a time (\u0026ldquo;step through\u0026rdquo; it), follow these steps:\n  Start the test case running with the Run button from the toolbar.\n  Immediately pause the executing test case with the Pause button.\n  Repeatedly select the Step button.\n  Find Button The Find button is used to see which UI element on the currently displayed webpage (in the browser) is used in the currently selected Selenium command.\nThis is useful when building a locator for a command\u0026rsquo;s first parameter (see the section on :ref:locators \u0026lt;locators-section\u0026gt; in the Selenium Commands chapter). It can be used with any command that identifies a UI element on a webpage, i.e. click, clickAndWait, type, and certain assert and verify commands, among others.\nFrom Table view, select any command that has a locator parameter. Click the Find button.\nNow look on the webpage: There should be a bright green rectangle enclosing the element specified by the locator parameter.\nPage Source for Debugging Often, when debugging a test case, you simply must look at the page source (the HTML for the webpage you\u0026rsquo;re trying to test) to determine a problem. Firefox makes this easy. Simply right-click the webpage and select \u0026lsquo;View-\u0026gt;Page Source.\nThe HTML opens in a separate window. Use its Search feature (Edit=\u0026gt;Find) to search for a keyword to find the HTML for the UI element you\u0026rsquo;re trying to test.\nAlternatively, select just that portion of the webpage for which you want to see the source. Then right-click the webpage and select View Selection Source. In this case, the separate HTML window will contain just a small amount of source, with highlighting on the portion representing your selection.\nLocator Assistance Whenever Selenium-IDE records a locator-type argument, it stores additional information which allows the user to view other possible locator-type arguments that could be used instead. This feature can be very useful for learning more about locators, and is often needed to help one build a different type of locator than the type that was recorded.\nThis locator assistance is presented on the Selenium-IDE window as a drop-down list accessible at the right end of the Target field (only when the Target field contains a recorded locator-type argument).\nBelow is a snapshot showing the contents of this drop-down for one command. Note that the first column of the drop-down provides alternative locators, whereas the second column indicates the type of each alternative.\nWriting a Test Suite A test suite is a collection of test cases which is displayed in the leftmost pane in the IDE.\nThe test suite pane can be manually opened or closed via selecting a small dot halfway down the right edge of the pane (which is the left edge of the entire Selenium-IDE window if the pane is closed).\nThe test suite pane will be automatically opened when an existing test suite is opened or when the user selects the New Test Case item from the File menu. In the latter case, the new test case will appear immediately below the previous test case.\nSelenium-IDE also supports loading pre-existing test cases by using the File -\u0026gt; Add Test Case menu option. This allows you to add existing test cases to a new test suite.\nA test suite file is an HTML file containing a one-column table. Each cell of each row in the section contains a link to a test case. The example below is of a test suite containing four test cases:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Sample Selenium Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Test Cases for De Anza A-Z Directory Links\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./a.html\u0026#34;\u0026gt;A Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./b.html\u0026#34;\u0026gt;B Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./c.html\u0026#34;\u0026gt;C Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./d.html\u0026#34;\u0026gt;D Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Note: Test case files should not have to be co-located with the test suite file that invokes them. And on Mac OS and Linux systems, that is indeed the case. However, at the time of this writing, a bug prevents Windows users from being able to place the test cases elsewhere than with the test suite that invokes them.\nUser Extensions User extensions are JavaScript files that allow one to create his or her own customizations and features to add additional functionality. Often this is in the form of customized commands although this extensibility is not limited to additional commands.\nThere are a number of useful extensions_ created by users.\nIMPORTANT: THIS SECTION IS OUT OF DATE\u0026ndash;WE WILL BE REVISING THIS SOON.\n _extensions: http://wiki.openqa.org/display/SEL/Contributed+User-Extensions  .. _goto_sel_ide.js extension:\nPerhaps the most popular of all Selenium-IDE extensions is one which provides flow control in the form of while loops and primitive conditionals. This extension is the goto_sel_ide.js_. For an example of how to use the functionality provided by this extension, look at the page_ created by its author.\nTo install this extension, put the pathname to its location on your computer in the Selenium Core extensions field of Selenium-IDE\u0026rsquo;s Options=\u0026gt;Options=\u0026gt;General tab.\nAfter selecting the OK button, you must close and reopen Selenium-IDE in order for the extensions file to be read. Any change you make to an extension will also require you to close and reopen Selenium-IDE.\nInformation on writing your own extensions can be found near the bottom of the Selenium Reference_ document.\nSometimes it can prove very useful to debug step by step Selenium IDE and your User Extension. The only debugger that appears able to debug XUL/Chrome based extensions is Venkman which is supported in Firefox until version 32 included. The step by step debug has been verified to work with Firefox 32 and Selenium IDE 2.9.0.\nFormat Format, under the Options menu, allows you to select a language for saving and displaying the test case. The default is HTML.\nIf you will be using Selenium-RC to run your test cases, this feature is used to translate your test case into a programming language. Select the language, e.g. Java, PHP, you will be using with Selenium-RC for developing your test programs. Then simply save the test case using File=\u0026gt;Export Test Case As. Your test case will be translated into a series of functions in the language you choose. Essentially, program code supporting your test is generated for you by Selenium-IDE.\nAlso, note that if the generated code does not suit your needs, you can alter it by editing a configuration file which defines the generation process.\nEach supported language has configuration settings which are editable. This is under the Options=\u0026gt;Options=\u0026gt;Formats tab.\nExecuting Selenium-IDE Tests on Different Browsers While Selenium-IDE can only run tests against Firefox, tests developed with Selenium-IDE can be run against other browsers, using a simple command-line interface that invokes the Selenium-RC server. This topic is covered in the :ref:Run Selenese tests \u0026lt;html-suite\u0026gt; section on Selenium-RC chapter. The -htmlSuite command-line option is the particular feature of interest.\nTroubleshooting Below is a list of image/explanation pairs which describe frequent sources of problems with Selenium-IDE:\nTable view is not available with this format.\nThis message can be occasionally displayed in the Table tab when Selenium IDE is launched. The workaround is to close and reopen Selenium IDE. See issue 1008. for more information. If you are able to reproduce this reliably then please provide details so that we can work on a fix.\n error loading test case: no command found\nYou\u0026rsquo;ve used File=\u0026gt;Open to try to open a test suite file. Use File=\u0026gt;Open Test Suite instead.\nAn enhancement request has been raised to improve this error message. See issue 1010.\n This type of error may indicate a timing problem, i.e., the element specified by a locator in your command wasn\u0026rsquo;t fully loaded when the command was executed. Try putting a pause 5000 before the command to determine whether the problem is indeed related to timing. If so, investigate using an appropriate waitFor* or *AndWait command before the failing command.\n Whenever your attempt to use variable substitution fails as is the case for the open command above, it indicates that you haven\u0026rsquo;t actually created the variable whose value you\u0026rsquo;re trying to access. This is sometimes due to putting the variable in the Value field when it should be in the Target field or vice versa. In the example above, the two parameters for the store command have been erroneously placed in the reverse order of what is required. For any Selenese command, the first required parameter must go in the Target field, and the second required parameter (if one exists) must go in the Value field.\n error loading test case: [Exception\u0026hellip; \u0026ldquo;Component returned failure code: 0x80520012 (NS_ERROR_FILE_NOT_FOUND) [nsIFileInputStream.init]\u0026rdquo; nresult: \u0026ldquo;0x80520012 (NS_ERROR_FILE_NOT_FOUND)\u0026rdquo; location: \u0026ldquo;JS frame :: chrome://selenium-ide/content/file-utils.js :: anonymous :: line 48\u0026rdquo; data: no]\nOne of the test cases in your test suite cannot be found. Make sure that the test case is indeed located where the test suite indicates it is located. Also, make sure that your actual test case files have the .html extension both in their filenames, and in the test suite file where they are referenced.\nAn enhancement request has been raised to improve this error message. See issue 1011.\n Your extension file\u0026rsquo;s contents have not been read by Selenium-IDE. Be sure you have specified the proper pathname to the extensions file via Options=\u0026gt;Options=\u0026gt;General in the Selenium Core extensions field. Also, Selenium-IDE must be restarted after any change to either an extensions file or to the contents of the Selenium Core extensions field.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/mock_external_services/",
	"title": "Mock external services",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Eliminating the dependencies on external services will greatly improve the speed and stability of your tests.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/waits/",
	"title": "Waits",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n WebDriver can generally be said to have a blocking API. Because it is an out-of-process library that instructs the browser what to do, and because the web platform has an intrinsically asynchronous nature, WebDriver does not track the active, real-time state of the DOM. This comes with some challenges that we will discuss here.\nFrom experience, most intermittent issues that arise from use of Selenium and WebDriver are connected to race conditions that occur between the browser and the user\u0026rsquo;s instructions. An example could be that the user instructs the browser to navigate to a page, then gets a no such element error when trying to find an element.\nConsider the following document:\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; The WebDriver instructions might look innocent enough:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Get and store Paragraph Text search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     The issue here is that the default page load strategy used in WebDriver listens for the document.readyState to change to \u0026quot;complete\u0026quot; before returning from the call to navigate. Because the p element is added after the document has completed loading, this WebDriver script might be intermittent. It “might” be intermittent because no guarantees can be made about elements or events that trigger asynchronously without explicitly waiting—or blocking—on those events.\nFortunately, the normal instruction set available on the WebElement interface—such as WebElement.click and WebElement.sendKeys—are guaranteed to be synchronous, in that the function calls will not return (or the callback will not trigger in callback-style languages) until the command has been completed in the browser. The advanced user interaction APIs, Keyboard and Mouse, are exceptions as they are explicitly intended as “do what I say” asynchronous commands.\nWaiting is having the automated task execution elapse a certain amount of time before continuing with the next step.\nTo overcome the problem of race conditions between the browser and your WebDriver script, most Selenium clients ship with a wait package. When employing a wait, you are using what is commonly referred to as an explicit wait.\nExplicit wait Explicit waits are available to Selenium clients for imperative, procedural languages. They allow your code to halt program execution, or freeze the thread, until the condition you pass it resolves. The condition is called with a certain frequency until the timeout of the wait is elapsed. This means that for as long as the condition returns a falsy value, it will keep trying and waiting.\nSince explicit waits allow you to wait for a condition to occur, they make a good fit for synchronising the state between the browser and its DOM, and your WebDriver script.\nTo remedy our buggy instruction set from earlier, we could employ a wait to have the findElement call wait until the dynamically added element from the script has been added to the DOM:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Initialize and wait till element(link) became clickable - timeout in 10 seconds WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Print the first result System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element(By.TAG_NAME, \u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Initialize and wait till element(link) became clickable - timeout in 10 seconds val firstResult = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Print the first result println(firstResult.text)     We pass in the condition as a function reference that the wait will run repeatedly until its return value is truthy. A “truthful” return value is anything that evaluates to boolean true in the language at hand, such as a string, number, a boolean, an object (including a WebElement), or a populated (non-empty) sequence or list. That means an empty list evaluates to false. When the condition is truthful and the blocking wait is aborted, the return value from the condition becomes the return value of the wait.\nWith this knowledge, and because the wait utility ignores no such element errors by default, we can refactor our instructions to be more concise:\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3)) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); }   driver.get \u0026#39;file:///race_condition.html\u0026#39; wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) ele = wait.until { driver.find_element(css: \u0026#39;p\u0026#39;)} foo = ele.text assert_match foo, \u0026#39;Hello from JavaScript\u0026#39;   let ele = await driver.wait(until.elementLocated(By.css(\u0026#39;p\u0026#39;)),10000); let foo = await ele.getText(); assert(foo == \u0026#34;Hello from JavaScript\u0026#34;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val ele = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026#34;p\u0026#34;))) assert(ele.text == \u0026#34;Hello from JavaScript!\u0026#34;)     In that example, we pass in an anonymous function (but we could also define it explicitly as we did earlier so it may be reused). The first and only argument that is passed to our condition is always a reference to our driver object, WebDriver (called d in the example). In a multi-threaded environment, you should be careful to operate on the driver reference passed in to the condition rather than the reference to the driver in the outer scope.\nBecause the wait will swallow no such element errors that are raised when the element is not found, the condition will retry until the element is found. Then it will take the return value, a WebElement, and pass it back through to our script.\nIf the condition fails, e.g. a truthful return value from the condition is never reached, the wait will throw/raise an error/exception called a timeout error.\nOptions The wait condition can be customised to match your needs. Sometimes it is unnecessary to wait the full extent of the default timeout, as the penalty for not hitting a successful condition can be expensive.\nThe wait lets you pass in an argument to override the timeout:\nJava Python C# Ruby JavaScript Kotlin new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) wait.until { driver.find_element(:id, \u0026#39;message\u0026#39;).displayed? }   await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000);   WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     Expected conditions Because it is quite a common occurrence to have to synchronise the DOM and your instructions, most clients also come with a set of predefined expected conditions. As might be obvious by the name, they are conditions that are predefined for frequent wait operations.\nThe conditions available in the different language bindings vary, but this is a non-exhaustive list of a few:\n alert is present element exists element is visible title contains title is element staleness visible text  You can refer to the API documentation for each client binding to find an exhaustive list of expected conditions:\n Java\u0026rsquo;s org.openqa.selenium.support.ui.ExpectedConditions class Python\u0026rsquo;s selenium.webdriver.support.expected_conditions class .NET\u0026rsquo;s OpenQA.Selenium.Support.UI.ExpectedConditions type  Implicit wait There is a second type of wait that is distinct from explicit wait called implicit wait. By implicitly waiting, WebDriver polls the DOM for a certain duration when trying to find any element. This can be useful when certain elements on the webpage are not available immediately and need some time to load.\nImplicit waiting for elements to appear is disabled by default and will need to be manually enabled on a per-session basis. Mixing explicit waits and implicit waits will cause unintended consequences, namely waits sleeping for the maximum time even if the element is available or condition is true.\nWarning: Do not mix implicit and explicit waits. Doing so can cause unpredictable wait times. For example, setting an implicit wait of 10 seconds and an explicit wait of 15 seconds could cause a timeout to occur after 20 seconds.\nAn implicit wait is to tell WebDriver to poll the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available. The default setting is 0, meaning disabled. Once set, the implicit wait is set for the life of the session.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element(By.ID, \u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Apply timeout for 10 seconds await driver.manage().setTimeouts( { implicit: 10000 } ); // Navigate to url await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     FluentWait FluentWait instance defines the maximum amount of time to wait for a condition, as well as the frequency with which to check the condition.\nUsers may configure the wait to ignore specific types of exceptions whilst waiting, such as NoSuchElementException when searching for an element on the page.\nJava Python C# Ruby JavaScript Kotlin // Waiting 30 seconds for an element to be present on the page, checking // for its presence once every 5 seconds. Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox exception = Selenium::WebDriver::Error::NoSuchElementError begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; wait = Selenium::WebDriver::Wait.new(timeout: 30, interval: 5, message: \u0026#39;Timed out after 30 sec\u0026#39;, ignore: exception) foo = wait.until { driver.find_element(id: \u0026#39;foo\u0026#39;)} ensure driver.quit end   const {Builder, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); // Waiting 30 seconds for an element to be present on the page, checking  // for its presence once every 5 seconds.  let foo = await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000, \u0026#39;Timed out after 30 seconds\u0026#39;, 5000); })();   val wait = FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/getting_started_with_webdriver/",
	"title": "WebDriver 시작하기",
	"tags": [],
	"description": "",
	"content": "WebDriver 시작하기 Selenium은 WebDriver 의 사용을 통해 모든 주요 브라우저의 자동화를 지원합니다.\nWebDriver 는 웹 브라우저의 동작을 제어하기 위한 언어 중립 인터페이스를 정의하는 API와 프로토콜 입니다.\n각 브라우저는 드라이버 라고 불리는 특정한 웹 드라이버 구현에 의해 뒷받침됩니다. 드라이버는 브라우저로의 위임을 담당하는 구성 요소이며, Selenium과 브라우저와의 통신을 처리합니다.\n이러한 분리는 브라우저 공급 업체가 브라우저 구현을 책임지게하려는 의식적인 노력의 일부입니다.\nSelenium은 가능한 한 이러한 타사의 드라이버를 사용하지만, 현실적으로 불가능할 경우 프로젝트에서 유지\u0026amp;관리하는 자체 드라이버도 제공합니다.\nSelenium 프레임워크는 이 모든 부분을 하나로 묶습니다. 서로 다른 브라우저 백엔드를 투명하게 사용할 수 있는\n사용자 대면 인터페이스를 통해 브라우저 간 및 플랫폼 간의 자동화가 가능합니다.\n드라이버에 대한 자세한 내용은 Driver Idiosyncrasies 를 참조하십시오.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/grid/when_to_use_grid/",
	"title": "When to use Grid",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Generally speaking, there’s two reasons why you might want to use Grid.\n To run your tests against multiple browsers, multiple versions of browser, and browsers running on different operating systems. To reduce the time it takes for the test suite to complete a test pass.  Grid is used to speed up the execution of a test pass by using multiple machines to run tests in parallel. For example, if you have a suite of 100 tests, but you set up Grid to support 4 different machines (VMs or separate physical machines) to run those tests, your test suite will complete in (roughly) one-fourth the time as it would if you ran your tests sequentially on a single machine. For large test suites, and long-running test suite such as those performing large amounts of data-validation, this can be a significant time-saver. Some test suites can take hours to run. Another reason to boost the time spent running the suite is to shorten the turnaround time for test results after developers check-in code for the AUT. Increasingly software teams practicing Agile software development want test feedback as immediately as possible as opposed to wait overnight for an overnight test pass.\nGrid is also used to support running tests against multiple runtime environments, specifically, against different browsers at the same time. For example, a ‘grid’ of virtual machines can be setup with each supporting a different browser that the application to be tested must support. So, machine 1 has Internet Explorer 8, machine 2, Internet Explorer 9, machine 3 the latest Chrome, and machine 4 the latest Firefox. When the test suite is run, Selenium-Grid receives each test-browser combination and assigns each test to run against its required browser.\nIn addition, one can have a grid of all the same browser, type and version. For instance, one could have a grid of 4 machines each running 3 instances of Firefox 70, allowing for a ‘server-farm’ (in a sense) of available Firefox instances. When the suite runs, each test is passed to Grid which assigns the test to the next available Firefox instance. In this manner one gets test pass where conceivably 12 tests are all running at the same time in parallel, significantly reducing the time required to complete a test pass.\nGrid is very flexible. These two examples can be combined to allow multiple instances of each browser type and version. A configuration such as this would provide both, parallel execution for fast test pass completion and support for multiple browser types and versions simultaneously.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/support_packages/mouse_and_keyboard_actions_in_detail/",
	"title": "마우스 동작 세부 사항",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Mouse represents a mouse event. Mouse actions are performed by using low-level interface which allows us to provide virtualized device input action to the web browser.\nclickAndHold It will move to the element and clicks (without releasing) in the middle of the given element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform click-and-hold action on the element webdriver.ActionChains(driver).click_and_hold(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ClickAndHold { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.ClickAndHold(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform click-and-hold action on the element driver.action.click_and_hold(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function clickAndHold() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform mouseMove to element and mouseDown (press) action on the element  await actions.move({origin:searchBtn}).press().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform() } finally { driver.quit() } }     contextClick This method firstly performs a mouse-move to the location of the element and performs the context-click (right click) on the given element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class contextClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform context-click action on the element webdriver.ActionChains(driver).context_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ContextClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.ContextClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform context-click action on the element driver.action.context_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function contextClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform context-click action on the element  await actions.contextClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform() } finally { driver.quit() } }     doubleClick It will move to the element and performs a double-click in the middle of the given element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class doubleClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element(By.LINK_TEXT, \u0026#34;Sign in\u0026#34;) # Perform double-click action on the element webdriver.ActionChains(driver).double_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DoubleClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.DoubleClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform double-click action on the element driver.action.double_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function doubleClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform double-click action on the element  await actions.doubleClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform() } finally { driver.quit() } }     moveToElement This method moves the mouse to the middle of the element. The element is also scrolled into the view on performing this action.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveToElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) # Performs mouse move action onto the element webdriver.ActionChains(driver).move_to_element(gmailLink).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveToElement { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.MoveToElement(gmailLink).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Performs mouse move action onto the element driver.action.move_to(gmail_link).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveToElement() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({origin:gmailLink}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform() } finally { driver.quit() } }     moveByOffset: This method moves the mouse from its current position (or 0,0) by the given offset. If the coordinates are outside the view window, then the mouse will end up outside the browser window.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveByOffset { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture x and y offset positions of element  int xOffset = gmailLink.getRect().getX(); int yOffset = gmailLink.getRect().getY(); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.moveByOffset(xOffset, yOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element(By.LINK_TEXT, \u0026#34;Gmail\u0026#34;) #Set x and y offset positions of element xOffset = 100 yOffset = 100 # Performs mouse move action onto the element webdriver.ActionChains(driver).move_by_offset(xOffset,yOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveByOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); // Set x and y offset positions of element  int xOffset = 100; int yOffset = 100; Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.MoveByOffset(xOffset, yOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Capture x and y offset positions of element x_offset = gmail_link.rect.x y_offset = gmail_link.rect.y # Performs mouse move action onto the offset position driver.action.move_to_location(x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveByOffset() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture offset positions of element  let offset = await gmailLink.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({x:parseInt(x),y:parseInt(y)}).pause(3000).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) // Capture x and y offset positions of element  val xOffset = gmailLink.rect.getX() val yOffset = gmailLink.rect.getY() val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveByOffset(xOffset, yOffset).build().perform() } finally { driver.quit() } }     dragAndDrop This method firstly performs a click-and-hold on the source element, moves to the location of the target element and then releases the mouse.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDrop { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs drag and drop action of sourceEle onto the targetEle webdriver.ActionChains(driver).drag_and_drop(sourceEle,targetEle).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDrop { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDrop(sourceEle, targetEle).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) # Store \u0026#39;box B\u0026#39; as source element target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Performs drag and drop action of sourceEle onto the targetEle driver.action.drag_and_drop(source_ele, target_ele).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDrop() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); // Performs drag and drop action of sourceEle onto the targetEle  await actions.dragAndDrop(sourceEle, targetEle).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform() } finally { driver.quit() } }     dragAndDropBy This method firstly performs a click-and-hold on the source element, moves to the given offset and then releases the mouse.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDropBy { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.getLocation().getX(); int targetEleYOffset = targetEle.getLocation().getY(); Actions actionProvider = new Actions(driver); // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) targetEleXOffset = targetEle.location.get(\u0026#34;x\u0026#34;) targetEleYOffset = targetEle.location.get(\u0026#34;y\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).drag_and_drop_by_offset(sourceEle, targetEleXOffset, targetEleYOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDropToOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.Location.X; int targetEleYOffset = targetEle.Location.Y; Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDropToOffset(sourceEle, targetEleXOffset, targetEleYOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Capture x and y offset positions of element x_offset = target_ele.rect.x y_offset = target_ele.rect.y # Performs dragAndDropBy onto the target element offset position driver.action.drag_and_drop_by(source_ele, x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDropBy() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); let offset = await targetEle.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs dragAndDropBy onto the target element offset position  await actions.dragAndDrop(sourceEle, {x:parseInt(x), y:parseInt(y)}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val targetEleXOffset = targetEle.location.getX() val targetEleYOffset = targetEle.location.getY() val actionProvider = Actions(driver) // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform() } finally { driver.quit() } }     release This action releases the depressed left mouse button. If WebElement is passed, it will release depressed left mouse button on the given WebElement\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class release { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform(); // Performs release event  actionProvider.release().build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element(By.ID, \u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element(By.ID, \u0026#34;droppable\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).click_and_hold(sourceEle).move_to_element(targetEle).perform() #Performs release event webdriver.ActionChains(driver).release().perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class Release { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.ClickAndHold(sourceEle).MoveToElement(targetEle).Build().Perform(); // Performs release event  actionProvider.Release().Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) driver.action.click_and_hold(source_ele).move_to(target_ele).perform # Performs release event driver.action.release.perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function release() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); await actions.move({origin:sourceEle}).press().perform(); // Performs release event on target element  await actions.move({origin:targetEle}).release().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform() // Performs release event  actionProvider.release().build().perform() } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/introduction/about_this_documentation/",
	"title": "이 문서에 대하여",
	"tags": [],
	"description": "",
	"content": "이 문서들은 Selenium의 코드와 마찬가지로 자원 봉사자들에 의해 100% 유지됩니다.\n많은 사람들이 이 문서가 만들어진 후 사용해오고 있지만, 더 많은 사람들은 찰나의 시간만 사용하고,\n신규 유저의 경험을 개전하기 위해 각자의 시간을 할애해 왔습니다.\n문서에 문제가 있는 경우, 우리에게 알려주세요!\n문제를 전달하는 가장 좋은 방법은 Github 저장소에 방문하는 것입니다. https://github.com/seleniumhq/seleniumhq.github.io/issues\n이미 동일한 문제가 접수되었는지 여부를 검색해보세요. 그렇지 않다면, 자유롭게 문제를 제기하면 됩니다.\n많은 커뮤니티 구성원들이 셀레니움 IRC 채널 irc.freenode.net 을 방문합니다.\n언제든지 방문하여 질문해 주세요.\n만약 당신이 이 문서들 중에서 유용한 도음을 받는다면, 이 문서에 기여해주세요!\n일반적인 커밋보다는 문서를 업데이트하는 것이 훨씬 쉽습니다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/improved_reporting/",
	"title": "Improved reporting",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Selenium is not designed to report on the status of test cases run. Taking advantage of the built-in reporting capabilities of unit test frameworks is a good start. Most unit test frameworks have reports that can generate xUnit or HTML formatted reports. xUnit reports are popular for importing results to a Continuous Integration (CI) server like Jenkins, Travis, Bamboo, etc. Here are some links for more information regarding report outputs for several languages.\nNUnit 3 Console Runner\nNUnit 3 Console Command Line\nxUnit getting test results in TeamCity\nxUnit getting test results in CruiseControl.NET\nxUnit getting test results in Azure DevOps\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/support_classes/",
	"title": "Support classes",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n WebDriver support classes are provided to simplify maintaining your code. They provide a nice abstraction to make modeling HTML element(s) as domain objects easier, also providing helper methods to make using such objects easy to reason about. We will learn about:\n Locator Strategies Events LoadableComponent ThreadGuard etc.  Let\u0026rsquo;s Start:\nThreadGuard  This class is only available in the Java Binding\n ThreadGuard checks that a driver is called only from the same thread that created it. Threading issues especially when running tests in Parallel may have mysterious and hard to diagnose errors. Using this wrapper prevents this category of errors and will raise an exception when it happens.\nThe following example simulate a clash of threads:\npublic class DriverClash { //thread main (id 1) created this driver  private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;\u0026lt;Set path to your Chromedriver\u0026gt;\u0026#34;); } //Thread-1 (id 24) is calling the same driver causing the clash to happen  Runnable r1 = () -\u0026gt; {protectedDriver.get(\u0026#34;https://selenium.dev\u0026#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } The result shown below:\nException in thread \u0026#34;Thread-1\u0026#34; org.openqa.selenium.WebDriverException: Thread safety error; this instance of WebDriver was constructed on thread main (id 1)and is being accessed by thread Thread-1 (id 24) This is not permitted and *will* cause undefined behaviour As seen in the example:\n protectedDriver Will be created in Main thread We use Java Runnable to spin up a new process and a new Thread to run the process Both Thread will clash because the Main Thread does not have protectedDriver in it\u0026rsquo;s memory. ThreadGuard.protect will throw an exception.  Note: This does not replace the need for using ThreadLocal to manage drivers when running parallel.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": "웹 드라이버(Web Driver) 최근 셀레니움의 가장 큰 변화는 WebDriver API의 포함이었다. 사용자가 로컬로 또는 Selenium 서버를 사용하여 원격 컴퓨터에서 브라우저를 기본적으로 구동하는 것은 브라우저 자동화 측면에서 비약적인 발전을 의미한다.\nSelenium WebDriver는 RC와 같은 역할에 적합하며, 원래의 1.x 바인딩을 통합하였다. 언어 바인딩과 개별 브라우저 제어 코드의 구현을 모두 말한다. 이것은 일반적으로 단지 WebDriver 라고 부르거나 때로는 Selenium 2 라고 부른다.\nSelenium 1.0 + WebDriver = Selenium 2.0\n  WebDriver는 Selenium-RC API의 일부 제한사항과 함께 보다 단순하고 간결한 프로그래밍 인터페이스로 설계되었다.\n  WebDriver는 Selenium 1.0과 비교하여 컴팩트한 객체 지향 API이다.\n  브라우저를 훨씬 효과적으로 구동하고 파일 업로드 또는 다운로드, 팝업, 대화 상자 도착자 등 기능 테스트 범위에 영향을 준 Selenium 1의 한계를 극복한다.\n  WebDriver는 Selenium RC의 Single-host 오리진 policy.의 한계를 극복한다.\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/worst_practices/test_dependency/",
	"title": "실험 의존성",
	"tags": [],
	"description": "",
	"content": "자동화된 실험에 대한 일반적인 생각이나 오해는 \u0026ldquo;특정한 순서\u0026quot;로 판단된다. 당신의 실험들은 어떠한 형태 로든 정해진 순서 에 따라 실행되어질 수 있고, 단순히 성공하기 위해 다른 테스트에 의존하지 않는다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/avoid_sharing_state/",
	"title": "Avoid sharing state",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Although mentioned in several places it is worth mentioning again. Ensure tests are isolated from one another.\n  Do not share test data. Imagine several tests that each query the database for valid orders before picking one to perform an action on. Should two tests pick up the same order you are likely to get unexpected behaviour.\n  Clean up stale data in the application that might be picked up by another test e.g. invalid order records.\n  Create a new WebDriver instance per test. This helps ensure test isolation and makes parallelization simpler.\n  "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/js_alerts_prompts_and_confirmations/",
	"title": "JavaScript alerts, prompts and confirmations",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n WebDriver provides an API for working with the three types of native popup messages offered by JavaScript. These popups are styled by the browser and offer limited customisation.\nAlerts The simplest of these is referred to as an alert, which shows a custom message, and a single button which dismisses the alert, labelled in most browsers as OK. It can also be dismissed in most browsers by pressing the close button, but this will always do the same thing as the OK button. See an example alert.\nWebDriver can get the text from the popup and accept or dismiss these alerts.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See an example alert\u0026#34;).click() # Wait for the alert to be displayed and store it in a variable alert = wait.until(expected_conditions.alert_is_present()) # Store the alert text in a variable text = alert.text # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert text in a variable string text = alert.Text; //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on OK button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the OK button await alert.accept(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Store the alert text in a variable val text = alert.getText() //Press the OK button alert.accept()     Confirm A confirm box is similar to an alert, except the user can also choose to cancel the message. See a sample confirm.\nThis example also shows a different approach to storing an alert:\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()); //Store the alert in a variable Alert alert = driver.switchTo().alert(); //Store the alert in a variable for reuse String text = alert.getText(); //Press the Cancel button alert.dismiss();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample confirm\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = driver.switch_to.alert # Store the alert text in a variable text = alert.text # Press the Cancel button alert.dismiss()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Wait for the alert to be displayed wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert in a variable IAlert alert = driver.SwitchTo().Alert(); //Store the alert in a variable for reuse string text = alert.Text; //Press the Cancel button alert.Dismiss();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on Cancel button alert.dismiss   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the Cancel button await alert.dismiss(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()) //Store the alert in a variable val alert = driver.switchTo().alert() //Store the alert in a variable for reuse val text = alert.text //Press the Cancel button alert.dismiss()     Prompt Prompts are similar to confirm boxes, except they also include a text input. Similar to working with form elements, you can use WebDriver\u0026rsquo;s send keys to fill in a response. This will completely replace the placeholder text. Pressing the cancel button will not submit any text. See a sample prompt.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element(By.LINK_TEXT, \u0026#34;See a sample prompt\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = Alert(driver) # Type your message alert.send_keys(\u0026#34;Selenium\u0026#34;) # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Type your message alert.SendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Type a message alert.send_keys(\u0026#34;selenium\u0026#34;) # Press on Ok button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Type your message await alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button await alert.accept(); //Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;) //Press the OK button alert.accept()     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/remote_webdriver/",
	"title": "Remote WebDriver",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Remote WebDriver You can use WebDriver remotely the same way you would use it locally. The primary difference is that a remote WebDriver needs to be configured so that it can run your tests on a separate machine.\nA remote WebDriver is composed of two pieces: a client and a server. The client is your WebDriver test and the server is simply a Java servlet, which can be hosted in any modern JEE app server.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/support_packages/working_with_cookies/",
	"title": "Working with cookies",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n A cookie is a small piece of data that is sent from a website and stored in your computer. Cookies are mostly used to recognise the user and load the stored information.\nWebDriver API provides a way to interact with cookies with built-in methods:\nAdd Cookie It is used to add a cookie to the current browsing context. Add Cookie only accepts a set of defined serializable JSON object. Here is the link to the list of accepted JSON key values\nFirst of all, you need to be on the domain that the cookie will be valid for. If you are trying to preset cookies before you start interacting with a site and your homepage is large / takes a while to load an alternative is to find a smaller page on the site (typically the 404 page is small, e.g. http://example.com/some404page)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Adds the cookie into current browser context  driver.manage().addCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;})   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace AddCookie { class AddCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Adds the cookie into current browser context  driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context driver.manage.add_cookie(name: \u0026#34;key\u0026#34;, value: \u0026#34;value\u0026#34;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;}); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Adds the cookie into current browser context  driver.manage().addCookie(Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit() } }     Get Named Cookie It returns the serialized cookie data matching with the cookie name among all associated cookies.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class getCookieNamed { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  Cookie cookie1 = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); System.out.println(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bar\u0026#34;}) # Get cookie details with named cookie \u0026#39;foo\u0026#39; print(driver.get_cookie(\u0026#34;foo\u0026#34;))   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetCookieNamed { class GetCookieNamed { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  var cookie = driver.Manage().Cookies.GetCookieNamed(\u0026#34;foo\u0026#34;); System.Console.WriteLine(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;) # Get cookie details with named cookie \u0026#39;foo\u0026#39; puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;foo\u0026#39;, value: \u0026#39;bar\u0026#39;}); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  driver.manage().getCookie(\u0026#39;foo\u0026#39;).then(function (cookie) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookie); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  val cookie = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); println(cookie); } finally { driver.quit() } }     Get All Cookies It returns a ‘successful serialized cookie data’ for current browsing context. If browser is no longer available it returns error.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Set; public class getAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Add few cookies  driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  Set\u0026lt;Cookie\u0026gt; cookies = driver.manage().getCookies(); System.out.println(cookies); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Get all available cookies print(driver.get_cookies())   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetAllCookies { class GetAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  var cookies = driver.Manage().Cookies.AllCookies; } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Get all available cookies puts driver.manage.all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  val cookies = driver.manage().cookies; println(cookies); } finally { driver.quit() } }     Delete Cookie It deletes the cookie data matching with the provided cookie name.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); Cookie cookie1 = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); /* Selenium Java bindings also provides a way to delete cookie by passing cookie object of current browsing context */ driver.manage().deleteCookie(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Delete a cookie with name \u0026#39;test1\u0026#39; driver.delete_cookie(\u0026#34;test1\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteCookie { class DeleteCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); var cookie = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.Manage().Cookies.AddCookie(cookie); // delete a cookie with name \u0026#39;test1\u0026#39;\t driver.Manage().Cookies.DeleteCookieNamed(\u0026#34;test1\u0026#34;); // Selenium .net bindings also provides a way to delete  // cookie by passing cookie object of current browsing context  driver.Manage().Cookies.DeleteCookie(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # delete a cookie with name \u0026#39;test1\u0026#39; driver.manage.delete_cookie(\u0026#39;test1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete a cookie with name \u0026#39;test1\u0026#39;  await driver.manage().deleteCookie(\u0026#39;test1\u0026#39;); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); val cookie1 = Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;) driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); // delete cookie by passing cookie object of current browsing context.  driver.manage().deleteCookie(cookie1); } finally { driver.quit() } }     Delete All Cookies It deletes all the cookies of the current browsing context.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Deletes all cookies driver.delete_all_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteAllCookies { class DeleteAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.Manage().Cookies.DeleteAllCookies(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # deletes all cookies driver.manage.delete_all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete all cookies  await driver.manage().deleteAllCookies(); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit() } }     Same-Site Cookie Attribute It allows a user to instruct browsers to control whether cookies are sent along with the request initiated by third party sites. It is introduced to prevent CSRF (Cross-Site Request Forgery) attacks.\nSame-Site cookie attribute accepts two parameters as instructions\nStrict: When the sameSite attribute is set as Strict, the cookie will not be sent along with requests initiated by third party websites.\nLax: When you set a cookie sameSite attribute to Lax, the cookie will be sent along with the GET request initiated by third party website.\nNote: As of now this feature is landed in chrome(80+version) and works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class cookieTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); Cookie cookie = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build(); Cookie cookie1 = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build(); driver.manage().addCookie(cookie); driver.manage().addCookie(cookie1); System.out.println(cookie.getSameSite()); System.out.println(cookie1.getSameSite()); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Strict\u0026#39;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Lax\u0026#39;}) cookie1 = driver.get_cookie(\u0026#39;foo\u0026#39;) cookie2 = driver.get_cookie(\u0026#39;foo1\u0026#39;) print(cookie1) print(cookie2)   // Please raise a PR    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Strict\u0026#34;) driver.manage.add_cookie(name: \u0026#34;foo1\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Lax\u0026#34;) puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) puts driver.manage.cookie_named(\u0026#39;foo1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39;  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Strict\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Lax\u0026#39;}); console.log(await driver.manage().getCookie(\u0026#39;key\u0026#39;)); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;http://www.example.com\u0026#34;) val cookie = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build() val cookie1 = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build() driver.manage().addCookie(cookie) driver.manage().addCookie(cookie1) println(cookie.getSameSite()) println(cookie1.getSameSite()) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/worst_practices/performance_testing/",
	"title": "성능 테스트",
	"tags": [],
	"description": "",
	"content": "Selenium과 WebDriver를 사용한 성능 테스트는 일반적으로 권장되지 않는다. 불가능해서가 아니라, 그것들이 성능을 테스트하는데 최적화되어 있지 않기 때문에 좋은 결과를 얻지 못 할 것이다.\n사용자의 입장에서는, 성능 테스트에 이상적으로 보일 수 있지만 WebDriver 테스트들은 내'외부의 수많은 취약점이 존재하고, 이는 사용자 본인이 직접 통제할 수 없다.\n예를 들어 브라우저 시작 속도, HTTP 서버의 속도, JavaScript 또는 CSS를 호스팅하는 타사 서버의 응답, WebDriver 구현 자체의 계측 페널티 등 이 지점들에서의 변동은 결과에 변화를 일으킬 것이다.\n웹사이트의 성능 차이를 구분하는 것은 어렵다. 외부 리소스의 성능, 특히 스크립트를 넣을 경우 브라우저에서 WebDriver를 사용할 때 성능 저하가 무엇인지 파악하기 어렵다.\n또 다른 잠재적인 매력은 \u0026ldquo;시간 절약\u0026quot;으로 — 기능 및 성능 테스트를 동시에 수행한다. 그러나 기능 테스트와 성능 테스트는 상반된 목표를 가지고 있다. 기능을 시험하기 위해 시험자는 인내심을 갖고 로드를 기다려야 할 수 있지만, 이것은 성능 시험 결과를 흐리게 할 것이고 그 반대의 경우도 마찬가지일 것이다.\n웹 사이트의 성능을 향상시키려면 환경 차이와 무관하게 전체 성능을 분석하고, 잘못된 코드 관행을 식별하고, 개별 리소스(예: CSS 또는 JavaScript)의 성능을 분석할 수 있어야 한다. 이 작업을 이미 수행할 수 있고, 보고 및 분석을 제공할 수 있으며, 개선 제안도 할 수 있는 성능 테스트 도구가 있다.\nExample (open source) packages to use are: JMeter\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/",
	"title": "Guidelines and recommendations",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Guidelines and recommendations A note on \u0026ldquo;Best Practices\u0026rdquo;: We\u0026rsquo;ve intentionally avoided the phrase \u0026ldquo;Best Practices\u0026rdquo; in this documentation. No one approach works for all situations. We prefer the idea of \u0026ldquo;Guidelines and Recommendations\u0026rdquo;. We encourage you to read through these and thoughtfully decide what approaches will work for you in your particular environment.\nFunctional testing is difficult to get right for many reasons. As if application state, complexity, and dependencies do not make testing difficult enough, dealing with browsers (especially with cross-browser incompatibilities) makes writing good tests a challenge.\nSelenium provides tools to make functional user interaction easier, but does not help you write well-architected test suites. In this chapter we offer advice, guidelines, and recommendations on how to approach functional web page automation.\nThis chapter records software design patterns popular amongst many of the users of Selenium that have proven successful over the years.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/http_proxies/",
	"title": "Http proxies",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n A proxy server acts as an intermediary for requests between a client and a server. In simple, the traffic flows through the proxy server on its way to the address you requested and back.\nA proxy server for automation scripts with Selenium could be helpful for:\n Capture network traffic Mock backend calls made by the website Access the required website under complex network topologies or strict corporate restrictions/policies.  If you are in a corporate environment, and a browser fails to connect to a URL, this is most likely because the environment needs a proxy to be accessed.\nSelenium WebDriver provides a way to proxy settings\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Proxy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.chrome.ChromeOptions; public class proxyTest { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;); ChromeOptions options = new ChromeOptions(); options.setCapability(\u0026#34;proxy\u0026#34;, proxy); WebDriver driver = new ChromeDriver(options); driver.get(\u0026#34;https://www.google.com/\u0026#34;); driver.manage().window().maximize(); driver.quit(); } }   from selenium import webdriver PROXY = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34; webdriver.DesiredCapabilities.FIREFOX[\u0026#39;proxy\u0026#39;] = { \u0026#34;httpProxy\u0026#34;: PROXY, \u0026#34;ftpProxy\u0026#34;: PROXY, \u0026#34;sslProxy\u0026#34;: PROXY, \u0026#34;proxyType\u0026#34;: \u0026#34;MANUAL\u0026#34;, } with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://selenium.dev\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; public class ProxyTest{ public static void Main() { ChromeOptions options = new ChromeOptions(); Proxy proxy = new Proxy(); proxy.Kind = ProxyKind.Manual; proxy.IsAutoDetect = false; proxy.SslProxy = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;; options.Proxy = proxy; options.AddArgument(\u0026#34;ignore-certificate-errors\u0026#34;); IWebDriver driver = new ChromeDriver(options); driver.Navigate().GoToUrl(\u0026#34;https://www.selenium.dev/\u0026#34;); } }   # Need PR   // need PR    import org.openqa.selenium.Proxy import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions class proxyTest { fun main() { val proxy = Proxy() proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;) val options = ChromeOptions() options.setCapability(\u0026#34;proxy\u0026#34;, proxy) val driver: WebDriver = ChromeDriver(options) driver[\u0026#34;https://www.google.com/\u0026#34;] driver.manage().window().maximize() driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/test_independency/",
	"title": "Test independency",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Write each test as its own unit. Write the tests in a way that will not be reliant on other tests to complete:\nLet us say there is a content management system with which you can create some custom content which then appears on your website as a module after publishing, and it may take some time to sync between the CMS and the application.\nA wrong way of testing your module is that the content is created and published in one test, and then checking the module in another test. This is not feasible as the content may not be available immediately for the other test after publishing.\nInstead, you can create a stub content which can be turned on and off within the affected test, and use that for validating the module. However, for content creation, you can still have a separate test.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/worst_practices/link_spidering/",
	"title": "링크 이동",
	"tags": [],
	"description": "",
	"content": "WebDriver를 링크를 통해 이동하는 것은 권장되는 연습이 아니다. 할 수 없어서가 아니라, WebDriver가 확실히 이것에 가장 이상적인 도구가 아니기 때문이다. WebDriver를 시작하는 데 시간이 필요하며 최대 1분까지 몇 초 정도 걸릴 수 있음 시험이 어떻게 작성되느냐에 따라, 그냥 페이지로 가서 DOM을 통과한다.\ncurl명령어를 실행하거나, BeautifulSoup과 같은 라이브러리를 사용함으로써, browser를 만들고 페이지로 이동하는데 의존하지 않는 방법이기에 WebDriver를 사용하는 것보다 더 많은 시간을 절약할 수 있다. 당신은 이 작업에 WebDriver를 사용하지 않음으로써 많은 시간을 절약하고 있다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/consider_using_a_fluent_api/",
	"title": "Consider using a fluent API",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Martin Fowler coined the term \u0026ldquo;Fluent API\u0026rdquo;. Selenium already implements something like this in their FluentWait class, which is meant as an alternative to the standard Waitclass. You could enable the Fluent API design pattern in your page object and then query the Google search page with a code snippet like this one:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); The Google page object class with this fluent behavior might look like this:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // If load() fails, calls isLoaded() until page is finished loading  PageFactory.initElements(driver, this); // Initialize WebElements on page  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, Duration.ofSeconds(3) ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } } "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/page_loading_strategy/",
	"title": "Page loading strategy",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Defines the current session\u0026rsquo;s page loading strategy. By default, when Selenium WebDriver loads a page, it follows the normal pageLoadStrategy. It is always recommended to stop downloading additional resources (like images, css, js) when the page loading takes lot of time.\nThe document.readyState property of a document describes the loading state of the current document. By default, WebDriver will hold off on responding to a driver.get() (or) driver.navigate().to() call until the document ready state is complete\nIn SPA applications (like Angular, react, Ember) once the dynamic content is already loaded (I.e once the pageLoadStrategy status is COMPLETE), clicking on a link or performing some action within the page will not make a new request to the server as the content is dynamically loaded at the client side without a pull page refresh.\nSPA applications can load many views dynamically without any server requests, So pageLoadStrategy will always show COMPLETE status until we do a new driver.get() and driver.navigate().to()\nWebDriver pageLoadStrategy supports the following values:\nnormal This will make Selenium WebDriver to wait for the entire page is loaded. When set to normal, Selenium WebDriver waits until the load event fire is returned.\nBy default normal is set to browser if none is provided.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;normal\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Normal; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;normal\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;normal\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     eager This will make Selenium WebDriver to wait until the initial HTML document has been completely loaded and parsed, and discards loading of stylesheets, images and subframes.\nWhen set to eager, Selenium WebDriver waits until DOMContentLoaded event fire is returned.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;eager\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Eager; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;eager\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;eager\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     none When set to none Selenium WebDriver only waits until the initial page is downloaded.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;none\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.None; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;none\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;none\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/worst_practices/",
	"title": "좋지 않는 관행",
	"tags": [],
	"description": "",
	"content": "좋지 않는 관행 "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/guidelines_and_recommendations/fresh_browser_per_test/",
	"title": "Fresh browser per test",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Start each test from a clean known state. Ideally, spin up a new virtual machine for each test. If spinning up a new virtual machine is not practical, at least start a new WebDriver for each test. For Firefox, start a WebDriver with your known profile.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile); "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/web_element/",
	"title": "Web element",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n WebElement represents a DOM element. WebElements can be found by searching from the document root using a WebDriver instance, or by searching under another WebElement.\nWebDriver API provides built-in methods to find the WebElements which are based on different properties like ID, Name, Class, XPath, CSS Selectors, link Text, etc.\nFind Element It is used to find an element and returns a first matching single WebElement reference, that can be used for future element actions\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element WebElement searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_box = driver.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_bar = driver.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element let searchBar = driver.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element val searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements Similar to \u0026lsquo;Find Element\u0026rsquo;, but returns a list of matching WebElements. To use a particular WebElement from the list, you need to loop over the list of elements to perform action on selected element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import java.util.List; public class findElementsExample { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement element : elements) { System.out.println(\u0026#34;Paragraph text:\u0026#34; + element.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() # Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using System.Collections.Generic; namespace FindElementsExample { class FindElementsExample { public static void Main(string[] args) { IWebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = driver.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await driver.findElements(By.tagName(\u0026#39;p\u0026#39;)); for(let e of elements) { console.log(await e.getText()); } } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (element in elements) { println(\u0026#34;Paragraph text:\u0026#34; + element.text) } } finally { driver.quit() } }     Find Element From Element It is used to find a child element within the context of parent element. To achieve this, the parent WebElement is chained with \u0026lsquo;findElement\u0026rsquo; to access child elements\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element(By.TAG_NAME, \u0026#34;form\u0026#34;) search_box = search_form.find_element(By.NAME, \u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = searchForm.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Get search box element from webElement \u0026#39;form\u0026#39; search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; let searchForm = driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Get search box element from webElement \u0026#39;form\u0026#39; let searchBar = searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements From Element It is used to find the list of matching child WebElements within the context of parent element. To achieve this, the parent WebElement is chained with \u0026lsquo;findElements\u0026rsquo; to access child elements\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import java.util.List; public class findElementsFromElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  WebElement element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement e : elements) { System.out.println(e.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(By.TAG_NAME, \u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(By.TAG_NAME, \u0026#39;p\u0026#39;) for e in elements: print(e.text)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System.Collections.Generic; namespace FindElementsFromElement { class FindElementsFromElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  IWebElement element = driver.FindElement(By.TagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = element.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(:tag_name,\u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get element with tag name \u0026#39;div\u0026#39;  let element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for(let e of elements) { console.log(await e.getText()); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get element with tag name \u0026#39;div\u0026#39;  val element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (e in elements) { println(e.text) } } finally { driver.quit() } }     Get Active Element It is used to track (or) find DOM element which has the focus in the current browsing context.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class activeElementTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  String attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); System.out.println(attr); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.find_element(By.CSS_SELECTOR, \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#34;webElement\u0026#34;) # Get attribute of current active element attr = driver.switch_to.active_element.get_attribute(\u0026#34;title\u0026#34;) print(attr)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace ActiveElement { class ActiveElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://www.google.com\u0026#34;); driver.FindElement(By.CssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).SendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  string attr = driver.SwitchTo().ActiveElement().GetAttribute(\u0026#34;title\u0026#34;); System.Console.WriteLine(attr); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.google.com\u0026#39; driver.find_element(css: \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#39;webElement\u0026#39;) # Get attribute of current active element attr = driver.switch_to.active_element.attribute(\u0026#39;title\u0026#39;) puts attr ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); await driver.get(\u0026#39;https://www.google.com\u0026#39;); await driver.findElement(By.css(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  let attr = await driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); console.log(`${attr}`) })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;) // Get attribute of current active element  val attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); print(attr); } finally { driver.quit() } }     "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/grid/",
	"title": "조합 격자(Grid)",
	"tags": [],
	"description": "",
	"content": "Grid Selenium Grid 는 Selenium 테스트가 명령을 원격 웹 브라우저 인스턴스로 보낼 수 있도록 하는 스마트 프록시 서버입니다. 이것의 목적은 여러 기계에서 병렬로 테스트를 실행할 수 있는 쉬운 방법을 제공하는 것입니다.\nSelenium Grid 에서 한 서버는 JSON 형식 테스트 명령을 하나 이상의 등록된 Grid 노드로 보내는 허브로서의 역할을 합니다. 테스트를 허브에 연결하여 원격 브라우저 인스턴스에 대한 액세스 권한을 얻으십시오. 허브에는 이러한 인스턴스에 대한 액세스 권한을 제공하고 제어를 허용하는 등록된 서버 목록이 있습니다.\nSelenium Grid 는 여러 컴퓨터에서 동시에 테스트를 실행할 수 있도록 하며, (개별 테스트 대신에) 서로 다른 브라우저 버전과 브라우저 구성을 중앙에서 관리할 수 있도록 합니다.\nSelenium Grid 는 묘책이 아닙니다. 일반적인 위임 및 배포 문제의 부분 집합을 해결하지만, 예를 들어 당신의 인프라를 관리하지 않으며 당신의 특정한 요구에 적합하지 않을 수 있습니다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/support_packages/chrome_devtools/",
	"title": "Chrome Devtools",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Selenium 4 alpha versions have much awaited native support for Chrome Dev Protocol through \u0026ldquo;DevTools\u0026rdquo; interface. This helps us getting Chrome Development properties such as Application Cache, Fetch, Network, Performance, Profiler, Resource Timing, Security and Target CDP domains etc.\nChrome DevTools is a set of web developer tools built directly into the Google Chrome browser. DevTools can help you edit pages on-the-fly and diagnose problems quickly, which ultimately helps you build better websites, faster.\nEmulate Geo Location: Some applications have different features and functionalities across different locations. Automating such applications is difficult because it is hard to emulate the geo locations in the browser using Selenium. But with the help of Devtools, we can easily emulate them. Below code snippet demonstrates that.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.devtools.DevTools; public void geoLocationTest(){ ChromeDriver driver = new ChromeDriver(); Map coordinates = new HashMap() {{ put(\u0026#34;latitude\u0026#34;, 50.2334); put(\u0026#34;longitude\u0026#34;, 0.2334); put(\u0026#34;accuracy\u0026#34;, 1); }}; driver.executeCdpCommand(\u0026#34;Emulation.setGeolocationOverride\u0026#34;, coordinates); driver.get(\u0026#34;\u0026lt;your site url\u0026gt;\u0026#34;); }   # Please raise a PR to add code sample   // Please raise a PR to add code sample    # Please raise a PR to add code sample   // Please raise a PR to add code sample    // Please raise a PR to add code sample      "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/driver_idiosyncrasies/",
	"title": "Driver idiosyncrasies",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Driver idiosyncrasies "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/webdriver/keyboard/",
	"title": "Keyboard",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Keyboard represents a KeyBoard event. KeyBoard actions are performed by using low-level interface which allows us to provide virtualized device input to the web browser.\nsendKeys The sendKeys types a key sequence in DOM element even if modifier key sequence is encountered. Here are the list of possible keystrokes that WebDriver Supports.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER);\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Firefox()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r \rusing (var driver = new FirefoxDriver())\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :firefox\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.firefox.FirefoxDriver\rfun main() {\rval driver = FirefoxDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER)\r} finally {\rdriver.quit()\r}\r}\r \r  keyDown The keyDown is used to simulate action of pressing a modifier key(CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER);\rActions actionProvider = new Actions(driver);\rAction keydown = actionProvider.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build();\rkeydown.perform();\r} finally {\rdriver.quit();\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r webdriver.ActionChains(driver).key_down(Keys.CONTROL).send_keys(\u0026#34;a\u0026#34;).perform()\r \rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r Actions actionProvider = new Actions(driver);\rIAction keydown = actionProvider.KeyDown(Keys.Control).SendKeys(\u0026#34;a\u0026#34;).Build();\rkeydown.Perform();\r}\rfinally\r{\rdriver.Quit();\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r driver.action.key_down(:control).send_keys(\u0026#39;a\u0026#39;).perform\rensure\rdriver.quit\rend\r \r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r await driver.actions().keyDown(Key.CONTROL).sendKeys(\u0026#39;a\u0026#39;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\rval action = Actions(driver)\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r action.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  keyUp The keyUp is used to simulate key-up (or) key-release action of a modifier key(CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rimport org.openqa.selenium.interactions.Actions;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r WebElement search = driver.findElement(By.name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search,\u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store google search box WebElement\r search = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\raction = webdriver.ActionChains(driver)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.key_down(Keys.SHIFT).send_keys_to_element(search, \u0026#34;qwerty\u0026#34;).key_up(Keys.SHIFT).send_keys(\u0026#34;qwerty\u0026#34;).perform()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing OpenQA.Selenium.Interactions;\rnamespace HelloSelenium\r{\rclass HelloSelenium\r{\rpublic static void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r IWebElement search = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.KeyDown(Keys.Shift).SendKeys(search, \u0026#34;qwerty\u0026#34;).KeyUp(Keys.Shift).SendKeys(\u0026#34;qwerty\u0026#34;).Perform();\r}\rfinally {\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Store google search box WebElement\r search = driver.find_element(name: \u0026#39;q\u0026#39;)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r driver.action.key_down(:shift).send_keys(search,\u0026#39;qwerty\u0026#39;).key_up(:shift).send_keys(\u0026#34;qwerty\u0026#34;).perform\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store google search box WebElement\r let search = driver.findElement(By.name(\u0026#39;q\u0026#39;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r await driver.actions().click(search).keyDown(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).keyUp(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Store google search box WebElement\r val search = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rval action = Actions(driver)\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search, \u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  clear Clears the content of an editable element. This is only applied for the elements which is editable and interactable, otherwise Selenium returns the error (invalid element state (or) Element not interactable)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.chrome.ChromeDriver;\rpublic class clear {\rpublic static void main(String[] args) {\rWebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r WebElement searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;));\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.clear();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.by import By\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store \u0026#39;SearchInput\u0026#39; element\r SearchInput = driver.find_element(By.NAME, \u0026#34;q\u0026#34;)\rSearchInput.send_keys(\u0026#34;selenium\u0026#34;)\r# Clears the entered text\r SearchInput.clear()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing System;\rnamespace SnipetProjectDelete\r{\rclass Program\r{\rstatic void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(@\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r IWebElement searchInput = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\rsearchInput.SendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.Clear();\r}\rfinally\r{\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# store \u0026#39;search_input\u0026#39; element\r search_input = driver.find_element(name: \u0026#39;q\u0026#39;)\rsearch_input.send_keys(\u0026#39;selenium\u0026#39;)\r# Clears the entered text\r search_input.clear\rensure\rdriver.quit\rend\r \rconst {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store \u0026#39;SearchInput\u0026#39; element\r let searchInput = driver.findElement(By.name(\u0026#39;q\u0026#39;));\rawait searchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r await searchInput.clear();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.chrome.ChromeDriver\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;)\r// Store \u0026#39;searchInput\u0026#39; element\r val searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;)\r// Clears the entered text\r searchInput.clear()\r} finally {\rdriver.quit()\r}\r}\r \r  "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/support_packages/",
	"title": "Support packages",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Support packages "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/legacy_docs/",
	"title": "Legacy",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Legacy Under this section you can find all the documentation related to the legacy components of Selenium. This is meant to be kept purely for historical reasons and not as a incentive to use deprecated components.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/front_matter/",
	"title": "Front matter",
	"tags": [],
	"description": "",
	"content": " Page being translated from English to Korean. Do you speak Korean? Help us to translate it by sending us pull requests!\n Front matter "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://www.selenium.dev/documentation/ko/",
	"title": "Selenium 브라우저 자동화 프로젝트",
	"tags": [],
	"description": "",
	"content": "Selenium 브라우저 자동화 프로젝트 Selenium은 웹 브라우저의 자동화를 가능하게 하고 지원하는 다양한 도구와 라이브러리를 포함한 프로젝트입니다.\n브라우저와의 사용자 간의 상호 작용을 테스트하는 확장 기능, 브라우저 할당 확장을 위한 배포 서버, 모든 주요 웹 브라우저에 적용 가능한 코드를 작성할 수 있는 W3C WebDriver 사양 구현을 위한 인프라를 제공합니다.\n이 프로젝트는 자신의 수천 시간을 투자해준 기여자들이, 누구나 자유롭게 사용하고, 즐기고, 개선할 수 있도록 소스 코드를 제공해주었기에 가능했습니다.\nSelenium은 브라우저 공급 업체, 엔지니어, 매니아를 모아 웹 플랫폼 자동화에 대한 공개 토론을 진행합니다. 이 프로젝트 매년 컨퍼런스를 개최하여 커뮤니티를 육성하고 가르침을 전합니다.\nSelenium의 핵심은 WebDriver 입니다. 이는 다양한 브라우저에서 호환 가능한 지시사항을 작성할 수 있는 인터페이스라 할 수 있습니다. 다음은 가장 간단한 지시사항 예시입니다:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; import java.time.Duration; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #This example requires Selenium WebDriver 3.13 or newer with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element(By.NAME, \u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located(By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;)) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;div\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;cheese\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;div\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated import org.openqa.selenium.support.ui.WebDriverWait import java.time.Duration fun main() { val driver = FirefoxDriver() val wait = WebDriverWait(driver, Duration.ofSeconds(10)) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))) println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } }     이 코드를 실행할 때의 동작 원리에 대한 전체적인 설명은 퀵 투어 를 참고하십시오. Selenium 설치 방법과 자동화 툴로써 활용하는 방안에 대해 더 알아보고 싶다면 narrative documentation 를 참고하십시오. 이를 통해 Selenium을 테스트 자동화 툴로써 성공적으로 활용하여, 간단한 테스트를 제작하고 다양한 브라우저와 운영체제 환경에서 실행할 수 있을 것입니다.\n시작하기 Selenium을 처음 사용해보신다면, 빠른 이해를 도울 수 있는 몇 가지 문서가 있습니다.\n 퀵 투어  WebDriver IDE Grid    "
},
{
	"uri": "https://www.selenium.dev/documentation/ko/contributing/",
	"title": "Selenium 사이트와 문서에 기여하기",
	"tags": [],
	"description": "",
	"content": "Selenium은 거대한 소프트웨어 프로젝트로, 사이트와 문서는 작동 원리를 이해하고 잠재력을 효과적으로 활용하는 데 중요한 역할을 합니다.\n이 프로젝트는 Selenium 사이트와 문서를 담고 있습니다. 여기엔 Selenium을 효과적으로 사용하기 위한 업데이트 정보를 제공하고, 어떻게 참여하고 기여할 수 있는지에 대한 지속적인 노력이 담겨 있습니다.\n사이트와 문서에 기여하기 위한 방법은 아래 기술된 과정을 따릅니다. 여러분은 익숙해질 때 까지 더 보기를 충분한 시간을 들여 읽어보시고 바랍니다.\n Selenium은 여러분의 기여를 환영합니다. 기여하는 방법은 여러 가지가 있습니다:\n이슈 제기하기 새로운 이슈를 제기하거나 기존 이슈에 코멘트를 남길 때, 논의 내용이 Selenium 소프트웨어, 사이트 또는 문서의 구체적인 기술적인 문제와 관련이 있는지 확인해주시기 바랍니다.\nSelenium의 모든 구성요소는 빠르게 변하기 때문에, 문서 내용이 업데이트 전의 내용일 수도 있습니다. 이런 경우를 발견하신다면, 주저하지 마시고 이슈를 제기해주시기 바랍니다. 문서 내용을 직접 최신화하실 수 있다면, 변경 내용에 대한 pull request를 해주시기 바랍니다.\n만약 여러분이 발견한 것이 이슈인지 아닌지 헷갈리신다면, 다음의 커뮤니케이션 채널을 통해 질문해주시기 바랍니다. https://selenium.dev/support.\n기여하기 Selenium 프로젝트는 새로운 기여자를 환영합니다. 꾸준히 중요하고 가치가 높은 기여를 해주신 기여자는 Committers 가 되어 프로젝트에 커밋 접근 권한을 갖게 됩니다.\n아래 가이드는 여러분에게 기여하는 과정을 안내합니다.\n1 단계: Fork 프로젝트를 Github 에서 Fork 하시고, 로컬에서 확인하세요.\n% git clone git@github.com:seleniumhq/seleniumhq.github.io.git % cd seleniumhq.github.io 의존성: Hugo 우리는 Hugo 를 사용해 사이트와 문서를 빌드하고 렌더링합니다. 바뀐 내용을 커밋하기 전에 로컬에서 확인하기 위해, Hugo 설치 하고, 익숙해지셨다면 로컬 서버 실행 를 통해 사이트를 렌더링해 확인해주시기 바랍니다. 자세한 설명은 다음 단계에서 보실 수 있습니다.\n2 단계: Branch 기능을 추가한 branch를 생성하고 개발을 시작하세요:\n% git checkout -b my-feature-branch 우리는 HEAD-based development 지향하고 있어, 모든 변경사항은 master에 직접 적용됩니다.\n3 단계: Make changes Repository는 사이트와 문서의 서로 다른 2개의 Hugo 프로젝트로 구성되어 있습니다. 사이트를 변경하시려면 site_source_files 디렉토리에서 작업해주시기 바랍니다. 변경된 모습을 미리 보시려면 사이트의 루트 디렉토리에서 hugo server 를 실행하시면 됩니다.\n% cd site_source_files % hugo server 문서를 변경하시려면, docs_source_files 디렉토리로 변경하시기 바랍니다.\n% cd docs_source_files % hugo server 문서는 다양한 언어로 번역되어 있으며, 번역은 영문에 기반을 두고 있습니다. 문서를 변경할 때는, 다른 모든 번역 문서도 변경해야 하는 점을 반드시 유의 해주시기 바랍니다. 이는 어떤 부분을 변경하느냐에 따라 달라질 수 있습니다, 예를 들어:\n 만약 여러분이 browser_manipulation.en.md 파일에 코드 예제를 추가했다면, browser_manipulation.es.md, browser_manipulation.ef.md, browser_manipulation.ja.md, 그리고 다른 모든 번역 문서에도 추가해주셔야 합니다. 만약 여러분이 번역 문서의 개선사항을 발견했다면, 해당 번역 문서만 변경하시면 됩니다. 만약 여러분이 새로운 언어의 번역을 추가하고자 한다면, 알맞은 접미사 파일명의 문서를 추가해주셔야 합니다. PR을 할 때, 모든 문서가 번역되어있을 필요는 없습니다, 번역은 때마다 반복적으로 하셔도 됩니다. config.toml 파일에 필요한 설정값을 잊지 마시고 확인해주시기 바랍니다. 만약 여러분이 영문 문서에 내용을 바꿨다면, 다른 번역 문서의 같은 부분에 변경된 내용(영어로)을 넣어주시기고, 문서의 최상단부에 아래와 같은 알림을 추가해주시기 바랍니다.  {{% notice info %}} \u0026lt;i class=\u0026#34;fas fa-language\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Page being translated from English to {LANGUAGE}. Do you speak {LANGUAGE}? Help us to translate it by sending us pull requests! {{% /notice %}} 4 단계: Commit 먼저 git에 이름과 이메일 주소를 입력하시기 바랍니다:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; 적절한 커밋 메시지를 쓰는 것이 중요합니다. 커밋 메세지는 무엇이, 왜 변경되었는지 설명해야 하며, 수정된 이슈들을 언급해야 합니다(만약에 있다면). 작성할 때 이 가이드라인들을 따르시기 바랍니다.\n 첫 줄은 50자 내외 혹은 그 이하이어야 하며 변경 사항의 짧은 설명을 포함해야 합니다. 두 번째 줄은 빈 줄로 두시기 바랍니다. 다른 모든 줄은 72자 내로 작성하십시오. N 이 수정사항을 커밋한 이슈 번호인, Fixes #N을 포함하십시오.  좋은 커밋 메세지는 이렇습니다:\nexplain commit normatively in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way `git log` will show things nicely even when it is indented. Fixes #141 첫 줄은 사람들이 git shortlog 나 git log --oneline 을 실행하면 보는 것이기 때문에 의미있어야합니다.\n5 단계 : Rebase 작업을 동기화하려면 git rebase를 사용하십시오. (git merge가 아니라)\n% git fetch upstream % git rebase upstream/master 6 단계: 테스트 항상 로컬 서버를 실행하는 것을 기억하십시오. 그러면 당신의 변경 사항들이 아무것도 안 건드리고 안전합니다.\n7 단계 : Push % git push origin my-feature-branch https://github.com/yourusername/seleniumhq.github.io.git 에서 Pull Request 를 누르고 형식을 채우시기 바랍니다. CLA에 서명했는지 나타내주시길 바랍니다 (7 단계 참고)\nPull request 는 몇 일 내에 확인됩니다. 주소에 코멘트들이 있다면, 새로운 커밋에 변경 사항(가급적 fixups)을 적용하고 같은 branch 에 push 해주시기 바랍니다.\n8 단계 : Integration 코드 확인이 완료되었으면, committer는 당신의 PR을 저장소의 master branch에 통합할 것입니다. 왜냐하면 우리는 master branch에 순차적인 이력을 유지하고 싶기 때문에, 우리는 당신의 branch 이력은 squash나 rebase 할 것입니다.\n커뮤니케이션 프로젝트 기여자들과 커뮤니티와 어떻게 소통할지에 대한 자세한 사항은 https://selenium.dev/support 에서 찾을 수 있습니다.\n"
},
{
	"uri": "https://www.selenium.dev/documentation/ko/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]